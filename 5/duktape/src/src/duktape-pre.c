#ifdef LAVA_LOGGING
#define LAVALOG(bugid, x, trigger)  ({(trigger && fprintf(stderr, "\nLAVALOG: %d: %s:%d\n", bugid, __FILE__, __LINE__)), (x);})
#endif
#ifdef FULL_LAVA_LOGGING
#define LAVALOG(bugid, x, trigger)  ({(trigger && fprintf(stderr, "\nLAVALOG: %d: %s:%d\n", bugid, __FILE__, __LINE__), (!trigger && fprintf(stderr, "\nLAVALOG_MISS: %d: %s:%d\n", bugid, __FILE__, __LINE__))) && fflush(0), (x);})
#endif
#ifndef LAVALOG
#define LAVALOG(y,x,z)  (x)
#endif
#ifdef DUA_LOGGING
#define DFLOG(idx, val)  ({fprintf(stderr, "\nDFLOG:%d=%d: %s:%d\n", idx, val, __FILE__, __LINE__) && fflush(0), data_flow[idx]=val;})
#else
#define DFLOG(idx, val) {data_flow[idx]=val;}
#endif
static unsigned int lava_val[17] = {0};
void lava_set(unsigned int, unsigned int);
__attribute__((visibility("default")))
void lava_set(unsigned int slot, unsigned int val) {
#ifdef DUA_LOGGING
fprintf(stderr, "\nlava_set:%d=%d: %s:%d\n", slot, val, __FILE__, __LINE__);
fflush(NULL);
#endif
lava_val[slot] = val; }
unsigned int lava_get(unsigned int);
__attribute__((visibility("default")))
unsigned int lava_get(unsigned int slot) { return lava_val[slot]; }










typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;







__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;


__extension__ typedef __u_quad_t __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef __u_quad_t __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef __quad_t __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct { int __val[2]; } __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef __u_quad_t __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;

__extension__ typedef int __daddr_t;
__extension__ typedef long int __swblk_t;
__extension__ typedef int __key_t;


__extension__ typedef int __clockid_t;


__extension__ typedef void * __timer_t;


__extension__ typedef long int __blksize_t;




__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;


__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;


__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;

__extension__ typedef int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


__extension__ typedef int __intptr_t;


__extension__ typedef unsigned int __socklen_t;



typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;


typedef __clock_t clock_t;





typedef __time_t time_t;



typedef __clockid_t clockid_t;
typedef __timer_t timer_t;



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





typedef unsigned int size_t;



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));




typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;



typedef __sigset_t sigset_t;





struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };

struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
typedef long int __fd_mask;
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;

extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);





__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     __attribute__ ((__nothrow__));





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





typedef unsigned long int pthread_t;


typedef union
{
  char __size[36];
  long int __align;
} pthread_attr_t;


typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;




typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;


    int __kind;
    unsigned int __nusers;
    __extension__ union
    {
      int __spins;
      __pthread_slist_t __list;
    };
  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;


    unsigned char __flags;
    unsigned char __shared;
    unsigned char __pad1;
    unsigned char __pad2;
    int __writer;
  } __data;
  char __size[32];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[20];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;









typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;





__extension__
typedef unsigned long long int uint64_t;






typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;



__extension__
typedef long long int int_least64_t;



typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;



__extension__
typedef unsigned long long int uint_least64_t;






typedef signed char int_fast8_t;





typedef int int_fast16_t;
typedef int int_fast32_t;
__extension__
typedef long long int int_fast64_t;



typedef unsigned char uint_fast8_t;





typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
__extension__
typedef unsigned long long int uint_fast64_t;
typedef int intptr_t;


typedef unsigned int uintptr_t;
__extension__
typedef long long int intmax_t;
__extension__
typedef unsigned long long int uintmax_t;



















struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int settimeofday (__const struct timeval *__tv,
    __const struct timezone *__tz)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int adjtime (__const struct timeval *__delta,
      struct timeval *__olddelta) __attribute__ ((__nothrow__));




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };




typedef enum __itimer_which __itimer_which_t;






extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) __attribute__ ((__nothrow__));




extern int setitimer (__itimer_which_t __which,
        __const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) __attribute__ ((__nothrow__));




extern int utimes (__const char *__file, __const struct timeval __tvp[2])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int lutimes (__const char *__file, __const struct timeval __tvp[2])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, __const struct timeval __tvp[2]) __attribute__ ((__nothrow__));






extern int futimesat (int __fd, __const char *__file,
        __const struct timeval __tvp[2]) __attribute__ ((__nothrow__));














struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  __const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;



extern clock_t clock (void) __attribute__ ((__nothrow__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   __const char *__restrict __format,
   __const struct tm *__restrict __tp) __attribute__ ((__nothrow__));





extern char *strptime (__const char *__restrict __s,
         __const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__));





typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;

extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     __const char *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) __attribute__ ((__nothrow__));



extern char *strptime_l (__const char *__restrict __s,
    __const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) __attribute__ ((__nothrow__));






extern struct tm *gmtime (__const time_t *__timer) __attribute__ ((__nothrow__));



extern struct tm *localtime (__const time_t *__timer) __attribute__ ((__nothrow__));





extern struct tm *gmtime_r (__const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__));



extern struct tm *localtime_r (__const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__));





extern char *asctime (__const struct tm *__tp) __attribute__ ((__nothrow__));


extern char *ctime (__const time_t *__timer) __attribute__ ((__nothrow__));







extern char *asctime_r (__const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__));


extern char *ctime_r (__const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__));



extern int daylight;
extern long int timezone;





extern int stime (__const time_t *__when) __attribute__ ((__nothrow__));
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__));


extern int dysize (int __year) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
extern int nanosleep (__const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__));


extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     __attribute__ ((__nothrow__));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       __const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__));


extern int timer_settime (timer_t __timerid, int __flags,
     __const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__));
extern int getdate_err;
extern struct tm *getdate (__const char *__string);
extern int getdate_r (__const char *__restrict __string,
        struct tm *__restrict __resbufp);







struct _IO_FILE;



typedef struct _IO_FILE FILE;





typedef struct _IO_FILE __FILE;




typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
typedef __builtin_va_list __gnuc_va_list;
struct _IO_jump_t; struct _IO_FILE;
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
  __off64_t _offset;
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);







extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__));
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__));




typedef __gnuc_va_list va_list;


typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (__const char *__filename) __attribute__ ((__nothrow__));

extern int rename (__const char *__old, __const char *__new) __attribute__ ((__nothrow__));




extern int renameat (int __oldfd, __const char *__old, int __newfd,
       __const char *__new) __attribute__ ((__nothrow__));








extern FILE *tmpfile (void) ;
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) __attribute__ ((__nothrow__)) ;





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__)) ;
extern char *tempnam (__const char *__dir, __const char *__pfx)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

extern int fflush_unlocked (FILE *__stream);
extern int fcloseall (void);









extern FILE *fopen (__const char *__restrict __filename,
      __const char *__restrict __modes) ;




extern FILE *freopen (__const char *__restrict __filename,
        __const char *__restrict __modes,
        FILE *__restrict __stream) ;


extern FILE *fopen64 (__const char *__restrict __filename,
        __const char *__restrict __modes) ;
extern FILE *freopen64 (__const char *__restrict __filename,
   __const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, __const char *__modes) __attribute__ ((__nothrow__)) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     __const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__)) ;




extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
  __attribute__ ((__nothrow__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__)) ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__));








extern int fprintf (FILE *__restrict __stream,
      __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      __const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       __const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        __const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         __const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       __const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int vdprintf (int __fd, __const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     __const char *__restrict __format, ...) ;




extern int scanf (__const char *__restrict __format, ...) ;

extern int sscanf (__const char *__restrict __s,
     __const char *__restrict __format, ...) __attribute__ ((__nothrow__));








extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (__const char *__restrict __s,
      __const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__scanf__, 2, 0)));









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;






extern char *gets (char *__s) ;

extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);





extern int puts (__const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

extern int fputs_unlocked (__const char *__restrict __s,
      FILE *__restrict __stream);
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, __const fpos_t *__pos);



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);




extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__)) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) ;








extern void perror (__const char *__s);






extern int sys_nerr;
extern __const char *__const sys_errlist[];


extern int _sys_nerr;
extern __const char *__const _sys_errlist[];




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) ;
extern FILE *popen (__const char *__command, __const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__));





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      __const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       __const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__));

typedef int wchar_t;








union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__)) ;




extern double atof (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern float strtof (__const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

extern long double strtold (__const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

extern long int strtol_l (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) ;

extern unsigned long int strtoul_l (__const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) ;

extern double strtod_l (__const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) ;

extern float strtof_l (__const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) ;

extern long double strtold_l (__const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) ;
extern char *l64a (long int __n) __attribute__ ((__nothrow__)) ;


extern long int a64l (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
extern long int random (void) __attribute__ ((__nothrow__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__));







extern double drand48 (void) __attribute__ ((__nothrow__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__));










extern void *alloca (size_t __size) __attribute__ ((__nothrow__));











extern void *valloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




extern void abort (void) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));







extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







extern void quick_exit (int __status) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







extern void _Exit (int __status) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));






extern char *getenv (__const char *__name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




extern char *__secure_getenv (__const char *__name)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern int putenv (char *__string) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (__const char *__name, __const char *__value, int __replace)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (__const char *__name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__));
extern char *mktemp (char *__template) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;









extern int system (__const char *__command) ;






extern char *canonicalize_file_name (__const char *__name)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__)) ;






typedef int (*__compar_fn_t) (__const void *, __const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (__const void *, __const void *, void *);





extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;

extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (__const char *__s, size_t __n) __attribute__ ((__nothrow__)) ;


extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__)) ;


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__)) ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__));

extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__));








extern int rpmatch (__const char *__response) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
extern int getsubopt (char **__restrict __optionp,
        char *__const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (__const char *__key) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) __attribute__ ((__nothrow__));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__)) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));















extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *memchr (__const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern void *rawmemchr (__const void *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern void *memrchr (__const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));

extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (__const char *__string, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));

extern char *strchr (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern char *strrchr (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern char *strchrnul (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern size_t strcspn (__const char *__s, __const char *__reject)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (__const char *__s, __const char *__accept)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *strpbrk (__const char *__s, __const char *__accept)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *strstr (__const char *__haystack, __const char *__needle)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
extern char *strcasestr (__const char *__haystack, __const char *__needle)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (__const void *__haystack, size_t __haystacklen,
       __const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   __const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        __const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (__const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) __attribute__ ((__nothrow__));

extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));





extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__));





extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern void bcopy (__const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *index (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern char *rindex (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) __attribute__ ((__nothrow__)) __attribute__ ((__const__));




extern int ffsl (long int __l) __attribute__ ((__nothrow__)) __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__));




extern int strcasecmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (__const char *__s1, __const char *__s2,
    __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (__const char *__s1, __const char *__s2,
     size_t __n, __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__));


extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
extern char *basename (__const char *__filename) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



typedef int __jmp_buf[6];



struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  };




typedef struct __jmp_buf_tag jmp_buf[1];



extern int setjmp (jmp_buf __env) __attribute__ ((__nothrow__));






extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __attribute__ ((__nothrow__));




extern int _setjmp (struct __jmp_buf_tag __env[1]) __attribute__ ((__nothrow__));




extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







extern void _longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







typedef struct __jmp_buf_tag sigjmp_buf[1];
extern void siglongjmp (sigjmp_buf __env, int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));

typedef int ptrdiff_t;












typedef long double float_t;

typedef long double double_t;


extern double acos (double __x) __attribute__ ((__nothrow__)); extern double __acos (double __x) __attribute__ ((__nothrow__));

extern double asin (double __x) __attribute__ ((__nothrow__)); extern double __asin (double __x) __attribute__ ((__nothrow__));

extern double atan (double __x) __attribute__ ((__nothrow__)); extern double __atan (double __x) __attribute__ ((__nothrow__));

extern double atan2 (double __y, double __x) __attribute__ ((__nothrow__)); extern double __atan2 (double __y, double __x) __attribute__ ((__nothrow__));


extern double cos (double __x) __attribute__ ((__nothrow__)); extern double __cos (double __x) __attribute__ ((__nothrow__));

extern double sin (double __x) __attribute__ ((__nothrow__)); extern double __sin (double __x) __attribute__ ((__nothrow__));

extern double tan (double __x) __attribute__ ((__nothrow__)); extern double __tan (double __x) __attribute__ ((__nothrow__));




extern double cosh (double __x) __attribute__ ((__nothrow__)); extern double __cosh (double __x) __attribute__ ((__nothrow__));

extern double sinh (double __x) __attribute__ ((__nothrow__)); extern double __sinh (double __x) __attribute__ ((__nothrow__));

extern double tanh (double __x) __attribute__ ((__nothrow__)); extern double __tanh (double __x) __attribute__ ((__nothrow__));




extern void sincos (double __x, double *__sinx, double *__cosx) __attribute__ ((__nothrow__)); extern void __sincos (double __x, double *__sinx, double *__cosx) __attribute__ ((__nothrow__))
                                                           ;





extern double acosh (double __x) __attribute__ ((__nothrow__)); extern double __acosh (double __x) __attribute__ ((__nothrow__));

extern double asinh (double __x) __attribute__ ((__nothrow__)); extern double __asinh (double __x) __attribute__ ((__nothrow__));

extern double atanh (double __x) __attribute__ ((__nothrow__)); extern double __atanh (double __x) __attribute__ ((__nothrow__));







extern double exp (double __x) __attribute__ ((__nothrow__)); extern double __exp (double __x) __attribute__ ((__nothrow__));


extern double frexp (double __x, int *__exponent) __attribute__ ((__nothrow__)); extern double __frexp (double __x, int *__exponent) __attribute__ ((__nothrow__));


extern double ldexp (double __x, int __exponent) __attribute__ ((__nothrow__)); extern double __ldexp (double __x, int __exponent) __attribute__ ((__nothrow__));


extern double log (double __x) __attribute__ ((__nothrow__)); extern double __log (double __x) __attribute__ ((__nothrow__));


extern double log10 (double __x) __attribute__ ((__nothrow__)); extern double __log10 (double __x) __attribute__ ((__nothrow__));


extern double modf (double __x, double *__iptr) __attribute__ ((__nothrow__)); extern double __modf (double __x, double *__iptr) __attribute__ ((__nothrow__));




extern double exp10 (double __x) __attribute__ ((__nothrow__)); extern double __exp10 (double __x) __attribute__ ((__nothrow__));

extern double pow10 (double __x) __attribute__ ((__nothrow__)); extern double __pow10 (double __x) __attribute__ ((__nothrow__));





extern double expm1 (double __x) __attribute__ ((__nothrow__)); extern double __expm1 (double __x) __attribute__ ((__nothrow__));


extern double log1p (double __x) __attribute__ ((__nothrow__)); extern double __log1p (double __x) __attribute__ ((__nothrow__));


extern double logb (double __x) __attribute__ ((__nothrow__)); extern double __logb (double __x) __attribute__ ((__nothrow__));






extern double exp2 (double __x) __attribute__ ((__nothrow__)); extern double __exp2 (double __x) __attribute__ ((__nothrow__));


extern double log2 (double __x) __attribute__ ((__nothrow__)); extern double __log2 (double __x) __attribute__ ((__nothrow__));








extern double pow (double __x, double __y) __attribute__ ((__nothrow__)); extern double __pow (double __x, double __y) __attribute__ ((__nothrow__));


extern double sqrt (double __x) __attribute__ ((__nothrow__)); extern double __sqrt (double __x) __attribute__ ((__nothrow__));





extern double hypot (double __x, double __y) __attribute__ ((__nothrow__)); extern double __hypot (double __x, double __y) __attribute__ ((__nothrow__));






extern double cbrt (double __x) __attribute__ ((__nothrow__)); extern double __cbrt (double __x) __attribute__ ((__nothrow__));








extern double ceil (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __ceil (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern double fabs (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __fabs (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern double floor (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __floor (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern double fmod (double __x, double __y) __attribute__ ((__nothrow__)); extern double __fmod (double __x, double __y) __attribute__ ((__nothrow__));




extern int __isinf (double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern int __finite (double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));





extern int isinf (double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern int finite (double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern double drem (double __x, double __y) __attribute__ ((__nothrow__)); extern double __drem (double __x, double __y) __attribute__ ((__nothrow__));



extern double significand (double __x) __attribute__ ((__nothrow__)); extern double __significand (double __x) __attribute__ ((__nothrow__));





extern double copysign (double __x, double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));






extern double nan (__const char *__tagb) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __nan (__const char *__tagb) __attribute__ ((__nothrow__)) __attribute__ ((__const__));





extern int __isnan (double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern int isnan (double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern double j0 (double) __attribute__ ((__nothrow__)); extern double __j0 (double) __attribute__ ((__nothrow__));
extern double j1 (double) __attribute__ ((__nothrow__)); extern double __j1 (double) __attribute__ ((__nothrow__));
extern double jn (int, double) __attribute__ ((__nothrow__)); extern double __jn (int, double) __attribute__ ((__nothrow__));
extern double y0 (double) __attribute__ ((__nothrow__)); extern double __y0 (double) __attribute__ ((__nothrow__));
extern double y1 (double) __attribute__ ((__nothrow__)); extern double __y1 (double) __attribute__ ((__nothrow__));
extern double yn (int, double) __attribute__ ((__nothrow__)); extern double __yn (int, double) __attribute__ ((__nothrow__));






extern double erf (double) __attribute__ ((__nothrow__)); extern double __erf (double) __attribute__ ((__nothrow__));
extern double erfc (double) __attribute__ ((__nothrow__)); extern double __erfc (double) __attribute__ ((__nothrow__));
extern double lgamma (double) __attribute__ ((__nothrow__)); extern double __lgamma (double) __attribute__ ((__nothrow__));






extern double tgamma (double) __attribute__ ((__nothrow__)); extern double __tgamma (double) __attribute__ ((__nothrow__));





extern double gamma (double) __attribute__ ((__nothrow__)); extern double __gamma (double) __attribute__ ((__nothrow__));






extern double lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__)); extern double __lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__));







extern double rint (double __x) __attribute__ ((__nothrow__)); extern double __rint (double __x) __attribute__ ((__nothrow__));


extern double nextafter (double __x, double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern double remainder (double __x, double __y) __attribute__ ((__nothrow__)); extern double __remainder (double __x, double __y) __attribute__ ((__nothrow__));



extern double scalbn (double __x, int __n) __attribute__ ((__nothrow__)); extern double __scalbn (double __x, int __n) __attribute__ ((__nothrow__));



extern int ilogb (double __x) __attribute__ ((__nothrow__)); extern int __ilogb (double __x) __attribute__ ((__nothrow__));




extern double scalbln (double __x, long int __n) __attribute__ ((__nothrow__)); extern double __scalbln (double __x, long int __n) __attribute__ ((__nothrow__));



extern double nearbyint (double __x) __attribute__ ((__nothrow__)); extern double __nearbyint (double __x) __attribute__ ((__nothrow__));



extern double round (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __round (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern double trunc (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __trunc (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__)); extern double __remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__));






extern long int lrint (double __x) __attribute__ ((__nothrow__)); extern long int __lrint (double __x) __attribute__ ((__nothrow__));
extern long long int llrint (double __x) __attribute__ ((__nothrow__)); extern long long int __llrint (double __x) __attribute__ ((__nothrow__));



extern long int lround (double __x) __attribute__ ((__nothrow__)); extern long int __lround (double __x) __attribute__ ((__nothrow__));
extern long long int llround (double __x) __attribute__ ((__nothrow__)); extern long long int __llround (double __x) __attribute__ ((__nothrow__));



extern double fdim (double __x, double __y) __attribute__ ((__nothrow__)); extern double __fdim (double __x, double __y) __attribute__ ((__nothrow__));


extern double fmax (double __x, double __y) __attribute__ ((__nothrow__)); extern double __fmax (double __x, double __y) __attribute__ ((__nothrow__));


extern double fmin (double __x, double __y) __attribute__ ((__nothrow__)); extern double __fmin (double __x, double __y) __attribute__ ((__nothrow__));



extern int __fpclassify (double __value) __attribute__ ((__nothrow__))
     __attribute__ ((__const__));


extern int __signbit (double __value) __attribute__ ((__nothrow__))
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) __attribute__ ((__nothrow__)); extern double __fma (double __x, double __y, double __z) __attribute__ ((__nothrow__));








extern double scalb (double __x, double __n) __attribute__ ((__nothrow__)); extern double __scalb (double __x, double __n) __attribute__ ((__nothrow__));


extern float acosf (float __x) __attribute__ ((__nothrow__)); extern float __acosf (float __x) __attribute__ ((__nothrow__));

extern float asinf (float __x) __attribute__ ((__nothrow__)); extern float __asinf (float __x) __attribute__ ((__nothrow__));

extern float atanf (float __x) __attribute__ ((__nothrow__)); extern float __atanf (float __x) __attribute__ ((__nothrow__));

extern float atan2f (float __y, float __x) __attribute__ ((__nothrow__)); extern float __atan2f (float __y, float __x) __attribute__ ((__nothrow__));


extern float cosf (float __x) __attribute__ ((__nothrow__)); extern float __cosf (float __x) __attribute__ ((__nothrow__));

extern float sinf (float __x) __attribute__ ((__nothrow__)); extern float __sinf (float __x) __attribute__ ((__nothrow__));

extern float tanf (float __x) __attribute__ ((__nothrow__)); extern float __tanf (float __x) __attribute__ ((__nothrow__));




extern float coshf (float __x) __attribute__ ((__nothrow__)); extern float __coshf (float __x) __attribute__ ((__nothrow__));

extern float sinhf (float __x) __attribute__ ((__nothrow__)); extern float __sinhf (float __x) __attribute__ ((__nothrow__));

extern float tanhf (float __x) __attribute__ ((__nothrow__)); extern float __tanhf (float __x) __attribute__ ((__nothrow__));




extern void
 sincosf
 (float __x, float *__sinx, float *__cosx) __attribute__ ((__nothrow__)); extern void
 __sincosf
 (float __x, float *__sinx, float *__cosx) __attribute__ ((__nothrow__))
                                                           ;





extern float acoshf (float __x) __attribute__ ((__nothrow__)); extern float __acoshf (float __x) __attribute__ ((__nothrow__));

extern float asinhf (float __x) __attribute__ ((__nothrow__)); extern float __asinhf (float __x) __attribute__ ((__nothrow__));

extern float atanhf (float __x) __attribute__ ((__nothrow__)); extern float __atanhf (float __x) __attribute__ ((__nothrow__));







extern float expf (float __x) __attribute__ ((__nothrow__)); extern float __expf (float __x) __attribute__ ((__nothrow__));


extern float frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__)); extern float __frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__));


extern float ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__)); extern float __ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__));


extern float logf (float __x) __attribute__ ((__nothrow__)); extern float __logf (float __x) __attribute__ ((__nothrow__));


extern float log10f (float __x) __attribute__ ((__nothrow__)); extern float __log10f (float __x) __attribute__ ((__nothrow__));


extern float modff (float __x, float *__iptr) __attribute__ ((__nothrow__)); extern float __modff (float __x, float *__iptr) __attribute__ ((__nothrow__));




extern float exp10f (float __x) __attribute__ ((__nothrow__)); extern float __exp10f (float __x) __attribute__ ((__nothrow__));

extern float pow10f (float __x) __attribute__ ((__nothrow__)); extern float __pow10f (float __x) __attribute__ ((__nothrow__));





extern float expm1f (float __x) __attribute__ ((__nothrow__)); extern float __expm1f (float __x) __attribute__ ((__nothrow__));


extern float log1pf (float __x) __attribute__ ((__nothrow__)); extern float __log1pf (float __x) __attribute__ ((__nothrow__));


extern float logbf (float __x) __attribute__ ((__nothrow__)); extern float __logbf (float __x) __attribute__ ((__nothrow__));






extern float exp2f (float __x) __attribute__ ((__nothrow__)); extern float __exp2f (float __x) __attribute__ ((__nothrow__));


extern float log2f (float __x) __attribute__ ((__nothrow__)); extern float __log2f (float __x) __attribute__ ((__nothrow__));








extern float powf (float __x, float __y) __attribute__ ((__nothrow__)); extern float __powf (float __x, float __y) __attribute__ ((__nothrow__));


extern float sqrtf (float __x) __attribute__ ((__nothrow__)); extern float __sqrtf (float __x) __attribute__ ((__nothrow__));





extern float hypotf (float __x, float __y) __attribute__ ((__nothrow__)); extern float __hypotf (float __x, float __y) __attribute__ ((__nothrow__));






extern float cbrtf (float __x) __attribute__ ((__nothrow__)); extern float __cbrtf (float __x) __attribute__ ((__nothrow__));








extern float ceilf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __ceilf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern float fabsf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __fabsf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern float floorf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __floorf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) __attribute__ ((__nothrow__)); extern float __fmodf (float __x, float __y) __attribute__ ((__nothrow__));




extern int __isinff (float __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern int __finitef (float __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));





extern int isinff (float __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern int finitef (float __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern float dremf (float __x, float __y) __attribute__ ((__nothrow__)); extern float __dremf (float __x, float __y) __attribute__ ((__nothrow__));



extern float significandf (float __x) __attribute__ ((__nothrow__)); extern float __significandf (float __x) __attribute__ ((__nothrow__));





extern float copysignf (float __x, float __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));






extern float nanf (__const char *__tagb) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __nanf (__const char *__tagb) __attribute__ ((__nothrow__)) __attribute__ ((__const__));





extern int __isnanf (float __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern int isnanf (float __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern float j0f (float) __attribute__ ((__nothrow__)); extern float __j0f (float) __attribute__ ((__nothrow__));
extern float j1f (float) __attribute__ ((__nothrow__)); extern float __j1f (float) __attribute__ ((__nothrow__));
extern float jnf (int, float) __attribute__ ((__nothrow__)); extern float __jnf (int, float) __attribute__ ((__nothrow__));
extern float y0f (float) __attribute__ ((__nothrow__)); extern float __y0f (float) __attribute__ ((__nothrow__));
extern float y1f (float) __attribute__ ((__nothrow__)); extern float __y1f (float) __attribute__ ((__nothrow__));
extern float ynf (int, float) __attribute__ ((__nothrow__)); extern float __ynf (int, float) __attribute__ ((__nothrow__));






extern float erff (float) __attribute__ ((__nothrow__)); extern float __erff (float) __attribute__ ((__nothrow__));
extern float erfcf (float) __attribute__ ((__nothrow__)); extern float __erfcf (float) __attribute__ ((__nothrow__));
extern float lgammaf (float) __attribute__ ((__nothrow__)); extern float __lgammaf (float) __attribute__ ((__nothrow__));






extern float tgammaf (float) __attribute__ ((__nothrow__)); extern float __tgammaf (float) __attribute__ ((__nothrow__));





extern float gammaf (float) __attribute__ ((__nothrow__)); extern float __gammaf (float) __attribute__ ((__nothrow__));






extern float lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__)); extern float __lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__));







extern float rintf (float __x) __attribute__ ((__nothrow__)); extern float __rintf (float __x) __attribute__ ((__nothrow__));


extern float nextafterf (float __x, float __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern float remainderf (float __x, float __y) __attribute__ ((__nothrow__)); extern float __remainderf (float __x, float __y) __attribute__ ((__nothrow__));



extern float scalbnf (float __x, int __n) __attribute__ ((__nothrow__)); extern float __scalbnf (float __x, int __n) __attribute__ ((__nothrow__));



extern int ilogbf (float __x) __attribute__ ((__nothrow__)); extern int __ilogbf (float __x) __attribute__ ((__nothrow__));




extern float scalblnf (float __x, long int __n) __attribute__ ((__nothrow__)); extern float __scalblnf (float __x, long int __n) __attribute__ ((__nothrow__));



extern float nearbyintf (float __x) __attribute__ ((__nothrow__)); extern float __nearbyintf (float __x) __attribute__ ((__nothrow__));



extern float roundf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __roundf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern float truncf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __truncf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__)); extern float __remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__));






extern long int lrintf (float __x) __attribute__ ((__nothrow__)); extern long int __lrintf (float __x) __attribute__ ((__nothrow__));
extern long long int llrintf (float __x) __attribute__ ((__nothrow__)); extern long long int __llrintf (float __x) __attribute__ ((__nothrow__));



extern long int lroundf (float __x) __attribute__ ((__nothrow__)); extern long int __lroundf (float __x) __attribute__ ((__nothrow__));
extern long long int llroundf (float __x) __attribute__ ((__nothrow__)); extern long long int __llroundf (float __x) __attribute__ ((__nothrow__));



extern float fdimf (float __x, float __y) __attribute__ ((__nothrow__)); extern float __fdimf (float __x, float __y) __attribute__ ((__nothrow__));


extern float fmaxf (float __x, float __y) __attribute__ ((__nothrow__)); extern float __fmaxf (float __x, float __y) __attribute__ ((__nothrow__));


extern float fminf (float __x, float __y) __attribute__ ((__nothrow__)); extern float __fminf (float __x, float __y) __attribute__ ((__nothrow__));



extern int __fpclassifyf (float __value) __attribute__ ((__nothrow__))
     __attribute__ ((__const__));


extern int __signbitf (float __value) __attribute__ ((__nothrow__))
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__)); extern float __fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__));








extern float scalbf (float __x, float __n) __attribute__ ((__nothrow__)); extern float __scalbf (float __x, float __n) __attribute__ ((__nothrow__));


extern long double acosl (long double __x) __attribute__ ((__nothrow__)); extern long double __acosl (long double __x) __attribute__ ((__nothrow__));

extern long double asinl (long double __x) __attribute__ ((__nothrow__)); extern long double __asinl (long double __x) __attribute__ ((__nothrow__));

extern long double atanl (long double __x) __attribute__ ((__nothrow__)); extern long double __atanl (long double __x) __attribute__ ((__nothrow__));

extern long double atan2l (long double __y, long double __x) __attribute__ ((__nothrow__)); extern long double __atan2l (long double __y, long double __x) __attribute__ ((__nothrow__));


extern long double cosl (long double __x) __attribute__ ((__nothrow__)); extern long double __cosl (long double __x) __attribute__ ((__nothrow__));

extern long double sinl (long double __x) __attribute__ ((__nothrow__)); extern long double __sinl (long double __x) __attribute__ ((__nothrow__));

extern long double tanl (long double __x) __attribute__ ((__nothrow__)); extern long double __tanl (long double __x) __attribute__ ((__nothrow__));




extern long double coshl (long double __x) __attribute__ ((__nothrow__)); extern long double __coshl (long double __x) __attribute__ ((__nothrow__));

extern long double sinhl (long double __x) __attribute__ ((__nothrow__)); extern long double __sinhl (long double __x) __attribute__ ((__nothrow__));

extern long double tanhl (long double __x) __attribute__ ((__nothrow__)); extern long double __tanhl (long double __x) __attribute__ ((__nothrow__));




extern void
 sincosl
 (long double __x, long double *__sinx, long double *__cosx) __attribute__ ((__nothrow__)); extern void
 __sincosl
 (long double __x, long double *__sinx, long double *__cosx) __attribute__ ((__nothrow__))
                                                           ;





extern long double acoshl (long double __x) __attribute__ ((__nothrow__)); extern long double __acoshl (long double __x) __attribute__ ((__nothrow__));

extern long double asinhl (long double __x) __attribute__ ((__nothrow__)); extern long double __asinhl (long double __x) __attribute__ ((__nothrow__));

extern long double atanhl (long double __x) __attribute__ ((__nothrow__)); extern long double __atanhl (long double __x) __attribute__ ((__nothrow__));







extern long double expl (long double __x) __attribute__ ((__nothrow__)); extern long double __expl (long double __x) __attribute__ ((__nothrow__));


extern long double frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__)); extern long double __frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__));


extern long double ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__)); extern long double __ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__));


extern long double logl (long double __x) __attribute__ ((__nothrow__)); extern long double __logl (long double __x) __attribute__ ((__nothrow__));


extern long double log10l (long double __x) __attribute__ ((__nothrow__)); extern long double __log10l (long double __x) __attribute__ ((__nothrow__));


extern long double modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__)); extern long double __modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__));




extern long double exp10l (long double __x) __attribute__ ((__nothrow__)); extern long double __exp10l (long double __x) __attribute__ ((__nothrow__));

extern long double pow10l (long double __x) __attribute__ ((__nothrow__)); extern long double __pow10l (long double __x) __attribute__ ((__nothrow__));





extern long double expm1l (long double __x) __attribute__ ((__nothrow__)); extern long double __expm1l (long double __x) __attribute__ ((__nothrow__));


extern long double log1pl (long double __x) __attribute__ ((__nothrow__)); extern long double __log1pl (long double __x) __attribute__ ((__nothrow__));


extern long double logbl (long double __x) __attribute__ ((__nothrow__)); extern long double __logbl (long double __x) __attribute__ ((__nothrow__));






extern long double exp2l (long double __x) __attribute__ ((__nothrow__)); extern long double __exp2l (long double __x) __attribute__ ((__nothrow__));


extern long double log2l (long double __x) __attribute__ ((__nothrow__)); extern long double __log2l (long double __x) __attribute__ ((__nothrow__));








extern long double powl (long double __x, long double __y) __attribute__ ((__nothrow__)); extern long double __powl (long double __x, long double __y) __attribute__ ((__nothrow__));


extern long double sqrtl (long double __x) __attribute__ ((__nothrow__)); extern long double __sqrtl (long double __x) __attribute__ ((__nothrow__));





extern long double hypotl (long double __x, long double __y) __attribute__ ((__nothrow__)); extern long double __hypotl (long double __x, long double __y) __attribute__ ((__nothrow__));






extern long double cbrtl (long double __x) __attribute__ ((__nothrow__)); extern long double __cbrtl (long double __x) __attribute__ ((__nothrow__));








extern long double ceill (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __ceill (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern long double fabsl (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __fabsl (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern long double floorl (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __floorl (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) __attribute__ ((__nothrow__)); extern long double __fmodl (long double __x, long double __y) __attribute__ ((__nothrow__));




extern int __isinfl (long double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern int __finitel (long double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));





extern int isinfl (long double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern int finitel (long double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) __attribute__ ((__nothrow__)); extern long double __dreml (long double __x, long double __y) __attribute__ ((__nothrow__));



extern long double significandl (long double __x) __attribute__ ((__nothrow__)); extern long double __significandl (long double __x) __attribute__ ((__nothrow__));





extern long double copysignl (long double __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));






extern long double nanl (__const char *__tagb) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __nanl (__const char *__tagb) __attribute__ ((__nothrow__)) __attribute__ ((__const__));





extern int __isnanl (long double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern int isnanl (long double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern long double j0l (long double) __attribute__ ((__nothrow__)); extern long double __j0l (long double) __attribute__ ((__nothrow__));
extern long double j1l (long double) __attribute__ ((__nothrow__)); extern long double __j1l (long double) __attribute__ ((__nothrow__));
extern long double jnl (int, long double) __attribute__ ((__nothrow__)); extern long double __jnl (int, long double) __attribute__ ((__nothrow__));
extern long double y0l (long double) __attribute__ ((__nothrow__)); extern long double __y0l (long double) __attribute__ ((__nothrow__));
extern long double y1l (long double) __attribute__ ((__nothrow__)); extern long double __y1l (long double) __attribute__ ((__nothrow__));
extern long double ynl (int, long double) __attribute__ ((__nothrow__)); extern long double __ynl (int, long double) __attribute__ ((__nothrow__));






extern long double erfl (long double) __attribute__ ((__nothrow__)); extern long double __erfl (long double) __attribute__ ((__nothrow__));
extern long double erfcl (long double) __attribute__ ((__nothrow__)); extern long double __erfcl (long double) __attribute__ ((__nothrow__));
extern long double lgammal (long double) __attribute__ ((__nothrow__)); extern long double __lgammal (long double) __attribute__ ((__nothrow__));






extern long double tgammal (long double) __attribute__ ((__nothrow__)); extern long double __tgammal (long double) __attribute__ ((__nothrow__));





extern long double gammal (long double) __attribute__ ((__nothrow__)); extern long double __gammal (long double) __attribute__ ((__nothrow__));






extern long double lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__)); extern long double __lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__));







extern long double rintl (long double __x) __attribute__ ((__nothrow__)); extern long double __rintl (long double __x) __attribute__ ((__nothrow__));


extern long double nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) __attribute__ ((__nothrow__)); extern long double __remainderl (long double __x, long double __y) __attribute__ ((__nothrow__));



extern long double scalbnl (long double __x, int __n) __attribute__ ((__nothrow__)); extern long double __scalbnl (long double __x, int __n) __attribute__ ((__nothrow__));



extern int ilogbl (long double __x) __attribute__ ((__nothrow__)); extern int __ilogbl (long double __x) __attribute__ ((__nothrow__));




extern long double scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__)); extern long double __scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__));



extern long double nearbyintl (long double __x) __attribute__ ((__nothrow__)); extern long double __nearbyintl (long double __x) __attribute__ ((__nothrow__));



extern long double roundl (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __roundl (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern long double truncl (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __truncl (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__)); extern long double __remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__));






extern long int lrintl (long double __x) __attribute__ ((__nothrow__)); extern long int __lrintl (long double __x) __attribute__ ((__nothrow__));
extern long long int llrintl (long double __x) __attribute__ ((__nothrow__)); extern long long int __llrintl (long double __x) __attribute__ ((__nothrow__));



extern long int lroundl (long double __x) __attribute__ ((__nothrow__)); extern long int __lroundl (long double __x) __attribute__ ((__nothrow__));
extern long long int llroundl (long double __x) __attribute__ ((__nothrow__)); extern long long int __llroundl (long double __x) __attribute__ ((__nothrow__));



extern long double fdiml (long double __x, long double __y) __attribute__ ((__nothrow__)); extern long double __fdiml (long double __x, long double __y) __attribute__ ((__nothrow__));


extern long double fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__)); extern long double __fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__));


extern long double fminl (long double __x, long double __y) __attribute__ ((__nothrow__)); extern long double __fminl (long double __x, long double __y) __attribute__ ((__nothrow__));



extern int __fpclassifyl (long double __value) __attribute__ ((__nothrow__))
     __attribute__ ((__const__));


extern int __signbitl (long double __value) __attribute__ ((__nothrow__))
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__)); extern long double __fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__));








extern long double scalbl (long double __x, long double __n) __attribute__ ((__nothrow__)); extern long double __scalbl (long double __x, long double __n) __attribute__ ((__nothrow__));
extern int signgam;
enum
  {
    FP_NAN,

    FP_INFINITE,

    FP_ZERO,

    FP_SUBNORMAL,

    FP_NORMAL

  };
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
struct exception

  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };




extern int matherr (struct exception *__exc);

typedef unsigned char duk_uint8_t;
typedef signed char duk_int8_t;





typedef unsigned short duk_uint16_t;
typedef signed short duk_int16_t;
typedef unsigned int duk_uint32_t;
typedef signed int duk_int32_t;
typedef unsigned long long duk_uint64_t;
typedef signed long long duk_int64_t;
typedef duk_uint8_t duk_uint_least8_t;
typedef duk_int8_t duk_int_least8_t;
typedef duk_uint16_t duk_uint_least16_t;
typedef duk_int16_t duk_int_least16_t;
typedef duk_uint32_t duk_uint_least32_t;
typedef duk_int32_t duk_int_least32_t;
typedef duk_uint8_t duk_uint_fast8_t;
typedef duk_int8_t duk_int_fast8_t;
typedef duk_uint16_t duk_uint_fast16_t;
typedef duk_int16_t duk_int_fast16_t;
typedef duk_uint32_t duk_uint_fast32_t;
typedef duk_int32_t duk_int_fast32_t;

typedef duk_uint64_t duk_uint_least64_t;
typedef duk_int64_t duk_int_least64_t;
typedef duk_uint64_t duk_uint_fast64_t;
typedef duk_int64_t duk_int_fast64_t;


typedef duk_uint64_t duk_uintmax_t;
typedef duk_int64_t duk_intmax_t;
typedef duk_int32_t duk_intptr_t;
typedef duk_uint32_t duk_uintptr_t;
typedef size_t duk_size_t;
typedef ptrdiff_t duk_ptrdiff_t;






typedef int duk_int_t;
typedef unsigned int duk_uint_t;
typedef duk_int_fast32_t duk_int_fast_t;
typedef duk_uint_fast32_t duk_uint_fast_t;
typedef int duk_small_int_t;
typedef unsigned int duk_small_uint_t;
typedef duk_int_fast16_t duk_small_int_fast_t;
typedef duk_uint_fast16_t duk_small_uint_fast_t;






typedef duk_small_uint_t duk_bool_t;




typedef duk_int_t duk_idx_t;




typedef duk_uint_t duk_uidx_t;






typedef duk_uint_t duk_uarridx_t;







typedef duk_small_int_t duk_ret_t;






typedef duk_int_t duk_errcode_t;
typedef duk_int_t duk_codepoint_t;
typedef duk_uint_t duk_ucodepoint_t;






typedef float duk_float_t;
typedef double duk_double_t;
typedef struct duk_hthread duk_context;
struct duk_thread_state;
struct duk_memory_functions;
struct duk_function_list_entry;
struct duk_number_list_entry;
struct duk_time_components;




typedef struct duk_thread_state duk_thread_state;
typedef struct duk_memory_functions duk_memory_functions;
typedef struct duk_function_list_entry duk_function_list_entry;
typedef struct duk_number_list_entry duk_number_list_entry;
typedef struct duk_time_components duk_time_components;

typedef duk_ret_t (*duk_c_function)(duk_context *ctx);
typedef void *(*duk_alloc_function) (void *udata, duk_size_t size);
typedef void *(*duk_realloc_function) (void *udata, void *ptr, duk_size_t size);
typedef void (*duk_free_function) (void *udata, void *ptr);
typedef void (*duk_fatal_function) (void *udata, const char *msg);
typedef void (*duk_decode_char_function) (void *udata, duk_codepoint_t codepoint);
typedef duk_codepoint_t (*duk_map_char_function) (void *udata, duk_codepoint_t codepoint);
typedef duk_ret_t (*duk_safe_call_function) (duk_context *ctx, void *udata);
typedef duk_size_t (*duk_debug_read_function) (void *udata, char *buffer, duk_size_t length);
typedef duk_size_t (*duk_debug_write_function) (void *udata, const char *buffer, duk_size_t length);
typedef duk_size_t (*duk_debug_peek_function) (void *udata);
typedef void (*duk_debug_read_flush_function) (void *udata);
typedef void (*duk_debug_write_flush_function) (void *udata);
typedef duk_idx_t (*duk_debug_request_function) (duk_context *ctx, void *udata, duk_idx_t nvalues);
typedef void (*duk_debug_detached_function) (duk_context *ctx, void *udata);

struct duk_thread_state {




 char data[128];
};

struct duk_memory_functions {
 duk_alloc_function alloc_func;
 duk_realloc_function realloc_func;
 duk_free_function free_func;
 void *udata;
};

struct duk_function_list_entry {
 const char *key;
 duk_c_function value;
 duk_idx_t nargs;
};

struct duk_number_list_entry {
 const char *key;
 duk_double_t value;
};

struct duk_time_components {
 duk_double_t year;
 duk_double_t month;
 duk_double_t day;
 duk_double_t hours;
 duk_double_t minutes;
 duk_double_t seconds;
 duk_double_t milliseconds;
 duk_double_t weekday;
};
__attribute__ ((visibility("default"))) extern const char *duk_api_global_filename;
__attribute__ ((visibility("default"))) extern duk_int_t duk_api_global_line;






__attribute__ ((visibility("default"))) extern
duk_context *duk_create_heap(duk_alloc_function alloc_func,
                             duk_realloc_function realloc_func,
                             duk_free_function free_func,
                             void *heap_udata,
                             duk_fatal_function fatal_handler);
__attribute__ ((visibility("default"))) extern void duk_destroy_heap(duk_context *ctx);

__attribute__ ((visibility("default"))) extern void duk_suspend(duk_context *ctx, duk_thread_state *state);
__attribute__ ((visibility("default"))) extern void duk_resume(duk_context *ctx, const duk_thread_state *state);
__attribute__ ((visibility("default"))) extern void *duk_alloc_raw(duk_context *ctx, duk_size_t size);
__attribute__ ((visibility("default"))) extern void duk_free_raw(duk_context *ctx, void *ptr);
__attribute__ ((visibility("default"))) extern void *duk_realloc_raw(duk_context *ctx, void *ptr, duk_size_t size);
__attribute__ ((visibility("default"))) extern void *duk_alloc(duk_context *ctx, duk_size_t size);
__attribute__ ((visibility("default"))) extern void duk_free(duk_context *ctx, void *ptr);
__attribute__ ((visibility("default"))) extern void *duk_realloc(duk_context *ctx, void *ptr, duk_size_t size);
__attribute__ ((visibility("default"))) extern void duk_get_memory_functions(duk_context *ctx, duk_memory_functions *out_funcs);
__attribute__ ((visibility("default"))) extern void duk_gc(duk_context *ctx, duk_uint_t flags);





__attribute__ ((visibility("default"))) extern void duk_throw_raw(duk_context *ctx) __attribute__((noreturn));


__attribute__ ((visibility("default"))) extern void duk_fatal_raw(duk_context *ctx, const char *err_msg) __attribute__((noreturn));


__attribute__ ((visibility("default"))) extern void duk_error_raw(duk_context *ctx, duk_errcode_t err_code, const char *filename, duk_int_t line, const char *fmt, ...) __attribute__((noreturn));
__attribute__ ((visibility("default"))) extern duk_ret_t duk_error_stash(duk_context *ctx, duk_errcode_t err_code, const char *fmt, ...) __attribute__((noreturn));
__attribute__ ((visibility("default"))) extern duk_ret_t duk_generic_error_stash(duk_context *ctx, const char *fmt, ...) __attribute__((noreturn));
__attribute__ ((visibility("default"))) extern duk_ret_t duk_eval_error_stash(duk_context *ctx, const char *fmt, ...) __attribute__((noreturn));
__attribute__ ((visibility("default"))) extern duk_ret_t duk_range_error_stash(duk_context *ctx, const char *fmt, ...) __attribute__((noreturn));
__attribute__ ((visibility("default"))) extern duk_ret_t duk_reference_error_stash(duk_context *ctx, const char *fmt, ...) __attribute__((noreturn));
__attribute__ ((visibility("default"))) extern duk_ret_t duk_syntax_error_stash(duk_context *ctx, const char *fmt, ...) __attribute__((noreturn));
__attribute__ ((visibility("default"))) extern duk_ret_t duk_type_error_stash(duk_context *ctx, const char *fmt, ...) __attribute__((noreturn));
__attribute__ ((visibility("default"))) extern duk_ret_t duk_uri_error_stash(duk_context *ctx, const char *fmt, ...) __attribute__((noreturn));
__attribute__ ((visibility("default"))) extern void duk_error_va_raw(duk_context *ctx, duk_errcode_t err_code, const char *filename, duk_int_t line, const char *fmt, va_list ap) __attribute__((noreturn));
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_strict_call(duk_context *ctx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_constructor_call(duk_context *ctx);





__attribute__ ((visibility("default"))) extern duk_idx_t duk_normalize_index(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_idx_t duk_require_normalize_index(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_valid_index(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_require_valid_index(duk_context *ctx, duk_idx_t idx);

__attribute__ ((visibility("default"))) extern duk_idx_t duk_get_top(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_set_top(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_idx_t duk_get_top_index(duk_context *ctx);
__attribute__ ((visibility("default"))) extern duk_idx_t duk_require_top_index(duk_context *ctx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_check_stack(duk_context *ctx, duk_idx_t extra);
__attribute__ ((visibility("default"))) extern void duk_require_stack(duk_context *ctx, duk_idx_t extra);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_check_stack_top(duk_context *ctx, duk_idx_t top);
__attribute__ ((visibility("default"))) extern void duk_require_stack_top(duk_context *ctx, duk_idx_t top);





__attribute__ ((visibility("default"))) extern void duk_swap(duk_context *ctx, duk_idx_t idx1, duk_idx_t idx2);
__attribute__ ((visibility("default"))) extern void duk_swap_top(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_dup(duk_context *ctx, duk_idx_t from_idx);
__attribute__ ((visibility("default"))) extern void duk_dup_top(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_insert(duk_context *ctx, duk_idx_t to_idx);
__attribute__ ((visibility("default"))) extern void duk_replace(duk_context *ctx, duk_idx_t to_idx);
__attribute__ ((visibility("default"))) extern void duk_copy(duk_context *ctx, duk_idx_t from_idx, duk_idx_t to_idx);
__attribute__ ((visibility("default"))) extern void duk_remove(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_xcopymove_raw(duk_context *to_ctx, duk_context *from_ctx, duk_idx_t count, duk_bool_t is_copy);
__attribute__ ((visibility("default"))) extern void duk_push_undefined(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_null(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_boolean(duk_context *ctx, duk_bool_t val);
__attribute__ ((visibility("default"))) extern void duk_push_true(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_false(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_number(duk_context *ctx, duk_double_t val);
__attribute__ ((visibility("default"))) extern void duk_push_nan(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_int(duk_context *ctx, duk_int_t val);
__attribute__ ((visibility("default"))) extern void duk_push_uint(duk_context *ctx, duk_uint_t val);
__attribute__ ((visibility("default"))) extern const char *duk_push_string(duk_context *ctx, const char *str);
__attribute__ ((visibility("default"))) extern const char *duk_push_lstring(duk_context *ctx, const char *str, duk_size_t len);
__attribute__ ((visibility("default"))) extern void duk_push_pointer(duk_context *ctx, void *p);
__attribute__ ((visibility("default"))) extern const char *duk_push_sprintf(duk_context *ctx, const char *fmt, ...);
__attribute__ ((visibility("default"))) extern const char *duk_push_vsprintf(duk_context *ctx, const char *fmt, va_list ap);
__attribute__ ((visibility("default"))) extern const char *duk_push_literal_raw(duk_context *ctx, const char *str, duk_size_t len);



__attribute__ ((visibility("default"))) extern void duk_push_this(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_new_target(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_current_function(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_current_thread(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_global_object(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_heap_stash(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_global_stash(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_thread_stash(duk_context *ctx, duk_context *target_ctx);

__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_object(duk_context *ctx);
__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_bare_object(duk_context *ctx);
__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_array(duk_context *ctx);
__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_c_function(duk_context *ctx, duk_c_function func, duk_idx_t nargs);
__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_c_lightfunc(duk_context *ctx, duk_c_function func, duk_idx_t nargs, duk_idx_t length, duk_int_t magic);
__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_thread_raw(duk_context *ctx, duk_uint_t flags);
__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_proxy(duk_context *ctx, duk_uint_t proxy_flags);







__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_error_object_raw(duk_context *ctx, duk_errcode_t err_code, const char *filename, duk_int_t line, const char *fmt, ...);





__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_error_object_stash(duk_context *ctx, duk_errcode_t err_code, const char *fmt, ...);







__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_error_object_va_raw(duk_context *ctx, duk_errcode_t err_code, const char *filename, duk_int_t line, const char *fmt, va_list ap);







__attribute__ ((visibility("default"))) extern void *duk_push_buffer_raw(duk_context *ctx, duk_size_t size, duk_small_uint_t flags);
__attribute__ ((visibility("default"))) extern void duk_push_buffer_object(duk_context *ctx, duk_idx_t idx_buffer, duk_size_t byte_offset, duk_size_t byte_length, duk_uint_t flags);

__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_heapptr(duk_context *ctx, void *ptr);





__attribute__ ((visibility("default"))) extern void duk_pop(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_pop_n(duk_context *ctx, duk_idx_t count);
__attribute__ ((visibility("default"))) extern void duk_pop_2(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_pop_3(duk_context *ctx);
__attribute__ ((visibility("default"))) extern duk_int_t duk_get_type(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_check_type(duk_context *ctx, duk_idx_t idx, duk_int_t type);
__attribute__ ((visibility("default"))) extern duk_uint_t duk_get_type_mask(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_check_type_mask(duk_context *ctx, duk_idx_t idx, duk_uint_t mask);

__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_undefined(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_null(duk_context *ctx, duk_idx_t idx);



__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_boolean(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_number(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_nan(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_string(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_object(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_buffer(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_buffer_data(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_pointer(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_lightfunc(duk_context *ctx, duk_idx_t idx);

__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_symbol(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_array(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_function(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_c_function(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_ecmascript_function(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_bound_function(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_thread(duk_context *ctx, duk_idx_t idx);



__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_constructable(duk_context *ctx, duk_idx_t idx);

__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_dynamic_buffer(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_fixed_buffer(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_external_buffer(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_errcode_t duk_get_error_code(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_boolean(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_double_t duk_get_number(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_int_t duk_get_int(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_uint_t duk_get_uint(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern const char *duk_get_string(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern const char *duk_get_lstring(duk_context *ctx, duk_idx_t idx, duk_size_t *out_len);
__attribute__ ((visibility("default"))) extern void *duk_get_buffer(duk_context *ctx, duk_idx_t idx, duk_size_t *out_size);
__attribute__ ((visibility("default"))) extern void *duk_get_buffer_data(duk_context *ctx, duk_idx_t idx, duk_size_t *out_size);
__attribute__ ((visibility("default"))) extern void *duk_get_pointer(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_c_function duk_get_c_function(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_context *duk_get_context(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void *duk_get_heapptr(duk_context *ctx, duk_idx_t idx);






__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_boolean_default(duk_context *ctx, duk_idx_t idx, duk_bool_t def_value);
__attribute__ ((visibility("default"))) extern duk_double_t duk_get_number_default(duk_context *ctx, duk_idx_t idx, duk_double_t def_value);
__attribute__ ((visibility("default"))) extern duk_int_t duk_get_int_default(duk_context *ctx, duk_idx_t idx, duk_int_t def_value);
__attribute__ ((visibility("default"))) extern duk_uint_t duk_get_uint_default(duk_context *ctx, duk_idx_t idx, duk_uint_t def_value);
__attribute__ ((visibility("default"))) extern const char *duk_get_string_default(duk_context *ctx, duk_idx_t idx, const char *def_value);
__attribute__ ((visibility("default"))) extern const char *duk_get_lstring_default(duk_context *ctx, duk_idx_t idx, duk_size_t *out_len, const char *def_ptr, duk_size_t def_len);
__attribute__ ((visibility("default"))) extern void *duk_get_buffer_default(duk_context *ctx, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_len);
__attribute__ ((visibility("default"))) extern void *duk_get_buffer_data_default(duk_context *ctx, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_len);
__attribute__ ((visibility("default"))) extern void *duk_get_pointer_default(duk_context *ctx, duk_idx_t idx, void *def_value);
__attribute__ ((visibility("default"))) extern duk_c_function duk_get_c_function_default(duk_context *ctx, duk_idx_t idx, duk_c_function def_value);
__attribute__ ((visibility("default"))) extern duk_context *duk_get_context_default(duk_context *ctx, duk_idx_t idx, duk_context *def_value);
__attribute__ ((visibility("default"))) extern void *duk_get_heapptr_default(duk_context *ctx, duk_idx_t idx, void *def_value);







__attribute__ ((visibility("default"))) extern duk_bool_t duk_opt_boolean(duk_context *ctx, duk_idx_t idx, duk_bool_t def_value);
__attribute__ ((visibility("default"))) extern duk_double_t duk_opt_number(duk_context *ctx, duk_idx_t idx, duk_double_t def_value);
__attribute__ ((visibility("default"))) extern duk_int_t duk_opt_int(duk_context *ctx, duk_idx_t idx, duk_int_t def_value);
__attribute__ ((visibility("default"))) extern duk_uint_t duk_opt_uint(duk_context *ctx, duk_idx_t idx, duk_uint_t def_value);
__attribute__ ((visibility("default"))) extern const char *duk_opt_string(duk_context *ctx, duk_idx_t idx, const char *def_ptr);
__attribute__ ((visibility("default"))) extern const char *duk_opt_lstring(duk_context *ctx, duk_idx_t idx, duk_size_t *out_len, const char *def_ptr, duk_size_t def_len);
__attribute__ ((visibility("default"))) extern void *duk_opt_buffer(duk_context *ctx, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_size);
__attribute__ ((visibility("default"))) extern void *duk_opt_buffer_data(duk_context *ctx, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_size);
__attribute__ ((visibility("default"))) extern void *duk_opt_pointer(duk_context *ctx, duk_idx_t idx, void *def_value);
__attribute__ ((visibility("default"))) extern duk_c_function duk_opt_c_function(duk_context *ctx, duk_idx_t idx, duk_c_function def_value);
__attribute__ ((visibility("default"))) extern duk_context *duk_opt_context(duk_context *ctx, duk_idx_t idx, duk_context *def_value);
__attribute__ ((visibility("default"))) extern void *duk_opt_heapptr(duk_context *ctx, duk_idx_t idx, void *def_value);
__attribute__ ((visibility("default"))) extern void duk_require_undefined(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_require_null(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_require_boolean(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_double_t duk_require_number(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_int_t duk_require_int(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_uint_t duk_require_uint(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern const char *duk_require_string(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern const char *duk_require_lstring(duk_context *ctx, duk_idx_t idx, duk_size_t *out_len);
__attribute__ ((visibility("default"))) extern void duk_require_object(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void *duk_require_buffer(duk_context *ctx, duk_idx_t idx, duk_size_t *out_size);
__attribute__ ((visibility("default"))) extern void *duk_require_buffer_data(duk_context *ctx, duk_idx_t idx, duk_size_t *out_size);
__attribute__ ((visibility("default"))) extern void *duk_require_pointer(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_c_function duk_require_c_function(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_context *duk_require_context(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_require_function(duk_context *ctx, duk_idx_t idx);


__attribute__ ((visibility("default"))) extern void *duk_require_heapptr(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_to_undefined(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_to_null(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_to_boolean(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_double_t duk_to_number(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_int_t duk_to_int(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_uint_t duk_to_uint(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_int32_t duk_to_int32(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_uint32_t duk_to_uint32(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_uint16_t duk_to_uint16(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern const char *duk_to_string(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern const char *duk_to_lstring(duk_context *ctx, duk_idx_t idx, duk_size_t *out_len);
__attribute__ ((visibility("default"))) extern void *duk_to_buffer_raw(duk_context *ctx, duk_idx_t idx, duk_size_t *out_size, duk_uint_t flags);
__attribute__ ((visibility("default"))) extern void *duk_to_pointer(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_to_object(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_to_primitive(duk_context *ctx, duk_idx_t idx, duk_int_t hint);
__attribute__ ((visibility("default"))) extern const char *duk_safe_to_lstring(duk_context *ctx, duk_idx_t idx, duk_size_t *out_len);







__attribute__ ((visibility("default"))) extern duk_size_t duk_get_length(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_set_length(duk_context *ctx, duk_idx_t idx, duk_size_t len);
__attribute__ ((visibility("default"))) extern const char *duk_base64_encode(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_base64_decode(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern const char *duk_hex_encode(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_hex_decode(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern const char *duk_json_encode(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_json_decode(duk_context *ctx, duk_idx_t idx);

__attribute__ ((visibility("default"))) extern const char *duk_buffer_to_string(duk_context *ctx, duk_idx_t idx);





__attribute__ ((visibility("default"))) extern void *duk_resize_buffer(duk_context *ctx, duk_idx_t idx, duk_size_t new_size);
__attribute__ ((visibility("default"))) extern void *duk_steal_buffer(duk_context *ctx, duk_idx_t idx, duk_size_t *out_size);
__attribute__ ((visibility("default"))) extern void duk_config_buffer(duk_context *ctx, duk_idx_t idx, void *ptr, duk_size_t len);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_prop(duk_context *ctx, duk_idx_t obj_idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_prop_string(duk_context *ctx, duk_idx_t obj_idx, const char *key);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_prop_lstring(duk_context *ctx, duk_idx_t obj_idx, const char *key, duk_size_t key_len);



__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_prop_literal_raw(duk_context *ctx, duk_idx_t obj_idx, const char *key, duk_size_t key_len);


__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_prop_index(duk_context *ctx, duk_idx_t obj_idx, duk_uarridx_t arr_idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_prop_heapptr(duk_context *ctx, duk_idx_t obj_idx, void *ptr);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_put_prop(duk_context *ctx, duk_idx_t obj_idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_put_prop_string(duk_context *ctx, duk_idx_t obj_idx, const char *key);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_put_prop_lstring(duk_context *ctx, duk_idx_t obj_idx, const char *key, duk_size_t key_len);



__attribute__ ((visibility("default"))) extern duk_bool_t duk_put_prop_literal_raw(duk_context *ctx, duk_idx_t obj_idx, const char *key, duk_size_t key_len);


__attribute__ ((visibility("default"))) extern duk_bool_t duk_put_prop_index(duk_context *ctx, duk_idx_t obj_idx, duk_uarridx_t arr_idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_put_prop_heapptr(duk_context *ctx, duk_idx_t obj_idx, void *ptr);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_del_prop(duk_context *ctx, duk_idx_t obj_idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_del_prop_string(duk_context *ctx, duk_idx_t obj_idx, const char *key);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_del_prop_lstring(duk_context *ctx, duk_idx_t obj_idx, const char *key, duk_size_t key_len);



__attribute__ ((visibility("default"))) extern duk_bool_t duk_del_prop_literal_raw(duk_context *ctx, duk_idx_t obj_idx, const char *key, duk_size_t key_len);


__attribute__ ((visibility("default"))) extern duk_bool_t duk_del_prop_index(duk_context *ctx, duk_idx_t obj_idx, duk_uarridx_t arr_idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_del_prop_heapptr(duk_context *ctx, duk_idx_t obj_idx, void *ptr);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_has_prop(duk_context *ctx, duk_idx_t obj_idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_has_prop_string(duk_context *ctx, duk_idx_t obj_idx, const char *key);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_has_prop_lstring(duk_context *ctx, duk_idx_t obj_idx, const char *key, duk_size_t key_len);



__attribute__ ((visibility("default"))) extern duk_bool_t duk_has_prop_literal_raw(duk_context *ctx, duk_idx_t obj_idx, const char *key, duk_size_t key_len);


__attribute__ ((visibility("default"))) extern duk_bool_t duk_has_prop_index(duk_context *ctx, duk_idx_t obj_idx, duk_uarridx_t arr_idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_has_prop_heapptr(duk_context *ctx, duk_idx_t obj_idx, void *ptr);

__attribute__ ((visibility("default"))) extern void duk_get_prop_desc(duk_context *ctx, duk_idx_t obj_idx, duk_uint_t flags);
__attribute__ ((visibility("default"))) extern void duk_def_prop(duk_context *ctx, duk_idx_t obj_idx, duk_uint_t flags);

__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_global_string(duk_context *ctx, const char *key);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_global_lstring(duk_context *ctx, const char *key, duk_size_t key_len);



__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_global_literal_raw(duk_context *ctx, const char *key, duk_size_t key_len);


__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_global_heapptr(duk_context *ctx, void *ptr);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_put_global_string(duk_context *ctx, const char *key);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_put_global_lstring(duk_context *ctx, const char *key, duk_size_t key_len);



__attribute__ ((visibility("default"))) extern duk_bool_t duk_put_global_literal_raw(duk_context *ctx, const char *key, duk_size_t key_len);


__attribute__ ((visibility("default"))) extern duk_bool_t duk_put_global_heapptr(duk_context *ctx, void *ptr);





__attribute__ ((visibility("default"))) extern void duk_inspect_value(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_inspect_callstack_entry(duk_context *ctx, duk_int_t level);





__attribute__ ((visibility("default"))) extern void duk_get_prototype(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_set_prototype(duk_context *ctx, duk_idx_t idx);





__attribute__ ((visibility("default"))) extern void duk_get_finalizer(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_set_finalizer(duk_context *ctx, duk_idx_t idx);





__attribute__ ((visibility("default"))) extern void duk_set_global_object(duk_context *ctx);





__attribute__ ((visibility("default"))) extern duk_int_t duk_get_magic(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_set_magic(duk_context *ctx, duk_idx_t idx, duk_int_t magic);
__attribute__ ((visibility("default"))) extern duk_int_t duk_get_current_magic(duk_context *ctx);





__attribute__ ((visibility("default"))) extern void duk_put_function_list(duk_context *ctx, duk_idx_t obj_idx, const duk_function_list_entry *funcs);
__attribute__ ((visibility("default"))) extern void duk_put_number_list(duk_context *ctx, duk_idx_t obj_idx, const duk_number_list_entry *numbers);





__attribute__ ((visibility("default"))) extern void duk_compact(duk_context *ctx, duk_idx_t obj_idx);
__attribute__ ((visibility("default"))) extern void duk_enum(duk_context *ctx, duk_idx_t obj_idx, duk_uint_t enum_flags);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_next(duk_context *ctx, duk_idx_t enum_idx, duk_bool_t get_value);
__attribute__ ((visibility("default"))) extern void duk_seal(duk_context *ctx, duk_idx_t obj_idx);
__attribute__ ((visibility("default"))) extern void duk_freeze(duk_context *ctx, duk_idx_t obj_idx);





__attribute__ ((visibility("default"))) extern void duk_concat(duk_context *ctx, duk_idx_t count);
__attribute__ ((visibility("default"))) extern void duk_join(duk_context *ctx, duk_idx_t count);
__attribute__ ((visibility("default"))) extern void duk_decode_string(duk_context *ctx, duk_idx_t idx, duk_decode_char_function callback, void *udata);
__attribute__ ((visibility("default"))) extern void duk_map_string(duk_context *ctx, duk_idx_t idx, duk_map_char_function callback, void *udata);
__attribute__ ((visibility("default"))) extern void duk_substring(duk_context *ctx, duk_idx_t idx, duk_size_t start_char_offset, duk_size_t end_char_offset);
__attribute__ ((visibility("default"))) extern void duk_trim(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_codepoint_t duk_char_code_at(duk_context *ctx, duk_idx_t idx, duk_size_t char_offset);





__attribute__ ((visibility("default"))) extern duk_bool_t duk_equals(duk_context *ctx, duk_idx_t idx1, duk_idx_t idx2);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_strict_equals(duk_context *ctx, duk_idx_t idx1, duk_idx_t idx2);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_samevalue(duk_context *ctx, duk_idx_t idx1, duk_idx_t idx2);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_instanceof(duk_context *ctx, duk_idx_t idx1, duk_idx_t idx2);





__attribute__ ((visibility("default"))) extern duk_double_t duk_random(duk_context *ctx);





__attribute__ ((visibility("default"))) extern void duk_call(duk_context *ctx, duk_idx_t nargs);
__attribute__ ((visibility("default"))) extern void duk_call_method(duk_context *ctx, duk_idx_t nargs);
__attribute__ ((visibility("default"))) extern void duk_call_prop(duk_context *ctx, duk_idx_t obj_idx, duk_idx_t nargs);
__attribute__ ((visibility("default"))) extern duk_int_t duk_pcall(duk_context *ctx, duk_idx_t nargs);
__attribute__ ((visibility("default"))) extern duk_int_t duk_pcall_method(duk_context *ctx, duk_idx_t nargs);
__attribute__ ((visibility("default"))) extern duk_int_t duk_pcall_prop(duk_context *ctx, duk_idx_t obj_idx, duk_idx_t nargs);
__attribute__ ((visibility("default"))) extern void duk_new(duk_context *ctx, duk_idx_t nargs);
__attribute__ ((visibility("default"))) extern duk_int_t duk_pnew(duk_context *ctx, duk_idx_t nargs);
__attribute__ ((visibility("default"))) extern duk_int_t duk_safe_call(duk_context *ctx, duk_safe_call_function func, void *udata, duk_idx_t nargs, duk_idx_t nrets);
__attribute__ ((visibility("default"))) extern duk_int_t duk_eval_raw(duk_context *ctx, const char *src_buffer, duk_size_t src_length, duk_uint_t flags);
__attribute__ ((visibility("default"))) extern duk_int_t duk_compile_raw(duk_context *ctx, const char *src_buffer, duk_size_t src_length, duk_uint_t flags);
__attribute__ ((visibility("default"))) extern void duk_dump_function(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_load_function(duk_context *ctx);





__attribute__ ((visibility("default"))) extern void duk_push_context_dump(duk_context *ctx);





__attribute__ ((visibility("default"))) extern void duk_debugger_attach(duk_context *ctx,
                                           duk_debug_read_function read_cb,
                                           duk_debug_write_function write_cb,
                                           duk_debug_peek_function peek_cb,
                                           duk_debug_read_flush_function read_flush_cb,
                                           duk_debug_write_flush_function write_flush_cb,
                                           duk_debug_request_function request_cb,
                                           duk_debug_detached_function detached_cb,
                                           void *udata);
__attribute__ ((visibility("default"))) extern void duk_debugger_detach(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_debugger_cooperate(duk_context *ctx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_debugger_notify(duk_context *ctx, duk_idx_t nvalues);
__attribute__ ((visibility("default"))) extern void duk_debugger_pause(duk_context *ctx);





__attribute__ ((visibility("default"))) extern duk_double_t duk_get_now(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_time_to_components(duk_context *ctx, duk_double_t timeval, duk_time_components *comp);
__attribute__ ((visibility("default"))) extern duk_double_t duk_components_to_time(duk_context *ctx, duk_time_components *comp);







union duk_double_union {
 double d;
 float f[2];

 duk_uint64_t ull[1];

 duk_uint32_t ui[2];
 duk_uint16_t us[4];
 duk_uint8_t uc[8];

 void *vp[2];

};

typedef union duk_double_union duk_double_union;
struct duk_jmpbuf {
 jmp_buf jb;
};
struct duk_jmpbuf;



struct duk_heaphdr;
struct duk_heaphdr_string;
struct duk_harray;
struct duk_hstring;
struct duk_hstring_external;
struct duk_hobject;
struct duk_hcompfunc;
struct duk_hnatfunc;
struct duk_hboundfunc;
struct duk_hthread;
struct duk_hbufobj;
struct duk_hdecenv;
struct duk_hobjenv;
struct duk_hproxy;
struct duk_hbuffer;
struct duk_hbuffer_fixed;
struct duk_hbuffer_dynamic;
struct duk_hbuffer_external;

struct duk_propaccessor;
union duk_propvalue;
struct duk_propdesc;

struct duk_heap;
struct duk_breakpoint;

struct duk_activation;
struct duk_catcher;
struct duk_ljstate;
struct duk_strcache_entry;
struct duk_litcache_entry;
struct duk_strtab_entry;





struct duk_bitdecoder_ctx;
struct duk_bitencoder_ctx;
struct duk_bufwriter_ctx;

struct duk_token;
struct duk_re_token;
struct duk_lexer_point;
struct duk_lexer_ctx;
struct duk_lexer_codepoint;

struct duk_compiler_instr;
struct duk_compiler_func;
struct duk_compiler_ctx;

struct duk_re_matcher_ctx;
struct duk_re_compiler_ctx;




typedef struct duk_jmpbuf duk_jmpbuf;



typedef struct duk_heaphdr duk_heaphdr;
typedef struct duk_heaphdr_string duk_heaphdr_string;
typedef struct duk_harray duk_harray;
typedef struct duk_hstring duk_hstring;
typedef struct duk_hstring_external duk_hstring_external;
typedef struct duk_hobject duk_hobject;
typedef struct duk_hcompfunc duk_hcompfunc;
typedef struct duk_hnatfunc duk_hnatfunc;
typedef struct duk_hboundfunc duk_hboundfunc;
typedef struct duk_hthread duk_hthread;
typedef struct duk_hbufobj duk_hbufobj;
typedef struct duk_hdecenv duk_hdecenv;
typedef struct duk_hobjenv duk_hobjenv;
typedef struct duk_hproxy duk_hproxy;
typedef struct duk_hbuffer duk_hbuffer;
typedef struct duk_hbuffer_fixed duk_hbuffer_fixed;
typedef struct duk_hbuffer_dynamic duk_hbuffer_dynamic;
typedef struct duk_hbuffer_external duk_hbuffer_external;

typedef struct duk_propaccessor duk_propaccessor;
typedef union duk_propvalue duk_propvalue;
typedef struct duk_propdesc duk_propdesc;

typedef struct duk_heap duk_heap;
typedef struct duk_breakpoint duk_breakpoint;

typedef struct duk_activation duk_activation;
typedef struct duk_catcher duk_catcher;
typedef struct duk_ljstate duk_ljstate;
typedef struct duk_strcache_entry duk_strcache_entry;
typedef struct duk_litcache_entry duk_litcache_entry;
typedef struct duk_strtab_entry duk_strtab_entry;





typedef struct duk_bitdecoder_ctx duk_bitdecoder_ctx;
typedef struct duk_bitencoder_ctx duk_bitencoder_ctx;
typedef struct duk_bufwriter_ctx duk_bufwriter_ctx;

typedef struct duk_token duk_token;
typedef struct duk_re_token duk_re_token;
typedef struct duk_lexer_point duk_lexer_point;
typedef struct duk_lexer_ctx duk_lexer_ctx;
typedef struct duk_lexer_codepoint duk_lexer_codepoint;

typedef struct duk_compiler_instr duk_compiler_instr;
typedef struct duk_compiler_func duk_compiler_func;
typedef struct duk_compiler_ctx duk_compiler_ctx;

typedef struct duk_re_matcher_ctx duk_re_matcher_ctx;
typedef struct duk_re_compiler_ctx duk_re_compiler_ctx;
typedef union duk_double_union duk_tval;
typedef struct {
 duk_uint16_t a;
 duk_uint16_t b;
 duk_uint16_t c;
 duk_uint16_t d;
} duk_tval_unused;
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_function_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_boolean_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_number_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_error_constructor_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_type_error_thrower(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_parse_int(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_parse_float(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_thread_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_pointer_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_proxy_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_arraybuffer_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_dataview_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_typedarray_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_textencoder_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_textdecoder_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_eval(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_is_nan(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_is_finite(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_decode_uri(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_decode_uri_component(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_encode_uri(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_encode_uri_component(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_escape(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_unescape(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_getprototype_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_setprototype_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_get_own_property_descriptor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_keys_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_assign(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_create(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_define_property(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_define_properties(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_seal_freeze_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_prevent_extensions(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_is_sealed_frozen_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_is_extensible(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_is(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_to_string(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_to_locale_string(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_value_of(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_has_own_property(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_is_prototype_of(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_property_is_enumerable(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_defineaccessor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_lookupaccessor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype_to_string(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype_apply(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype_call(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype_bind(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_native_function_length(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_native_function_name(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_constructor_is_array(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_to_string(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_join_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_concat(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_pop(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_push(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_reverse(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_shift(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_slice(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_sort(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_splice(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_unshift(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_indexof_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_iter_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_reduce_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_constructor_from_char_code(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_constructor_from_code_point(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_to_string(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_char_at(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_char_code_at(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_concat(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_indexof_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_locale_compare(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_match(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_replace(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_search(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_slice(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_split(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_substring(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_caseconv_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_trim(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_repeat(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_startswith_endswith(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_includes(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_substr(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_boolean_prototype_tostring_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_number_check_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_to_string(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_to_locale_string(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_value_of(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_to_fixed(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_to_exponential(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_to_precision(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_constructor_parse(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_constructor_utc(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_constructor_now(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_tostring_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_to_json(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_value_of(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_get_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_get_timezone_offset(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_set_time(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_set_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_prototype_exec(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_prototype_test(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_prototype_tostring(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_prototype_flags(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_prototype_shared_getter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_stack_getter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_stack_setter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_filename_getter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_filename_setter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_linenumber_getter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_linenumber_setter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_to_string(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_onearg_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_twoarg_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_clz32(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_hypot(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_imul(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_max(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_min(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_random(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_sign(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_json_object_parse(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_json_object_stringify(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_info(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_act(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_gc(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_fin(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_enc(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_dec(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_compact(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_thread_yield(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_thread_resume(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_thread_current(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_pointer_prototype_tostring_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_apply(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_construct(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_object_delete_property(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_object_get(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_object_has(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_object_set(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_arraybuffer_isview(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_typedarray_bytelength_getter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_buffer_slice_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_typedarray_byteoffset_getter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_typedarray_buffer_getter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_buffer_readfield(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_buffer_writefield(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_typedarray_set(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_uint8array_allocplain(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_uint8array_plainof(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_concat(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_is_encoding(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_is_buffer(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_byte_length(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_buffer_compare_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_tostring(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_tojson(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_fill(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_copy(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_write(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_textencoder_prototype_encoding_getter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_textencoder_prototype_encode(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_textdecoder_prototype_shared_getter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_textdecoder_prototype_decode(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_performance_now(duk_context *ctx);
struct duk_bitdecoder_ctx {
 const duk_uint8_t *data;
 duk_size_t offset;
 duk_size_t length;
 duk_uint32_t currval;
 duk_small_int_t currbits;
};







struct duk_bitencoder_ctx {
 duk_uint8_t *data;
 duk_size_t offset;
 duk_size_t length;
 duk_uint32_t currval;
 duk_small_int_t currbits;
 duk_small_int_t truncated;
};
struct duk_bufwriter_ctx {
 duk_uint8_t *p;
 duk_uint8_t *p_base;
 duk_uint8_t *p_limit;
 duk_hbuffer_dynamic *buf;
};
static __attribute__ ((unused)) duk_uint32_t duk_bd_decode(duk_bitdecoder_ctx *ctx, duk_small_int_t bits);
static __attribute__ ((unused)) duk_small_uint_t duk_bd_decode_flag(duk_bitdecoder_ctx *ctx);
static __attribute__ ((unused)) duk_uint32_t duk_bd_decode_flagged(duk_bitdecoder_ctx *ctx, duk_small_int_t bits, duk_uint32_t def_value);
static __attribute__ ((unused)) duk_int32_t duk_bd_decode_flagged_signed(duk_bitdecoder_ctx *ctx, duk_small_int_t bits, duk_int32_t def_value);
static __attribute__ ((unused)) duk_uint32_t duk_bd_decode_varuint(duk_bitdecoder_ctx *ctx);
static __attribute__ ((unused)) duk_small_uint_t duk_bd_decode_bitpacked_string(duk_bitdecoder_ctx *bd, duk_uint8_t *out);

static __attribute__ ((unused)) void duk_be_encode(duk_bitencoder_ctx *ctx, duk_uint32_t data, duk_small_int_t bits);
static __attribute__ ((unused)) void duk_be_finish(duk_bitencoder_ctx *ctx);


static __attribute__ ((unused)) duk_double_t duk_util_tinyrandom_get_double(duk_hthread *thr);
static __attribute__ ((unused)) void duk_util_tinyrandom_prepare_seed(duk_hthread *thr);


static __attribute__ ((unused)) void duk_bw_init(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx, duk_hbuffer_dynamic *h_buf);
static __attribute__ ((unused)) void duk_bw_init_pushbuf(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx, duk_size_t buf_size);
static __attribute__ ((unused)) duk_uint8_t *duk_bw_resize(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx, duk_size_t sz);
static __attribute__ ((unused)) void duk_bw_compact(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx);
static __attribute__ ((unused)) void duk_bw_write_raw_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t src_off, duk_size_t len);
static __attribute__ ((unused)) void duk_bw_write_ensure_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t src_off, duk_size_t len);
static __attribute__ ((unused)) void duk_bw_insert_raw_bytes(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t dst_off, const duk_uint8_t *buf, duk_size_t len);
static __attribute__ ((unused)) void duk_bw_insert_ensure_bytes(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t dst_off, const duk_uint8_t *buf, duk_size_t len);
static __attribute__ ((unused)) void duk_bw_insert_raw_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t dst_off, duk_size_t src_off, duk_size_t len);
static __attribute__ ((unused)) void duk_bw_insert_ensure_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t dst_off, duk_size_t src_off, duk_size_t len);
static __attribute__ ((unused)) duk_uint8_t *duk_bw_insert_raw_area(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t off, duk_size_t len);
static __attribute__ ((unused)) duk_uint8_t *duk_bw_insert_ensure_area(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t off, duk_size_t len);
static __attribute__ ((unused)) void duk_bw_remove_raw_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t off, duk_size_t len);


static __attribute__ ((unused)) duk_uint16_t duk_raw_read_u16_be(duk_uint8_t **p);
static __attribute__ ((unused)) duk_uint32_t duk_raw_read_u32_be(duk_uint8_t **p);
static __attribute__ ((unused)) duk_double_t duk_raw_read_double_be(duk_uint8_t **p);
static __attribute__ ((unused)) void duk_raw_write_u16_be(duk_uint8_t **p, duk_uint16_t val);
static __attribute__ ((unused)) void duk_raw_write_u32_be(duk_uint8_t **p, duk_uint32_t val);
static __attribute__ ((unused)) void duk_raw_write_double_be(duk_uint8_t **p, duk_double_t val);
static __attribute__ ((unused)) duk_small_int_t duk_memcmp(const void *s1, const void *s2, duk_size_t len);
static __attribute__ ((unused)) duk_small_int_t duk_memcmp_unsafe(const void *s1, const void *s2, duk_size_t len);

static __attribute__ ((unused)) duk_bool_t duk_is_whole_get_int32_nonegzero(duk_double_t x, duk_int32_t *ival);
static __attribute__ ((unused)) duk_bool_t duk_is_whole_get_int32(duk_double_t x, duk_int32_t *ival);
static __attribute__ ((unused)) duk_bool_t duk_double_is_anyinf(duk_double_t x);
static __attribute__ ((unused)) duk_bool_t duk_double_is_posinf(duk_double_t x);
static __attribute__ ((unused)) duk_bool_t duk_double_is_neginf(duk_double_t x);
static __attribute__ ((unused)) duk_bool_t duk_double_is_nan(duk_double_t x);
static __attribute__ ((unused)) duk_bool_t duk_double_is_nan_or_zero(duk_double_t x);
static __attribute__ ((unused)) duk_bool_t duk_double_is_nan_or_inf(duk_double_t x);
static __attribute__ ((unused)) duk_bool_t duk_double_is_nan_zero_inf(duk_double_t x);
static __attribute__ ((unused)) duk_small_uint_t duk_double_signbit(duk_double_t x);
static __attribute__ ((unused)) duk_double_t duk_double_trunc_towards_zero(duk_double_t x);
static __attribute__ ((unused)) duk_bool_t duk_double_same_sign(duk_double_t x, duk_double_t y);
static __attribute__ ((unused)) duk_double_t duk_double_fmin(duk_double_t x, duk_double_t y);
static __attribute__ ((unused)) duk_double_t duk_double_fmax(duk_double_t x, duk_double_t y);
static __attribute__ ((unused)) duk_bool_t duk_double_is_finite(duk_double_t x);
static __attribute__ ((unused)) duk_bool_t duk_double_is_integer(duk_double_t x);
static __attribute__ ((unused)) duk_bool_t duk_double_is_safe_integer(duk_double_t x);

static __attribute__ ((unused)) duk_double_t duk_double_div(duk_double_t x, duk_double_t y);
static __attribute__ ((unused)) duk_int_t duk_double_to_int_t(duk_double_t x);
static __attribute__ ((unused)) duk_uint_t duk_double_to_uint_t(duk_double_t x);
static __attribute__ ((unused)) duk_int32_t duk_double_to_int32_t(duk_double_t x);
static __attribute__ ((unused)) duk_uint32_t duk_double_to_uint32_t(duk_double_t x);
static __attribute__ ((unused)) duk_float_t duk_double_to_float_t(duk_double_t x);
typedef duk_uint32_t duk_instr_t;







typedef void (*duk_re_range_callback)(void *user, duk_codepoint_t r1, duk_codepoint_t r2, duk_bool_t direct);
struct duk_token {
 duk_small_uint_t t;
 duk_small_uint_t t_nores;
 duk_double_t num;
 duk_hstring *str1;
 duk_hstring *str2;
 duk_size_t start_offset;
 duk_int_t start_line;
 duk_int_t num_escapes;
 duk_bool_t lineterm;
 duk_bool_t allow_auto_semi;
};




struct duk_re_token {
 duk_small_uint_t t;
 duk_small_uint_t greedy;
 duk_uint32_t num;
 duk_uint32_t qmin;
 duk_uint32_t qmax;
};


struct duk_lexer_point {
 duk_size_t offset;
 duk_int_t line;
};


struct duk_lexer_codepoint {
 duk_codepoint_t codepoint;
 duk_size_t offset;
 duk_int_t line;
};


struct duk_lexer_ctx {

 duk_lexer_codepoint *window;
 duk_lexer_codepoint buffer[64];




 duk_hthread *thr;

 const duk_uint8_t *input;
 duk_size_t input_length;
 duk_size_t input_offset;
 duk_int_t input_line;

 duk_idx_t slot1_idx;
 duk_idx_t slot2_idx;
 duk_idx_t buf_idx;
 duk_hbuffer_dynamic *buf;
 duk_bufwriter_ctx bw;

 duk_int_t token_count;
 duk_int_t token_limit;

 duk_small_uint_t flags;
};





static __attribute__ ((unused)) void duk_lexer_initctx(duk_lexer_ctx *lex_ctx);

static __attribute__ ((unused)) void duk_lexer_getpoint(duk_lexer_ctx *lex_ctx, duk_lexer_point *pt);
static __attribute__ ((unused)) void duk_lexer_setpoint(duk_lexer_ctx *lex_ctx, duk_lexer_point *pt);

static __attribute__ ((unused))
void duk_lexer_parse_js_input_element(duk_lexer_ctx *lex_ctx,
                                      duk_token *out_token,
                                      duk_bool_t strict_mode,
                                      duk_bool_t regexp_mode);

static __attribute__ ((unused)) void duk_lexer_parse_re_token(duk_lexer_ctx *lex_ctx, duk_re_token *out_token);
static __attribute__ ((unused)) void duk_lexer_parse_re_ranges(duk_lexer_ctx *lex_ctx, duk_re_range_callback gen_range, void *userdata);
typedef duk_int32_t duk_regconst_t;

typedef struct {
 duk_small_uint_t t;
 duk_regconst_t regconst;
 duk_idx_t valstack_idx;
} duk_ispec;

typedef struct {
 duk_small_uint_t t;
 duk_small_uint_t op;
 duk_ispec x1;
 duk_ispec x2;
} duk_ivalue;







struct duk_compiler_instr {
 duk_instr_t ins;

 duk_uint32_t line;

};
typedef struct {
 duk_small_uint_t flags;
 duk_int_t label_id;
 duk_hstring *h_label;
 duk_int_t catch_depth;
 duk_int_t pc_label;
} duk_labelinfo;


struct duk_compiler_func {





 duk_bufwriter_ctx bw_code;

 duk_hstring *h_name;

 duk_hobject *h_consts;
 duk_hobject *h_funcs;


 duk_hobject *h_decls;



 duk_hobject *h_labelnames;
 duk_hbuffer_dynamic *h_labelinfos;
 duk_hobject *h_argnames;
 duk_hobject *h_varmap;



 duk_idx_t consts_idx;
 duk_idx_t funcs_idx;
 duk_idx_t decls_idx;
 duk_idx_t labelnames_idx;
 duk_idx_t labelinfos_idx;
 duk_idx_t argnames_idx;
 duk_idx_t varmap_idx;


 duk_regconst_t temp_first;
 duk_regconst_t temp_next;
 duk_regconst_t temp_max;


 duk_regconst_t shuffle1;
 duk_regconst_t shuffle2;
 duk_regconst_t shuffle3;


 duk_int_t nud_count;
 duk_int_t led_count;
 duk_int_t paren_level;
 duk_bool_t expr_lhs;
 duk_bool_t allow_in;


 duk_int_t stmt_next;
 duk_int_t label_next;
 duk_int_t catch_depth;
 duk_int_t with_depth;
 duk_int_t fnum_next;
 duk_int_t num_formals;
 duk_regconst_t reg_stmt_value;






 duk_uint8_t is_function;
 duk_uint8_t is_eval;
 duk_uint8_t is_global;
 duk_uint8_t is_namebinding;
 duk_uint8_t is_constructable;
 duk_uint8_t is_setget;
 duk_uint8_t is_strict;
 duk_uint8_t is_notail;
 duk_uint8_t in_directive_prologue;
 duk_uint8_t in_scanning;
 duk_uint8_t may_direct_eval;
 duk_uint8_t id_access_arguments;
 duk_uint8_t id_access_slow;
 duk_uint8_t id_access_slow_own;
 duk_uint8_t is_arguments_shadowed;
 duk_uint8_t needs_shuffle;
 duk_uint8_t reject_regexp_in_adv;
 duk_uint8_t allow_regexp_in_adv;
};

struct duk_compiler_ctx {
 duk_hthread *thr;


 duk_hstring *h_filename;


 duk_lexer_ctx lex;


 duk_token prev_token;
 duk_token curr_token;
 duk_idx_t tok11_idx;
 duk_idx_t tok12_idx;
 duk_idx_t tok21_idx;
 duk_idx_t tok22_idx;


 duk_int_t recursion_depth;
 duk_int_t recursion_limit;


 duk_int_t emit_jumpslot_pc;


 duk_compiler_func curr_func;
};





static __attribute__ ((unused)) void duk_js_compile(duk_hthread *thr, const duk_uint8_t *src_buffer, duk_size_t src_length, duk_small_uint_t flags);
struct duk_re_matcher_ctx {
 duk_hthread *thr;

 duk_uint32_t re_flags;
 const duk_uint8_t *input;
 const duk_uint8_t *input_end;
 const duk_uint8_t *bytecode;
 const duk_uint8_t *bytecode_end;
 const duk_uint8_t **saved;
 duk_uint32_t nsaved;
 duk_uint32_t recursion_depth;
 duk_uint32_t recursion_limit;
 duk_uint32_t steps_count;
 duk_uint32_t steps_limit;
};

struct duk_re_compiler_ctx {
 duk_hthread *thr;

 duk_uint32_t re_flags;
 duk_lexer_ctx lex;
 duk_re_token curr_token;
 duk_bufwriter_ctx bw;
 duk_uint32_t captures;
 duk_uint32_t highest_backref;
 duk_uint32_t recursion_depth;
 duk_uint32_t recursion_limit;
 duk_uint32_t nranges;
};






static __attribute__ ((unused)) void duk_regexp_compile(duk_hthread *thr);
static __attribute__ ((unused)) void duk_regexp_create_instance(duk_hthread *thr);
static __attribute__ ((unused)) void duk_regexp_match(duk_hthread *thr);
static __attribute__ ((unused)) void duk_regexp_match_force_global(duk_hthread *thr);
struct duk_heaphdr {
 duk_uint32_t h_flags;
 duk_uint32_t h_refcount;
 duk_heaphdr *h_next;







 duk_heaphdr *h_prev;
};

struct duk_heaphdr_string {






 duk_uint32_t h_flags;
 duk_uint32_t h_refcount;







 duk_hstring *h_next;

};
static __attribute__ ((unused)) void duk_refzero_check_slow(duk_hthread *thr);
static __attribute__ ((unused)) void duk_refzero_check_fast(duk_hthread *thr);

static __attribute__ ((unused)) void duk_heaphdr_refcount_finalize_norz(duk_heap *heap, duk_heaphdr *hdr);
static __attribute__ ((unused)) void duk_hobject_refcount_finalize_norz(duk_heap *heap, duk_hobject *h);
static __attribute__ ((unused)) void duk_heaphdr_refzero(duk_hthread *thr, duk_heaphdr *h);
static __attribute__ ((unused)) void duk_heaphdr_refzero_norz(duk_hthread *thr, duk_heaphdr *h);

static __attribute__ ((unused)) void duk_hstring_refzero(duk_hthread *thr, duk_hstring *h);
static __attribute__ ((unused)) void duk_hbuffer_refzero(duk_hthread *thr, duk_hbuffer *h);
static __attribute__ ((unused)) void duk_hobject_refzero(duk_hthread *thr, duk_hobject *h);
static __attribute__ ((unused)) void duk_hobject_refzero_norz(duk_hthread *thr, duk_hobject *h);
static __attribute__ ((unused)) void duk_valstack_grow_check_throw(duk_hthread *thr, duk_size_t min_bytes);
static __attribute__ ((unused)) duk_bool_t duk_valstack_grow_check_nothrow(duk_hthread *thr, duk_size_t min_bytes);
static __attribute__ ((unused)) void duk_valstack_shrink_check_nothrow(duk_hthread *thr, duk_bool_t snug);

static __attribute__ ((unused)) void duk_copy_tvals_incref(duk_hthread *thr, duk_tval *tv_dst, duk_tval *tv_src, duk_size_t count);

static __attribute__ ((unused)) duk_tval *duk_reserve_gap(duk_hthread *thr, duk_idx_t idx_base, duk_idx_t count);

static __attribute__ ((unused)) void duk_set_top_unsafe(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) void duk_set_top_and_wipe(duk_hthread *thr, duk_idx_t top, duk_idx_t idx_wipe_start);

static __attribute__ ((unused)) void duk_dup_0(duk_hthread *thr);
static __attribute__ ((unused)) void duk_dup_1(duk_hthread *thr);
static __attribute__ ((unused)) void duk_dup_2(duk_hthread *thr);

static __attribute__ ((unused)) void duk_dup_m2(duk_hthread *thr);
static __attribute__ ((unused)) void duk_dup_m3(duk_hthread *thr);
static __attribute__ ((unused)) void duk_dup_m4(duk_hthread *thr);

static __attribute__ ((unused)) void duk_remove_unsafe(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) void duk_remove_m2(duk_hthread *thr);
static __attribute__ ((unused)) void duk_remove_n(duk_hthread *thr, duk_idx_t idx, duk_idx_t count);
static __attribute__ ((unused)) void duk_remove_n_unsafe(duk_hthread *thr, duk_idx_t idx, duk_idx_t count);

static __attribute__ ((unused)) duk_int_t duk_get_type_tval(duk_tval *tv);
static __attribute__ ((unused)) duk_uint_t duk_get_type_mask_tval(duk_tval *tv);




static __attribute__ ((unused)) duk_small_uint_t duk_get_class_number(duk_hthread *thr, duk_idx_t idx);

static __attribute__ ((unused)) duk_tval *duk_get_tval(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_tval *duk_get_tval_or_unused(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_tval *duk_require_tval(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) void duk_push_tval(duk_hthread *thr, duk_tval *tv);




static __attribute__ ((unused)) void duk_push_this_check_object_coercible(duk_hthread *thr);


static __attribute__ ((unused)) duk_hobject *duk_push_this_coercible_to_object(duk_hthread *thr);


static __attribute__ ((unused)) duk_hstring *duk_push_this_coercible_to_string(duk_hthread *thr);

static __attribute__ ((unused)) duk_hstring *duk_push_uint_to_hstring(duk_hthread *thr, duk_uint_t i);





static __attribute__ ((unused)) duk_tval *duk_get_borrowed_this_tval(duk_hthread *thr);
static __attribute__ ((unused)) duk_bool_t duk_is_string_notsymbol(duk_hthread *thr, duk_idx_t idx);

static __attribute__ ((unused)) duk_bool_t duk_is_callable_tval(duk_hthread *thr, duk_tval *tv);

static __attribute__ ((unused)) duk_hstring *duk_get_hstring(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hstring *duk_get_hstring_notsymbol(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) const char *duk_get_string_notsymbol(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hobject *duk_get_hobject(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hbuffer *duk_get_hbuffer(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hthread *duk_get_hthread(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hcompfunc *duk_get_hcompfunc(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hnatfunc *duk_get_hnatfunc(duk_hthread *thr, duk_idx_t idx);

static __attribute__ ((unused)) void *duk_get_buffer_data_raw(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_len, duk_bool_t throw_flag, duk_bool_t *out_isbuffer);

static __attribute__ ((unused)) duk_hobject *duk_get_hobject_with_class(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t classnum);

static __attribute__ ((unused)) duk_hobject *duk_get_hobject_promote_mask(duk_hthread *thr, duk_idx_t idx, duk_uint_t type_mask);
static __attribute__ ((unused)) duk_hobject *duk_require_hobject_promote_mask(duk_hthread *thr, duk_idx_t idx, duk_uint_t type_mask);
static __attribute__ ((unused)) duk_hobject *duk_require_hobject_accept_mask(duk_hthread *thr, duk_idx_t idx, duk_uint_t type_mask);
static __attribute__ ((unused)) duk_hstring *duk_known_hstring(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hobject *duk_known_hobject(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hbuffer *duk_known_hbuffer(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hcompfunc *duk_known_hcompfunc(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hnatfunc *duk_known_hnatfunc(duk_hthread *thr, duk_idx_t idx);

static __attribute__ ((unused)) duk_double_t duk_to_number_tval(duk_hthread *thr, duk_tval *tv);

static __attribute__ ((unused)) duk_hstring *duk_to_hstring(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hstring *duk_to_hstring_m1(duk_hthread *thr);
static __attribute__ ((unused)) duk_hstring *duk_to_hstring_acceptsymbol(duk_hthread *thr, duk_idx_t idx);

static __attribute__ ((unused)) duk_hobject *duk_to_hobject(duk_hthread *thr, duk_idx_t idx);

static __attribute__ ((unused)) duk_double_t duk_to_number_m1(duk_hthread *thr);
static __attribute__ ((unused)) duk_double_t duk_to_number_m2(duk_hthread *thr);

static __attribute__ ((unused)) duk_bool_t duk_to_boolean_top_pop(duk_hthread *thr);




static __attribute__ ((unused)) void duk_push_class_string_tval(duk_hthread *thr, duk_tval *tv, duk_bool_t avoid_side_effects);

static __attribute__ ((unused)) duk_int_t duk_to_int_clamped_raw(duk_hthread *thr, duk_idx_t idx, duk_int_t minval, duk_int_t maxval, duk_bool_t *out_clamped);
static __attribute__ ((unused)) duk_int_t duk_to_int_clamped(duk_hthread *thr, duk_idx_t idx, duk_int_t minval, duk_int_t maxval);
static __attribute__ ((unused)) duk_int_t duk_to_int_check_range(duk_hthread *thr, duk_idx_t idx, duk_int_t minval, duk_int_t maxval);

static __attribute__ ((unused)) duk_uint8_t duk_to_uint8clamped(duk_hthread *thr, duk_idx_t idx);

static __attribute__ ((unused)) duk_hstring *duk_to_property_key_hstring(duk_hthread *thr, duk_idx_t idx);

static __attribute__ ((unused)) duk_hstring *duk_require_hstring(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hstring *duk_require_hstring_notsymbol(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) const char *duk_require_lstring_notsymbol(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_len);
static __attribute__ ((unused)) const char *duk_require_string_notsymbol(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hobject *duk_require_hobject(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hbuffer *duk_require_hbuffer(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hthread *duk_require_hthread(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hcompfunc *duk_require_hcompfunc(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hnatfunc *duk_require_hnatfunc(duk_hthread *thr, duk_idx_t idx);

static __attribute__ ((unused)) duk_hobject *duk_require_hobject_with_class(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t classnum);

static __attribute__ ((unused)) void duk_push_hstring(duk_hthread *thr, duk_hstring *h);
static __attribute__ ((unused)) void duk_push_hstring_stridx(duk_hthread *thr, duk_small_uint_t stridx);
static __attribute__ ((unused)) void duk_push_hstring_empty(duk_hthread *thr);
static __attribute__ ((unused)) void duk_push_hobject(duk_hthread *thr, duk_hobject *h);
static __attribute__ ((unused)) void duk_push_hbuffer(duk_hthread *thr, duk_hbuffer *h);




static __attribute__ ((unused)) void duk_push_hobject_bidx(duk_hthread *thr, duk_small_int_t builtin_idx);
static __attribute__ ((unused)) duk_hobject *duk_push_object_helper(duk_hthread *thr, duk_uint_t hobject_flags_and_class, duk_small_int_t prototype_bidx);
static __attribute__ ((unused)) duk_hobject *duk_push_object_helper_proto(duk_hthread *thr, duk_uint_t hobject_flags_and_class, duk_hobject *proto);
static __attribute__ ((unused)) duk_hcompfunc *duk_push_hcompfunc(duk_hthread *thr);
static __attribute__ ((unused)) duk_hboundfunc *duk_push_hboundfunc(duk_hthread *thr);
static __attribute__ ((unused)) void duk_push_c_function_builtin(duk_hthread *thr, duk_c_function func, duk_int_t nargs);
static __attribute__ ((unused)) void duk_push_c_function_builtin_noconstruct(duk_hthread *thr, duk_c_function func, duk_int_t nargs);




static __attribute__ ((unused)) duk_harray *duk_push_harray(duk_hthread *thr);
static __attribute__ ((unused)) duk_harray *duk_push_harray_with_size(duk_hthread *thr, duk_uint32_t size);
static __attribute__ ((unused)) duk_tval *duk_push_harray_with_size_outptr(duk_hthread *thr, duk_uint32_t size);

static __attribute__ ((unused)) void duk_push_string_funcptr(duk_hthread *thr, duk_uint8_t *ptr, duk_size_t sz);
static __attribute__ ((unused)) void duk_push_lightfunc_name_raw(duk_hthread *thr, duk_c_function func, duk_small_uint_t lf_flags);
static __attribute__ ((unused)) void duk_push_lightfunc_name(duk_hthread *thr, duk_tval *tv);
static __attribute__ ((unused)) void duk_push_lightfunc_tostring(duk_hthread *thr, duk_tval *tv);




static __attribute__ ((unused)) duk_hbufobj *duk_push_bufobj_raw(duk_hthread *thr, duk_uint_t hobject_flags_and_class, duk_small_int_t prototype_bidx);


static __attribute__ ((unused)) void *duk_push_fixed_buffer_nozero(duk_hthread *thr, duk_size_t len);
static __attribute__ ((unused)) void *duk_push_fixed_buffer_zero(duk_hthread *thr, duk_size_t len);

static __attribute__ ((unused)) const char *duk_push_string_readable(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) const char *duk_push_string_tval_readable(duk_hthread *thr, duk_tval *tv);
static __attribute__ ((unused)) const char *duk_push_string_tval_readable_error(duk_hthread *thr, duk_tval *tv);
static __attribute__ ((unused)) duk_bool_t duk_get_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx);
static __attribute__ ((unused)) duk_bool_t duk_get_prop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args);




static __attribute__ ((unused)) duk_bool_t duk_get_prop_stridx_boolean(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx, duk_bool_t *out_has_prop);

static __attribute__ ((unused)) duk_bool_t duk_put_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx);
static __attribute__ ((unused)) duk_bool_t duk_put_prop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args);





static __attribute__ ((unused)) duk_bool_t duk_del_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx);
static __attribute__ ((unused)) duk_bool_t duk_has_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx);
static __attribute__ ((unused)) void duk_xdef_prop(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t desc_flags);

static __attribute__ ((unused)) void duk_xdef_prop_index(duk_hthread *thr, duk_idx_t obj_idx, duk_uarridx_t arr_idx, duk_small_uint_t desc_flags);




static __attribute__ ((unused)) void duk_xdef_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx, duk_small_uint_t desc_flags);
static __attribute__ ((unused)) void duk_xdef_prop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args);
static __attribute__ ((unused)) void duk_xdef_prop_stridx_thrower(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx);

static __attribute__ ((unused)) duk_bool_t duk_get_method_stridx(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t stridx);

static __attribute__ ((unused)) void duk_pack(duk_hthread *thr, duk_idx_t count);
static __attribute__ ((unused)) duk_idx_t duk_unpack_array_like(duk_hthread *thr, duk_idx_t idx);




static __attribute__ ((unused)) void duk_require_constructor_call(duk_hthread *thr);
static __attribute__ ((unused)) void duk_require_constructable(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) void duk_push_symbol_descriptive_string(duk_hthread *thr, duk_hstring *h);

static __attribute__ ((unused)) void duk_resolve_nonbound_function(duk_hthread *thr);

static __attribute__ ((unused)) duk_idx_t duk_get_top_require_min(duk_hthread *thr, duk_idx_t min_top);
static __attribute__ ((unused)) duk_idx_t duk_get_top_index_unsafe(duk_hthread *thr);

static __attribute__ ((unused)) void duk_pop_n_unsafe(duk_hthread *thr, duk_idx_t count);
static __attribute__ ((unused)) void duk_pop_unsafe(duk_hthread *thr);
static __attribute__ ((unused)) void duk_pop_2_unsafe(duk_hthread *thr);
static __attribute__ ((unused)) void duk_pop_3_unsafe(duk_hthread *thr);
static __attribute__ ((unused)) void duk_pop_n_nodecref_unsafe(duk_hthread *thr, duk_idx_t count);
static __attribute__ ((unused)) void duk_pop_nodecref_unsafe(duk_hthread *thr);
static __attribute__ ((unused)) void duk_pop_2_nodecref_unsafe(duk_hthread *thr);
static __attribute__ ((unused)) void duk_pop_3_nodecref_unsafe(duk_hthread *thr);
static __attribute__ ((unused)) void duk_pop_undefined(duk_hthread *thr);

static __attribute__ ((unused)) void duk_compact_m1(duk_hthread *thr);

static __attribute__ ((unused)) void duk_seal_freeze_raw(duk_hthread *thr, duk_idx_t obj_idx, duk_bool_t is_freeze);

static __attribute__ ((unused)) void duk_insert_undefined(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) void duk_insert_undefined_n(duk_hthread *thr, duk_idx_t idx, duk_idx_t count);

static __attribute__ ((unused)) void duk_concat_2(duk_hthread *thr);

static __attribute__ ((unused)) duk_int_t duk_pcall_method_flags(duk_hthread *thr, duk_idx_t nargs, duk_small_uint_t call_flags);
static __attribute__ ((unused)) duk_double_t duk_time_get_ecmascript_time(duk_hthread *thr);
static __attribute__ ((unused)) duk_double_t duk_time_get_ecmascript_time_nofrac(duk_hthread *thr);
static __attribute__ ((unused)) duk_double_t duk_time_get_monotonic_time(duk_hthread *thr);
struct duk_hstring {





 duk_heaphdr_string hdr;





 duk_uint32_t hash;




 duk_uarridx_t arridx;






 duk_uint32_t blen;
 duk_uint32_t clen;
};


struct duk_hstring_external {
 duk_hstring str;







 const duk_uint8_t *extdata;
};





static __attribute__ ((unused)) duk_ucodepoint_t duk_hstring_char_code_at_raw(duk_hthread *thr, duk_hstring *h, duk_uint_t pos, duk_bool_t surrogate_aware);
static __attribute__ ((unused)) duk_bool_t duk_hstring_equals_ascii_cstring(duk_hstring *h, const char *cstr);
static __attribute__ ((unused)) duk_size_t duk_hstring_get_charlen(duk_hstring *h);
struct duk_propaccessor {
 duk_hobject *get;
 duk_hobject *set;
};

union duk_propvalue {




 duk_tval v;
 duk_propaccessor a;
};

struct duk_propdesc {

 duk_small_uint_t flags;
 duk_hobject *get;
 duk_hobject *set;


 duk_int_t e_idx;
 duk_int_t h_idx;
 duk_int_t a_idx;
};

struct duk_hobject {
 duk_heaphdr hdr;
 duk_uint8_t *props;






 duk_hobject *prototype;
 duk_uint32_t e_size;
 duk_uint32_t e_next;
 duk_uint32_t a_size;

 duk_uint32_t h_size;


};
static __attribute__ ((unused)) duk_hobject *duk_hobject_alloc_unchecked(duk_heap *heap, duk_uint_t hobject_flags);
static __attribute__ ((unused)) duk_hobject *duk_hobject_alloc(duk_hthread *thr, duk_uint_t hobject_flags);
static __attribute__ ((unused)) duk_harray *duk_harray_alloc(duk_hthread *thr, duk_uint_t hobject_flags);
static __attribute__ ((unused)) duk_hcompfunc *duk_hcompfunc_alloc(duk_hthread *thr, duk_uint_t hobject_flags);
static __attribute__ ((unused)) duk_hnatfunc *duk_hnatfunc_alloc(duk_hthread *thr, duk_uint_t hobject_flags);
static __attribute__ ((unused)) duk_hboundfunc *duk_hboundfunc_alloc(duk_heap *heap, duk_uint_t hobject_flags);

static __attribute__ ((unused)) duk_hbufobj *duk_hbufobj_alloc(duk_hthread *thr, duk_uint_t hobject_flags);

static __attribute__ ((unused)) duk_hthread *duk_hthread_alloc_unchecked(duk_heap *heap, duk_uint_t hobject_flags);
static __attribute__ ((unused)) duk_hthread *duk_hthread_alloc(duk_hthread *thr, duk_uint_t hobject_flags);
static __attribute__ ((unused)) duk_hdecenv *duk_hdecenv_alloc(duk_hthread *thr, duk_uint_t hobject_flags);
static __attribute__ ((unused)) duk_hobjenv *duk_hobjenv_alloc(duk_hthread *thr, duk_uint_t hobject_flags);
static __attribute__ ((unused)) duk_hproxy *duk_hproxy_alloc(duk_hthread *thr, duk_uint_t hobject_flags);


static __attribute__ ((unused)) void duk_hobject_realloc_props(duk_hthread *thr,
                                                 duk_hobject *obj,
                                                 duk_uint32_t new_e_size,
                                                 duk_uint32_t new_a_size,
                                                 duk_uint32_t new_h_size,
                                                 duk_bool_t abandon_array);
static __attribute__ ((unused)) void duk_hobject_resize_entrypart(duk_hthread *thr,
                                                    duk_hobject *obj,
                                                    duk_uint32_t new_e_size);







static __attribute__ ((unused)) duk_bool_t duk_hobject_find_existing_entry(duk_heap *heap, duk_hobject *obj, duk_hstring *key, duk_int_t *e_idx, duk_int_t *h_idx);
static __attribute__ ((unused)) duk_tval *duk_hobject_find_existing_entry_tval_ptr(duk_heap *heap, duk_hobject *obj, duk_hstring *key);
static __attribute__ ((unused)) duk_tval *duk_hobject_find_existing_entry_tval_ptr_and_attrs(duk_heap *heap, duk_hobject *obj, duk_hstring *key, duk_uint_t *out_attrs);
static __attribute__ ((unused)) duk_tval *duk_hobject_find_existing_array_entry_tval_ptr(duk_heap *heap, duk_hobject *obj, duk_uarridx_t i);
static __attribute__ ((unused)) duk_bool_t duk_hobject_get_own_propdesc(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *out_desc, duk_small_uint_t flags);
static __attribute__ ((unused)) duk_bool_t duk_hobject_getprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key);
static __attribute__ ((unused)) duk_bool_t duk_hobject_putprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key, duk_tval *tv_val, duk_bool_t throw_flag);
static __attribute__ ((unused)) duk_bool_t duk_hobject_delprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key, duk_bool_t throw_flag);
static __attribute__ ((unused)) duk_bool_t duk_hobject_hasprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key);




static __attribute__ ((unused)) duk_bool_t duk_hobject_delprop_raw(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_small_uint_t flags);
static __attribute__ ((unused)) duk_bool_t duk_hobject_hasprop_raw(duk_hthread *thr, duk_hobject *obj, duk_hstring *key);
static __attribute__ ((unused)) void duk_hobject_define_property_internal(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_small_uint_t flags);
static __attribute__ ((unused)) void duk_hobject_define_property_internal_arridx(duk_hthread *thr, duk_hobject *obj, duk_uarridx_t arr_idx, duk_small_uint_t flags);
static __attribute__ ((unused)) duk_size_t duk_hobject_get_length(duk_hthread *thr, duk_hobject *obj);



static __attribute__ ((unused)) duk_bool_t duk_hobject_has_finalizer_fast_raw(duk_hobject *obj);



static __attribute__ ((unused)) void duk_hobject_prepare_property_descriptor(duk_hthread *thr,
                                                               duk_idx_t idx_in,
                                                               duk_uint_t *out_defprop_flags,
                                                               duk_idx_t *out_idx_value,
                                                               duk_hobject **out_getter,
                                                               duk_hobject **out_setter);
static __attribute__ ((unused)) duk_bool_t duk_hobject_define_property_helper(duk_hthread *thr,
                                                                duk_uint_t defprop_flags,
                                                                duk_hobject *obj,
                                                                duk_hstring *key,
                                                                duk_idx_t idx_value,
                                                                duk_hobject *get,
                                                                duk_hobject *set,
                                                                duk_bool_t throw_flag);


static __attribute__ ((unused)) void duk_hobject_object_get_own_property_descriptor(duk_hthread *thr, duk_idx_t obj_idx);
static __attribute__ ((unused)) void duk_hobject_object_seal_freeze_helper(duk_hthread *thr, duk_hobject *obj, duk_bool_t is_freeze);
static __attribute__ ((unused)) duk_bool_t duk_hobject_object_is_sealed_frozen_helper(duk_hthread *thr, duk_hobject *obj, duk_bool_t is_frozen);
static __attribute__ ((unused)) duk_bool_t duk_hobject_object_ownprop_helper(duk_hthread *thr, duk_small_uint_t required_desc_flags);


static __attribute__ ((unused)) duk_bool_t duk_hobject_get_internal_value(duk_heap *heap, duk_hobject *obj, duk_tval *tv);
static __attribute__ ((unused)) duk_hstring *duk_hobject_get_internal_value_string(duk_heap *heap, duk_hobject *obj);


static __attribute__ ((unused)) void duk_hobject_compact_props(duk_hthread *thr, duk_hobject *obj);



static __attribute__ ((unused)) duk_bool_t duk_hobject_proxy_check(duk_hobject *obj, duk_hobject **out_target, duk_hobject **out_handler);
static __attribute__ ((unused)) duk_hobject *duk_hobject_resolve_proxy_target(duk_hobject *obj);



static __attribute__ ((unused)) void duk_hobject_enumerator_create(duk_hthread *thr, duk_small_uint_t enum_flags);
static __attribute__ ((unused)) duk_ret_t duk_hobject_get_enumerated_keys(duk_hthread *thr, duk_small_uint_t enum_flags);
static __attribute__ ((unused)) duk_bool_t duk_hobject_enumerator_next(duk_hthread *thr, duk_bool_t get_value);


static __attribute__ ((unused)) void duk_hobject_set_prototype_updref(duk_hthread *thr, duk_hobject *h, duk_hobject *p);



static __attribute__ ((unused)) void duk_hobject_pc2line_pack(duk_hthread *thr, duk_compiler_instr *instrs, duk_uint_fast32_t length);
static __attribute__ ((unused)) duk_uint_fast32_t duk_hobject_pc2line_query(duk_hthread *thr, duk_idx_t idx_func, duk_uint_fast32_t pc);



static __attribute__ ((unused)) duk_bool_t duk_hobject_prototype_chain_contains(duk_hthread *thr, duk_hobject *h, duk_hobject *p, duk_bool_t ignore_loop);
struct duk_hcompfunc {

 duk_hobject obj;
 duk_hbuffer *data;
 duk_hobject **funcs;
 duk_instr_t *bytecode;
 duk_hobject *lex_env;
 duk_hobject *var_env;
 duk_uint16_t nregs;
 duk_uint16_t nargs;
};
struct duk_hnatfunc {

 duk_hobject obj;

 duk_c_function func;
 duk_int16_t nargs;
 duk_int16_t magic;
};
struct duk_hboundfunc {

 duk_hobject obj;




 duk_tval target;


 duk_tval this_binding;


 duk_tval *args;
 duk_idx_t nargs;
};
struct duk_hbufobj {

 duk_hobject obj;


 duk_hbuffer *buf;


 duk_hobject *buf_prop;
 duk_uint_t offset;
 duk_uint_t length;
 duk_uint8_t shift;





 duk_uint8_t elem_type;
 duk_uint8_t is_typedarray;
};

static __attribute__ ((unused)) duk_uint_t duk_hbufobj_clamp_bytelength(duk_hbufobj *h_bufobj, duk_uint_t len);
static __attribute__ ((unused)) void duk_hbufobj_push_uint8array_from_plain(duk_hthread *thr, duk_hbuffer *h_buf);
static __attribute__ ((unused)) void duk_hbufobj_push_validated_read(duk_hthread *thr, duk_hbufobj *h_bufobj, duk_uint8_t *p, duk_small_uint_t elem_size);
static __attribute__ ((unused)) void duk_hbufobj_validated_write(duk_hthread *thr, duk_hbufobj *h_bufobj, duk_uint8_t *p, duk_small_uint_t elem_size);
static __attribute__ ((unused)) void duk_hbufobj_promote_plain(duk_hthread *thr, duk_idx_t idx);
struct duk_activation {
 duk_tval tv_func;
 duk_hobject *func;
 duk_activation *parent;
 duk_hobject *var_env;
 duk_hobject *lex_env;
 duk_catcher *cat;
 duk_instr_t *curr_pc;
 duk_size_t bottom_byteoff;
 duk_size_t retval_byteoff;
 duk_size_t reserve_byteoff;





 duk_small_uint_t flags;
};

struct duk_catcher {
 duk_catcher *parent;
 duk_hstring *h_varname;

 duk_instr_t *pc_base;
 duk_size_t idx_base;
 duk_uint32_t flags;



};

struct duk_hthread {

 duk_hobject obj;






 duk_instr_t **ptr_curr_pc;


 duk_heap *heap;


 duk_uint8_t strict;


 duk_uint8_t state;
 duk_uint8_t unused1;
 duk_uint8_t unused2;
 duk_tval *valstack;
 duk_tval *valstack_end;
 duk_tval *valstack_alloc_end;
 duk_tval *valstack_bottom;
 duk_tval *valstack_top;




 duk_activation *callstack_curr;
 duk_size_t callstack_top;
 duk_size_t callstack_preventcount;


 duk_hthread *resumer;


 duk_compiler_ctx *compile_ctx;
 duk_hobject *builtins[51];
 duk_hstring **strs;


};





static __attribute__ ((unused)) void duk_hthread_copy_builtin_objects(duk_hthread *thr_from, duk_hthread *thr_to);
static __attribute__ ((unused)) void duk_hthread_create_builtin_objects(duk_hthread *thr);
static __attribute__ ((unused)) duk_bool_t duk_hthread_init_stacks(duk_heap *heap, duk_hthread *thr);
static __attribute__ ((unused)) void duk_hthread_terminate(duk_hthread *thr);

static __attribute__ ((unused)) duk_activation *duk_hthread_activation_alloc(duk_hthread *thr);
static __attribute__ ((unused)) void duk_hthread_activation_free(duk_hthread *thr, duk_activation *act);
static __attribute__ ((unused)) void duk_hthread_activation_unwind_norz(duk_hthread *thr);
static __attribute__ ((unused)) void duk_hthread_activation_unwind_reuse_norz(duk_hthread *thr);
static __attribute__ ((unused)) duk_activation *duk_hthread_get_activation_for_level(duk_hthread *thr, duk_int_t level);

static __attribute__ ((unused)) duk_catcher *duk_hthread_catcher_alloc(duk_hthread *thr);
static __attribute__ ((unused)) void duk_hthread_catcher_free(duk_hthread *thr, duk_catcher *cat);
static __attribute__ ((unused)) void duk_hthread_catcher_unwind_norz(duk_hthread *thr, duk_activation *act);
static __attribute__ ((unused)) void duk_hthread_catcher_unwind_nolexenv_norz(duk_hthread *thr, duk_activation *act);





static __attribute__ ((unused)) void *duk_hthread_get_valstack_ptr(duk_heap *heap, void *ud);




static __attribute__ ((unused)) duk_uint_fast32_t duk_hthread_get_act_prev_pc(duk_hthread *thr, duk_activation *act);
static __attribute__ ((unused)) void duk_hthread_sync_currpc(duk_hthread *thr);
static __attribute__ ((unused)) void duk_hthread_sync_and_null_currpc(duk_hthread *thr);
struct duk_harray {

 duk_hobject obj;







 duk_uint32_t length;
 duk_bool_t length_nonwritable;
};
struct duk_hdecenv {

 duk_hobject obj;





 duk_hthread *thread;
 duk_hobject *varmap;
 duk_size_t regbase_byteoff;
};

struct duk_hobjenv {

 duk_hobject obj;


 duk_hobject *target;





 duk_bool_t has_this;
};
struct duk_hbuffer {
 duk_heaphdr hdr;
 duk_size_t size;
};







struct duk_hbuffer_fixed {






 union {
  struct {
   duk_heaphdr hdr;



   duk_size_t size;

  } s;



  duk_double_t dummy_for_align8_1;

  duk_uint64_t dummy_for_align8_2;






 } u;
}

__attribute__ ((aligned (8)))



;
struct duk_hbuffer_dynamic {
 duk_heaphdr hdr;




 duk_size_t size;





 void *curr_alloc;
};





struct duk_hbuffer_external {
 duk_heaphdr hdr;




 duk_size_t size;





 void *curr_alloc;
};





static __attribute__ ((unused)) duk_hbuffer *duk_hbuffer_alloc(duk_heap *heap, duk_size_t size, duk_small_uint_t flags, void **out_bufdata);
static __attribute__ ((unused)) void *duk_hbuffer_get_dynalloc_ptr(duk_heap *heap, void *ud);


static __attribute__ ((unused)) void duk_hbuffer_resize(duk_hthread *thr, duk_hbuffer_dynamic *buf, duk_size_t new_size);
static __attribute__ ((unused)) void duk_hbuffer_reset(duk_hthread *thr, duk_hbuffer_dynamic *buf);
struct duk_hproxy {

 duk_hobject obj;


 duk_hobject *target;


 duk_hobject *handler;
};
typedef void *(*duk_mem_getptr)(duk_heap *heap, void *ud);
struct duk_breakpoint {
 duk_hstring *filename;
 duk_uint32_t line;
};
struct duk_strcache_entry {
 duk_hstring *h;
 duk_uint32_t bidx;
 duk_uint32_t cidx;
};






struct duk_ljstate {
 duk_jmpbuf *jmpbuf_ptr;
 duk_small_uint_t type;
 duk_bool_t iserror;
 duk_tval value1;
 duk_tval value2;
};
struct duk_litcache_entry {
 const duk_uint8_t *addr;
 duk_hstring *h;
};





struct duk_heap {
 duk_small_uint_t flags;


 duk_alloc_function alloc_func;
 duk_realloc_function realloc_func;
 duk_free_function free_func;




 void *heap_udata;






 duk_fatal_function fatal_func;





 duk_heaphdr *heap_allocated;
 duk_heaphdr *refzero_list;




 duk_heaphdr *finalize_list;
 duk_activation *activation_free;


 duk_catcher *catcher_free;







 duk_int_t ms_trigger_counter;





 duk_uint_t ms_recursion_depth;


 duk_small_uint_t ms_base_flags;




 duk_uint_t ms_running;







 duk_uint_t ms_prevent_count;






 duk_uint_t pf_prevent_count;






 duk_uint_t pf_skip_finalizers;
 duk_bool_t creating_error;






 duk_bool_t augmenting_error;



 duk_ljstate lj;


 duk_hthread *heap_thread;


 duk_hthread *curr_thread;


 duk_hobject *heap_object;


 duk_int_t call_recursion_depth;
 duk_int_t call_recursion_limit;


 duk_uint32_t hash_seed;






 duk_uint64_t rnd_state[2];
 duk_uint32_t sym_counter[2];
 duk_hstring **strtable;

 duk_uint32_t st_mask;
 duk_uint32_t st_size;

 duk_uint32_t st_count;

 duk_bool_t st_resizing;




 duk_strcache_entry strcache[4];






 duk_litcache_entry litcache[256];
 duk_hstring *strs[166];
};





static __attribute__ ((unused))
duk_heap *duk_heap_alloc(duk_alloc_function alloc_func,
                         duk_realloc_function realloc_func,
                         duk_free_function free_func,
                         void *heap_udata,
                         duk_fatal_function fatal_func);
static __attribute__ ((unused)) void duk_heap_free(duk_heap *heap);
static __attribute__ ((unused)) void duk_free_hobject(duk_heap *heap, duk_hobject *h);
static __attribute__ ((unused)) void duk_free_hbuffer(duk_heap *heap, duk_hbuffer *h);
static __attribute__ ((unused)) void duk_free_hstring(duk_heap *heap, duk_hstring *h);
static __attribute__ ((unused)) void duk_heap_free_heaphdr_raw(duk_heap *heap, duk_heaphdr *hdr);

static __attribute__ ((unused)) void duk_heap_insert_into_heap_allocated(duk_heap *heap, duk_heaphdr *hdr);

static __attribute__ ((unused)) void duk_heap_remove_from_heap_allocated(duk_heap *heap, duk_heaphdr *hdr);


static __attribute__ ((unused)) void duk_heap_insert_into_finalize_list(duk_heap *heap, duk_heaphdr *hdr);
static __attribute__ ((unused)) void duk_heap_remove_from_finalize_list(duk_heap *heap, duk_heaphdr *hdr);
static __attribute__ ((unused)) duk_hstring *duk_heap_strtable_intern(duk_heap *heap, const duk_uint8_t *str, duk_uint32_t blen);
static __attribute__ ((unused)) duk_hstring *duk_heap_strtable_intern_checked(duk_hthread *thr, const duk_uint8_t *str, duk_uint32_t len);

static __attribute__ ((unused)) duk_hstring *duk_heap_strtable_intern_literal_checked(duk_hthread *thr, const duk_uint8_t *str, duk_uint32_t blen);

static __attribute__ ((unused)) duk_hstring *duk_heap_strtable_intern_u32(duk_heap *heap, duk_uint32_t val);
static __attribute__ ((unused)) duk_hstring *duk_heap_strtable_intern_u32_checked(duk_hthread *thr, duk_uint32_t val);

static __attribute__ ((unused)) void duk_heap_strtable_unlink(duk_heap *heap, duk_hstring *h);

static __attribute__ ((unused)) void duk_heap_strtable_unlink_prev(duk_heap *heap, duk_hstring *h, duk_hstring *prev);
static __attribute__ ((unused)) void duk_heap_strtable_force_resize(duk_heap *heap);
static __attribute__ ((unused)) void duk_heap_strtable_free(duk_heap *heap);




static __attribute__ ((unused)) void duk_heap_strcache_string_remove(duk_heap *heap, duk_hstring *h);
static __attribute__ ((unused)) duk_uint_fast32_t duk_heap_strcache_offset_char2byte(duk_hthread *thr, duk_hstring *h, duk_uint_fast32_t char_offset);


static __attribute__ ((unused)) void *duk_default_alloc_function(void *udata, duk_size_t size);
static __attribute__ ((unused)) void *duk_default_realloc_function(void *udata, void *ptr, duk_size_t newsize);
static __attribute__ ((unused)) void duk_default_free_function(void *udata, void *ptr);


static __attribute__ ((unused)) void *duk_heap_mem_alloc(duk_heap *heap, duk_size_t size);
static __attribute__ ((unused)) void *duk_heap_mem_alloc_zeroed(duk_heap *heap, duk_size_t size);
static __attribute__ ((unused)) void *duk_heap_mem_alloc_checked(duk_hthread *thr, duk_size_t size);
static __attribute__ ((unused)) void *duk_heap_mem_alloc_checked_zeroed(duk_hthread *thr, duk_size_t size);
static __attribute__ ((unused)) void *duk_heap_mem_realloc(duk_heap *heap, void *ptr, duk_size_t newsize);
static __attribute__ ((unused)) void *duk_heap_mem_realloc_indirect(duk_heap *heap, duk_mem_getptr cb, void *ud, duk_size_t newsize);
static __attribute__ ((unused)) void duk_heap_mem_free(duk_heap *heap, void *ptr);

static __attribute__ ((unused)) void duk_heap_free_freelists(duk_heap *heap);


static __attribute__ ((unused)) void duk_heap_run_finalizer(duk_heap *heap, duk_hobject *obj);
static __attribute__ ((unused)) void duk_heap_process_finalize_list(duk_heap *heap);


static __attribute__ ((unused)) void duk_heap_mark_and_sweep(duk_heap *heap, duk_small_uint_t flags);

static __attribute__ ((unused)) duk_uint32_t duk_heap_hashstring(duk_heap *heap, const duk_uint8_t *str, duk_size_t len);
static __attribute__ ((unused)) void duk_err_handle_error(duk_hthread *thr, const char *filename, duk_uint_t line_and_code, const char *msg) __attribute__((noreturn));
static __attribute__ ((unused)) void duk_err_handle_error_fmt(duk_hthread *thr, const char *filename, duk_uint_t line_and_code, const char *fmt, ...) __attribute__((noreturn));





static __attribute__ ((unused)) void duk_err_create_and_throw(duk_hthread *thr, duk_errcode_t code, const char *msg, const char *filename, duk_int_t line) __attribute__((noreturn));




static __attribute__ ((unused)) void duk_error_throw_from_negative_rc(duk_hthread *thr, duk_ret_t rc) __attribute__((noreturn));





static __attribute__ ((unused)) void duk_err_augment_error_create(duk_hthread *thr, duk_hthread *thr_callstack, const char *filename, duk_int_t line, duk_small_uint_t flags);


static __attribute__ ((unused)) void duk_err_augment_error_throw(duk_hthread *thr);






static __attribute__ ((unused)) void duk_err_require_type_index(duk_hthread *thr, const char *filename, duk_int_t linenumber, duk_idx_t idx, const char *expect_name) __attribute__((noreturn));

static __attribute__ ((unused)) void duk_err_error_internal(duk_hthread *thr, const char *filename, duk_int_t linenumber) __attribute__((noreturn));
static __attribute__ ((unused)) void duk_err_error_alloc_failed(duk_hthread *thr, const char *filename, duk_int_t linenumber) __attribute__((noreturn));
static __attribute__ ((unused)) void duk_err_error(duk_hthread *thr, const char *filename, duk_int_t linenumber, const char *message) __attribute__((noreturn));
static __attribute__ ((unused)) void duk_err_range_index(duk_hthread *thr, const char *filename, duk_int_t linenumber, duk_idx_t idx) __attribute__((noreturn));
static __attribute__ ((unused)) void duk_err_range_push_beyond(duk_hthread *thr, const char *filename, duk_int_t linenumber) __attribute__((noreturn));
static __attribute__ ((unused)) void duk_err_range(duk_hthread *thr, const char *filename, duk_int_t linenumber, const char *message) __attribute__((noreturn));
static __attribute__ ((unused)) void duk_err_type_invalid_args(duk_hthread *thr, const char *filename, duk_int_t linenumber) __attribute__((noreturn));
static __attribute__ ((unused)) void duk_err_type_invalid_state(duk_hthread *thr, const char *filename, duk_int_t linenumber) __attribute__((noreturn));
static __attribute__ ((unused)) void duk_err_type_invalid_trap_result(duk_hthread *thr, const char *filename, duk_int_t linenumber) __attribute__((noreturn));
static __attribute__ ((unused)) void duk_err_longjmp(duk_hthread *thr) __attribute__((noreturn));

static __attribute__ ((unused)) void duk_default_fatal_handler(void *udata, const char *msg) __attribute__((noreturn));

static __attribute__ ((unused)) void duk_err_setup_ljstate1(duk_hthread *thr, duk_small_uint_t lj_type, duk_tval *tv_val);




static __attribute__ ((unused)) duk_hobject *duk_error_prototype_from_code(duk_hthread *thr, duk_errcode_t err_code);
extern const duk_uint8_t duk_unicode_ids_noa[1063];
extern const duk_uint8_t duk_unicode_ids_m_let_noa[42];
extern const duk_uint8_t duk_unicode_idp_m_ids_noa[549];
extern const duk_uint8_t duk_unicode_caseconv_uc[1386];
extern const duk_uint8_t duk_unicode_caseconv_lc[680];
extern const duk_uint8_t duk_unicode_re_canon_bitmap[256];
static __attribute__ ((unused)) duk_small_int_t duk_unicode_get_xutf8_length(duk_ucodepoint_t cp);



static __attribute__ ((unused)) duk_small_int_t duk_unicode_encode_xutf8(duk_ucodepoint_t cp, duk_uint8_t *out);
static __attribute__ ((unused)) duk_small_int_t duk_unicode_encode_cesu8(duk_ucodepoint_t cp, duk_uint8_t *out);
static __attribute__ ((unused)) duk_small_int_t duk_unicode_decode_xutf8(duk_hthread *thr, const duk_uint8_t **ptr, const duk_uint8_t *ptr_start, const duk_uint8_t *ptr_end, duk_ucodepoint_t *out_cp);
static __attribute__ ((unused)) duk_ucodepoint_t duk_unicode_decode_xutf8_checked(duk_hthread *thr, const duk_uint8_t **ptr, const duk_uint8_t *ptr_start, const duk_uint8_t *ptr_end);
static __attribute__ ((unused)) duk_size_t duk_unicode_unvalidated_utf8_length(const duk_uint8_t *data, duk_size_t blen);
static __attribute__ ((unused)) duk_small_int_t duk_unicode_is_whitespace(duk_codepoint_t cp);
static __attribute__ ((unused)) duk_small_int_t duk_unicode_is_line_terminator(duk_codepoint_t cp);
static __attribute__ ((unused)) duk_small_int_t duk_unicode_is_identifier_start(duk_codepoint_t cp);
static __attribute__ ((unused)) duk_small_int_t duk_unicode_is_identifier_part(duk_codepoint_t cp);
static __attribute__ ((unused)) duk_small_int_t duk_unicode_is_letter(duk_codepoint_t cp);
static __attribute__ ((unused)) void duk_unicode_case_convert_string(duk_hthread *thr, duk_bool_t uppercase);

static __attribute__ ((unused)) duk_codepoint_t duk_unicode_re_canonicalize_char(duk_hthread *thr, duk_codepoint_t cp);
static __attribute__ ((unused)) duk_small_int_t duk_unicode_re_is_wordchar(duk_codepoint_t cp);
typedef struct {
 duk_hthread *thr;
 duk_bufwriter_ctx bw;
 duk_hobject *h_replacer;
 duk_hstring *h_gap;
 duk_idx_t idx_proplist;
 duk_idx_t idx_loop;
 duk_small_uint_t flags;
 duk_small_uint_t flag_ascii_only;
 duk_small_uint_t flag_avoid_key_quotes;

 duk_small_uint_t flag_ext_custom;
 duk_small_uint_t flag_ext_compatible;
 duk_small_uint_t flag_ext_custom_or_compatible;

 duk_uint_t recursion_depth;
 duk_uint_t recursion_limit;
 duk_uint_t mask_for_undefined;

 duk_small_uint_t stridx_custom_undefined;
 duk_small_uint_t stridx_custom_nan;
 duk_small_uint_t stridx_custom_neginf;
 duk_small_uint_t stridx_custom_posinf;
 duk_small_uint_t stridx_custom_function;

 duk_hobject *visiting[64];
} duk_json_enc_ctx;

typedef struct {
 duk_hthread *thr;
 const duk_uint8_t *p;
 const duk_uint8_t *p_start;
 const duk_uint8_t *p_end;
 duk_idx_t idx_reviver;
 duk_small_uint_t flags;

 duk_small_uint_t flag_ext_custom;
 duk_small_uint_t flag_ext_compatible;
 duk_small_uint_t flag_ext_custom_or_compatible;

 duk_int_t recursion_depth;
 duk_int_t recursion_limit;
} duk_json_dec_ctx;
static __attribute__ ((unused)) duk_bool_t duk_js_toboolean(duk_tval *tv);
static __attribute__ ((unused)) duk_double_t duk_js_tonumber(duk_hthread *thr, duk_tval *tv);
static __attribute__ ((unused)) duk_double_t duk_js_tointeger_number(duk_double_t x);
static __attribute__ ((unused)) duk_double_t duk_js_tointeger(duk_hthread *thr, duk_tval *tv);
static __attribute__ ((unused)) duk_uint32_t duk_js_touint32(duk_hthread *thr, duk_tval *tv);
static __attribute__ ((unused)) duk_int32_t duk_js_toint32(duk_hthread *thr, duk_tval *tv);
static __attribute__ ((unused)) duk_uint16_t duk_js_touint16(duk_hthread *thr, duk_tval *tv);
static __attribute__ ((unused)) duk_uarridx_t duk_js_to_arrayindex_string(const duk_uint8_t *str, duk_uint32_t blen);




static __attribute__ ((unused)) duk_bool_t duk_js_equals_helper(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y, duk_small_uint_t flags);
static __attribute__ ((unused)) duk_small_int_t duk_js_data_compare(const duk_uint8_t *buf1, const duk_uint8_t *buf2, duk_size_t len1, duk_size_t len2);
static __attribute__ ((unused)) duk_small_int_t duk_js_string_compare(duk_hstring *h1, duk_hstring *h2);



static __attribute__ ((unused)) duk_bool_t duk_js_compare_helper(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y, duk_small_uint_t flags);
static __attribute__ ((unused)) duk_bool_t duk_js_instanceof(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y);



static __attribute__ ((unused)) duk_bool_t duk_js_in(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y);
static __attribute__ ((unused)) duk_small_uint_t duk_js_typeof_stridx(duk_tval *tv_x);


static __attribute__ ((unused)) double duk_js_arith_pow(double x, double y);
static __attribute__ ((unused)) double duk_js_arith_mod(double x, double y);
static __attribute__ ((unused)) duk_bool_t duk_js_getvar_envrec(duk_hthread *thr, duk_hobject *env, duk_hstring *name, duk_bool_t throw_flag);
static __attribute__ ((unused)) duk_bool_t duk_js_getvar_activation(duk_hthread *thr, duk_activation *act, duk_hstring *name, duk_bool_t throw_flag);
static __attribute__ ((unused)) void duk_js_putvar_envrec(duk_hthread *thr, duk_hobject *env, duk_hstring *name, duk_tval *val, duk_bool_t strict);
static __attribute__ ((unused)) void duk_js_putvar_activation(duk_hthread *thr, duk_activation *act, duk_hstring *name, duk_tval *val, duk_bool_t strict);



static __attribute__ ((unused)) duk_bool_t duk_js_delvar_activation(duk_hthread *thr, duk_activation *act, duk_hstring *name);
static __attribute__ ((unused)) duk_bool_t duk_js_declvar_activation(duk_hthread *thr, duk_activation *act, duk_hstring *name, duk_tval *val, duk_small_uint_t prop_flags, duk_bool_t is_func_decl);
static __attribute__ ((unused)) void duk_js_init_activation_environment_records_delayed(duk_hthread *thr, duk_activation *act);
static __attribute__ ((unused)) void duk_js_close_environment_record(duk_hthread *thr, duk_hobject *env);
static __attribute__ ((unused)) duk_hobject *duk_create_activation_environment_record(duk_hthread *thr, duk_hobject *func, duk_size_t bottom_byteoff);
static __attribute__ ((unused)) void duk_js_push_closure(duk_hthread *thr,
                                           duk_hcompfunc *fun_temp,
                                           duk_hobject *outer_var_env,
                                           duk_hobject *outer_lex_env,
                                           duk_bool_t add_auto_proto);


static __attribute__ ((unused)) duk_int_t duk_handle_call_unprotected(duk_hthread *thr, duk_idx_t idx_func, duk_small_uint_t call_flags);
static __attribute__ ((unused)) duk_int_t duk_handle_call_unprotected_nargs(duk_hthread *thr, duk_idx_t nargs, duk_small_uint_t call_flags);
static __attribute__ ((unused)) duk_int_t duk_handle_safe_call(duk_hthread *thr, duk_safe_call_function func, void *udata, duk_idx_t num_stack_args, duk_idx_t num_stack_res);
static __attribute__ ((unused)) void duk_call_construct_postprocess(duk_hthread *thr, duk_small_uint_t proxy_invariant);

static __attribute__ ((unused)) void duk_call_setup_propcall_error(duk_hthread *thr, duk_tval *tv_targ, duk_tval *tv_base, duk_tval *tv_key);



static __attribute__ ((unused)) void duk_js_execute_bytecode(duk_hthread *exec_thr);
static __attribute__ ((unused)) void duk_numconv_stringify(duk_hthread *thr, duk_small_int_t radix, duk_small_int_t digits, duk_small_uint_t flags);
static __attribute__ ((unused)) void duk_numconv_parse(duk_hthread *thr, duk_small_int_t radix, duk_small_uint_t flags);
static __attribute__ ((unused)) void duk_bi_date_timeval_to_parts(duk_double_t d, duk_int_t *parts, duk_double_t *dparts, duk_small_uint_t flags);
static __attribute__ ((unused)) duk_double_t duk_bi_date_get_timeval_from_dparts(duk_double_t *dparts, duk_small_uint_t flags);
static __attribute__ ((unused)) duk_bool_t duk_bi_date_is_leap_year(duk_int_t year);
static __attribute__ ((unused)) duk_bool_t duk_bi_date_timeval_in_valid_range(duk_double_t x);
static __attribute__ ((unused)) duk_bool_t duk_bi_date_year_in_valid_range(duk_double_t year);
static __attribute__ ((unused)) duk_bool_t duk_bi_date_timeval_in_leeway_range(duk_double_t x);


static __attribute__ ((unused)) duk_double_t duk_bi_date_get_now_gettimeofday(void);
static __attribute__ ((unused)) duk_int_t duk_bi_date_get_local_tzoffset_gmtime(duk_double_t d);
static __attribute__ ((unused)) duk_bool_t duk_bi_date_parse_string_strptime(duk_hthread *thr, const char *str);





static __attribute__ ((unused)) duk_bool_t duk_bi_date_format_parts_strftime(duk_hthread *thr, duk_int_t *parts, duk_int_t tzoffset, duk_small_uint_t flags);
static __attribute__ ((unused))
void duk_bi_json_parse_helper(duk_hthread *thr,
                              duk_idx_t idx_value,
                              duk_idx_t idx_reviver,
                              duk_small_uint_t flags);
static __attribute__ ((unused))
void duk_bi_json_stringify_helper(duk_hthread *thr,
                                  duk_idx_t idx_value,
                                  duk_idx_t idx_replacer,
                                  duk_idx_t idx_space,
                                  duk_small_uint_t flags);

static __attribute__ ((unused)) duk_ret_t duk_textdecoder_decode_utf8_nodejs(duk_hthread *thr);


static __attribute__ ((unused)) void duk_proxy_ownkeys_postprocess(duk_hthread *thr, duk_hobject *h_proxy_target, duk_uint_t flags);
static __attribute__ ((unused)) const duk_uint8_t duk_strings_data[967] = {
79,40,209,144,168,105,6,78,54,139,89,185,44,48,46,90,120,8,154,140,35,103,
35,113,193,73,5,52,112,180,104,166,135,52,188,4,98,12,27,146,156,80,211,31,
129,115,150,64,52,220,109,24,18,68,156,24,38,67,114,36,55,9,119,151,132,
140,93,18,113,128,153,201,212,201,205,2,248,8,196,24,224,104,82,146,40,224,
193,48,114,168,37,147,196,54,123,28,4,98,12,43,148,67,103,177,192,70,32,
196,121,68,54,123,28,18,192,199,144,124,4,98,12,43,136,108,244,117,184,8,
196,24,95,40,134,207,71,91,128,140,65,133,113,13,158,158,151,1,24,131,11,
229,16,217,233,233,112,17,136,48,206,21,110,4,244,244,184,8,196,24,103,10,
183,2,122,218,156,4,98,12,24,203,112,64,179,113,193,79,8,218,155,131,32,
184,70,212,220,13,10,82,68,252,123,144,217,146,38,228,207,18,0,100,37,64,
178,212,11,161,17,104,162,96,10,200,193,57,165,65,169,16,5,100,81,27,70,18,
32,10,200,68,185,13,116,221,197,184,64,89,57,41,197,13,49,234,5,208,156,
113,87,55,118,147,20,187,56,161,166,92,221,212,73,210,236,226,134,153,115,
119,76,201,203,179,138,26,99,73,212,136,136,164,25,174,137,56,32,72,137,
101,23,52,45,13,34,86,9,79,136,104,201,114,149,96,52,138,134,140,151,75,
226,233,186,120,121,22,39,54,83,141,5,55,68,236,36,164,3,16,225,115,150,64,
52,205,163,2,72,154,83,138,26,99,75,12,11,150,103,5,36,20,211,70,140,133,
67,72,49,241,160,227,81,196,52,168,106,39,132,252,183,136,105,80,212,79,2,
249,110,128,126,88,95,133,109,237,237,237,151,235,127,46,249,119,203,190,
186,206,33,181,2,208,61,190,12,19,34,65,19,81,132,108,228,97,1,107,33,12,
32,45,100,137,64,247,175,9,19,155,41,198,130,155,134,69,146,100,227,226,
231,146,51,192,204,73,140,224,145,221,102,241,68,196,169,248,30,75,12,11,
151,242,233,187,143,138,24,137,162,164,255,253,63,3,201,97,129,114,254,92,
112,75,136,108,166,6,136,159,255,167,224,121,44,48,46,95,203,166,238,74,
113,67,77,201,128,223,255,223,224,121,44,48,46,95,203,145,46,9,205,16,39,
201,62,36,0,192,21,147,255,238,145,39,199,197,211,116,240,242,113,197,78,
214,211,226,233,187,107,105,19,119,37,56,161,166,52,221,212,201,205,36,240,
242,16,96,152,12,178,52,211,56,228,73,150,83,0,148,39,137,75,67,73,198,209,
129,36,85,185,201,196,2,32,193,48,17,160,97,16,84,44,156,104,24,67,189,200,
108,201,19,238,114,96,137,137,50,238,113,164,188,211,185,192,226,100,19,
134,68,110,112,174,139,0,185,31,115,149,4,88,7,159,115,146,117,34,34,35,
115,143,22,146,208,210,19,115,140,3,207,185,202,130,36,109,85,185,194,161,
160,90,50,72,155,115,149,2,232,67,137,204,122,22,66,161,175,164,210,72,199,
130,137,1,50,32,145,143,38,120,186,195,35,106,51,146,230,8,36,77,109,65,38,
226,72,159,191,189,181,70,140,133,222,249,212,227,66,125,245,187,251,219,
77,3,119,190,117,56,208,159,125,110,254,246,210,26,93,239,157,78,52,39,223,
93,191,189,180,212,52,187,223,58,156,104,79,190,187,127,123,104,180,104,
183,190,117,56,208,159,125,102,254,209,104,209,124,234,113,161,62,250,80,
196,128,81,4,9,16,162,4,196,116,9,205,154,27,66,32,100,13,12,98,68,227,33,
65,69,204,195,34,201,50,8,110,33,23,34,28,168,104,22,188,12,174,138,11,70,
138,104,115,68,130,137,13,82,27,41,129,162,35,138,54,146,198,137,39,72,180,
210,178,38,35,146,103,68,139,51,197,214,28,227,131,79,15,35,138,58,130,37,
19,155,41,146,174,64,203,99,161,100,37,145,51,148,75,4,164,66,54,140,49,46,
247,70,103,37,230,70,142,70,67,30,232,204,178,163,201,18,54,139,89,39,26,
16,165,2,228,69,33,143,89,24,70,206,73,67,102,72,148,2,32,214,73,157,224,
18,128,98,29,241,69,65,50,37,241,116,200,41,144,102,125,2,180,8,210,152,38,
129,23,8,34,198,
};






static __attribute__ ((unused)) const duk_c_function duk_bi_native_functions[177] = {
 ((void *)0),
 duk_bi_array_constructor,
 duk_bi_array_constructor_is_array,
 duk_bi_array_prototype_concat,
 duk_bi_array_prototype_indexof_shared,
 duk_bi_array_prototype_iter_shared,
 duk_bi_array_prototype_join_shared,
 duk_bi_array_prototype_pop,
 duk_bi_array_prototype_push,
 duk_bi_array_prototype_reduce_shared,
 duk_bi_array_prototype_reverse,
 duk_bi_array_prototype_shift,
 duk_bi_array_prototype_slice,
 duk_bi_array_prototype_sort,
 duk_bi_array_prototype_splice,
 duk_bi_array_prototype_to_string,
 duk_bi_array_prototype_unshift,
 duk_bi_arraybuffer_constructor,
 duk_bi_arraybuffer_isview,
 duk_bi_boolean_constructor,
 duk_bi_boolean_prototype_tostring_shared,
 duk_bi_buffer_compare_shared,
 duk_bi_buffer_readfield,
 duk_bi_buffer_slice_shared,
 duk_bi_buffer_writefield,
 duk_bi_dataview_constructor,
 duk_bi_date_constructor,
 duk_bi_date_constructor_now,
 duk_bi_date_constructor_parse,
 duk_bi_date_constructor_utc,
 duk_bi_date_prototype_get_shared,
 duk_bi_date_prototype_get_timezone_offset,
 duk_bi_date_prototype_set_shared,
 duk_bi_date_prototype_set_time,
 duk_bi_date_prototype_to_json,
 duk_bi_date_prototype_tostring_shared,
 duk_bi_date_prototype_value_of,
 duk_bi_duktape_object_act,
 duk_bi_duktape_object_compact,
 duk_bi_duktape_object_dec,
 duk_bi_duktape_object_enc,
 duk_bi_duktape_object_fin,
 duk_bi_duktape_object_gc,
 duk_bi_duktape_object_info,
 duk_bi_error_constructor_shared,
 duk_bi_error_prototype_filename_getter,
 duk_bi_error_prototype_filename_setter,
 duk_bi_error_prototype_linenumber_getter,
 duk_bi_error_prototype_linenumber_setter,
 duk_bi_error_prototype_stack_getter,
 duk_bi_error_prototype_stack_setter,
 duk_bi_error_prototype_to_string,
 duk_bi_function_constructor,
 duk_bi_function_prototype,
 duk_bi_function_prototype_apply,
 duk_bi_function_prototype_bind,
 duk_bi_function_prototype_call,
 duk_bi_function_prototype_to_string,
 duk_bi_global_object_decode_uri,
 duk_bi_global_object_decode_uri_component,
 duk_bi_global_object_encode_uri,
 duk_bi_global_object_encode_uri_component,
 duk_bi_global_object_escape,
 duk_bi_global_object_eval,
 duk_bi_global_object_is_finite,
 duk_bi_global_object_is_nan,
 duk_bi_global_object_parse_float,
 duk_bi_global_object_parse_int,
 duk_bi_global_object_unescape,
 duk_bi_json_object_parse,
 duk_bi_json_object_stringify,
 duk_bi_math_object_clz32,
 duk_bi_math_object_hypot,
 duk_bi_math_object_imul,
 duk_bi_math_object_max,
 duk_bi_math_object_min,
 duk_bi_math_object_onearg_shared,
 duk_bi_math_object_random,
 duk_bi_math_object_sign,
 duk_bi_math_object_twoarg_shared,
 duk_bi_native_function_length,
 duk_bi_native_function_name,
 duk_bi_nodejs_buffer_byte_length,
 duk_bi_nodejs_buffer_concat,
 duk_bi_nodejs_buffer_constructor,
 duk_bi_nodejs_buffer_copy,
 duk_bi_nodejs_buffer_fill,
 duk_bi_nodejs_buffer_is_buffer,
 duk_bi_nodejs_buffer_is_encoding,
 duk_bi_nodejs_buffer_tojson,
 duk_bi_nodejs_buffer_tostring,
 duk_bi_nodejs_buffer_write,
 duk_bi_number_check_shared,
 duk_bi_number_constructor,
 duk_bi_number_prototype_to_exponential,
 duk_bi_number_prototype_to_fixed,
 duk_bi_number_prototype_to_locale_string,
 duk_bi_number_prototype_to_precision,
 duk_bi_number_prototype_to_string,
 duk_bi_number_prototype_value_of,
 duk_bi_object_constructor,
 duk_bi_object_constructor_assign,
 duk_bi_object_constructor_create,
 duk_bi_object_constructor_define_properties,
 duk_bi_object_constructor_define_property,
 duk_bi_object_constructor_get_own_property_descriptor,
 duk_bi_object_constructor_is,
 duk_bi_object_constructor_is_extensible,
 duk_bi_object_constructor_is_sealed_frozen_shared,
 duk_bi_object_constructor_keys_shared,
 duk_bi_object_constructor_prevent_extensions,
 duk_bi_object_constructor_seal_freeze_shared,
 duk_bi_object_getprototype_shared,
 duk_bi_object_prototype_defineaccessor,
 duk_bi_object_prototype_has_own_property,
 duk_bi_object_prototype_is_prototype_of,
 duk_bi_object_prototype_lookupaccessor,
 duk_bi_object_prototype_property_is_enumerable,
 duk_bi_object_prototype_to_locale_string,
 duk_bi_object_prototype_to_string,
 duk_bi_object_prototype_value_of,
 duk_bi_object_setprototype_shared,
 duk_bi_performance_now,
 duk_bi_pointer_constructor,
 duk_bi_pointer_prototype_tostring_shared,
 duk_bi_proxy_constructor,
 duk_bi_reflect_apply,
 duk_bi_reflect_construct,
 duk_bi_reflect_object_delete_property,
 duk_bi_reflect_object_get,
 duk_bi_reflect_object_has,
 duk_bi_reflect_object_set,
 duk_bi_regexp_constructor,
 duk_bi_regexp_prototype_exec,
 duk_bi_regexp_prototype_flags,
 duk_bi_regexp_prototype_shared_getter,
 duk_bi_regexp_prototype_test,
 duk_bi_regexp_prototype_tostring,
 duk_bi_string_constructor,
 duk_bi_string_constructor_from_char_code,
 duk_bi_string_constructor_from_code_point,
 duk_bi_string_prototype_caseconv_shared,
 duk_bi_string_prototype_char_at,
 duk_bi_string_prototype_char_code_at,
 duk_bi_string_prototype_concat,
 duk_bi_string_prototype_includes,
 duk_bi_string_prototype_indexof_shared,
 duk_bi_string_prototype_locale_compare,
 duk_bi_string_prototype_match,
 duk_bi_string_prototype_repeat,
 duk_bi_string_prototype_replace,
 duk_bi_string_prototype_search,
 duk_bi_string_prototype_slice,
 duk_bi_string_prototype_split,
 duk_bi_string_prototype_startswith_endswith,
 duk_bi_string_prototype_substr,
 duk_bi_string_prototype_substring,
 duk_bi_string_prototype_to_string,
 duk_bi_string_prototype_trim,
 duk_bi_textdecoder_constructor,
 duk_bi_textdecoder_prototype_decode,
 duk_bi_textdecoder_prototype_shared_getter,
 duk_bi_textencoder_constructor,
 duk_bi_textencoder_prototype_encode,
 duk_bi_textencoder_prototype_encoding_getter,
 duk_bi_thread_constructor,
 duk_bi_thread_current,
 duk_bi_thread_resume,
 duk_bi_thread_yield,
 duk_bi_type_error_thrower,
 duk_bi_typedarray_buffer_getter,
 duk_bi_typedarray_bytelength_getter,
 duk_bi_typedarray_byteoffset_getter,
 duk_bi_typedarray_constructor,
 duk_bi_typedarray_set,
 duk_bi_uint8array_allocplain,
 duk_bi_uint8array_plainof,
};

static __attribute__ ((unused)) const duk_uint8_t duk_builtins_data[4116] = {
144,148,105,224,32,68,52,228,62,12,104,200,165,132,52,167,194,138,105,243,
124,57,28,211,57,18,64,52,238,126,44,138,111,171,241,164,19,87,129,30,33,
167,16,145,159,8,211,136,9,225,42,5,240,145,139,163,163,8,211,136,10,228,
64,211,19,132,140,93,29,56,70,156,64,119,34,66,146,36,104,137,194,70,46,
142,172,35,78,32,47,146,195,102,11,240,145,139,163,175,8,211,136,9,228,240,
242,112,145,139,163,179,8,211,136,8,237,34,130,118,49,116,118,225,26,48,0,
1,82,29,201,158,46,183,39,135,147,132,140,93,16,132,76,66,33,8,66,16,132,
33,8,66,26,179,233,97,167,60,150,34,33,154,112,0,1,75,247,35,79,95,237,198,
174,200,47,31,23,95,17,13,51,19,35,93,68,216,209,128,0,10,208,174,79,15,32,
248,8,196,24,8,107,192,0,5,106,118,27,94,0,0,43,83,227,94,0,0,43,84,46,215,
128,0,10,213,28,198,188,0,0,86,169,100,53,224,0,2,181,79,85,175,0,0,21,170,
154,45,120,0,0,173,85,217,107,192,0,5,106,182,243,86,193,106,52,127,130,
249,50,94,124,35,68,225,146,49,13,31,186,23,201,146,243,224,200,39,12,145,
136,67,134,19,49,0,0,0,0,0,0,3,225,255,51,0,0,0,0,0,0,3,193,255,47,18,1,
172,19,120,71,10,25,196,136,113,162,156,136,199,42,57,204,144,115,132,240,
149,2,248,72,197,209,58,2,185,16,52,196,225,35,23,68,233,14,228,72,82,68,
141,17,56,72,197,209,58,130,249,44,54,96,191,9,24,186,39,88,79,39,135,147,
132,140,93,19,176,35,180,138,9,216,197,209,59,82,79,35,40,242,65,248,58,42,
96,121,14,232,94,62,46,190,15,42,31,145,33,86,65,76,242,214,143,73,48,242,
243,79,49,56,243,115,207,57,64,243,180,79,61,72,243,244,207,65,80,244,53,
79,69,88,244,98,30,8,200,156,67,102,120,241,79,4,100,78,21,110,4,207,32,47,
147,37,231,194,52,78,25,34,122,81,124,153,47,62,12,130,112,201,19,211,139,
121,34,87,69,128,104,137,239,83,18,238,108,165,2,162,92,104,56,220,233,1,8,
151,10,134,162,100,206,16,18,50,9,195,39,105,20,101,136,18,25,4,225,147,
180,138,5,215,49,238,105,27,60,185,1,36,104,156,50,118,145,70,96,129,34,52,
78,25,59,72,160,93,115,30,230,145,179,204,144,12,73,8,15,38,104,128,138,52,
146,16,30,77,1,0,2,11,132,193,198,36,248,248,186,110,158,30,78,56,188,194,
70,183,170,136,48,98,79,142,179,120,248,185,228,140,241,193,146,66,138,31,
55,71,138,128,153,137,62,58,205,227,226,231,146,51,199,26,6,18,92,146,64,
96,74,72,51,120,43,192,97,68,128,153,56,72,7,12,133,67,73,199,197,207,36,
103,142,35,2,3,33,80,210,113,241,115,201,25,160,146,225,160,9,34,1,124,178,
1,139,18,19,36,229,146,8,190,36,169,27,62,18,243,35,100,135,54,92,162,2,17,
46,72,128,89,7,200,32,33,18,225,98,236,145,188,130,64,196,75,132,188,200,
217,32,43,39,28,128,69,19,18,228,144,42,98,79,142,179,120,248,185,228,140,
241,201,97,129,114,229,201,37,2,68,184,200,1,147,93,159,153,213,34,235,250,
96,48,157,32,24,94,160,1,199,4,184,235,55,143,139,158,72,207,28,226,3,81,
46,62,46,155,167,135,147,142,47,60,129,71,197,207,36,103,142,34,92,35,104,
194,68,1,89,58,36,8,109,109,12,133,67,73,195,18,115,36,118,182,185,168,8,
109,109,12,133,67,73,201,18,115,36,118,182,185,168,130,27,91,75,115,149,71,
240,196,156,201,29,173,174,129,2,27,91,75,115,149,71,242,68,156,201,29,173,
174,129,34,12,16,28,128,62,191,42,3,71,146,68,4,16,22,188,161,240,16,40,
104,242,103,196,16,93,158,125,96,110,115,235,64,131,16,16,58,37,192,70,32,
194,144,114,25,67,95,40,6,18,8,32,48,156,209,2,108,124,96,224,144,6,247,62,
16,0,143,164,143,12,248,15,18,84,145,145,34,128,11,35,160,179,140,0,44,150,
129,18,58,0,146,116,103,32,128,105,61,104,17,36,175,1,232,217,29,5,156,179,
224,58,26,50,95,142,43,159,64,181,130,83,226,26,50,95,142,43,159,192,7,255,
248,41,42,72,226,1,160,18,78,97,32,26,64,114,186,60,32,4,120,6,148,13,128,
124,3,76,12,84,46,100,140,3,78,13,18,14,130,36,67,232,23,18,14,130,39,34,
131,30,113,15,224,3,255,253,6,48,40,194,197,204,224,142,8,240,78,25,60,231,
192,210,197,204,224,156,50,113,238,67,103,232,62,28,138,156,104,82,170,107,
255,32,48,191,144,1,132,112,71,128,159,168,128,161,28,17,224,156,50,112,19,
245,144,22,39,12,156,123,144,217,240,19,245,146,3,9,205,16,39,236,62,3,161,
163,37,248,226,251,141,1,107,4,167,196,52,100,191,28,95,113,164,13,91,132,
5,147,130,115,30,8,147,222,64,43,1,49,31,224,64,60,72,245,128,68,249,32,13,
34,2,34,63,204,128,89,45,2,39,209,0,89,61,104,159,213,0,153,80,50,156,80,
211,126,16,11,155,184,183,88,145,224,129,34,122,64,17,155,184,183,8,11,39,
22,235,18,60,16,36,79,72,1,115,119,40,247,146,60,16,36,79,72,32,140,221,
197,184,64,89,57,71,188,145,224,129,34,122,65,1,39,20,51,244,0,52,72,242,2,
127,18,2,165,48,70,114,229,145,51,253,141,1,4,104,229,203,34,103,251,26,64,
132,52,75,160,201,47,105,160,26,84,12,167,31,186,8,50,0,114,58,113,163,46,
190,120,35,11,60,4,25,68,81,61,96,47,181,80,46,132,129,255,255,255,255,255,
255,222,254,39,172,67,118,170,5,208,144,0,64,0,0,0,0,0,0,51,16,0,0,0,0,0,0,
62,31,200,245,238,146,38,138,147,105,13,42,26,137,226,0,0,0,0,0,0,7,131,
249,30,180,134,4,209,82,109,33,165,67,81,60,64,0,0,0,0,0,0,240,255,15,210,
62,72,91,155,0,0,0,0,0,0,2,192,240,135,88,11,237,72,5,38,210,27,50,24,145,
129,255,255,255,255,255,254,126,134,67,172,67,118,164,2,147,105,13,153,12,
72,192,255,255,255,255,255,255,63,195,16,240,70,68,226,27,51,199,138,120,
35,34,112,171,112,38,121,7,16,137,112,168,106,38,77,193,1,40,151,16,217,
144,196,142,224,144,21,18,227,65,198,238,9,67,81,46,72,5,39,16,217,144,196,
142,224,152,228,148,227,64,0,0,0,0,0,0,0,0,131,175,223,16,194,111,8,97,119,
224,3,205,220,42,46,65,238,200,13,155,184,75,189,205,35,102,128,47,116,64,
92,221,199,196,130,68,144,230,239,72,65,152,12,21,224,140,137,92,128,62,
210,98,177,252,3,107,173,88,3,146,211,141,32,0,0,0,0,0,3,225,255,19,175,
188,0,100,221,193,130,100,228,167,20,52,215,129,3,38,238,77,12,39,37,56,
161,166,188,10,194,94,6,18,155,184,183,8,11,39,6,9,147,146,156,80,211,94,7,
18,155,184,183,8,11,39,38,134,19,146,156,80,211,94,8,12,53,224,130,195,222,
8,77,133,210,24,91,224,3,152,147,228,208,194,95,0,44,196,159,11,69,175,152,
32,35,100,33,135,24,147,237,38,34,246,139,95,48,64,70,200,68,8,49,39,198,
57,179,61,144,138,22,98,79,180,152,153,215,54,103,178,17,129,204,73,240,96,
153,44,132,112,163,18,125,164,196,62,130,100,178,18,1,140,73,240,96,197,
144,146,18,98,79,180,152,135,208,98,200,74,8,49,39,195,186,145,149,144,150,
22,98,79,180,152,143,215,82,50,178,19,2,140,73,241,136,109,38,73,89,9,161,
166,36,251,73,137,157,67,105,50,74,200,78,10,49,39,201,16,78,104,229,100,
39,134,152,147,237,38,41,116,130,115,71,43,33,64,60,196,159,24,133,173,18,
32,156,209,202,200,81,18,49,39,218,76,76,234,22,180,72,130,115,71,43,33,72,
68,196,159,38,134,19,46,105,56,226,150,68,157,160,1,228,73,242,104,97,46,
16,31,34,79,140,66,214,137,16,78,104,229,108,169,137,72,147,237,38,38,117,
11,90,36,65,57,163,149,178,168,21,34,79,146,32,156,209,202,218,250,161,178,
36,251,73,138,93,32,156,209,202,218,250,193,82,36,248,196,54,147,36,173,
191,174,27,34,79,180,152,153,212,54,147,36,173,191,176,17,34,79,135,117,35,
43,115,236,133,200,147,237,38,35,245,212,140,173,207,180,15,34,79,131,4,
201,108,173,133,72,147,237,38,33,244,19,37,178,184,17,34,79,140,115,102,
123,107,238,133,200,147,237,38,38,117,205,153,237,175,188,23,34,79,133,162,
215,204,16,17,182,254,248,116,137,62,210,98,47,104,181,243,4,4,109,191,192,
131,152,147,230,8,8,217,12,16,60,137,62,96,128,141,178,193,160,206,1,201,
176,113,146,0,0,0,0,0,0,0,0,49,185,252,65,137,207,227,37,215,207,227,12,86,
127,24,152,188,254,49,88,33,46,65,120,72,4,153,37,63,33,13,127,148,4,26,0,
57,62,6,228,163,228,74,86,215,62,55,28,110,179,226,113,70,223,62,47,24,38,
191,30,2,125,32,40,20,87,114,41,225,42,5,240,145,139,163,145,41,68,250,128,
80,41,174,228,85,200,129,166,39,9,24,186,57,18,148,79,172,5,2,170,238,69,
220,137,10,72,145,162,39,9,24,186,57,18,148,79,176,5,2,186,238,69,124,150,
27,48,95,132,140,93,28,137,74,39,218,2,129,101,119,34,158,79,15,39,9,24,
186,57,18,148,79,184,5,2,218,238,69,29,164,80,78,198,46,142,68,165,16,64,
28,24,61,73,25,33,205,128,0,0,0,0,1,167,166,129,108,242,151,15,39,8,34,26,
87,97,200,3,0,167,129,32,8,194,195,16,6,84,55,10,60,3,35,69,132,30,1,140,
130,193,143,1,196,230,60,2,158,8,131,153,64,115,42,46,191,176,8,194,246,0,
80,5,220,193,95,6,234,5,100,225,35,23,71,35,6,228,140,93,29,180,55,108,145,
139,163,182,112,52,107,67,76,56,3,153,132,20,28,76,156,89,26,105,158,62,0,
0,42,193,2,201,104,17,41,34,156,204,176,160,226,100,226,200,211,76,241,240,
0,1,86,2,131,137,147,142,41,100,73,199,192,0,5,96,6,13,10,82,70,62,0,0,42,
130,88,115,18,124,67,103,177,69,49,129,6,36,249,68,54,123,20,82,216,65,137,
62,33,179,209,214,162,152,208,147,18,124,162,27,61,29,106,41,112,32,196,
159,16,217,233,233,81,76,112,73,137,62,81,13,158,158,149,20,186,20,98,79,
133,91,129,61,61,42,41,120,40,196,159,10,183,2,122,218,148,82,248,60,137,
62,33,179,216,166,216,192,137,18,124,162,27,61,138,109,108,34,68,159,16,
217,232,235,83,108,104,76,137,62,81,13,158,142,181,54,184,17,34,79,136,108,
244,244,169,182,56,38,68,159,40,134,207,79,74,155,93,10,145,39,194,173,192,
158,158,149,54,188,21,34,79,133,91,129,61,109,74,109,125,155,51,136,71,161,
196,201,45,167,146,59,68,89,24,70,206,0,0,0,0,0,0,7,129,249,155,51,168,71,
161,196,201,45,167,146,59,68,89,24,70,206,0,0,0,0,0,0,7,129,249,155,51,200,
71,161,196,201,45,167,146,59,68,89,24,70,206,0,0,0,0,0,0,7,129,249,155,51,
232,71,161,196,201,45,167,146,59,68,89,24,70,206,0,0,0,0,0,0,0,2,1,155,52,
8,71,161,196,201,45,167,146,59,68,89,24,70,206,0,0,0,0,0,0,0,2,1,155,52,40,
71,161,196,201,45,167,146,59,68,89,24,70,206,0,0,0,0,0,0,0,130,1,155,52,72,
71,161,196,201,45,167,146,59,68,89,24,70,206,0,0,0,0,0,0,0,130,1,155,52,
104,71,161,196,201,45,167,146,59,68,89,24,70,206,0,0,0,0,0,0,0,130,1,155,
52,136,71,161,196,201,45,167,146,59,68,89,24,70,206,0,0,0,0,0,0,1,2,1,135,
52,166,32,76,72,1,246,136,235,103,177,69,0,136,144,3,226,27,61,138,41,44,
50,36,0,251,68,117,179,209,214,234,201,69,16,50,36,0,251,68,117,179,209,
214,232,73,69,34,5,196,128,31,16,217,232,235,117,100,162,147,2,226,64,15,
136,108,244,117,186,18,81,74,129,145,32,7,218,35,173,158,158,151,86,74,40,
161,145,32,7,218,35,173,158,158,151,66,74,41,20,46,36,0,248,134,207,79,75,
171,37,20,154,23,18,0,124,67,103,167,165,208,146,138,85,11,137,0,62,21,110,
4,250,178,81,70,11,137,0,62,21,110,4,250,18,81,72,193,145,32,7,193,186,129,
89,58,178,81,71,12,137,0,62,13,212,10,201,208,146,138,71,10,137,0,62,209,
29,108,250,178,81,104,1,81,32,7,218,35,173,159,66,74,45,32,38,36,0,248,134,
207,171,37,22,160,19,18,0,124,67,103,208,146,139,88,10,180,81,50,118,136,
235,103,177,77,128,155,69,19,39,16,217,236,83,105,97,182,138,38,78,209,29,
108,244,117,186,178,83,100,13,180,81,50,118,136,235,103,163,173,208,146,
155,68,12,180,81,50,113,13,158,142,183,86,74,109,48,50,209,68,201,196,54,
122,58,221,9,41,181,64,219,69,19,39,104,142,182,122,122,93,89,41,178,134,
218,40,153,59,68,117,179,211,210,232,73,77,162,134,90,40,153,56,134,207,79,
75,171,37,54,154,25,104,162,100,226,27,61,61,46,132,148,218,168,101,162,
137,147,133,91,129,62,172,148,217,131,45,20,76,156,42,220,9,244,36,166,209,
131,109,20,76,156,27,168,21,147,171,37,54,112,219,69,19,39,6,234,5,100,232,
73,77,163,133,218,40,153,59,68,117,179,234,201,78,32,5,218,40,153,59,68,
117,179,232,73,78,36,5,90,40,153,56,134,207,171,37,56,160,21,104,162,100,
226,27,62,132,148,226,195,95,182,97,176,218,128,8,84,45,123,38,1,137,10,1,
114,160,64,56,156,199,130,36,160,72,8,39,63,27,24,1,100,180,8,148,146,0,45,
162,137,147,111,2,8,4,16,7,8,96,120,72,13,42,226,145,97,87,224,168,1,58,
182,232,232,64,22,85,181,187,177,107,2,64,7,213,183,74,7,121,207,215,242,
17,119,49,248,94,173,198,210,36,15,232,34,182,84,113,95,115,240,221,91,141,
163,160,72,1,220,164,194,175,121,123,103,224,186,244,64,24,45,68,84,251,33,
9,64,15,217,66,51,209,218,210,129,154,118,254,205,61,65,204,126,23,178,132,
103,165,3,52,237,253,154,122,131,216,254,168,48,6,90,130,1,0,39,75,80,72,8,
9,33,186,130,80,64,76,13,212,19,2,130,96,110,150,173,0,65,6,51,212,20,128,
65,17,11,212,19,130,137,121,211,210,209,144,6,39,75,80,80,0,201,119,234,10,
8,41,86,231,71,80,80,129,79,135,186,122,69,224,34,25,69,233,80,3,91,141,
168,40,96,139,113,180,181,5,36,21,110,54,142,134,160,165,1,176,23,211,47,0,
216,134,233,215,128,111,117,181,104,128,209,3,70,230,106,64,5,139,168,209,
234,10,32,36,144,102,234,136,3,146,27,168,40,160,146,132,103,168,40,192,
115,3,117,5,28,22,113,163,69,168,41,103,1,66,188,17,145,52,40,4,202,113,67,
76,130,227,68,194,13,240,108,0,0,83,96,0,2,161,0,104,146,84,97,48,0,1,78,
192,56,169,24,145,179,192,0,5,48,8,56,16,32,128,56,18,52,125,166,86,147,
182,140,28,50,21,13,39,31,23,60,145,158,56,140,141,47,113,6,155,186,188,24,
49,39,199,89,188,124,92,242,70,120,224,201,33,69,15,155,163,197,68,14,49,
39,199,197,211,116,240,242,113,197,230,18,180,253,228,3,17,46,18,243,35,
100,128,172,156,114,70,163,146,76,34,248,146,164,108,248,75,204,141,146,28,
217,114,137,27,78,251,241,173,234,162,160,225,1,3,34,92,170,9,105,164,32,
225,64,131,155,1,193,133,7,19,39,22,70,154,103,143,128,0,10,176,20,28,76,
156,113,75,34,78,62,0,0,43,0,48,104,82,146,49,240,0,1,84,11,180,192,0,5,
114,1,18,160,65,24,131,20,145,25,172,48,132,122,28,76,146,218,121,35,180,
69,145,132,108,224,0,0,0,0,0,0,120,31,153,172,56,132,122,28,76,146,218,121,
35,180,69,145,132,108,224,0,0,0,0,0,0,120,31,168,160,45,110,23,30,176,33,
184,0,0,175,32,29,235,2,27,199,23,0,0,22,4,51,88,129,8,244,56,153,37,180,
242,71,104,139,35,8,217,192,0,0,0,0,0,0,240,63,51,88,145,8,244,56,153,37,
180,242,71,104,139,35,8,217,192,0,0,0,0,0,0,0,64,51,88,161,8,244,56,153,37,
180,242,71,104,139,35,8,217,192,0,0,0,0,0,0,0,64,51,88,177,8,244,56,153,37,
180,242,71,104,139,35,8,217,192,0,0,0,0,0,0,16,64,51,88,193,8,244,56,153,
37,180,242,71,104,139,35,8,217,192,0,0,0,0,0,0,16,64,51,88,209,8,244,56,
153,37,180,242,71,104,139,35,8,217,192,0,0,0,0,0,0,16,64,51,88,225,8,244,
56,153,37,180,242,71,104,139,35,8,217,192,0,0,0,0,0,0,32,64,32,227,194,0,
97,57,162,4,245,232,5,34,92,35,68,225,161,166,218,16,16,137,112,52,41,73,
29,153,1,65,196,201,197,145,166,153,245,200,3,137,204,120,34,74,8,200,58,
112,28,211,32,130,52,78,26,26,110,248,0,0,164,4,12,70,137,195,39,252,73,
240,117,32,57,168,97,4,104,156,52,52,221,255,160,20,160,152,23,223,250,32,
148,25,174,137,58,23,51,191,244,84,12,50,9,195,39,240,81,238,2,3,107,173,
214,3,192,
};
static __attribute__ ((unused)) void duk_err_handle_error_fmt(duk_hthread *thr, const char *filename, duk_uint_t line_and_code, const char *fmt, ...) {
 va_list ap={0};
 char msg[256]={0};
 __builtin_va_start(ap,fmt);
 (void) vsnprintf(msg, sizeof(msg), fmt, ap);
 msg[sizeof(msg) - 1] = (char) 0;
 duk_err_create_and_throw(thr, (duk_errcode_t) (line_and_code >> 24), msg, filename, (duk_int_t) (line_and_code & 0x00ffffffL));
 __builtin_va_end(ap);
}

static __attribute__ ((unused)) void duk_err_handle_error(duk_hthread *thr, const char *filename, duk_uint_t line_and_code, const char *msg) {
 duk_err_create_and_throw(thr, (duk_errcode_t) (line_and_code >> 24), msg, filename, (duk_int_t) (line_and_code & 0x00ffffffL));
}
static __attribute__ ((unused)) void duk_err_require_type_index(duk_hthread *thr, const char *filename, duk_int_t linenumber, duk_idx_t idx, const char *expect_name) {
 do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) (linenumber); do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr), (filename), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("%s required, found %s (stack index %ld)"), (expect_name), (duk_push_string_readable(thr, idx)), ((long) idx)); } while (0)
                                                                                ;
}

static __attribute__ ((unused)) void duk_err_error_internal(duk_hthread *thr, const char *filename, duk_int_t linenumber) {
 do { duk_errcode_t duk__err = (1); duk_int_t duk__line = (duk_int_t) (linenumber); do { } while (0); do { } while (0); duk_err_handle_error((thr), (filename), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("internal error")); } while (0);
}
static __attribute__ ((unused)) void duk_err_error_alloc_failed(duk_hthread *thr, const char *filename, duk_int_t linenumber) {
 do { duk_errcode_t duk__err = (1); duk_int_t duk__line = (duk_int_t) (linenumber); do { } while (0); do { } while (0); duk_err_handle_error((thr), (filename), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("alloc failed")); } while (0);
}
static __attribute__ ((unused)) void duk_err_error(duk_hthread *thr, const char *filename, duk_int_t linenumber, const char *message) {
 do { duk_errcode_t duk__err = (1); duk_int_t duk__line = (duk_int_t) (linenumber); do { } while (0); do { } while (0); duk_err_handle_error((thr), (filename), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (message)); } while (0);
}
static __attribute__ ((unused)) void duk_err_range(duk_hthread *thr, const char *filename, duk_int_t linenumber, const char *message) {
 do { duk_errcode_t duk__err = (3); duk_int_t duk__line = (duk_int_t) (linenumber); do { } while (0); do { } while (0); duk_err_handle_error((thr), (filename), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (message)); } while (0);
}
static __attribute__ ((unused)) void duk_err_range_index(duk_hthread *thr, const char *filename, duk_int_t linenumber, duk_idx_t idx) {
 do { duk_errcode_t duk__err = (3); duk_int_t duk__line = (duk_int_t) (linenumber); do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr), (filename), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("invalid stack index %ld"), ((long) (idx))); } while (0);
}
static __attribute__ ((unused)) void duk_err_range_push_beyond(duk_hthread *thr, const char *filename, duk_int_t linenumber) {
 do { duk_errcode_t duk__err = (3); duk_int_t duk__line = (duk_int_t) (linenumber); do { } while (0); do { } while (0); duk_err_handle_error((thr), (filename), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("cannot push beyond allocated stack")); } while (0);
}
static __attribute__ ((unused)) void duk_err_type_invalid_args(duk_hthread *thr, const char *filename, duk_int_t linenumber) {
 do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) (linenumber); do { } while (0); do { } while (0); duk_err_handle_error((thr), (filename), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("invalid args")); } while (0);
}
static __attribute__ ((unused)) void duk_err_type_invalid_state(duk_hthread *thr, const char *filename, duk_int_t linenumber) {
 do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) (linenumber); do { } while (0); do { } while (0); duk_err_handle_error((thr), (filename), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("invalid state")); } while (0);
}
static __attribute__ ((unused)) void duk_err_type_invalid_trap_result(duk_hthread *thr, const char *filename, duk_int_t linenumber) {
 do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) (linenumber); do { } while (0); do { } while (0); duk_err_handle_error((thr), (filename), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("invalid trap result")); } while (0);
}
static __attribute__ ((unused)) void duk_default_fatal_handler(void *udata, const char *msg) {
 do { (void) (udata); } while (0);
 do { (void) (msg); } while (0);

 msg = msg ? msg : "NULL";
 do { } while (0);
 abort();


 do { } while (0);
 for (;;) {

 }
}
static __attribute__ ((unused)) const duk_int8_t duk_is_idchar_tab[128] = {




 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0,
 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,
 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0
};






static __attribute__ ((unused)) duk_small_int_t duk_unicode_get_xutf8_length(duk_ucodepoint_t cp) {
 duk_uint_fast32_t x = (duk_uint_fast32_t) cp;
 if (x < 0x80UL) {

  return 1;
 } else if (x < 0x800UL) {

  return 2;
 } else if (x < 0x10000UL) {

  return 3;
 } else if (x < 0x200000UL) {

  return 4;
 } else if (x < 0x4000000UL) {

  return 5;
 } else if (x < (duk_ucodepoint_t) 0x80000000UL) {

  return 6;
 } else {

  return 7;
 }
}
static __attribute__ ((unused)) const duk_uint8_t duk_unicode_xutf8_markers[7] = {
 0x00, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe
};





static __attribute__ ((unused)) duk_small_int_t duk_unicode_encode_xutf8(duk_ucodepoint_t cp, duk_uint8_t *out) {
 duk_uint_fast32_t x = (duk_uint_fast32_t) cp;
 duk_small_int_t len={0};
 duk_uint8_t marker={0};
 duk_small_int_t i={0};

 len = duk_unicode_get_xutf8_length(cp);
 do { } while (0);

 marker = duk_unicode_xutf8_markers[len - 1];

 i = len;
 do { } while (0);
 do {
  i--;
  if (i > 0) {
   out[i] = (duk_uint8_t) (0x80 + (x & 0x3f));
   x >>= 6;
  } else {




   out[0] = (duk_uint8_t) (marker + x);
  }
 } while (i > 0);

 return len;
}





static __attribute__ ((unused)) duk_small_int_t duk_unicode_encode_cesu8(duk_ucodepoint_t cp, duk_uint8_t *out) {
 duk_uint_fast32_t x = (duk_uint_fast32_t) cp;
 duk_small_int_t len={0};

 if (x < 0x80UL) {
  out[0] = (duk_uint8_t) x;
  len = 1;
 } else if (x < 0x800UL) {
  out[0] = (duk_uint8_t) (0xc0 + ((x >> 6) & 0x1f));
  out[1] = (duk_uint8_t) (0x80 + (x & 0x3f));
  len = 2;
 } else if (x < 0x10000UL) {

  out[0] = (duk_uint8_t) (0xe0 + ((x >> 12) & 0x0f));
  out[1] = (duk_uint8_t) (0x80 + ((x >> 6) & 0x3f));
  out[2] = (duk_uint8_t) (0x80 + (x & 0x3f));
  len = 3;
 } else {
  x -= 0x10000UL;

  out[0] = (duk_uint8_t) (0xed);
  out[1] = (duk_uint8_t) (0xa0 + ((x >> 16) & 0x0f));
  out[2] = (duk_uint8_t) (0x80 + ((x >> 10) & 0x3f));
  out[3] = (duk_uint8_t) (0xed);
  out[4] = (duk_uint8_t) (0xb0 + ((x >> 6) & 0x0f));
  out[5] = (duk_uint8_t) (0x80 + (x & 0x3f));
  len = 6;
 }

 return len;
}


static __attribute__ ((unused)) duk_small_int_t duk_unicode_decode_xutf8(duk_hthread *thr, const duk_uint8_t **ptr, const duk_uint8_t *ptr_start, const duk_uint8_t *ptr_end, duk_ucodepoint_t *out_cp) {
 const duk_uint8_t *p={0};
 duk_uint32_t res={0};
 duk_uint_fast8_t ch={0};
 duk_small_int_t n={0};

 do { (void) (thr); } while (0);

 p = *ptr;
 if (p < ptr_start || p >= ptr_end) {
  goto fail;
 }






 ch = (duk_uint_fast8_t) (*p++);
 if (ch < 0x80) {

  res = (duk_uint32_t) (ch & 0x7f);
  n = 0;
 } else if (ch < 0xc0) {

  goto fail;
 } else if (ch < 0xe0) {

  res = (duk_uint32_t) (ch & 0x1f);
  n = 1;
 } else if (ch < 0xf0) {

  res = (duk_uint32_t) (ch & 0x0f);
  n = 2;
 } else if (ch < 0xf8) {

  res = (duk_uint32_t) (ch & 0x07);
  n = 3;
 } else if (ch < 0xfc) {

  res = (duk_uint32_t) (ch & 0x03);
  n = 4;
 } else if (ch < 0xfe) {

  res = (duk_uint32_t) (ch & 0x01);
  n = 5;
 } else if (ch < 0xff) {

  res = (duk_uint32_t) (0);
  n = 6;
 } else {
  goto fail;
 }

 do { } while (0);
 if (p + n > ptr_end) {

  goto fail;
 }

 while (n > 0) {
  do { } while (0);
  ch = (duk_uint_fast8_t) (*p++);
  res = (res << 6) + (duk_uint32_t) (ch & 0x3f);
  n--;
 }

 *ptr = p;
 *out_cp = res;
 return 1;

 fail:
 return 0;
}


static __attribute__ ((unused)) duk_ucodepoint_t duk_unicode_decode_xutf8_checked(duk_hthread *thr, const duk_uint8_t **ptr, const duk_uint8_t *ptr_start, const duk_uint8_t *ptr_end) {
 duk_ucodepoint_t cp={0};

 if (duk_unicode_decode_xutf8(thr, ptr, ptr_start, ptr_end, &cp)) {
  return cp;
 }
 do { duk_err_error_internal((thr), "duk_unicode_support.c", (duk_int_t) 282); } while (0);
 do { } while (0);
}
static __attribute__ ((unused)) duk_size_t duk_unicode_unvalidated_utf8_length(const duk_uint8_t *data, duk_size_t blen) {
 const duk_uint8_t *p={0};
 const duk_uint8_t *p_end={0};
 const duk_uint32_t *p32_end={0};
 const duk_uint32_t *p32={0};
 duk_size_t ncont={0};
 duk_size_t clen={0};

 ncont = 0;
 p = data;
 p_end = data + blen;
 if (blen < 16) {
  goto skip_fastpath;
 }




 while (((duk_size_t) (const void *) p) & 0x03U) {
  duk_uint8_t x={0};
  x = *p++;
  if (__builtin_expect((x >= 0x80 && x <= 0xbf), 0)) {
   ncont++;
  }
 }


 p32_end = (const duk_uint32_t *) (const void *) (p + ((duk_size_t) (p_end - p) & (duk_size_t) (~0x03)));
 p32 = (const duk_uint32_t *) (const void *) p;
 while (p32 != (const duk_uint32_t *) p32_end) {
  duk_uint32_t x={0};
  x = *p32++;
  if (__builtin_expect(((x & 0x80808080UL) == 0), 1)) {
   ;
  } else {




   x ^= 0x80808080UL;
   if (__builtin_expect((!(x & 0xc0000000UL)), 0)) {
    ncont++;
   }
   if (__builtin_expect((!(x & 0x00c00000UL)), 0)) {
    ncont++;
   }
   if (__builtin_expect((!(x & 0x0000c000UL)), 0)) {
    ncont++;
   }
   if (__builtin_expect((!(x & 0x000000c0UL)), 0)) {
    ncont++;
   }
  }
 }
 p = (const duk_uint8_t *) p32;


 skip_fastpath:
 while (p != p_end) {
  duk_uint8_t x={0};
  x = *p++;
  if (__builtin_expect((x >= 0x80 && x <= 0xbf), 0)) {
   ncont++;
  }
 }

 do { } while (0);
 clen = blen - ncont;
 do { } while (0);
 return clen;
}
static duk_uint32_t duk__uni_decode_value(duk_bitdecoder_ctx *bd_ctx) {
 duk_uint32_t t={0};

 t = (duk_uint32_t) duk_bd_decode(bd_ctx, 4);
 if (t <= 0x0eU) {
  return t;
 }
 t = (duk_uint32_t) duk_bd_decode(bd_ctx, 8);
 if (t <= 0xfdU) {
  return t + 0x0f;
 }
 if (t == 0xfeU) {
  t = (duk_uint32_t) duk_bd_decode(bd_ctx, 12);
  return t + 0x0fU + 0xfeU;
 } else {
  t = (duk_uint32_t) duk_bd_decode(bd_ctx, 24);
  return t + 0x0fU + 0xfeU + 0x1000UL;
 }
}

static duk_small_int_t duk__uni_range_match(const duk_uint8_t *unitab, duk_size_t unilen, duk_codepoint_t cp) {
 duk_bitdecoder_ctx bd_ctx={0};
 duk_codepoint_t prev_re={0};

 do { void *duk__dst = (&bd_ctx); duk_size_t duk__len = (sizeof(bd_ctx)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 bd_ctx.data = (const duk_uint8_t *) unitab;
 bd_ctx.length = (duk_size_t) unilen;

 prev_re = 0;
 for (;;) {
  duk_codepoint_t r1, r2={0};
  r1 = (duk_codepoint_t) duk__uni_decode_value(&bd_ctx);
  if (r1 == 0) {
   break;
  }
  r2 = (duk_codepoint_t) duk__uni_decode_value(&bd_ctx);

  r1 = prev_re + r1;
  r2 = r1 + r2;
  prev_re = r2;



  do { } while (0)
                                                                                   ;
  if (cp >= r1 && cp <= r2) {
   return 1;
  }
 }

 return 0;
}





static __attribute__ ((unused)) duk_small_int_t duk_unicode_is_whitespace(duk_codepoint_t cp) {
 duk_uint_fast8_t lo={0};
 duk_uint_fast32_t hi={0};



 lo = (duk_uint_fast8_t) (cp & 0xff);
 hi = (duk_uint_fast32_t) (cp >> 8);

 if (hi == 0x0000UL) {
  if (lo == 0x09U || lo == 0x0bU || lo == 0x0cU ||
      lo == 0x20U || lo == 0xa0U) {
   return 1;
  }
 } else if (hi == 0x0020UL) {
  if (lo <= 0x0aU || lo == 0x2fU || lo == 0x5fU) {
   return 1;
  }
 } else if (cp == 0x1680L || cp == 0x180eL || cp == 0x3000L ||
            cp == 0xfeffL) {
  return 1;
 }

 return 0;
}





static __attribute__ ((unused)) duk_small_int_t duk_unicode_is_line_terminator(duk_codepoint_t cp) {







 if (cp == 0x000aL || cp == 0x000dL || cp == 0x2028L ||
     cp == 0x2029L) {
  return 1;
 }

 return 0;
}





static __attribute__ ((unused)) duk_small_int_t duk_unicode_is_identifier_start(duk_codepoint_t cp) {
 if (cp <= 0x7fL) {

  return (cp >= 0) && (duk_is_idchar_tab[cp] > 0);
 }




 if (duk__uni_range_match(duk_unicode_ids_noa,
                          (duk_size_t) sizeof(duk_unicode_ids_noa),
                          (duk_codepoint_t) cp)) {
  return 1;
 }
 return 0;
}





static __attribute__ ((unused)) duk_small_int_t duk_unicode_is_identifier_part(duk_codepoint_t cp) {
 if (cp <= 0x7fL) {

  return (cp >= 0) && (duk_is_idchar_tab[cp] != 0);
 }




 if (duk__uni_range_match(duk_unicode_ids_noa,
                          sizeof(duk_unicode_ids_noa),
                          (duk_codepoint_t) cp) ||
     duk__uni_range_match(duk_unicode_idp_m_ids_noa,
                          sizeof(duk_unicode_idp_m_ids_noa),
                          (duk_codepoint_t) cp)) {
  return 1;
 }
 return 0;
}





static __attribute__ ((unused)) duk_small_int_t duk_unicode_is_letter(duk_codepoint_t cp) {
 if (cp <= 0x7fL) {
  if ((cp >= 'a' && cp <= 'z') ||
      (cp >= 'A' && cp <= 'Z')) {
   return 1;
  }
  return 0;
 }




 if (duk__uni_range_match(duk_unicode_ids_noa,
                          sizeof(duk_unicode_ids_noa),
                          (duk_codepoint_t) cp) &&
     !duk__uni_range_match(duk_unicode_ids_m_let_noa,
                           sizeof(duk_unicode_ids_m_let_noa),
                           (duk_codepoint_t) cp)) {
  return 1;
 }
 return 0;
}
static
duk_codepoint_t duk__slow_case_conversion(duk_hthread *thr,
                                          duk_bufwriter_ctx *bw,
                                          duk_codepoint_t cp,
                                          duk_bitdecoder_ctx *bd_ctx) {
 duk_small_int_t skip = 0;
 duk_small_int_t n={0};
 duk_small_int_t t={0};
 duk_small_int_t count={0};
 duk_codepoint_t tmp_cp={0};
 duk_codepoint_t start_i={0};
 duk_codepoint_t start_o={0};

 do { } while (0);
 do { (void) (thr); } while (0);

 do { } while (0);


 do { } while (0);
 for (;;) {
  skip++;
  n = (duk_small_int_t) duk_bd_decode(bd_ctx, 6);
  if (n == 0x3f) {

   break;
  }
  do { } while (0);

  while (n--) {
   start_i = (duk_codepoint_t) duk_bd_decode(bd_ctx, 16);
   start_o = (duk_codepoint_t) duk_bd_decode(bd_ctx, 16);
   count = (duk_small_int_t) duk_bd_decode(bd_ctx, 7);
   do { } while (0)
                                                                                   ;

   if (cp >= start_i) {
    tmp_cp = cp - start_i;
    if (tmp_cp < (duk_codepoint_t) count * (duk_codepoint_t) skip &&
        (tmp_cp % (duk_codepoint_t) skip) == 0) {
     do { } while (0);
     cp = start_o + tmp_cp;
     goto single;
    }
   }
  }
 }


 n = (duk_small_int_t) duk_bd_decode(bd_ctx, 7);
 do { } while (0);
 while (n--) {
  start_i = (duk_codepoint_t) duk_bd_decode(bd_ctx, 16);
  start_o = (duk_codepoint_t) duk_bd_decode(bd_ctx, 16);
  do { } while (0);
  if (cp == start_i) {
   do { } while (0);
   cp = start_o;
   goto single;
  }
 }


 n = (duk_small_int_t) duk_bd_decode(bd_ctx, 7);
 do { } while (0);
 while (n--) {
  start_i = (duk_codepoint_t) duk_bd_decode(bd_ctx, 16);
  t = (duk_small_int_t) duk_bd_decode(bd_ctx, 2);
  do { } while (0);
  if (cp == start_i) {
   do { } while (0);
   if (bw != ((void *)0)) {
    while (t--) {
     tmp_cp = (duk_codepoint_t) duk_bd_decode(bd_ctx, 16);
     do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) ((duk_ucodepoint_t) tmp_cp); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, (bw)->p); (bw)->p += duk__enc_len; } while (0);
    }
   }
   return -1;
  } else {
   while (t--) {
    (void) duk_bd_decode(bd_ctx, 16);
   }
  }
 }


 do { } while (0);


 single:
 if (bw != ((void *)0)) {
  do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) ((duk_ucodepoint_t) cp); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, (bw)->p); (bw)->p += duk__enc_len; } while (0);
 }
 return cp;
}
static
duk_codepoint_t duk__case_transform_helper(duk_hthread *thr,
                                           duk_bufwriter_ctx *bw,
                                           duk_codepoint_t cp,
                                           duk_codepoint_t prev,
                                           duk_codepoint_t next,
                                           duk_bool_t uppercase) {
 duk_bitdecoder_ctx bd_ctx={0};


 if (cp < 0x80L) {






  if (uppercase) {
   if (cp >= 'a' && cp <= 'z') {
    cp = cp - 'a' + 'A';
   }
  } else {
   if (cp >= 'A' && cp <= 'Z') {
    cp = cp - 'A' + 'a';
   }
  }

  if (bw != ((void *)0)) {
   do { do { (((void) 0), ((void) 0)); } while (0); *(bw)->p++ = (duk_uint8_t) ((duk_uint8_t) cp); } while (0);
  }
  return cp;
 }




 if (uppercase) {

 } else {






  if (cp == 0x03a3L &&
      duk_unicode_is_letter(prev) &&
      !duk_unicode_is_letter(next)) {





   cp = 0x03c2L;
   goto singlechar;
  }




 }


 do { void *duk__dst = (&bd_ctx); duk_size_t duk__len = (sizeof(bd_ctx)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 if (uppercase) {
  bd_ctx.data = (const duk_uint8_t *) duk_unicode_caseconv_uc;
  bd_ctx.length = (duk_size_t) sizeof(duk_unicode_caseconv_uc);
 } else {
  bd_ctx.data = (const duk_uint8_t *) duk_unicode_caseconv_lc;
  bd_ctx.length = (duk_size_t) sizeof(duk_unicode_caseconv_lc);
 }
 return duk__slow_case_conversion(thr, bw, cp, &bd_ctx);

 singlechar:
 if (bw != ((void *)0)) {
  do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) ((duk_ucodepoint_t) cp); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, (bw)->p); (bw)->p += duk__enc_len; } while (0);
 }
 return cp;






}





static __attribute__ ((unused)) void duk_unicode_case_convert_string(duk_hthread *thr, duk_bool_t uppercase) {
 duk_hstring *h_input={0};
 duk_bufwriter_ctx bw_alloc={0};
 duk_bufwriter_ctx *bw={0};
 const duk_uint8_t *p, *p_start, *p_end={0};
 duk_codepoint_t prev, curr, next={0};

 h_input = duk_require_hstring(thr, -1);
 do { } while (0);

 bw = &bw_alloc;
 do { duk_bw_init_pushbuf((thr), (bw), (((h_input)->blen))); } while (0);



 p_start = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_input) + 1));
 p_end = p_start + ((h_input)->blen);
 p = p_start;

 prev = -1; do { (void) (prev); } while (0);
 curr = -1;
 next = -1;
 for (;;) {
  prev = curr;
  curr = next;
  next = -1;
  if (p < p_end) {
   next = (duk_codepoint_t) duk_unicode_decode_xutf8_checked(thr, &p, p_start, p_end);
  } else {

   if (curr < 0) {
    break;
   }
  }


  if (curr >= 0) {





   do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (8 * 7); duk__space = (duk_size_t) ((bw)->p_limit - (bw)->p); if (duk__space < duk__sz) { (void) duk_bw_resize((thr), (bw), duk__sz); } } while (0);

   duk__case_transform_helper(thr,
                              bw,
                              (duk_codepoint_t) curr,
                              prev,
                              next,
                              uppercase);
  }
 }

 do { duk_bw_compact((thr), (bw)); } while (0);
 (void) duk_buffer_to_string(thr, -1);

 duk_remove_m2(thr);
}
static __attribute__ ((unused)) duk_codepoint_t duk_unicode_re_canonicalize_char(duk_hthread *thr, duk_codepoint_t cp) {
 duk_codepoint_t y={0};

 y = duk__case_transform_helper(thr,
                                ((void *)0),
                                cp,
                                -1,
                                -1,
                                1);

 if ((y < 0) || (cp >= 0x80 && y < 0x80)) {



  return cp;
 }

 return y;

}






static __attribute__ ((unused)) duk_small_int_t duk_unicode_re_is_wordchar(duk_codepoint_t x) {




 if ((x >= '0' && x <= '9') ||
     (x >= 'a' && x <= 'z') ||
     (x >= 'A' && x <= 'Z') ||
     (x == '_')) {
  return 1;
 }
 return 0;
}






static __attribute__ ((unused)) const duk_uint16_t duk_unicode_re_ranges_digit[2] = {
 (duk_uint16_t) 0x0030UL, (duk_uint16_t) 0x0039UL,
};
static __attribute__ ((unused)) const duk_uint16_t duk_unicode_re_ranges_white[22] = {
 (duk_uint16_t) 0x0009UL, (duk_uint16_t) 0x000DUL,
 (duk_uint16_t) 0x0020UL, (duk_uint16_t) 0x0020UL,
 (duk_uint16_t) 0x00A0UL, (duk_uint16_t) 0x00A0UL,
 (duk_uint16_t) 0x1680UL, (duk_uint16_t) 0x1680UL,
 (duk_uint16_t) 0x180EUL, (duk_uint16_t) 0x180EUL,
 (duk_uint16_t) 0x2000UL, (duk_uint16_t) 0x200AUL,
 (duk_uint16_t) 0x2028UL, (duk_uint16_t) 0x2029UL,
 (duk_uint16_t) 0x202FUL, (duk_uint16_t) 0x202FUL,
 (duk_uint16_t) 0x205FUL, (duk_uint16_t) 0x205FUL,
 (duk_uint16_t) 0x3000UL, (duk_uint16_t) 0x3000UL,
 (duk_uint16_t) 0xFEFFUL, (duk_uint16_t) 0xFEFFUL,
};
static __attribute__ ((unused)) const duk_uint16_t duk_unicode_re_ranges_wordchar[8] = {
 (duk_uint16_t) 0x0030UL, (duk_uint16_t) 0x0039UL,
 (duk_uint16_t) 0x0041UL, (duk_uint16_t) 0x005AUL,
 (duk_uint16_t) 0x005FUL, (duk_uint16_t) 0x005FUL,
 (duk_uint16_t) 0x0061UL, (duk_uint16_t) 0x007AUL,
};
static __attribute__ ((unused)) const duk_uint16_t duk_unicode_re_ranges_not_digit[4] = {
 (duk_uint16_t) 0x0000UL, (duk_uint16_t) 0x002FUL,
 (duk_uint16_t) 0x003AUL, (duk_uint16_t) 0xFFFFUL,
};
static __attribute__ ((unused)) const duk_uint16_t duk_unicode_re_ranges_not_white[24] = {
 (duk_uint16_t) 0x0000UL, (duk_uint16_t) 0x0008UL,
 (duk_uint16_t) 0x000EUL, (duk_uint16_t) 0x001FUL,
 (duk_uint16_t) 0x0021UL, (duk_uint16_t) 0x009FUL,
 (duk_uint16_t) 0x00A1UL, (duk_uint16_t) 0x167FUL,
 (duk_uint16_t) 0x1681UL, (duk_uint16_t) 0x180DUL,
 (duk_uint16_t) 0x180FUL, (duk_uint16_t) 0x1FFFUL,
 (duk_uint16_t) 0x200BUL, (duk_uint16_t) 0x2027UL,
 (duk_uint16_t) 0x202AUL, (duk_uint16_t) 0x202EUL,
 (duk_uint16_t) 0x2030UL, (duk_uint16_t) 0x205EUL,
 (duk_uint16_t) 0x2060UL, (duk_uint16_t) 0x2FFFUL,
 (duk_uint16_t) 0x3001UL, (duk_uint16_t) 0xFEFEUL,
 (duk_uint16_t) 0xFF00UL, (duk_uint16_t) 0xFFFFUL,
};
static __attribute__ ((unused)) const duk_uint16_t duk_unicode_re_ranges_not_wordchar[10] = {
 (duk_uint16_t) 0x0000UL, (duk_uint16_t) 0x002FUL,
 (duk_uint16_t) 0x003AUL, (duk_uint16_t) 0x0040UL,
 (duk_uint16_t) 0x005BUL, (duk_uint16_t) 0x005EUL,
 (duk_uint16_t) 0x0060UL, (duk_uint16_t) 0x0060UL,
 (duk_uint16_t) 0x007BUL, (duk_uint16_t) 0xFFFFUL,
};
static __attribute__ ((unused)) const duk_uint8_t duk_lc_digits[36] = {
 0x30, 0x31, 0x32, 0x33,
 0x34, 0x35, 0x36, 0x37,
 0x38, 0x39, 0x61, 0x62,
 0x63, 0x64, 0x65, 0x66,
 0x67, 0x68, 0x69, 0x6a,
 0x6b, 0x6c, 0x6d, 0x6e,
 0x6f, 0x70, 0x71, 0x72,
 0x73, 0x74, 0x75, 0x76,
 0x77, 0x78, 0x79, 0x7a
};

static __attribute__ ((unused)) const duk_uint8_t duk_uc_nybbles[16] = {
 0x30, 0x31, 0x32, 0x33,
 0x34, 0x35, 0x36, 0x37,
 0x38, 0x39, 0x41, 0x42,
 0x43, 0x44, 0x45, 0x46
};





static __attribute__ ((unused)) const duk_int8_t duk_hex_dectab[256] = {

 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1,
 -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
};



static __attribute__ ((unused)) const duk_int16_t duk_hex_dectab_shift4[256] = {
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, -1, -1, -1, -1, -1, -1,
   -1, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
};
static __attribute__ ((unused)) const duk_uint16_t duk_hex_enctab[256] = {
 0x3030U, 0x3130U, 0x3230U, 0x3330U, 0x3430U, 0x3530U, 0x3630U, 0x3730U,
 0x3830U, 0x3930U, 0x6130U, 0x6230U, 0x6330U, 0x6430U, 0x6530U, 0x6630U,
 0x3031U, 0x3131U, 0x3231U, 0x3331U, 0x3431U, 0x3531U, 0x3631U, 0x3731U,
 0x3831U, 0x3931U, 0x6131U, 0x6231U, 0x6331U, 0x6431U, 0x6531U, 0x6631U,
 0x3032U, 0x3132U, 0x3232U, 0x3332U, 0x3432U, 0x3532U, 0x3632U, 0x3732U,
 0x3832U, 0x3932U, 0x6132U, 0x6232U, 0x6332U, 0x6432U, 0x6532U, 0x6632U,
 0x3033U, 0x3133U, 0x3233U, 0x3333U, 0x3433U, 0x3533U, 0x3633U, 0x3733U,
 0x3833U, 0x3933U, 0x6133U, 0x6233U, 0x6333U, 0x6433U, 0x6533U, 0x6633U,
 0x3034U, 0x3134U, 0x3234U, 0x3334U, 0x3434U, 0x3534U, 0x3634U, 0x3734U,
 0x3834U, 0x3934U, 0x6134U, 0x6234U, 0x6334U, 0x6434U, 0x6534U, 0x6634U,
 0x3035U, 0x3135U, 0x3235U, 0x3335U, 0x3435U, 0x3535U, 0x3635U, 0x3735U,
 0x3835U, 0x3935U, 0x6135U, 0x6235U, 0x6335U, 0x6435U, 0x6535U, 0x6635U,
 0x3036U, 0x3136U, 0x3236U, 0x3336U, 0x3436U, 0x3536U, 0x3636U, 0x3736U,
 0x3836U, 0x3936U, 0x6136U, 0x6236U, 0x6336U, 0x6436U, 0x6536U, 0x6636U,
 0x3037U, 0x3137U, 0x3237U, 0x3337U, 0x3437U, 0x3537U, 0x3637U, 0x3737U,
 0x3837U, 0x3937U, 0x6137U, 0x6237U, 0x6337U, 0x6437U, 0x6537U, 0x6637U,
 0x3038U, 0x3138U, 0x3238U, 0x3338U, 0x3438U, 0x3538U, 0x3638U, 0x3738U,
 0x3838U, 0x3938U, 0x6138U, 0x6238U, 0x6338U, 0x6438U, 0x6538U, 0x6638U,
 0x3039U, 0x3139U, 0x3239U, 0x3339U, 0x3439U, 0x3539U, 0x3639U, 0x3739U,
 0x3839U, 0x3939U, 0x6139U, 0x6239U, 0x6339U, 0x6439U, 0x6539U, 0x6639U,
 0x3061U, 0x3161U, 0x3261U, 0x3361U, 0x3461U, 0x3561U, 0x3661U, 0x3761U,
 0x3861U, 0x3961U, 0x6161U, 0x6261U, 0x6361U, 0x6461U, 0x6561U, 0x6661U,
 0x3062U, 0x3162U, 0x3262U, 0x3362U, 0x3462U, 0x3562U, 0x3662U, 0x3762U,
 0x3862U, 0x3962U, 0x6162U, 0x6262U, 0x6362U, 0x6462U, 0x6562U, 0x6662U,
 0x3063U, 0x3163U, 0x3263U, 0x3363U, 0x3463U, 0x3563U, 0x3663U, 0x3763U,
 0x3863U, 0x3963U, 0x6163U, 0x6263U, 0x6363U, 0x6463U, 0x6563U, 0x6663U,
 0x3064U, 0x3164U, 0x3264U, 0x3364U, 0x3464U, 0x3564U, 0x3664U, 0x3764U,
 0x3864U, 0x3964U, 0x6164U, 0x6264U, 0x6364U, 0x6464U, 0x6564U, 0x6664U,
 0x3065U, 0x3165U, 0x3265U, 0x3365U, 0x3465U, 0x3565U, 0x3665U, 0x3765U,
 0x3865U, 0x3965U, 0x6165U, 0x6265U, 0x6365U, 0x6465U, 0x6565U, 0x6665U,
 0x3066U, 0x3166U, 0x3266U, 0x3366U, 0x3466U, 0x3566U, 0x3666U, 0x3766U,
 0x3866U, 0x3966U, 0x6166U, 0x6266U, 0x6366U, 0x6466U, 0x6566U, 0x6666U

};
static __attribute__ ((unused)) duk_uint8_t duk_class_number_to_stridx[32] = {
 15,
 4,
 6,
 5,
 3,
 8,
 10,
 12,
 14,
 13,
 9,
 11,
 7,
 27,
 2,
 28,
 29,
 31,
 32,
 16,
 17,
 18,
 19,
 20,
 21,
 22,
 23,
 24,
 25,
 26,
 15,
 15,
};
static __attribute__ ((unused)) void *duk_default_alloc_function(void *udata, duk_size_t size) {
 void *res={0};
 do { (void) (udata); } while (0);
 res = malloc(size);
 do { } while (0)
                                                          ;
 return res;
}

static __attribute__ ((unused)) void *duk_default_realloc_function(void *udata, void *ptr, duk_size_t newsize) {
 void *res={0};
 do { (void) (udata); } while (0);
 res = realloc(ptr, newsize);
 do { } while (0)
                                                                           ;
 return res;
}

static __attribute__ ((unused)) void duk_default_free_function(void *udata, void *ptr) {
 do { } while (0);
 do { (void) (udata); } while (0);
 free(ptr);
}






__attribute__ ((visibility("default"))) void *duk_resize_buffer(duk_hthread *thr, duk_idx_t idx, duk_size_t new_size) {
 duk_hbuffer_dynamic *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hbuffer_dynamic *) duk_require_hbuffer(thr, idx);
 do { } while (0);

 if (!((((&(h)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) && !(((&(h)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0))) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 16; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_buffer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("wrong buffer type"))); } while (0); } while (0);
  do { } while (0);
 }


 duk_hbuffer_resize(thr, h, new_size);

 return ((h)->curr_alloc);
}

__attribute__ ((visibility("default"))) void *duk_steal_buffer(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size) {
 duk_hbuffer_dynamic *h={0};
 void *ptr={0};
 duk_size_t sz={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hbuffer_dynamic *) duk_require_hbuffer(thr, idx);
 do { } while (0);

 if (!((((&(h)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) && !(((&(h)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0))) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 37; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_buffer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("wrong buffer type"))); } while (0); } while (0);
  do { } while (0);
 }






 ptr = ((h)->curr_alloc);
 sz = (((duk_hbuffer *) ((duk_hbuffer *) (h)))->size);
 if (out_size) {
  *out_size = sz;
 }
 do { (h)->curr_alloc = (void *) ((void *)0); } while (0);
 do { ((duk_hbuffer *) ((duk_hbuffer *) (h)))->size = ((0)); } while (0);

 return ptr;
}

__attribute__ ((visibility("default"))) void duk_config_buffer(duk_hthread *thr, duk_idx_t idx, void *ptr, duk_size_t len) {
 duk_hbuffer_external *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hbuffer_external *) duk_require_hbuffer(thr, idx);
 do { } while (0);

 if (!(((&(h)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 66; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_buffer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("wrong buffer type"))); } while (0); } while (0);
  do { } while (0);
 }
 do { } while (0);

 do { (h)->curr_alloc = (void *) (ptr); } while (0);
 do { ((duk_hbuffer *) ((duk_hbuffer *) (h)))->size = ((len)); } while (0);
}
static duk_uint8_t *duk__load_string_raw(duk_hthread *thr, duk_uint8_t *p) {
 duk_uint32_t len={0};

 len = duk_raw_read_u32_be(&(p));;
 duk_push_lstring(thr, (const char *) p, len);
 p += len;
 return p;
}

static duk_uint8_t *duk__load_buffer_raw(duk_hthread *thr, duk_uint8_t *p) {
 duk_uint32_t len={0};
 duk_uint8_t *buf={0};

 len = duk_raw_read_u32_be(&(p));;
 buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, (duk_size_t) len);
 do { } while (0);
 do { void *duk__dst = ((void *) buf); const void *duk__src = ((const void *) p); duk_size_t duk__len = ((size_t) len); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 p += len;
 return p;
}

static duk_uint8_t *duk__dump_hstring_raw(duk_uint8_t *p, duk_hstring *h) {
 duk_size_t len={0};
 duk_uint32_t tmp32={0};

 do { } while (0);

 len = ((h)->blen);
 do { } while (0);
 tmp32 = (duk_uint32_t) len;
 duk_raw_write_u32_be(&(p), (duk_uint32_t) (tmp32));
 do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) ((const duk_uint8_t *) ((h) + 1))); duk_size_t duk__len = (len); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0)

                ;
 p += len;
 return p;
}

static duk_uint8_t *duk__dump_hbuffer_raw(duk_hthread *thr, duk_uint8_t *p, duk_hbuffer *h) {
 duk_size_t len={0};
 duk_uint32_t tmp32={0};

 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 len = (((duk_hbuffer *) (h))->size);
 do { } while (0);
 tmp32 = (duk_uint32_t) len;
 duk_raw_write_u32_be(&(p), (duk_uint32_t) (tmp32));

 do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) ( (((&((h))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h))) + 1)) )); duk_size_t duk__len = (len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0)

                       ;
 p += len;
 return p;
}

static duk_uint8_t *duk__dump_string_prop(duk_hthread *thr, duk_uint8_t *p, duk_bufwriter_ctx *bw_ctx, duk_hobject *func, duk_small_uint_t stridx) {
 duk_hstring *h_str={0};
 duk_tval *tv={0};

 tv = duk_hobject_find_existing_entry_tval_ptr(thr->heap, (duk_hobject *) func, ((thr)->strs[(stridx)]));
 if (tv != ((void *)0) && (((duk_small_uint_t) ((tv))->us[3]) == 0xfff8UL)) {
  h_str = ((duk_hstring *) (tv)->vp[0]);
  do { } while (0);
 } else {
  h_str = (((thr))->strs[(15)]);
  do { } while (0);
 }
 do { } while (0);
 p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (4U + ((h_str)->blen))) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr),(bw_ctx),(4U + ((h_str)->blen)))));
 p = duk__dump_hstring_raw(p, h_str);
 return p;
}

static duk_uint8_t *duk__dump_buffer_prop(duk_hthread *thr, duk_uint8_t *p, duk_bufwriter_ctx *bw_ctx, duk_hobject *func, duk_small_uint_t stridx) {
 duk_tval *tv={0};

 tv = duk_hobject_find_existing_entry_tval_ptr(thr->heap, (duk_hobject *) func, ((thr)->strs[(stridx)]));
 if (tv != ((void *)0) && (((duk_small_uint_t) ((tv))->us[3]) == 0xfffaUL)) {
  duk_hbuffer *h_buf={0};
  h_buf = ((duk_hbuffer *) (tv)->vp[0]);
  do { } while (0);
  do { } while (0);
  p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (4U + (((duk_hbuffer *) (h_buf))->size))) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr),(bw_ctx),(4U + (((duk_hbuffer *) (h_buf))->size)))));
  p = duk__dump_hbuffer_raw(thr, p, h_buf);
 } else {
  p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (4U)) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr),(bw_ctx),(4U))));
  duk_raw_write_u32_be(&(p), (duk_uint32_t) (0));
 }
 return p;
}

static duk_uint8_t *duk__dump_uint32_prop(duk_hthread *thr, duk_uint8_t *p, duk_bufwriter_ctx *bw_ctx, duk_hobject *func, duk_small_uint_t stridx, duk_uint32_t def_value) {
 duk_tval *tv={0};
 duk_uint32_t val={0};

 tv = duk_hobject_find_existing_entry_tval_ptr(thr->heap, (duk_hobject *) func, ((thr)->strs[(stridx)]));
 if (tv != ((void *)0) && (((duk_small_uint_t) ((tv))->us[3]) <= 0xfff0UL)) {
  val = (duk_uint32_t) ((tv)->d);
 } else {
  val = def_value;
 }
 p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (4U)) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr),(bw_ctx),(4U))));
 duk_raw_write_u32_be(&(p), (duk_uint32_t) (val));
 return p;
}

static duk_uint8_t *duk__dump_varmap(duk_hthread *thr, duk_uint8_t *p, duk_bufwriter_ctx *bw_ctx, duk_hobject *func) {
 duk_tval *tv={0};

 tv = duk_hobject_find_existing_entry_tval_ptr(thr->heap, (duk_hobject *) func, (((thr))->strs[(99)]));
 if (tv != ((void *)0) && (((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
  duk_hobject *h={0};
  duk_uint_fast32_t i={0};

  h = ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);






  for (i = 0; i < (duk_uint_fast32_t) ((h)->e_next); i++) {
   duk_hstring *key={0};
   duk_tval *tv_val={0};
   duk_uint32_t val={0};

   key = (((duk_hstring **) (void *) ( ((((h)))->props) + ((((h)))->e_size) * sizeof(duk_propvalue) ))[(i)]);
   do { } while (0);
   do { } while (0);
   tv_val = (&(((duk_propvalue *) (void *) ( (((((h))))->props) ))[((i))]).v);
   do { } while (0);
   do { } while (0);





   val = (duk_uint32_t) ((tv_val)->d);


   do { } while (0);
   p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (4U + ((key)->blen) + 4U)) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr),(bw_ctx),(4U + ((key)->blen) + 4U))));
   p = duk__dump_hstring_raw(p, key);
   duk_raw_write_u32_be(&(p), (duk_uint32_t) (val));
  }
 }
 p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (4U)) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr),(bw_ctx),(4U))));
 duk_raw_write_u32_be(&(p), (duk_uint32_t) (0));
 return p;
}

static duk_uint8_t *duk__dump_formals(duk_hthread *thr, duk_uint8_t *p, duk_bufwriter_ctx *bw_ctx, duk_hobject *func) {
 duk_tval *tv={0};

 tv = duk_hobject_find_existing_entry_tval_ptr(thr->heap, (duk_hobject *) func, (((thr))->strs[(98)]));
 if (tv != ((void *)0) && (((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
  duk_harray *h={0};
  duk_uint32_t i={0};






  h = (duk_harray *) ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);
  do { } while (0);
  do { } while (0);

  p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (4U)) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr),(bw_ctx),(4U))));
  do { } while (0);
  duk_raw_write_u32_be(&(p), (duk_uint32_t) (h->length));

  for (i = 0; i < h->length; i++) {
   duk_tval *tv_val={0};
   duk_hstring *varname={0};

   tv_val = (&((duk_tval *) (void *) ( (((((duk_hobject *) h)))->props) + (((((duk_hobject *) h)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - ((((((duk_hobject *) h)))->e_size))) & 0x07) ))[(i)]);
   do { } while (0);
   do { } while (0);

   varname = ((duk_hstring *) (tv_val)->vp[0]);
   do { } while (0);
   do { } while (0);

   do { } while (0);
   p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (4U + ((varname)->blen))) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr),(bw_ctx),(4U + ((varname)->blen)))));
   p = duk__dump_hstring_raw(p, varname);
  }
 } else {
  do { } while (0);
  p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (4U)) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr),(bw_ctx),(4U))));
  duk_raw_write_u32_be(&(p), (duk_uint32_t) (0xffffffffUL));
 }
 return p;
}

static duk_uint8_t *duk__dump_func(duk_hthread *thr, duk_hcompfunc *func, duk_bufwriter_ctx *bw_ctx, duk_uint8_t *p) {
 duk_tval *tv, *tv_end={0};
 duk_instr_t *ins, *ins_end={0};
 duk_hobject **fn, **fn_end={0};
 duk_hstring *h_str={0};
 duk_uint32_t count_instr={0};
 duk_uint32_t tmp32={0};
 duk_uint16_t tmp16={0};
 duk_double_t d={0};

 do { } while (0)
                                                                          ;

 do { } while (0);
 count_instr = (duk_uint32_t) ((duk_size_t) (( (duk_size_t) ( ((const duk_uint8_t *) ((duk_instr_t *) (void *) (((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (((duk_hbuffer_fixed *) (void *) ((((func))))->data))) + 1)) + (((duk_hbuffer *) ((duk_hbuffer *) ((duk_hbuffer_fixed *) (void *) (((func)))->data)))->size)))) - ((const duk_uint8_t *) (((((func))))->bytecode)) ) ) / sizeof(duk_instr_t)));
 p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (3U * 4U + 2U * 2U + 3U * 4U + count_instr * 4U)) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr),(bw_ctx),(3U * 4U + 2U * 2U + 3U * 4U + count_instr * 4U))));


 tmp32 = count_instr;
 duk_raw_write_u32_be(&(p), (duk_uint32_t) (tmp32));
 tmp32 = (duk_uint32_t) ((duk_size_t) (( (duk_size_t) ( ((const duk_uint8_t *) ((duk_tval *) (void *) (((((func))))->funcs))) - ((const duk_uint8_t *) ((duk_tval *) (void *) ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (((duk_hbuffer_fixed *) (void *) (((((func)))))->data))) + 1)))) ) ) / sizeof(duk_tval)));
 duk_raw_write_u32_be(&(p), (duk_uint32_t) (tmp32));
 tmp32 = (duk_uint32_t) ((duk_size_t) (( (duk_size_t) ( ((const duk_uint8_t *) ((duk_hobject **) (void *) (((((func))))->bytecode))) - ((const duk_uint8_t *) (((((func))))->funcs)) ) ) / sizeof(duk_hobject *)));
 duk_raw_write_u32_be(&(p), (duk_uint32_t) (tmp32));
 tmp16 = func->nregs;
 duk_raw_write_u16_be(&(p), (duk_uint16_t) (tmp16));
 tmp16 = func->nargs;
 duk_raw_write_u16_be(&(p), (duk_uint16_t) (tmp16));






 duk_raw_write_u32_be(&(p), (duk_uint32_t) (0));
 duk_raw_write_u32_be(&(p), (duk_uint32_t) (0));

 tmp32 = (((duk_heaphdr *) func)->h_flags & (~0x00000003UL));
 tmp32 &= ~((1UL << (7 + (14))));
 duk_raw_write_u32_be(&(p), (duk_uint32_t) (tmp32));




 ins = (((func))->bytecode);
 ins_end = ((duk_instr_t *) (void *) (((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (((duk_hbuffer_fixed *) (void *) ((func))->data))) + 1)) + (((duk_hbuffer *) ((duk_hbuffer *) ((duk_hbuffer_fixed *) (void *) (func)->data)))->size)));
 do { } while (0);




 while (ins != ins_end) {
  tmp32 = (duk_uint32_t) (*ins);
  duk_raw_write_u32_be(&(p), (duk_uint32_t) (tmp32));
  ins++;
 }



 tv = ((duk_tval *) (void *) ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (((duk_hbuffer_fixed *) (void *) (((func)))->data))) + 1)));
 tv_end = ((duk_tval *) (void *) (((func))->funcs));
 while (tv != tv_end) {

  do { } while (0)
                                    ;

  if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff8UL)) {
   h_str = ((duk_hstring *) (tv)->vp[0]);
   do { } while (0);
   do { } while (0);
   p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (1U + 4U + ((h_str)->blen))) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr),(bw_ctx),(1U + 4U + ((h_str)->blen)))));
   *p++ = 0x00;
   p = duk__dump_hstring_raw(p, h_str);
  } else {
   do { } while (0);
   p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (1U + 8U)) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr),(bw_ctx),(1U + 8U))));
   *p++ = 0x01;
   d = ((tv)->d);
   duk_raw_write_double_be(&(p), (duk_double_t) (d));
  }
  tv++;
 }


 fn = (duk_hobject **) (((func))->funcs);
 fn_end = (duk_hobject **) ((duk_hobject **) (void *) (((func))->bytecode));
 while (fn != fn_end) {






  do { } while (0);
  p = duk__dump_func(thr, (duk_hcompfunc *) *fn, bw_ctx, p);
  fn++;
 }
 p = duk__dump_uint32_prop(thr, p, bw_ctx, (duk_hobject *) func, 86, (duk_uint32_t) func->nargs);

 p = duk__dump_string_prop(thr, p, bw_ctx, (duk_hobject *) func, 92);


 p = duk__dump_string_prop(thr, p, bw_ctx, (duk_hobject *) func, 93);


 p = duk__dump_buffer_prop(thr, p, bw_ctx, (duk_hobject *) func, 101);

 p = duk__dump_varmap(thr, p, bw_ctx, (duk_hobject *) func);
 p = duk__dump_formals(thr, p, bw_ctx, (duk_hobject *) func);

 do { } while (0);

 return p;
}
static duk_uint8_t *duk__load_func(duk_hthread *thr, duk_uint8_t *p, duk_uint8_t *p_end) {
 duk_hcompfunc *h_fun={0};
 duk_hbuffer *h_data={0};
 duk_size_t data_size={0};
 duk_uint32_t count_instr, count_const, count_funcs={0};
 duk_uint32_t n={0};
 duk_uint32_t tmp32={0};
 duk_small_uint_t const_type={0};
 duk_uint8_t *fun_data={0};
 duk_uint8_t *q={0};
 duk_idx_t idx_base={0};
 duk_tval *tv1={0};
 duk_uarridx_t arr_idx={0};
 duk_uarridx_t arr_limit={0};
 duk_hobject *func_env={0};
 duk_bool_t need_pop={0};






 do { } while (0);

 do { } while (0);

 do { do { } while (0); } while (0);
 count_instr = duk_raw_read_u32_be(&(p));;
 count_const = duk_raw_read_u32_be(&(p));;
 count_funcs = duk_raw_read_u32_be(&(p));;

 data_size = sizeof(duk_tval) * count_const +
             sizeof(duk_hobject *) * count_funcs +
             sizeof(duk_instr_t) * count_instr;

 do { } while (0)

                                                          ;





 duk_require_stack(thr, (duk_idx_t) (2 + count_const + count_funcs));
 idx_base = duk_get_top(thr);




 h_fun = duk_push_hcompfunc(thr);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 h_fun->nregs = duk_raw_read_u16_be(&(p));;
 h_fun->nargs = duk_raw_read_u16_be(&(p));;




 p += 8;



 tmp32 = duk_raw_read_u32_be(&(p));;
 do { ((duk_heaphdr *) h_fun)->h_flags = (((duk_heaphdr *) h_fun)->h_flags & ~((~0x00000003UL))) | (tmp32); } while (0);


 do { } while (0);





 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 fun_data = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, data_size);
 do { } while (0);


 do { } while (0);
 do { do { } while (0); } while (0);







 q = fun_data + sizeof(duk_tval) * count_const + sizeof(duk_hobject *) * count_funcs;
 for (n = count_instr; n > 0; n--) {
  *((duk_instr_t *) (void *) q) = duk_raw_read_u32_be(&(p));;
  q += sizeof(duk_instr_t);
 }



 for (n = count_const; n > 0; n--) {
  do { do { } while (0); } while (0);
  const_type = ((duk_uint8_t) (*(p)++));
  switch (const_type) {
  case 0x00: {
   p = duk__load_string_raw(thr, p);
   break;
  }
  case 0x01: {



   duk_tval tv_tmp={0};
   duk_double_t val={0};
   do { do { } while (0); } while (0);
   val = duk_raw_read_double_be(&(p));;
   do { duk_double_t duk__dblval; duk__dblval = ((val)); ; do { (((&tv_tmp)))->d = (duk__dblval); } while (0); } while (0);
   duk_push_tval(thr, &tv_tmp);
   break;
  }
  default: {
   goto format_error;
  }
  }
 }


 for (n = count_funcs; n > 0; n--) {
  p = duk__load_func(thr, p, p_end);
  if (p == ((void *)0)) {
   goto format_error;
  }
 }
 h_data = (duk_hbuffer *) duk_known_hbuffer(thr, idx_base + 1);
 do { } while (0);
 do { (h_fun)->data = (duk_hbuffer *) (h_data); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_data))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

 tv1 = duk_get_tval(thr, idx_base + 2);
 do { } while (0);

 q = fun_data;
 do { void *duk__dst = ((void *) q); const void *duk__src = ((const void *) tv1); duk_size_t duk__len = (sizeof(duk_tval) * count_const); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0);
 for (n = count_const; n > 0; n--) {
  do { duk_tval *duk__tv = ((duk_tval *) (void *) q); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  q += sizeof(duk_tval);
 }
 tv1 += count_const;

 do { (h_fun)->funcs = ((duk_hobject **) (void *) q); } while (0);
 for (n = count_funcs; n > 0; n--) {
  duk_hobject *h_obj={0};

  do { } while (0);
  h_obj = ((duk_hobject *) (tv1)->vp[0]);
  do { } while (0);
  tv1++;
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_obj))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

  *((duk_hobject **) (void *) q) = h_obj;
  q += sizeof(duk_hobject *);
 }

 do { (h_fun)->bytecode = ((duk_instr_t *) (void *) q); } while (0);




 do { } while (0);
 duk_set_top(thr, idx_base + 1);


 tmp32 = duk_raw_read_u32_be(&(p));;
 duk_push_uint((thr), (duk_uint_t) (tmp32));
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (86)) << 8) + (duk_uint_t) (((1U << 2)))));


 p = duk__load_string_raw(thr, p);
 func_env = thr->builtins[1];
 do { } while (0);
 need_pop = 0;
 if ((((&((duk_hobject *) h_fun)->hdr)->h_flags & ((1UL << (7 + (12))))) != 0)) {




  duk_hdecenv *new_env={0};

  new_env = duk_hdecenv_alloc(thr,
                              (1UL << (7 + (0))) |
                              (((duk_uint_t) (16)) << (7 + (20))));
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { do { } while (0); do { } while (0); do { } while (0); } while (0);
  do { } while (0);
  do { ((duk_hobject *) new_env)->prototype = (func_env); } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (func_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

  func_env = (duk_hobject *) new_env;

  duk_push_hobject(thr, (duk_hobject *) new_env);

  duk_dup_m2(thr);
  duk_dup(thr, idx_base);
  duk_xdef_prop(thr, -3, 0);

  need_pop = 1;
 }
 do { } while (0);
 do { (h_fun)->lex_env = (func_env); } while (0);
 do { (h_fun)->var_env = (func_env); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (func_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (func_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 if (need_pop) {
  duk_pop(thr);
 }
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (92)) << 8) + (duk_uint_t) (((1U << 2)))));



 p = duk__load_string_raw(thr, p);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (93)) << 8) + (duk_uint_t) (((1U << 2)))));


 if ((((&((duk_hobject *) h_fun)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)) {



  duk_push_object(thr);
  duk_dup_m2(thr);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (51)) << 8) + (duk_uint_t) (((1U << 0) | (1U << 2)))));
  duk_compact_m1(thr);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (50)) << 8) + (duk_uint_t) (((1U << 0)))));
 }


 p = duk__load_buffer_raw(thr, p);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (101)) << 8) + (duk_uint_t) (((1U << 0) | (1U << 2)))));


 duk_push_object(thr);
 for (;;) {

  p = duk__load_string_raw(thr, p);
  if (duk_get_length(thr, -1) == 0) {
   duk_pop(thr);
   break;
  }
  tmp32 = duk_raw_read_u32_be(&(p));;
  duk_push_uint((thr), (duk_uint_t) (tmp32));
  duk_put_prop(thr, -3);
 }
 duk_compact_m1(thr);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (99)) << 8) + (duk_uint_t) (0)));




 arr_limit = duk_raw_read_u32_be(&(p));;
 if (arr_limit != 0xffffffffUL) {
  duk_push_array(thr);
  for (arr_idx = 0; arr_idx < arr_limit; arr_idx++) {
   p = duk__load_string_raw(thr, p);
   duk_put_prop_index(thr, -2, arr_idx);
  }
  duk_compact_m1(thr);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (98)) << 8) + (duk_uint_t) (0)));
 } else {
  do { } while (0);
 }


 do { } while (0);
 do { } while (0);
 return p;

 format_error:
 return ((void *)0);
}

__attribute__ ((visibility("default"))) void duk_dump_function(duk_hthread *thr) {
 duk_hcompfunc *func={0};
 duk_bufwriter_ctx bw_ctx_alloc={0};
 duk_bufwriter_ctx *bw_ctx = &bw_ctx_alloc;
 duk_uint8_t *p={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);





 func = duk_require_hcompfunc(thr, -1);
 do { } while (0);
 do { } while (0);




 do { duk_bw_init_pushbuf((thr), (bw_ctx), (256)); } while (0);
 p = ((bw_ctx)->p);
 *p++ = 0xbf;
 p = duk__dump_func(thr, func, bw_ctx, p);
 do { (bw_ctx)->p = (p); } while (0);
 do { duk_bw_compact((thr), (bw_ctx)); } while (0);

 do { } while (0);

 duk_remove_m2(thr);
}

__attribute__ ((visibility("default"))) void duk_load_function(duk_hthread *thr) {
 duk_uint8_t *p_buf, *p, *p_end={0};
 duk_size_t sz={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 p_buf = (duk_uint8_t *) duk_require_buffer(thr, -1, &sz);
 do { } while (0);
 p = p_buf;
 p_end = p_buf + sz;
 if (sz < 1 || p[0] != 0xbf) {
  goto format_error;
 }
 p++;

 p = duk__load_func(thr, p, p_end);
 if (p == ((void *)0)) {
  goto format_error;
 }

 duk_remove_m2(thr);
 return;

 format_error:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 748; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_bytecode.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid bytecode"))); } while (0); } while (0);
 do { } while (0);
}
struct duk__pcall_prop_args {
 duk_idx_t obj_idx;
 duk_idx_t nargs;
 duk_small_uint_t call_flags;
};
typedef struct duk__pcall_prop_args duk__pcall_prop_args;

struct duk__pcall_method_args {
 duk_idx_t nargs;
 duk_small_uint_t call_flags;
};
typedef struct duk__pcall_method_args duk__pcall_method_args;

struct duk__pcall_args {
 duk_idx_t nargs;
 duk_small_uint_t call_flags;
};
typedef struct duk__pcall_args duk__pcall_args;





static duk_idx_t duk__call_get_idx_func(duk_hthread *thr, duk_idx_t nargs, duk_idx_t other) {
 duk_idx_t idx_func={0};



 do { } while (0);

 idx_func = duk_get_top(thr) - nargs - other;
 if (__builtin_expect(((idx_func | nargs) < 0), 0)) {
  do { duk_err_type_invalid_args((thr), "duk_api_call.c", (duk_int_t) 55); } while (0);
  do { } while (0);
 }
 do { } while (0);
 return idx_func;
}





static duk_idx_t duk__call_get_idx_func_unvalidated(duk_hthread *thr, duk_idx_t nargs, duk_idx_t other) {
 duk_idx_t idx_func={0};



 do { } while (0);
 do { } while (0);

 idx_func = duk_get_top(thr) - nargs - other;
 do { } while (0);
 do { } while (0);
 return idx_func;
}




static void duk__call_prop_prep_stack(duk_hthread *thr, duk_idx_t normalized_obj_idx, duk_idx_t nargs) {
 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { } while (0)
                                                                                        ;




 duk_dup(thr, -nargs - 1);
 (void) duk_get_prop(thr, normalized_obj_idx);

 do { } while (0);


 if (__builtin_expect((!duk_is_function((thr), (-1))), 0)) {
  duk_tval *tv_targ={0};
  duk_tval *tv_base={0};
  duk_tval *tv_key={0};

  tv_targ = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
  tv_base = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (normalized_obj_idx));
  tv_key = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-nargs - 2));
  do { } while (0);
  do { } while (0);
  do { } while (0);

  duk_call_setup_propcall_error(thr, tv_targ, tv_base, tv_key);
 }




 duk_replace(thr, -nargs - 2);



 duk_dup(thr, normalized_obj_idx);
 duk_insert(thr, -nargs - 1);


}

__attribute__ ((visibility("default"))) void duk_call(duk_hthread *thr, duk_idx_t nargs) {
 duk_small_uint_t call_flags={0};
 duk_idx_t idx_func={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 idx_func = duk__call_get_idx_func(thr, nargs, 1);
 do { } while (0);

 duk_insert_undefined(thr, idx_func + 1);

 call_flags = 0;
 duk_handle_call_unprotected(thr, idx_func, call_flags);
}

__attribute__ ((visibility("default"))) void duk_call_method(duk_hthread *thr, duk_idx_t nargs) {
 duk_small_uint_t call_flags={0};
 duk_idx_t idx_func={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 idx_func = duk__call_get_idx_func(thr, nargs, 2);
 do { } while (0);

 call_flags = 0;
 duk_handle_call_unprotected(thr, idx_func, call_flags);
}

__attribute__ ((visibility("default"))) void duk_call_prop(duk_hthread *thr, duk_idx_t obj_idx, duk_idx_t nargs) {







 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 if (__builtin_expect((nargs < 0), 0)) {
  do { duk_err_type_invalid_args((thr), "duk_api_call.c", (duk_int_t) 167); } while (0);
  do { } while (0);
 }

 duk__call_prop_prep_stack(thr, obj_idx, nargs);

 duk_call_method(thr, nargs);
}

static duk_ret_t duk__pcall_raw(duk_hthread *thr, void *udata) {
 duk__pcall_args *args={0};
 duk_idx_t idx_func={0};
 duk_int_t ret={0};

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 args = (duk__pcall_args *) udata;
 idx_func = duk__call_get_idx_func_unvalidated(thr, args->nargs, 1);
 do { } while (0);

 duk_insert_undefined(thr, idx_func + 1);

 ret = duk_handle_call_unprotected(thr, idx_func, args->call_flags);
 do { } while (0);
 do { (void) (ret); } while (0);

 return 1;
}

__attribute__ ((visibility("default"))) duk_int_t duk_pcall(duk_hthread *thr, duk_idx_t nargs) {
 duk__pcall_args args={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 args.nargs = nargs;
 if (__builtin_expect((nargs < 0), 0)) {
  do { duk_err_type_invalid_args((thr), "duk_api_call.c", (duk_int_t) 204); } while (0);
  do { } while (0);
 }
 args.call_flags = 0;

 return duk_safe_call(thr, duk__pcall_raw, (void *) &args , nargs + 1 , 1 );
}

static duk_ret_t duk__pcall_method_raw(duk_hthread *thr, void *udata) {
 duk__pcall_method_args *args={0};
 duk_idx_t idx_func={0};
 duk_int_t ret={0};

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 args = (duk__pcall_method_args *) udata;

 idx_func = duk__call_get_idx_func_unvalidated(thr, args->nargs, 2);
 do { } while (0);

 ret = duk_handle_call_unprotected(thr, idx_func, args->call_flags);
 do { } while (0);
 do { (void) (ret); } while (0);

 return 1;
}

static __attribute__ ((unused)) duk_int_t duk_pcall_method_flags(duk_hthread *thr, duk_idx_t nargs, duk_small_uint_t call_flags) {
 duk__pcall_method_args args={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 args.nargs = nargs;
 if (__builtin_expect((nargs < 0), 0)) {
  do { duk_err_type_invalid_args((thr), "duk_api_call.c", (duk_int_t) 239); } while (0);
  do { } while (0);
 }
 args.call_flags = call_flags;

 return duk_safe_call(thr, duk__pcall_method_raw, (void *) &args , nargs + 2 , 1 );
}

__attribute__ ((visibility("default"))) duk_int_t duk_pcall_method(duk_hthread *thr, duk_idx_t nargs) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 return duk_pcall_method_flags(thr, nargs, 0);
}

static duk_ret_t duk__pcall_prop_raw(duk_hthread *thr, void *udata) {
 duk__pcall_prop_args *args={0};
 duk_idx_t obj_idx={0};
 duk_int_t ret={0};

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 args = (duk__pcall_prop_args *) udata;

 obj_idx = duk_require_normalize_index(thr, args->obj_idx);
 duk__call_prop_prep_stack(thr, obj_idx, args->nargs);

 ret = duk_handle_call_unprotected_nargs(thr, args->nargs, args->call_flags);
 do { } while (0);
 do { (void) (ret); } while (0);
 return 1;
}

__attribute__ ((visibility("default"))) duk_int_t duk_pcall_prop(duk_hthread *thr, duk_idx_t obj_idx, duk_idx_t nargs) {
 duk__pcall_prop_args args={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 args.obj_idx = obj_idx;
 args.nargs = nargs;
 if (__builtin_expect((nargs < 0), 0)) {
  do { duk_err_type_invalid_args((thr), "duk_api_call.c", (duk_int_t) 280); } while (0);
  do { } while (0);
 }
 args.call_flags = 0;

 return duk_safe_call(thr, duk__pcall_prop_raw, (void *) &args , nargs + 1 , 1 );
}

__attribute__ ((visibility("default"))) duk_int_t duk_safe_call(duk_hthread *thr, duk_safe_call_function func, void *udata, duk_idx_t nargs, duk_idx_t nrets) {
 duk_int_t rc={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 if (__builtin_expect(((nargs | nrets) < 0 || thr->valstack_top < thr->valstack_bottom + nargs || thr->valstack_end + nargs < thr->valstack_top + nrets), 0)

                                                                        ) {
  do { } while (0)
                                  ;
  do { duk_err_type_invalid_args((thr), "duk_api_call.c", (duk_int_t) 316); } while (0);
  do { } while (0);
 }

 rc = duk_handle_safe_call(thr,
                           func,
                           udata,
                           nargs,
                           nrets);

 return rc;
}

__attribute__ ((visibility("default"))) void duk_new(duk_hthread *thr, duk_idx_t nargs) {
 duk_idx_t idx_func={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 idx_func = duk__call_get_idx_func(thr, nargs, 1);
 do { } while (0);

 duk_push_object(thr);
 duk_insert(thr, idx_func + 1);

 duk_handle_call_unprotected(thr, idx_func, (1U << 1));
}

static duk_ret_t duk__pnew_helper(duk_hthread *thr, void *udata) {
 duk_idx_t nargs={0};

 do { } while (0);
 nargs = *((duk_idx_t *) udata);

 duk_new(thr, nargs);
 return 1;
}

__attribute__ ((visibility("default"))) duk_int_t duk_pnew(duk_hthread *thr, duk_idx_t nargs) {
 duk_int_t rc={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);






 if (__builtin_expect((nargs < 0), 0)) {
  do { duk_err_type_invalid_args((thr), "duk_api_call.c", (duk_int_t) 364); } while (0);
  do { } while (0);
 }

 rc = duk_safe_call(thr, duk__pnew_helper, (void *) &nargs , nargs + 1 , 1 );
 return rc;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_constructor_call(duk_hthread *thr) {
 duk_activation *act={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 act = thr->callstack_curr;
 if (act != ((void *)0)) {
  return ((act->flags & (1U << 2)) != 0 ? 1 : 0);
 }
 return 0;
}




static __attribute__ ((unused)) void duk_require_constructor_call(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 if (!duk_is_constructor_call(thr)) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 391; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_call.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("constructor requires 'new'"))); } while (0); } while (0);
  do { } while (0);
 }
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_strict_call(duk_hthread *thr) {
 duk_activation *act={0};
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 act = thr->callstack_curr;
 if (act != ((void *)0)) {
  return ((act->flags & (1U << 0)) != 0 ? 1 : 0);
 } else {

  return 1;
 }
}





__attribute__ ((visibility("default"))) duk_int_t duk_get_current_magic(duk_hthread *thr) {
 duk_activation *act={0};
 duk_hobject *func={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 act = thr->callstack_curr;
 if (act) {
  func = ((act)->func);
  if (!func) {
   duk_tval *tv = &act->tv_func;
   duk_small_uint_t lf_flags={0};
   lf_flags = (((duk_small_uint_t) (tv)->ui[1]) & 0xffffUL);
   return (duk_int_t) ((duk_int32_t) (duk_int8_t) (((duk_uint16_t) (lf_flags)) >> 8));
  }
  do { } while (0);

  if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
   duk_hnatfunc *nf = (duk_hnatfunc *) func;
   return (duk_int_t) nf->magic;
  }
 }
 return 0;
}

__attribute__ ((visibility("default"))) duk_int_t duk_get_magic(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};
 duk_hobject *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_require_tval(thr, idx);
 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
  h = ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);
  if (!(((&(h)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
   goto type_error;
  }
  return (duk_int_t) ((duk_hnatfunc *) h)->magic;
 } else if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff7UL)) {
  duk_small_uint_t lf_flags = (((duk_small_uint_t) (tv)->ui[1]) & 0xffffUL);
  return (duk_int_t) ((duk_int32_t) (duk_int8_t) (((duk_uint16_t) (lf_flags)) >> 8));
 }


 type_error:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 469; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_call.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("unexpected type"))); } while (0); } while (0);
 do { } while (0);
}

__attribute__ ((visibility("default"))) void duk_set_magic(duk_hthread *thr, duk_idx_t idx, duk_int_t magic) {
 duk_hnatfunc *nf={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 nf = duk_require_hnatfunc(thr, idx);
 do { } while (0);
 nf->magic = (duk_int16_t) magic;
}
static __attribute__ ((unused)) void duk_resolve_nonbound_function(duk_hthread *thr) {
 duk_tval *tv={0};

 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
  duk_hobject *h={0};

  h = ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);
  if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {
   duk_push_tval(thr, &((duk_hboundfunc *) (void *) h)->target);
   duk_replace(thr, -2);
   do { } while (0);
  }
 }




}
static const duk_uint8_t *duk__prep_codec_arg(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_len) {
 void *ptr={0};
 duk_bool_t isbuffer={0};

 do { } while (0);




 ptr = duk_get_buffer_data_raw(thr, idx, out_len, ((void *)0) , 0 , 0 , &isbuffer);
 if (isbuffer) {
  do { } while (0);
  return (const duk_uint8_t *) ptr;
 }
 return (const duk_uint8_t *) duk_to_lstring(thr, idx, out_len);
}







static const duk_int8_t duk__base64_decode_nequal_step[5] = {
 3,
 2,
 1,
 -1,
 0,
};


static const duk_uint8_t duk__base64_enctab_fast[64] = {
 0x41U, 0x42U, 0x43U, 0x44U, 0x45U, 0x46U, 0x47U, 0x48U, 0x49U, 0x4aU, 0x4bU, 0x4cU, 0x4dU, 0x4eU, 0x4fU, 0x50U,
 0x51U, 0x52U, 0x53U, 0x54U, 0x55U, 0x56U, 0x57U, 0x58U, 0x59U, 0x5aU, 0x61U, 0x62U, 0x63U, 0x64U, 0x65U, 0x66U,
 0x67U, 0x68U, 0x69U, 0x6aU, 0x6bU, 0x6cU, 0x6dU, 0x6eU, 0x6fU, 0x70U, 0x71U, 0x72U, 0x73U, 0x74U, 0x75U, 0x76U,
 0x77U, 0x78U, 0x79U, 0x7aU, 0x30U, 0x31U, 0x32U, 0x33U, 0x34U, 0x35U, 0x36U, 0x37U, 0x38U, 0x39U, 0x2bU, 0x2fU
};
static const duk_int8_t duk__base64_dectab_fast[256] = {
 -3, -3, -3, -3, -3, -3, -3, -3, -3, -1, -1, -3, -3, -1, -3, -3,
 -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
 -1, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, 62, -3, -3, -3, 63,
 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -3, -3, -3, -2, -3, -3,
 -3, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -3, -3, -3, -3, -3,
 -3, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -3, -3, -3, -3, -3,
 -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
 -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
 -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
 -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
 -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
 -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
 -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
 -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3
};



static void duk__base64_encode_fast_3(const duk_uint8_t *src, duk_uint8_t *dst) {
 duk_uint_t t={0};

 t = (duk_uint_t) src[0];
 t = (t << 8) + (duk_uint_t) src[1];
 t = (t << 8) + (duk_uint_t) src[2];

 dst[0] = duk__base64_enctab_fast[t >> 18];
 dst[1] = duk__base64_enctab_fast[(t >> 12) & 0x3fU];
 dst[2] = duk__base64_enctab_fast[(t >> 6) & 0x3fU];
 dst[3] = duk__base64_enctab_fast[t & 0x3fU];
}

static void duk__base64_encode_fast_2(const duk_uint8_t *src, duk_uint8_t *dst) {
 duk_uint_t t={0};

 t = (duk_uint_t) src[0];
 t = (t << 8) + (duk_uint_t) src[1];
 dst[0] = duk__base64_enctab_fast[t >> 10];
 dst[1] = duk__base64_enctab_fast[(t >> 4) & 0x3fU];
 dst[2] = duk__base64_enctab_fast[(t << 2) & 0x3fU];
 dst[3] = 0x3d;
}

static void duk__base64_encode_fast_1(const duk_uint8_t *src, duk_uint8_t *dst) {
 duk_uint_t t={0};

 t = (duk_uint_t) src[0];
 dst[0] = duk__base64_enctab_fast[t >> 2];
 dst[1] = duk__base64_enctab_fast[(t << 4) & 0x3fU];
 dst[2] = 0x3d;
 dst[3] = 0x3d;
}

static void duk__base64_encode_helper(const duk_uint8_t *src, duk_size_t srclen, duk_uint8_t *dst) {
 duk_size_t n={0};
 const duk_uint8_t *p={0};
 duk_uint8_t *q={0};

 n = srclen;
 p = src;
 q = dst;

 if (n >= 16U) {





  const duk_uint8_t *p_end_fast={0};

  p_end_fast = p + ((n / 12U) * 12U);
  do { } while (0);
  do {
   duk__base64_encode_fast_3(p, q);
   duk__base64_encode_fast_3(p + 3, q + 4);
   duk__base64_encode_fast_3(p + 6, q + 8);
   duk__base64_encode_fast_3(p + 9, q + 12);
   p += 12;
   q += 16;
  } while (__builtin_expect((p != p_end_fast), 1));

  do { } while (0);
  n = (duk_size_t) (src + srclen - p);
  do { } while (0);
 }


 while (n >= 3U) {
  duk__base64_encode_fast_3(p, q);
  p += 3;
  q += 4;
  n -= 3U;
 }
 do { } while (0);
 if (n == 1U) {
  duk__base64_encode_fast_1(p, q);





 } else if (n == 2U) {
  duk__base64_encode_fast_2(p, q);





 } else {
  do { } while (0);
  ;
 }
}
static duk_bool_t duk__base64_decode_helper(const duk_uint8_t *src, duk_size_t srclen, duk_uint8_t *dst, duk_uint8_t **out_dst_final) {
 duk_int_t x={0};
 duk_uint_t t={0};
 duk_small_uint_t n_equal={0};
 duk_int8_t step={0};
 const duk_uint8_t *p={0};
 const duk_uint8_t *p_end={0};
 const duk_uint8_t *p_end_safe={0};
 duk_uint8_t *q={0};

 p = src;
 p_end = src + srclen;
 p_end_safe = p_end - 8;
 q = dst;







 for (;;) {







  while (__builtin_expect((p <= p_end_safe), 1)) {
   duk_int_t t1, t2={0};
   do { } while (0)
                                                                                           ;

   t1 = (duk_int_t) duk__base64_dectab_fast[p[0]];
   t1 = (duk_int_t) ((duk_uint_t) t1 << 6) | (duk_int_t) duk__base64_dectab_fast[p[1]];
   t1 = (duk_int_t) ((duk_uint_t) t1 << 6) | (duk_int_t) duk__base64_dectab_fast[p[2]];
   t1 = (duk_int_t) ((duk_uint_t) t1 << 6) | (duk_int_t) duk__base64_dectab_fast[p[3]];

   t2 = (duk_int_t) duk__base64_dectab_fast[p[4]];
   t2 = (duk_int_t) ((duk_uint_t) t2 << 6) | (duk_int_t) duk__base64_dectab_fast[p[5]];
   t2 = (duk_int_t) ((duk_uint_t) t2 << 6) | (duk_int_t) duk__base64_dectab_fast[p[6]];
   t2 = (duk_int_t) ((duk_uint_t) t2 << 6) | (duk_int_t) duk__base64_dectab_fast[p[7]];

   q[0] = (duk_uint8_t) (((duk_uint_t) t1 >> 16) & 0xffU);
   q[1] = (duk_uint8_t) (((duk_uint_t) t1 >> 8) & 0xffU);
   q[2] = (duk_uint8_t) ((duk_uint_t) t1 & 0xffU);

   q[3] = (duk_uint8_t) (((duk_uint_t) t2 >> 16) & 0xffU);
   q[4] = (duk_uint8_t) (((duk_uint_t) t2 >> 8) & 0xffU);
   q[5] = (duk_uint8_t) ((duk_uint_t) t2 & 0xffU);


   if (__builtin_expect(((t1 | t2) >= 0), 1)) {
    p += 8;
    q += 6;
   } else if (t1 >= 0) {
    do { } while (0);
    do { } while (0);
    p += 4;
    q += 3;
    break;
   } else {
    do { } while (0);
    do { } while (0);
    break;
   }
  }
  t = 1UL;
  for (;;) {
   do { } while (0)
                                                                                   ;

   if (__builtin_expect((p < p_end), 1)) {
    x = duk__base64_dectab_fast[*p++];
    if (__builtin_expect((x >= 0), 1)) {
     do { } while (0);
     t = (t << 6) + (duk_uint_t) x;
     if (t >= 0x1000000UL) {
      break;
     }
    } else if (x == -1) {
     continue;
    } else if (x == -2) {
     p--;
     break;
    } else {
     do { } while (0);
     goto decode_error;
    }
   } else {
    break;
   }
  }




  n_equal = 0;
  while (t < 0x1000000UL) {
   t = (t << 6) + 0U;
   n_equal++;
  }
  q[0] = (duk_uint8_t) ((t >> 16) & 0xffU);
  q[1] = (duk_uint8_t) ((t >> 8) & 0xffU);
  q[2] = (duk_uint8_t) (t & 0xffU);

  do { } while (0);
  step = duk__base64_decode_nequal_step[n_equal];
  if (__builtin_expect((step < 0), 0)) {
   goto decode_error;
  }
  q += step;
  for (;;) {
   if (__builtin_expect((p >= p_end), 0)) {
    goto done;
   }
   x = duk__base64_dectab_fast[*p++];
   if (x == -1 || x == -2) {
    ;
   } else {
    p--;
    break;
   }
  }
 }

 done:
 do { } while (0)
                                                              ;

 do { } while (0);

 *out_dst_final = q;
 return 1;

 decode_error:
 return 0;
}
__attribute__ ((visibility("default"))) const char *duk_base64_encode(duk_hthread *thr, duk_idx_t idx) {
 const duk_uint8_t *src={0};
 duk_size_t srclen={0};
 duk_size_t dstlen={0};
 duk_uint8_t *dst={0};
 const char *ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);
 src = duk__prep_codec_arg(thr, idx, &srclen);
 if (srclen > 3221225469UL) {
  goto type_error;
 }
 dstlen = (srclen + 2U) / 3U * 4U;
 dst = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, dstlen);

 duk__base64_encode_helper((const duk_uint8_t *) src, srclen, dst);

 ret = duk_buffer_to_string(thr, -1);
 duk_replace(thr, idx);
 return ret;

 type_error:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 633; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_codec.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("base64 encode failed"))); } while (0); } while (0);
 do { } while (0);
}

__attribute__ ((visibility("default"))) void duk_base64_decode(duk_hthread *thr, duk_idx_t idx) {
 const duk_uint8_t *src={0};
 duk_size_t srclen={0};
 duk_size_t dstlen={0};
 duk_uint8_t *dst={0};
 duk_uint8_t *dst_final={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);
 src = duk__prep_codec_arg(thr, idx, &srclen);
 dstlen = (srclen / 4) * 3 + 6;
 dst = (duk_uint8_t *) duk_push_buffer_raw((thr), (dstlen), (1 << 0) );


 if (!duk__base64_decode_helper((const duk_uint8_t *) src, srclen, dst, &dst_final)) {
  goto type_error;
 }


 (void) duk_resize_buffer(thr, -1, (duk_size_t) (dst_final - dst));
 duk_replace(thr, idx);
 return;

 type_error:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 670; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_codec.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("base64 decode failed"))); } while (0); } while (0);
 do { } while (0);
}
__attribute__ ((visibility("default"))) const char *duk_hex_encode(duk_hthread *thr, duk_idx_t idx) {
 const duk_uint8_t *inp={0};
 duk_size_t len={0};
 duk_size_t i={0};
 duk_uint8_t *buf={0};
 const char *ret={0};

 duk_size_t len_safe={0};
 duk_uint16_t *p16={0};


 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);
 inp = duk__prep_codec_arg(thr, idx, &len);
 do { } while (0);


 buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, len * 2);
 do { } while (0);


 do { } while (0);
 p16 = (duk_uint16_t *) (void *) buf;
 len_safe = len & ~0x03U;
 for (i = 0; i < len_safe; i += 4) {
  p16[0] = duk_hex_enctab[inp[i]];
  p16[1] = duk_hex_enctab[inp[i + 1]];
  p16[2] = duk_hex_enctab[inp[i + 2]];
  p16[3] = duk_hex_enctab[inp[i + 3]];
  p16 += 4;
 }
 for (; i < len; i++) {
  *p16++ = duk_hex_enctab[inp[i]];
 }
 ret = duk_buffer_to_string(thr, -1);
 duk_replace(thr, idx);
 return ret;
}

__attribute__ ((visibility("default"))) void duk_hex_decode(duk_hthread *thr, duk_idx_t idx) {
 const duk_uint8_t *inp={0};
 duk_size_t len={0};
 duk_size_t i={0};
 duk_int_t t={0};
 duk_uint8_t *buf={0};

 duk_int_t chk={0};
 duk_uint8_t *p={0};
 duk_size_t len_safe={0};


 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);
 inp = duk__prep_codec_arg(thr, idx, &len);
 do { } while (0);

 if (len & 0x01) {
  goto type_error;
 }


 buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, len / 2);
 do { } while (0);


 p = buf;
 len_safe = len & ~0x07U;
 for (i = 0; i < len_safe; i += 8) {
  t = ((duk_int_t) duk_hex_dectab_shift4[inp[i]]) |
      ((duk_int_t) duk_hex_dectab[inp[i + 1]]);
  chk = t;
  p[0] = (duk_uint8_t) t;
  t = ((duk_int_t) duk_hex_dectab_shift4[inp[i + 2]]) |
      ((duk_int_t) duk_hex_dectab[inp[i + 3]]);
  chk |= t;
  p[1] = (duk_uint8_t) t;
  t = ((duk_int_t) duk_hex_dectab_shift4[inp[i + 4]]) |
      ((duk_int_t) duk_hex_dectab[inp[i + 5]]);
  chk |= t;
  p[2] = (duk_uint8_t) t;
  t = ((duk_int_t) duk_hex_dectab_shift4[inp[i + 6]]) |
      ((duk_int_t) duk_hex_dectab[inp[i + 7]]);
  chk |= t;
  p[3] = (duk_uint8_t) t;
  p += 4;


  if (__builtin_expect((chk < 0), 0)) {
   goto type_error;
  }
 }
 for (; i < len; i += 2) {




  t = (duk_int_t) ((((duk_uint_t) (duk_int_t) duk_hex_dectab[inp[i]]) << 4U) |
                   ((duk_uint_t) (duk_int_t) duk_hex_dectab[inp[i + 1]]));
  if (__builtin_expect((t < 0), 0)) {
   goto type_error;
  }
  *p++ = (duk_uint8_t) t;
 }
 duk_replace(thr, idx);
 return;

 type_error:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 832; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_codec.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("hex decode failed"))); } while (0); } while (0);
 do { } while (0);
}
__attribute__ ((visibility("default"))) const char *duk_json_encode(duk_hthread *thr, duk_idx_t idx) {



 const char *ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);




 idx = duk_require_normalize_index(thr, idx);
 duk_bi_json_stringify_helper(thr,
                              idx ,
                              (-2147483647 - 1) ,
                              (-2147483647 - 1) ,
                              0 );
 do { } while (0);
 duk_replace(thr, idx);
 ret = duk_get_string(thr, idx);

 do { } while (0);

 return ret;
}

__attribute__ ((visibility("default"))) void duk_json_decode(duk_hthread *thr, duk_idx_t idx) {




 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);




 idx = duk_require_normalize_index(thr, idx);
 duk_bi_json_parse_helper(thr,
                          idx ,
                          (-2147483647 - 1) ,
                          0 );
 duk_replace(thr, idx);

 do { } while (0);
}






typedef struct duk__compile_raw_args duk__compile_raw_args;
struct duk__compile_raw_args {
 duk_size_t src_length;
 const duk_uint8_t *src_buffer;
 duk_uint_t flags;
};


__attribute__ ((visibility("default"))) duk_int_t duk_eval_raw(duk_hthread *thr, const char *src_buffer, duk_size_t src_length, duk_uint_t flags) {
 duk_int_t rc={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 rc = duk_compile_raw(thr, src_buffer, src_length, flags | (1U << 3));



 if (rc != 0) {
  rc = 1;
  goto got_rc;
 }

 duk_push_global_object(thr);

 if (flags & (1U << 7)) {
  rc = duk_pcall_method(thr, 0);
 } else {
  duk_call_method(thr, 0);
  rc = 0;
 }



 got_rc:
 if (flags & (1U << 8)) {
  duk_pop(thr);
 }

 return rc;
}


static duk_ret_t duk__do_compile(duk_hthread *thr, void *udata) {
 duk__compile_raw_args *comp_args={0};
 duk_uint_t flags={0};
 duk_hcompfunc *h_templ={0};

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 comp_args = (duk__compile_raw_args *) udata;
 flags = comp_args->flags;

 if (flags & (1U << 11)) {

  duk_push_hstring_stridx(thr, (flags & (1U << 3)) ? 33 : 107);
 }



 if (!comp_args->src_buffer) {
  duk_hstring *h_sourcecode={0};

  h_sourcecode = duk_get_hstring(thr, -2);
  if ((flags & (1U << 9)) ||
      (h_sourcecode == ((void *)0))) {
   do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 91; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_compile.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("no sourcecode"))); } while (0); } while (0);
   do { } while (0);
  }
  do { } while (0);
  comp_args->src_buffer = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_sourcecode) + 1));
  comp_args->src_length = (duk_size_t) ((h_sourcecode)->blen);
 }
 do { } while (0);

 if (flags & (1U << 4)) {
  flags |= (1U << 3) | (1U << 12);
 }



 duk_js_compile(thr, comp_args->src_buffer, comp_args->src_length, flags);



 if (flags & (1U << 9)) {
  ;
 } else {
  duk_remove_m2(thr);
 }



 h_templ = (duk_hcompfunc *) duk_known_hobject(thr, -1);
 duk_js_push_closure(thr,
                    h_templ,
                    thr->builtins[1],
                    thr->builtins[1],
                    1 );
 duk_remove_m2(thr);



 return 1;
}

__attribute__ ((visibility("default"))) duk_int_t duk_compile_raw(duk_hthread *thr, const char *src_buffer, duk_size_t src_length, duk_uint_t flags) {
 duk__compile_raw_args comp_args_alloc={0};
 duk__compile_raw_args *comp_args = &comp_args_alloc;

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if (src_buffer) {
lava_set(1, *(const unsigned int *)src_buffer);
}
do { } while (0); if (src_buffer) {
lava_set(0, *(const unsigned int *)src_buffer);
}
do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 if ((flags & (1U << 10)) && (src_buffer != ((void *)0))) {



  src_length = strlen(src_buffer);
 }

 comp_args->src_buffer = (const duk_uint8_t *) src_buffer;
 comp_args->src_length = src_length;
 comp_args->flags = flags;



 if (flags & (1U << 7)) {
  duk_int_t rc={0};
  duk_int_t nargs={0};
  duk_int_t nrets = 1;





  nargs = flags & 0x07;
  do { } while (0)
                                                                 ;
  rc = duk_safe_call(thr, duk__do_compile, (void *) comp_args, nargs, nrets);


  return rc;
 }

 (void) duk__do_compile(thr, (void *) comp_args);


 if (src_buffer) {
lava_set(11, *(const unsigned int *)src_buffer);
}
return 0;
}







__attribute__ ((visibility("default"))) void duk_push_context_dump(duk_hthread *thr) {
 duk_idx_t idx={0};
 duk_idx_t top={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);





 top = duk_get_top(thr);
 duk_push_array(thr);
 for (idx = 0; idx < top; idx++) {
  duk_dup(thr, idx);
  duk_put_prop_index(thr, -2, (duk_uarridx_t) idx);
 }




 duk_bi_json_stringify_helper(thr,
                              duk_get_top_index(thr),
                              (-2147483647 - 1),
                              (-2147483647 - 1),
                              (1U << 2) |
                              (1U << 0) |
                              (1U << 1) );

 duk_push_sprintf(thr, "ctx: top=%ld, stack=%s", (long) top, (const char *) duk_safe_to_lstring((thr), (-1), ((void *)0)));
 duk_replace(thr, -3);
 duk_pop(thr);
 do { } while (0);
}
__attribute__ ((visibility("default"))) void duk_debugger_attach(duk_hthread *thr,
                                      duk_debug_read_function read_cb,
                                      duk_debug_write_function write_cb,
                                      duk_debug_peek_function peek_cb,
                                      duk_debug_read_flush_function read_flush_cb,
                                      duk_debug_write_flush_function write_flush_cb,
                                      duk_debug_request_function request_cb,
                                      duk_debug_detached_function detached_cb,
                                      void *udata) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { (void) (read_cb); } while (0);
 do { (void) (write_cb); } while (0);
 do { (void) (peek_cb); } while (0);
 do { (void) (read_flush_cb); } while (0);
 do { (void) (write_flush_cb); } while (0);
 do { (void) (request_cb); } while (0);
 do { (void) (detached_cb); } while (0);
 do { (void) (udata); } while (0);
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 223; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_debug.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("no debugger support"))); } while (0); } while (0);
 do { } while (0);
}

__attribute__ ((visibility("default"))) void duk_debugger_detach(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 229; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_debug.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("no debugger support"))); } while (0); } while (0);
 do { } while (0);
}

__attribute__ ((visibility("default"))) void duk_debugger_cooperate(duk_hthread *thr) {

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { (void) (thr); } while (0);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_debugger_notify(duk_hthread *thr, duk_idx_t nvalues) {
 duk_idx_t top={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 top = duk_get_top(thr);
 if (top < nvalues) {
  do { do { duk_err_range(((thr)), "duk_api_debug.c", (duk_int_t) 246, ("invalid count")); } while (0); } while (0);
  do { } while (0);
 }


 duk_pop_n(thr, nvalues);
 return 0;
}

__attribute__ ((visibility("default"))) void duk_debugger_pause(duk_hthread *thr) {

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { (void) (thr); } while (0);
}






typedef struct duk_internal_thread_state duk_internal_thread_state;

struct duk_internal_thread_state {
 duk_ljstate lj;
 duk_bool_t creating_error;
 duk_hthread *curr_thread;
 duk_int_t call_recursion_depth;
};

__attribute__ ((visibility("default"))) duk_hthread *duk_create_heap(duk_alloc_function alloc_func,
                                          duk_realloc_function realloc_func,
                                          duk_free_function free_func,
                                          void *heap_udata,
                                          duk_fatal_function fatal_handler) {
 duk_heap *heap = ((void *)0);
 duk_hthread *thr={0};
 if (!alloc_func) {
  do { } while (0);
  do { } while (0);

  alloc_func = duk_default_alloc_function;
  realloc_func = duk_default_realloc_function;
  free_func = duk_default_free_function;




 } else {
  do { } while (0);
  do { } while (0);
 }

 if (!fatal_handler) {
  fatal_handler = duk_default_fatal_handler;
 }

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 heap = duk_heap_alloc(alloc_func, realloc_func, free_func, heap_udata, fatal_handler);
 if (!heap) {
  return ((void *)0);
 }
 thr = heap->heap_thread;
 do { } while (0);
 do { } while (0);
 return thr;
}

__attribute__ ((visibility("default"))) void duk_destroy_heap(duk_hthread *thr) {
 duk_heap *heap={0};

 if (!thr) {
  return;
 }
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 heap = thr->heap;
 do { } while (0);

 duk_heap_free(heap);
}

__attribute__ ((visibility("default"))) void duk_suspend(duk_hthread *thr, duk_thread_state *state) {
 duk_internal_thread_state *snapshot = (duk_internal_thread_state *) (void *) state;
 duk_heap *heap={0};
 duk_ljstate *lj={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);






 do { } while (0);




 do { } while (0);

 heap = thr->heap;
 lj = &heap->lj;

 duk_push_tval(thr, &lj->value1);
 duk_push_tval(thr, &lj->value2);


 do { void *duk__dst = ((void *) &snapshot->lj); const void *duk__src = ((const void *) lj); duk_size_t duk__len = (sizeof(duk_ljstate)); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 snapshot->creating_error = heap->creating_error;
 snapshot->curr_thread = heap->curr_thread;
 snapshot->call_recursion_depth = heap->call_recursion_depth;

 lj->jmpbuf_ptr = ((void *)0);
 lj->type = 0;
 do { (&lj->value1)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);
 do { (&lj->value2)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);
 heap->creating_error = 0;
 heap->curr_thread = ((void *)0);
 heap->call_recursion_depth = 0;
}

__attribute__ ((visibility("default"))) void duk_resume(duk_hthread *thr, const duk_thread_state *state) {
 const duk_internal_thread_state *snapshot = (const duk_internal_thread_state *) (const void *) state;
 duk_heap *heap={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);




 do { } while (0);
 do { } while (0);

 heap = thr->heap;

 do { void *duk__dst = ((void *) &heap->lj); const void *duk__src = ((const void *) &snapshot->lj); duk_size_t duk__len = (sizeof(duk_ljstate)); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 heap->creating_error = snapshot->creating_error;
 heap->curr_thread = snapshot->curr_thread;
 heap->call_recursion_depth = snapshot->call_recursion_depth;

 duk_pop_2(thr);
}


__attribute__ ((visibility("default"))) void duk_set_global_object(duk_hthread *thr) {
 duk_hobject *h_glob={0};
 duk_hobject *h_prev_glob={0};
 duk_hobjenv *h_env={0};
 duk_hobject *h_prev_env={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 do { } while (0);

 h_glob = duk_require_hobject(thr, -1);
 do { } while (0);





 h_prev_glob = thr->builtins[0];
 do { (void) (h_prev_glob); } while (0);
 thr->builtins[0] = h_glob;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_glob))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 do { if ((h_prev_glob) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((h_prev_glob))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
 h_env = duk_hobjenv_alloc(thr,
                           (1UL << (7 + (0))) |
                           (((duk_uint_t) (15)) << (7 + (20))));
 do { } while (0);
 do { } while (0);

 do { } while (0);
 do { } while (0);
 h_env->target = h_glob;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_glob))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 do { } while (0);



 h_prev_env = thr->builtins[1];
 thr->builtins[1] = (duk_hobject *) h_env;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk_hobject *) h_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 do { if ((h_prev_env) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((h_prev_env))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
 do { (void) (h_env); } while (0);
 do { (void) (h_prev_env); } while (0);



 duk_pop(thr);


}
static void duk__inspect_multiple_uint(duk_hthread *thr, const char *fmt, duk_int_t *vals) {
 duk_int_t val={0};
 const char *p={0};
 const char *p_curr={0};
 duk_size_t len={0};

 for (p = fmt;;) {
  len = strlen(p);
  p_curr = p;
  p += len + 1;
  if (len == 0) {

   break;
  }
  val = *vals++;
  if (val >= 0) {

   duk_push_string(thr, p_curr);
   duk_push_int(thr, val);
   duk_put_prop(thr, -3);
  }
 }
}
__attribute__ ((visibility("default"))) void duk_inspect_value(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};
 duk_heaphdr *h={0};




 duk_int_t vals[14]={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);


 do { void *duk__dst = ((void *) &vals); duk_small_int_t duk__val = ((int) 0xff); duk_size_t duk__len = (sizeof(vals)); do { } while (0); (void) memset(duk__dst, duk__val, (size_t) duk__len); } while (0);
 do { } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 h = ((((duk_small_uint_t) ((tv))->us[3]) >= 0xfff8UL) ? ((duk_heaphdr *) (tv)->vp[0]) : ((void *)0));

 vals[0] = duk_get_type_tval(tv);
 vals[1] = (duk_int_t) ((duk_small_uint_t) (tv)->us[3]);

 duk_push_bare_object(thr);
 tv = ((void *)0);

 if (h == ((void *)0)) {
  goto finish;
 }
 duk_push_pointer(thr, (void *) h);
 duk_put_prop_literal_raw((thr), (-2), ("hptr"), sizeof(("hptr")) - 1U);
 vals[2] = (duk_int_t) ((h)->h_refcount);

 vals[13] = 0;




 switch ((duk_small_int_t) ((h)->h_flags & 0x00000003UL)) {
 case 0: {
  duk_hstring *h_str = (duk_hstring *) h;
  vals[3] = (duk_int_t) (sizeof(duk_hstring) + ((h_str)->blen) + 1);





  break;
 }
 case 1: {
  duk_hobject *h_obj = (duk_hobject *) h;


  if ((((&((h_obj))->hdr)->h_flags & ((1UL << (7 + (15))))) != 0)) {
   vals[3] = sizeof(duk_harray);
  } else if ((((&(h_obj)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
   vals[3] = sizeof(duk_hcompfunc);
  } else if ((((&(h_obj)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
   vals[3] = sizeof(duk_hnatfunc);
  } else if (((((&((h_obj))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 18)) {
   vals[3] = sizeof(duk_hthread);
   vals[12] = ((duk_hthread *) h_obj)->state;

  } else if ((((&(h_obj)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {
   vals[3] = sizeof(duk_hbufobj);


  } else {
   vals[3] = (duk_small_uint_t) sizeof(duk_hobject);
  }

  vals[4] = (duk_int_t) (((&(h_obj)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL));
  vals[5] = (duk_int_t) ( ((((h_obj))->e_size)) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((h_obj))->e_size)))) & 0x07) + ((((h_obj))->a_size)) * sizeof(duk_tval) + ((((h_obj))->h_size)) * sizeof(duk_uint32_t) );
  vals[6] = (duk_int_t) ((h_obj)->e_size);
  vals[7] = (duk_int_t) ((h_obj)->e_next);
  vals[8] = (duk_int_t) ((h_obj)->a_size);
  vals[9] = (duk_int_t) ((h_obj)->h_size);
  if ((((&(h_obj)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
   duk_hbuffer *h_data = (duk_hbuffer *) ((duk_hbuffer_fixed *) (void *) ((duk_hcompfunc *) h_obj)->data);
   vals[10] = (duk_int_t) (h_data ? (((duk_hbuffer *) (h_data))->size) : 0);
  }
  break;
 }
 case 2: {
  duk_hbuffer *h_buf = (duk_hbuffer *) h;

  if ((((&(h_buf)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0)) {
   if ((((&(h_buf)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)) {
    vals[13] = 2;
    vals[3] = (duk_uint_t) (sizeof(duk_hbuffer_external));
   } else {



    vals[13] = 1;
    vals[3] = (duk_uint_t) (sizeof(duk_hbuffer_dynamic));
   }
   vals[11] = (duk_int_t) ((((duk_hbuffer *) (h_buf))->size));
  } else {
   do { } while (0);
   vals[3] = (duk_int_t) (sizeof(duk_hbuffer_fixed) + (((duk_hbuffer *) (h_buf))->size));
  }
  break;
 }
 }

 finish:
 duk__inspect_multiple_uint(thr,
     "type" "\x00" "itag" "\x00" "refc" "\x00" "hbytes" "\x00" "class" "\x00"
     "pbytes" "\x00" "esize" "\x00" "enext" "\x00" "asize" "\x00" "hsize" "\x00"
     "bcbytes" "\x00" "dbytes" "\x00" "tstate" "\x00" "variant" "\x00" "\x00",
     (duk_int_t *) &vals);
}

__attribute__ ((visibility("default"))) void duk_inspect_callstack_entry(duk_hthread *thr, duk_int_t level) {
 duk_activation *act={0};
 duk_uint_fast32_t pc={0};
 duk_uint_fast32_t line={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);





 act = duk_hthread_get_activation_for_level(thr, level);
 if (act == ((void *)0)) {
  duk_push_undefined(thr);
  return;
 }
 duk_push_bare_object(thr);





 pc = duk_hthread_get_act_prev_pc(thr, act);

 duk_push_tval(thr, &act->tv_func);

 duk_push_uint(thr, (duk_uint_t) pc);
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-3)) << 16) + ((duk_uint_t) (89))));


 line = duk_hobject_pc2line_query(thr, -1, pc);



 duk_push_uint(thr, (duk_uint_t) line);
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-3)) << 16) + ((duk_uint_t) (90))));

 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (132))));





}






__attribute__ ((visibility("default"))) void *duk_alloc_raw(duk_hthread *thr, duk_size_t size) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 return ((thr->heap)->alloc_func((thr->heap)->heap_udata, (size)));
}

__attribute__ ((visibility("default"))) void duk_free_raw(duk_hthread *thr, void *ptr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 ((thr->heap)->free_func((thr->heap)->heap_udata, (void *) (ptr)));
}

__attribute__ ((visibility("default"))) void *duk_realloc_raw(duk_hthread *thr, void *ptr, duk_size_t size) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 return ((thr->heap)->realloc_func((thr->heap)->heap_udata, (void *) (ptr), (size)));
}

__attribute__ ((visibility("default"))) void *duk_alloc(duk_hthread *thr, duk_size_t size) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 return duk_heap_mem_alloc((thr->heap), (size));
}

__attribute__ ((visibility("default"))) void duk_free(duk_hthread *thr, void *ptr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk_heap_mem_free((thr)->heap, (ptr));
}

__attribute__ ((visibility("default"))) void *duk_realloc(duk_hthread *thr, void *ptr, duk_size_t size) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk_heap_mem_realloc((thr->heap), (ptr), (size));
}

__attribute__ ((visibility("default"))) void duk_get_memory_functions(duk_hthread *thr, duk_memory_functions *out_funcs) {
 duk_heap *heap={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 heap = thr->heap;
 out_funcs->alloc_func = heap->alloc_func;
 out_funcs->realloc_func = heap->realloc_func;
 out_funcs->free_func = heap->free_func;
 out_funcs->udata = heap->heap_udata;
}

__attribute__ ((visibility("default"))) void duk_gc(duk_hthread *thr, duk_uint_t flags) {
 duk_heap *heap={0};
 duk_small_uint_t ms_flags={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 heap = thr->heap;
 do { } while (0);

 do { } while (0);
 do { } while (0);
 ms_flags = (duk_small_uint_t) flags;
 duk_heap_mark_and_sweep(heap, ms_flags);
}
__attribute__ ((visibility("default"))) duk_bool_t duk_get_prop(duk_hthread *thr, duk_idx_t obj_idx) {
 duk_tval *tv_obj={0};
 duk_tval *tv_key={0};
 duk_bool_t rc={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);





 tv_obj = duk_require_tval(thr, obj_idx);
 tv_key = duk_require_tval(thr, -1);

 rc = duk_hobject_getprop(thr, tv_obj, tv_key);
 do { } while (0);


 duk_remove_m2(thr);
 do { } while (0);
 return rc;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_get_prop_string(duk_hthread *thr, duk_idx_t obj_idx, const char *key) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_string(thr, key);
 return duk_get_prop(thr, obj_idx);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_get_prop_lstring(duk_hthread *thr, duk_idx_t obj_idx, const char *key, duk_size_t key_len) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_lstring(thr, key, key_len);
 return duk_get_prop(thr, obj_idx);
}


__attribute__ ((visibility("default"))) duk_bool_t duk_get_prop_literal_raw(duk_hthread *thr, duk_idx_t obj_idx, const char *key, duk_size_t key_len) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_literal_raw(thr, key, key_len);
 return duk_get_prop(thr, obj_idx);
}


__attribute__ ((visibility("default"))) duk_bool_t duk_get_prop_index(duk_hthread *thr, duk_idx_t obj_idx, duk_uarridx_t arr_idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 duk_push_uint((thr), (duk_uint_t) (arr_idx));
 return duk_get_prop(thr, obj_idx);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_get_prop_heapptr(duk_hthread *thr, duk_idx_t obj_idx, void *ptr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_heapptr(thr, ptr);
 return duk_get_prop(thr, obj_idx);
}

static __attribute__ ((unused)) duk_bool_t duk_get_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_hstring(thr, ((thr)->strs[(stridx)]));
 return duk_get_prop(thr, obj_idx);
}

static __attribute__ ((unused)) duk_bool_t duk_get_prop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args) {
 return duk_get_prop_stridx(thr, (duk_idx_t) (duk_int16_t) (packed_args >> 16),
                                 (duk_small_uint_t) (packed_args & 0xffffUL));
}

static __attribute__ ((unused)) duk_bool_t duk_get_prop_stridx_boolean(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx, duk_bool_t *out_has_prop) {
 duk_bool_t rc={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 rc = duk_get_prop_stridx(thr, obj_idx, stridx);
 if (out_has_prop) {
  *out_has_prop = rc;
 }
 return duk_to_boolean_top_pop(thr);
}

static duk_bool_t duk__put_prop_shared(duk_hthread *thr, duk_idx_t obj_idx, duk_idx_t idx_key) {
 duk_tval *tv_obj={0};
 duk_tval *tv_key={0};
 duk_tval *tv_val={0};
 duk_bool_t throw_flag={0};
 duk_bool_t rc={0};
 do { } while (0)
                                                   ;

 tv_obj = duk_require_tval(thr, obj_idx);
 tv_key = duk_require_tval(thr, idx_key);
 tv_val = duk_require_tval(thr, idx_key ^ 1);
 throw_flag = duk_is_strict_call(thr);

 rc = duk_hobject_putprop(thr, tv_obj, tv_key, tv_val, throw_flag);
 do { } while (0);

 duk_pop_2(thr);
 return rc;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_put_prop(duk_hthread *thr, duk_idx_t obj_idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__put_prop_shared(thr, obj_idx, -2);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_put_prop_string(duk_hthread *thr, duk_idx_t obj_idx, const char *key) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);





 obj_idx = duk_normalize_index(thr, obj_idx);
 (void) duk_push_string(thr, key);
 return duk__put_prop_shared(thr, obj_idx, -1);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_put_prop_lstring(duk_hthread *thr, duk_idx_t obj_idx, const char *key, duk_size_t key_len) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_normalize_index(thr, obj_idx);
 (void) duk_push_lstring(thr, key, key_len);
 return duk__put_prop_shared(thr, obj_idx, -1);
}


__attribute__ ((visibility("default"))) duk_bool_t duk_put_prop_literal_raw(duk_hthread *thr, duk_idx_t obj_idx, const char *key, duk_size_t key_len) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 obj_idx = duk_normalize_index(thr, obj_idx);
 (void) duk_push_literal_raw(thr, key, key_len);
 return duk__put_prop_shared(thr, obj_idx, -1);
}


__attribute__ ((visibility("default"))) duk_bool_t duk_put_prop_index(duk_hthread *thr, duk_idx_t obj_idx, duk_uarridx_t arr_idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 duk_push_uint((thr), (duk_uint_t) (arr_idx));
 return duk__put_prop_shared(thr, obj_idx, -1);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_put_prop_heapptr(duk_hthread *thr, duk_idx_t obj_idx, void *ptr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_heapptr(thr, ptr);
 return duk__put_prop_shared(thr, obj_idx, -1);
}


static __attribute__ ((unused)) duk_bool_t duk_put_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 duk_push_hstring(thr, ((thr)->strs[(stridx)]));
 return duk__put_prop_shared(thr, obj_idx, -1);
}

static __attribute__ ((unused)) duk_bool_t duk_put_prop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args) {
 return duk_put_prop_stridx(thr, (duk_idx_t) (duk_int16_t) (packed_args >> 16),
                                 (duk_small_uint_t) (packed_args & 0xffffUL));
}

__attribute__ ((visibility("default"))) duk_bool_t duk_del_prop(duk_hthread *thr, duk_idx_t obj_idx) {
 duk_tval *tv_obj={0};
 duk_tval *tv_key={0};
 duk_bool_t throw_flag={0};
 duk_bool_t rc={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);





 tv_obj = duk_require_tval(thr, obj_idx);
 tv_key = duk_require_tval(thr, -1);
 throw_flag = duk_is_strict_call(thr);

 rc = duk_hobject_delprop(thr, tv_obj, tv_key, throw_flag);
 do { } while (0);

 duk_pop(thr);
 return rc;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_del_prop_string(duk_hthread *thr, duk_idx_t obj_idx, const char *key) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_string(thr, key);
 return duk_del_prop(thr, obj_idx);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_del_prop_lstring(duk_hthread *thr, duk_idx_t obj_idx, const char *key, duk_size_t key_len) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_lstring(thr, key, key_len);
 return duk_del_prop(thr, obj_idx);
}


__attribute__ ((visibility("default"))) duk_bool_t duk_del_prop_literal_raw(duk_hthread *thr, duk_idx_t obj_idx, const char *key, duk_size_t key_len) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_literal_raw(thr, key, key_len);
 return duk_del_prop(thr, obj_idx);
}


__attribute__ ((visibility("default"))) duk_bool_t duk_del_prop_index(duk_hthread *thr, duk_idx_t obj_idx, duk_uarridx_t arr_idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 duk_push_uint((thr), (duk_uint_t) (arr_idx));
 return duk_del_prop(thr, obj_idx);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_del_prop_heapptr(duk_hthread *thr, duk_idx_t obj_idx, void *ptr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_heapptr(thr, ptr);
 return duk_del_prop(thr, obj_idx);
}

static __attribute__ ((unused)) duk_bool_t duk_del_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 duk_push_hstring(thr, ((thr)->strs[(stridx)]));
 return duk_del_prop(thr, obj_idx);
}
__attribute__ ((visibility("default"))) duk_bool_t duk_has_prop(duk_hthread *thr, duk_idx_t obj_idx) {
 duk_tval *tv_obj={0};
 duk_tval *tv_key={0};
 duk_bool_t rc={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);





 tv_obj = duk_require_tval(thr, obj_idx);
 tv_key = duk_require_tval(thr, -1);

 rc = duk_hobject_hasprop(thr, tv_obj, tv_key);
 do { } while (0);

 duk_pop(thr);
 return rc;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_has_prop_string(duk_hthread *thr, duk_idx_t obj_idx, const char *key) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_string(thr, key);
 return duk_has_prop(thr, obj_idx);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_has_prop_lstring(duk_hthread *thr, duk_idx_t obj_idx, const char *key, duk_size_t key_len) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_lstring(thr, key, key_len);
 return duk_has_prop(thr, obj_idx);
}


__attribute__ ((visibility("default"))) duk_bool_t duk_has_prop_literal_raw(duk_hthread *thr, duk_idx_t obj_idx, const char *key, duk_size_t key_len) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_literal_raw(thr, key, key_len);
 return duk_has_prop(thr, obj_idx);
}


__attribute__ ((visibility("default"))) duk_bool_t duk_has_prop_index(duk_hthread *thr, duk_idx_t obj_idx, duk_uarridx_t arr_idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 duk_push_uint((thr), (duk_uint_t) (arr_idx));
 return duk_has_prop(thr, obj_idx);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_has_prop_heapptr(duk_hthread *thr, duk_idx_t obj_idx, void *ptr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_heapptr(thr, ptr);
 return duk_has_prop(thr, obj_idx);
}

static __attribute__ ((unused)) duk_bool_t duk_has_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 duk_push_hstring(thr, ((thr)->strs[(stridx)]));
 return duk_has_prop(thr, obj_idx);
}
static __attribute__ ((unused)) void duk_xdef_prop(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t desc_flags) {
 duk_hobject *obj={0};
 duk_hstring *key={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 obj = duk_require_hobject(thr, obj_idx);
 do { } while (0);
 key = duk_to_property_key_hstring(thr, -2);
 do { } while (0);
 do { } while (0);

 duk_hobject_define_property_internal(thr, obj, key, desc_flags);

 duk_pop(thr);
}

static __attribute__ ((unused)) void duk_xdef_prop_index(duk_hthread *thr, duk_idx_t obj_idx, duk_uarridx_t arr_idx, duk_small_uint_t desc_flags) {
 duk_hobject *obj={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 obj = duk_require_hobject(thr, obj_idx);
 do { } while (0);

 duk_hobject_define_property_internal_arridx(thr, obj, arr_idx, desc_flags);

}

static __attribute__ ((unused)) void duk_xdef_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx, duk_small_uint_t desc_flags) {
 duk_hobject *obj={0};
 duk_hstring *key={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj = duk_require_hobject(thr, obj_idx);
 do { } while (0);
 key = ((thr)->strs[(stridx)]);
 do { } while (0);
 do { } while (0);

 duk_hobject_define_property_internal(thr, obj, key, desc_flags);

}

static __attribute__ ((unused)) void duk_xdef_prop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args) {
 duk_xdef_prop_stridx(thr, (duk_idx_t) (duk_int8_t) (packed_args >> 24),
                           (duk_small_uint_t) (packed_args >> 8) & 0xffffUL,
                           (duk_small_uint_t) (packed_args & 0xffL));
}
static __attribute__ ((unused)) void duk_xdef_prop_stridx_thrower(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 duk_push_hstring_stridx(thr, stridx);
 duk_push_hobject_bidx(thr, 33);
 duk_dup_top(thr);
 duk_def_prop(thr, obj_idx, (1U << 8) | (1U << 7) | (1U << 9));
}


__attribute__ ((visibility("default"))) void duk_get_prop_desc(duk_hthread *thr, duk_idx_t obj_idx, duk_uint_t flags) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { (void) (flags); } while (0);

 duk_hobject_object_get_own_property_descriptor(thr, obj_idx);
}


__attribute__ ((visibility("default"))) void duk_def_prop(duk_hthread *thr, duk_idx_t obj_idx, duk_uint_t flags) {
 duk_idx_t idx_base={0};
 duk_hobject *obj={0};
 duk_hstring *key={0};
 duk_idx_t idx_value={0};
 duk_hobject *get={0};
 duk_hobject *set={0};
 duk_uint_t is_data_desc={0};
 duk_uint_t is_acc_desc={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 obj = duk_require_hobject(thr, obj_idx);

 is_data_desc = flags & ((1U << 6) | (1U << 3));
 is_acc_desc = flags & ((1U << 7) | (1U << 8));
 if (is_data_desc && is_acc_desc) {




  goto fail_invalid_desc;
 }

 idx_base = duk_get_top_index(thr);
 if (flags & (1U << 8)) {
  ((void) duk_check_type_mask((thr), (idx_base), ((1U << 1U) | (1U << 6U) | (1U << 9U)) | (1U << 10)))

                                                               ;
  set = duk_get_hobject_promote_mask((thr), (idx_base), (1U << 9U));
  if (set != ((void *)0) && !(((&((set))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {
   goto fail_not_callable;
  }
  idx_base--;
 } else {
  set = ((void *)0);
 }
 if (flags & (1U << 7)) {
  ((void) duk_check_type_mask((thr), (idx_base), ((1U << 1U) | (1U << 6U) | (1U << 9U)) | (1U << 10)))

                                                               ;
  get = duk_get_hobject_promote_mask((thr), (idx_base), (1U << 9U));
  if (get != ((void *)0) && !(((&((get))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {
   goto fail_not_callable;
  }
  idx_base--;
 } else {
  get = ((void *)0);
 }
 if (flags & (1U << 6)) {
  idx_value = idx_base;
  idx_base--;
 } else {
  idx_value = (duk_idx_t) -1;
 }
 key = duk_to_property_key_hstring(thr, idx_base);
 do { } while (0);

 duk_require_valid_index(thr, idx_base);

 duk_hobject_define_property_helper(thr,
                                    flags ,
                                    obj,
                                    key,
                                    idx_value,
                                    get,
                                    set,
                                    1 );



 duk_set_top(thr, idx_base);



 return;

 fail_invalid_desc:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 558; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_object.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid descriptor"))); } while (0); } while (0);
 do { } while (0);

 fail_not_callable:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 562; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_object.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not callable"))); } while (0); } while (0);
 do { } while (0);
}
__attribute__ ((visibility("default"))) void duk_compact(duk_hthread *thr, duk_idx_t obj_idx) {
 duk_hobject *obj={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 obj = duk_get_hobject(thr, obj_idx);
 if (obj) {

  duk_hobject_compact_props(thr, obj);
 }
}

static __attribute__ ((unused)) void duk_compact_m1(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk_compact(thr, -1);
}



__attribute__ ((visibility("default"))) void duk_enum(duk_hthread *thr, duk_idx_t obj_idx, duk_uint_t enum_flags) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk_dup(thr, obj_idx);
 duk_require_hobject_promote_mask(thr, -1, (1U << 9U) | (1U << 7U));
 duk_hobject_enumerator_create(thr, enum_flags);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_next(duk_hthread *thr, duk_idx_t enum_index, duk_bool_t get_value) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk_require_hobject(thr, enum_index);
 duk_dup(thr, enum_index);
 return duk_hobject_enumerator_next(thr, get_value);
}

static __attribute__ ((unused)) void duk_seal_freeze_raw(duk_hthread *thr, duk_idx_t obj_idx, duk_bool_t is_freeze) {
 duk_tval *tv={0};
 duk_hobject *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_require_tval(thr, obj_idx);
 do { } while (0);







 switch (((duk_small_uint_t) (tv)->us[3])) {
 case 0xfffaUL:



  if (is_freeze) {
   goto fail_cannot_freeze;
  }
  break;
 case 0xfff7UL:

  break;
 case 0xfff9UL:
  h = ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);
  if (is_freeze && (((&(h)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {



   do { } while (0);
   goto fail_cannot_freeze;
  }
  duk_hobject_object_seal_freeze_helper(thr, h, is_freeze);




  duk_hobject_compact_props(thr, h);
  break;
 default:

  break;
 }
 return;

 fail_cannot_freeze:
 do { duk_err_type_invalid_args((thr), "duk_api_object.c", (duk_int_t) 660); } while (0);
 do { } while (0);
}

__attribute__ ((visibility("default"))) void duk_seal(duk_hthread *thr, duk_idx_t obj_idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk_seal_freeze_raw(thr, obj_idx, 0 );
}

__attribute__ ((visibility("default"))) void duk_freeze(duk_hthread *thr, duk_idx_t obj_idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk_seal_freeze_raw(thr, obj_idx, 1 );
}





__attribute__ ((visibility("default"))) void duk_put_function_list(duk_hthread *thr, duk_idx_t obj_idx, const duk_function_list_entry *funcs) {
 const duk_function_list_entry *ent = funcs;

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 if (ent != ((void *)0)) {
  while (ent->key != ((void *)0)) {
   duk_push_c_function(thr, ent->value, ent->nargs);
   duk_put_prop_string(thr, obj_idx, ent->key);
   ent++;
  }
 }
}

__attribute__ ((visibility("default"))) void duk_put_number_list(duk_hthread *thr, duk_idx_t obj_idx, const duk_number_list_entry *numbers) {
 const duk_number_list_entry *ent = numbers;
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 if (ent != ((void *)0)) {
  while (ent->key != ((void *)0)) {
   tv = thr->valstack_top++;
   do { } while (0);
   do { duk_double_t duk__dblval; duk__dblval = ((ent->value)); ; do { (((tv)))->d = (duk__dblval); } while (0); } while (0);
   duk_put_prop_string(thr, obj_idx, ent->key);
   ent++;
  }
 }
}





__attribute__ ((visibility("default"))) duk_bool_t duk_get_global_string(duk_hthread *thr, const char *key) {
 duk_bool_t ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);



 duk_push_hobject(thr, thr->builtins[0]);
 ret = duk_get_prop_string(thr, -1, key);
 duk_remove_m2(thr);
 return ret;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_get_global_lstring(duk_hthread *thr, const char *key, duk_size_t key_len) {
 duk_bool_t ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);



 duk_push_hobject(thr, thr->builtins[0]);
 ret = duk_get_prop_lstring(thr, -1, key, key_len);
 duk_remove_m2(thr);
 return ret;
}


__attribute__ ((visibility("default"))) duk_bool_t duk_get_global_literal_raw(duk_hthread *thr, const char *key, duk_size_t key_len) {
 duk_bool_t ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);



 duk_push_hobject(thr, thr->builtins[0]);
 ret = duk_get_prop_literal_raw(thr, -1, key, key_len);
 duk_remove_m2(thr);
 return ret;
}


__attribute__ ((visibility("default"))) duk_bool_t duk_get_global_heapptr(duk_hthread *thr, void *ptr) {
 duk_bool_t ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);



 duk_push_hobject(thr, thr->builtins[0]);
 ret = duk_get_prop_heapptr(thr, -1, ptr);
 duk_remove_m2(thr);
 return ret;
}


__attribute__ ((visibility("default"))) duk_bool_t duk_put_global_string(duk_hthread *thr, const char *key) {
 duk_bool_t ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);



 duk_push_hobject(thr, thr->builtins[0]);
 duk_insert(thr, -2);
 ret = duk_put_prop_string(thr, -2, key);
 duk_pop(thr);
 return ret;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_put_global_lstring(duk_hthread *thr, const char *key, duk_size_t key_len) {
 duk_bool_t ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);



 duk_push_hobject(thr, thr->builtins[0]);
 duk_insert(thr, -2);
 ret = duk_put_prop_lstring(thr, -2, key, key_len);
 duk_pop(thr);
 return ret;
}


__attribute__ ((visibility("default"))) duk_bool_t duk_put_global_literal_raw(duk_hthread *thr, const char *key, duk_size_t key_len) {
 duk_bool_t ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);



 duk_push_hobject(thr, thr->builtins[0]);
 duk_insert(thr, -2);
 ret = duk_put_prop_literal_raw(thr, -2, key, key_len);
 duk_pop(thr);
 return ret;
}


__attribute__ ((visibility("default"))) duk_bool_t duk_put_global_heapptr(duk_hthread *thr, void *ptr) {
 duk_bool_t ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);



 duk_push_hobject(thr, thr->builtins[0]);
 duk_insert(thr, -2);
 ret = duk_put_prop_heapptr(thr, -2, ptr);
 duk_pop(thr);
 return ret;
}





static __attribute__ ((unused)) duk_bool_t duk_get_method_stridx(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t stridx) {
 (void) duk_get_prop_stridx(thr, idx, stridx);
 if (((duk_get_type_mask((thr), (-1)) & ((1U << 2U) | (1U << 1U))) ? 1 : 0)) {
  duk_pop_nodecref_unsafe(thr);
  return 0;
 }
 if (!duk_is_function((thr), (-1))) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 851; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_object.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not callable"))); } while (0); } while (0);
  do { } while (0);
 }
 return 1;
}





__attribute__ ((visibility("default"))) void duk_get_prototype(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *obj={0};
 duk_hobject *proto={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 obj = duk_require_hobject(thr, idx);
 do { } while (0);


 proto = ((obj)->prototype);
 if (proto) {
  duk_push_hobject(thr, proto);
 } else {
  duk_push_undefined(thr);
 }
}

__attribute__ ((visibility("default"))) void duk_set_prototype(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *obj={0};
 duk_hobject *proto={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 obj = duk_require_hobject(thr, idx);
 do { } while (0);
 ((void) duk_check_type_mask((thr), (-1), ((1U << 1U) | (1U << 6U)) | (1U << 10)))
                                                     ;
 proto = duk_get_hobject(thr, -1);
 duk_hobject_set_prototype_updref((thr), (obj), (proto));

 duk_pop(thr);
}
__attribute__ ((visibility("default"))) void duk_get_finalizer(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk_get_prop_stridx(thr, idx, 104);
}

__attribute__ ((visibility("default"))) void duk_set_finalizer(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *h={0};
 duk_bool_t callable={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_require_hobject(thr, idx);
 callable = duk_is_function((thr), (-1));
 duk_put_prop_stridx(thr, idx, 104);
 if (callable) {
  do { do { } while (0); (&(h)->hdr)->h_flags |= ((1UL << (7 + (14)))); } while (0);
 } else {
  do { do { } while (0); (&(h)->hdr)->h_flags &= ~(((1UL << (7 + (14))))); } while (0);
 }
}






__attribute__ ((visibility("default"))) duk_double_t duk_random(duk_hthread *thr) {
 return (duk_double_t) duk_util_tinyrandom_get_double(thr);
}
static duk_idx_t duk__push_c_function_raw(duk_hthread *thr, duk_c_function func, duk_idx_t nargs, duk_uint_t flags, duk_small_uint_t proto_bidx);






__attribute__ ((visibility("default"))) const char *duk_api_global_filename = ((void *)0);
__attribute__ ((visibility("default"))) duk_int_t duk_api_global_line = 0;






static const char * const duk__symbol_type_strings[4] = {
 "hidden", "global", "local", "wellknown"
};
static duk_small_uint_t duk__get_symbol_type(duk_hstring *h) {
 const duk_uint8_t *data={0};
 duk_size_t len={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);

 data = (const duk_uint8_t *) ((const duk_uint8_t *) ((h) + 1));
 len = ((h)->blen);
 do { } while (0);



 if (data[0] == 0xffU) {
  return 0;
 } else if (data[0] == 0x82U) {
  return 0;
 } else if (data[0] == 0x80U) {
  return 1;
 } else if (data[len - 1] != 0xffU) {
  return 2;
 } else {
  return 3;
 }
}

static const char *duk__get_symbol_type_string(duk_hstring *h) {
 duk_small_uint_t idx={0};
 idx = duk__get_symbol_type(h);
 do { } while (0);
 return duk__symbol_type_strings[idx];
}

static duk_heaphdr *duk__get_tagged_heaphdr_raw(duk_hthread *thr, duk_idx_t idx, duk_uint_t tag);

static duk_int_t duk__api_coerce_d2i(duk_hthread *thr, duk_idx_t idx, duk_int_t def_value, duk_bool_t require) {
 duk_tval *tv={0};
 duk_small_int_t c={0};
 duk_double_t d={0};

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if ((((duk_small_uint_t) ((tv))->us[3]) <= 0xfff0UL)) {
  d = ((tv)->d);
  c = (duk_small_int_t) (sizeof (d) == sizeof (float) ? __fpclassifyf (d) : sizeof (d) == sizeof (double) ? __fpclassify (d) : __fpclassifyl (d));
  if (c == FP_NAN) {
   return 0;
  } else if (d < (duk_double_t) (-2147483647 - 1)) {

   return (-2147483647 - 1);
  } else if (d > (duk_double_t) 2147483647) {

   return 2147483647;
  } else {

   return (duk_int_t) d;
  }
 }

 if (require) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 174, (idx), ("number")); } while (0);
  do { } while (0);
 }

 return def_value;
}

static duk_uint_t duk__api_coerce_d2ui(duk_hthread *thr, duk_idx_t idx, duk_uint_t def_value, duk_bool_t require) {
 duk_tval *tv={0};
 duk_small_int_t c={0};
 duk_double_t d={0};



 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if ((((duk_small_uint_t) ((tv))->us[3]) <= 0xfff0UL)) {
  d = ((tv)->d);
  c = (duk_small_int_t) (sizeof (d) == sizeof (float) ? __fpclassifyf (d) : sizeof (d) == sizeof (double) ? __fpclassify (d) : __fpclassifyl (d));
  if (c == FP_NAN) {
   return 0;
  } else if (d < 0.0) {

   return (duk_uint_t) 0;
  } else if (d > (duk_double_t) (2147483647 * 2U + 1U)) {

   return (duk_uint_t) (2147483647 * 2U + 1U);
  } else {

   return (duk_uint_t) d;
  }
 }

 if (require) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 225, (idx), ("number")); } while (0);
  do { } while (0);
 }

 return def_value;
}
__attribute__ ((visibility("default"))) duk_idx_t duk_normalize_index(duk_hthread *thr, duk_idx_t idx) {
 duk_uidx_t vs_size={0};
 duk_uidx_t uidx={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 vs_size = (duk_uidx_t) (thr->valstack_top - thr->valstack_bottom);
 do { } while (0);

 if (idx < 0) {
  uidx = vs_size + (duk_uidx_t) idx;
 } else {

  do { } while (0);
  uidx = (duk_uidx_t) idx;
 }


 do { } while (0);

 if (__builtin_expect((uidx < vs_size), 1)) {
  return (duk_idx_t) uidx;
 }
 return (-2147483647 - 1);
}

__attribute__ ((visibility("default"))) duk_idx_t duk_require_normalize_index(duk_hthread *thr, duk_idx_t idx) {
 duk_uidx_t vs_size={0};
 duk_uidx_t uidx={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { } while (0);
 vs_size = (duk_uidx_t) (thr->valstack_top - thr->valstack_bottom);
 do { } while (0);

 if (idx < 0) {
  uidx = vs_size + (duk_uidx_t) idx;
 } else {
  do { } while (0);
  uidx = (duk_uidx_t) idx;
 }


 do { } while (0);

 if (__builtin_expect((uidx < vs_size), 1)) {
  return (duk_idx_t) uidx;
 }
 do { duk_err_range_index((thr), "duk_api_stack.c", (duk_int_t) 300, (idx)); } while (0);
 do { } while (0);
}

static __attribute__ ((unused)) duk_tval *duk_get_tval(duk_hthread *thr, duk_idx_t idx) {
 duk_uidx_t vs_size={0};
 duk_uidx_t uidx={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { } while (0);
 vs_size = (duk_uidx_t) (thr->valstack_top - thr->valstack_bottom);
 do { } while (0);

 if (idx < 0) {
  uidx = vs_size + (duk_uidx_t) idx;
 } else {
  do { } while (0);
  uidx = (duk_uidx_t) idx;
 }


 do { } while (0);

 if (__builtin_expect((uidx < vs_size), 1)) {
  return thr->valstack_bottom + uidx;
 }
 return ((void *)0);
}







static const duk_tval_unused duk__const_tval_unused = { 0xfff2UL, 0xfff2UL, 0xfff2UL, 0xfff2UL };

static __attribute__ ((unused)) duk_tval *duk_get_tval_or_unused(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval(thr, idx);
 if (tv != ((void *)0)) {
  return tv;
 }
 return (duk_tval *) ((void *) (duk_uintptr_t) (&duk__const_tval_unused));
}

static __attribute__ ((unused)) duk_tval *duk_require_tval(duk_hthread *thr, duk_idx_t idx) {
 duk_uidx_t vs_size={0};
 duk_uidx_t uidx={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { } while (0);
 vs_size = (duk_uidx_t) (thr->valstack_top - thr->valstack_bottom);
 do { } while (0);


 if (idx < 0) {
  uidx = vs_size + (duk_uidx_t) idx;
 } else {
  do { } while (0);
  uidx = (duk_uidx_t) idx;
 }


 do { } while (0);

 if (__builtin_expect((uidx < vs_size), 1)) {
  return thr->valstack_bottom + uidx;
 }
 do { duk_err_range_index((thr), "duk_api_stack.c", (duk_int_t) 376, (idx)); } while (0);
 do { } while (0);
}


__attribute__ ((visibility("default"))) duk_bool_t duk_is_valid_index(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 return (duk_normalize_index(thr, idx) >= 0);
}


__attribute__ ((visibility("default"))) void duk_require_valid_index(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 if (__builtin_expect((duk_normalize_index(thr, idx) < 0), 0)) {
  do { duk_err_range_index((thr), "duk_api_stack.c", (duk_int_t) 394, (idx)); } while (0);
  do { } while (0);
 }
}





__attribute__ ((visibility("default"))) duk_idx_t duk_get_top(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 return (duk_idx_t) (thr->valstack_top - thr->valstack_bottom);
}




static __attribute__ ((unused)) duk_idx_t duk_get_top_require_min(duk_hthread *thr, duk_idx_t min_top) {
 duk_idx_t ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 ret = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom);
 if (__builtin_expect((ret < min_top), 0)) {
  do { duk_err_type_invalid_args((thr), "duk_api_stack.c", (duk_int_t) 419); } while (0);
  do { } while (0);
 }
 return ret;
}





__attribute__ ((visibility("default"))) void duk_set_top(duk_hthread *thr, duk_idx_t idx) {
 duk_uidx_t vs_size={0};
 duk_uidx_t vs_limit={0};
 duk_uidx_t uidx={0};
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { } while (0);
 do { } while (0);
 vs_size = (duk_uidx_t) (thr->valstack_top - thr->valstack_bottom);
 vs_limit = (duk_uidx_t) (thr->valstack_end - thr->valstack_bottom);

 if (idx < 0) {



  uidx = vs_size + (duk_uidx_t) idx;
 } else {



  uidx = (duk_uidx_t) idx;
 }


 do { } while (0);
 do { } while (0);





 if (__builtin_expect((uidx > vs_limit), 0)) {
  do { duk_err_range_index((thr), "duk_api_stack.c", (duk_int_t) 464, (idx)); } while (0);
  do { } while (0);
 }

 do { } while (0);







 if (uidx >= vs_size) {
  thr->valstack_top = thr->valstack_bottom + uidx;
 } else {


  duk_uidx_t count={0};
  duk_tval *tv_end={0};

  count = vs_size - uidx;
  do { } while (0);
  tv = thr->valstack_top;
  tv_end = tv - count;
  do { } while (0);
  do {
   tv--;
   do { } while (0);
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { (tv__dst)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz((((thr))), duk__h); } } } while (0); } while (0);
  } while (tv != tv_end);
  thr->valstack_top = tv_end;
  do { duk_refzero_check_fast((thr)); } while (0);
 }
}
static __attribute__ ((unused)) void duk_set_top_unsafe(duk_hthread *thr, duk_idx_t idx) {
 duk_uidx_t uidx={0};
 duk_uidx_t vs_size={0};
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 uidx = (duk_uidx_t) idx;
 vs_size = (duk_uidx_t) (thr->valstack_top - thr->valstack_bottom);

 if (uidx >= vs_size) {
  thr->valstack_top = thr->valstack_bottom + uidx;
 } else {


  duk_uidx_t count={0};
  duk_tval *tv_end={0};

  count = vs_size - uidx;
  do { } while (0);
  tv = thr->valstack_top;
  tv_end = tv - count;
  do { } while (0);
  do {
   tv--;
   do { } while (0);
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { (tv__dst)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz((((thr))), duk__h); } } } while (0); } while (0);
  } while (tv != tv_end);
  thr->valstack_top = tv_end;
  do { duk_refzero_check_fast((thr)); } while (0);
 }
}






static __attribute__ ((unused)) void duk_set_top_and_wipe(duk_hthread *thr, duk_idx_t top, duk_idx_t idx_wipe_start) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 duk_set_top_unsafe(thr, idx_wipe_start);
 duk_set_top_unsafe(thr, top);
}

__attribute__ ((visibility("default"))) duk_idx_t duk_get_top_index(duk_hthread *thr) {
 duk_idx_t ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 ret = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom) - 1;
 if (__builtin_expect((ret < 0), 0)) {




  return (-2147483647 - 1);
 }
 return ret;
}




static __attribute__ ((unused)) duk_idx_t duk_get_top_index_unsafe(duk_hthread *thr) {
 duk_idx_t ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 ret = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom) - 1;
 return ret;
}

__attribute__ ((visibility("default"))) duk_idx_t duk_require_top_index(duk_hthread *thr) {
 duk_idx_t ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 ret = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom) - 1;
 if (__builtin_expect((ret < 0), 0)) {
  do { duk_err_range_index((thr), "duk_api_stack.c", (duk_int_t) 647, (-1)); } while (0);
  do { } while (0);
 }
 return ret;
}
static duk_bool_t duk__resize_valstack(duk_hthread *thr, duk_size_t new_size) {
 duk_tval *pre_valstack={0};
 duk_tval *pre_bottom={0};
 duk_tval *pre_top={0};
 duk_tval *pre_end={0};
 duk_tval *pre_alloc_end={0};
 duk_ptrdiff_t ptr_diff={0};
 duk_tval *new_valstack={0};
 duk_size_t new_alloc_size={0};
 duk_tval *tv_prev_alloc_end={0};
 duk_tval *p={0};

 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 pre_valstack = thr->valstack;
 pre_bottom = thr->valstack_bottom;
 pre_top = thr->valstack_top;
 pre_end = thr->valstack_end;
 pre_alloc_end = thr->valstack_alloc_end;

 do { (void) (pre_valstack); } while (0);
 do { (void) (pre_bottom); } while (0);
 do { (void) (pre_top); } while (0);
 do { (void) (pre_end); } while (0);
 do { (void) (pre_alloc_end); } while (0);
 new_alloc_size = sizeof(duk_tval) * new_size;
 new_valstack = (duk_tval *) duk_heap_mem_realloc_indirect((thr->heap), (duk_hthread_get_valstack_ptr), ((void *) thr), (new_alloc_size));
 if (__builtin_expect((new_valstack == ((void *)0)), 0)) {



  do { } while (0);
  do { } while (0)
                                                                             ;
  return 0;
 }
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);




 ptr_diff = (duk_ptrdiff_t) ((duk_uint8_t *) new_valstack - (duk_uint8_t *) thr->valstack);
 tv_prev_alloc_end = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_alloc_end + ptr_diff);
 thr->valstack = new_valstack;
 thr->valstack_bottom = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ptr_diff);
 thr->valstack_top = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_top + ptr_diff);
 thr->valstack_end = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_end + ptr_diff);
 thr->valstack_alloc_end = (duk_tval *) (void *) ((duk_uint8_t *) new_valstack + new_alloc_size);


 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0)
                                                                                                    ;


 p = tv_prev_alloc_end;
 while (p < thr->valstack_alloc_end) {

  do { (p)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);
  p++;
 }
 return 1;
}

static duk_bool_t duk__valstack_grow(duk_hthread *thr, duk_size_t min_bytes, duk_bool_t throw_on_error) {
 duk_size_t min_size={0};
 duk_size_t new_size={0};

 do { } while (0);
 min_size = min_bytes / sizeof(duk_tval);





 new_size = min_size + (min_size >> 2);







 if (__builtin_expect((new_size > 1000000L || new_size < min_size), 0)) {



  if (throw_on_error) {
   do { duk_err_range((thr), "duk_api_stack.c", (duk_int_t) 848, ("valstack limit")); } while (0);
   do { } while (0);
  }
  return 0;
 }

 if (duk__resize_valstack(thr, new_size) == 0) {
  if (throw_on_error) {
   do { duk_err_error_alloc_failed((thr), "duk_api_stack.c", (duk_int_t) 856); } while (0);
   do { } while (0);
  }
  return 0;
 }

 thr->valstack_end = thr->valstack + min_size;
 do { } while (0);

 return 1;
}




static __attribute__ ((unused)) void duk_valstack_grow_check_throw(duk_hthread *thr, duk_size_t min_bytes) {
 duk_tval *tv={0};

 tv = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + min_bytes);
 if (__builtin_expect((thr->valstack_end >= tv), 1)) {
  return;
 }
 if (__builtin_expect((thr->valstack_alloc_end >= tv), 1)) {



  thr->valstack_end = tv;
  return;
 }
 (void) duk__valstack_grow(thr, min_bytes, 1 );
}


static __attribute__ ((unused)) duk_bool_t duk_valstack_grow_check_nothrow(duk_hthread *thr, duk_size_t min_bytes) {
 duk_tval *tv={0};

 tv = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + min_bytes);
 if (__builtin_expect((thr->valstack_end >= tv), 1)) {
  return 1;
 }
 if (__builtin_expect((thr->valstack_alloc_end >= tv), 1)) {
  thr->valstack_end = tv;
  return 1;
 }
 return duk__valstack_grow(thr, min_bytes, 0 );
}


static __attribute__ ((unused)) void duk_valstack_shrink_check_nothrow(duk_hthread *thr, duk_bool_t snug) {
 duk_size_t alloc_bytes={0};
 duk_size_t reserve_bytes={0};
 duk_size_t shrink_bytes={0};

 alloc_bytes = (duk_size_t) ((duk_uint8_t *) thr->valstack_alloc_end - (duk_uint8_t *) thr->valstack);
 reserve_bytes = (duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack);
 do { } while (0);
 if (snug) {
  shrink_bytes = reserve_bytes;
 } else {
  duk_size_t proportion, slack={0};






  proportion = alloc_bytes >> 2;
  if (alloc_bytes - reserve_bytes < proportion) {

   return;
  }






  do { } while (0);
  slack = alloc_bytes >> 4;



  shrink_bytes = reserve_bytes +
                 slack / sizeof(duk_tval) * sizeof(duk_tval);
 }






 do { } while (0)
                                                                                 ;
 do { } while (0);
 if (shrink_bytes >= alloc_bytes) {



  return;
 }
 do { } while (0);

 do { } while (0);

 duk__resize_valstack(thr, shrink_bytes / sizeof(duk_tval));
}

__attribute__ ((visibility("default"))) duk_bool_t duk_check_stack(duk_hthread *thr, duk_idx_t extra) {
 duk_size_t min_new_bytes={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 if (__builtin_expect((extra < 0 || extra > 1000000L), 0)) {
  if (extra < 0) {



   extra = 0;
  } else {

   extra = 1000000L;
  }
 }

 min_new_bytes = (duk_size_t) ((duk_uint8_t *) thr->valstack_top - (duk_uint8_t *) thr->valstack) +
                 sizeof(duk_tval) * ((duk_size_t) extra + 32U);
 return duk_valstack_grow_check_nothrow(thr, min_new_bytes);
}

__attribute__ ((visibility("default"))) void duk_require_stack(duk_hthread *thr, duk_idx_t extra) {
 duk_size_t min_new_bytes={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 if (__builtin_expect((extra < 0 || extra > 1000000L), 0)) {
  if (extra < 0) {



   extra = 0;
  } else {

   extra = 1000000L;
  }
 }

 min_new_bytes = (duk_size_t) ((duk_uint8_t *) thr->valstack_top - (duk_uint8_t *) thr->valstack) +
                 sizeof(duk_tval) * ((duk_size_t) extra + 32U);
 duk_valstack_grow_check_throw(thr, min_new_bytes);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_check_stack_top(duk_hthread *thr, duk_idx_t top) {
 duk_size_t min_new_bytes={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 if (__builtin_expect((top < 0 || top > 1000000L), 0)) {
  if (top < 0) {



   top = 0;
  } else {

   top = 1000000L;
  }
 }

 do { } while (0);
 min_new_bytes = (duk_size_t) ((duk_uint8_t *) thr->valstack_bottom - (duk_uint8_t *) thr->valstack) +
                 sizeof(duk_tval) * ((duk_size_t) top + 32U);
 return duk_valstack_grow_check_nothrow(thr, min_new_bytes);
}

__attribute__ ((visibility("default"))) void duk_require_stack_top(duk_hthread *thr, duk_idx_t top) {
 duk_size_t min_new_bytes={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 if (__builtin_expect((top < 0 || top > 1000000L), 0)) {
  if (top < 0) {



   top = 0;
  } else {

   top = 1000000L;
  }
 }

 do { } while (0);
 min_new_bytes = (duk_size_t) ((duk_uint8_t *) thr->valstack_bottom - (duk_uint8_t *) thr->valstack) +
                 sizeof(duk_tval) * ((duk_size_t) top + 32U);
 duk_valstack_grow_check_throw(thr, min_new_bytes);
}





__attribute__ ((visibility("default"))) void duk_swap(duk_hthread *thr, duk_idx_t idx1, duk_idx_t idx2) {
 duk_tval *tv1={0};
 duk_tval *tv2={0};
 duk_tval tv_tmp={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv1 = duk_require_tval(thr, idx1);
 do { } while (0);
 tv2 = duk_require_tval(thr, idx2);
 do { } while (0);


 do { *(&tv_tmp) = *(tv1); } while (0);
 do { *(tv1) = *(tv2); } while (0);
 do { *(tv2) = *(&tv_tmp); } while (0);
}

__attribute__ ((visibility("default"))) void duk_swap_top(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk_swap(thr, idx, -1);
}

__attribute__ ((visibility("default"))) void duk_dup(duk_hthread *thr, duk_idx_t from_idx) {
 duk_tval *tv_from={0};
 duk_tval *tv_to={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 1096); } while (0); } } while (0);

 tv_from = duk_require_tval(thr, from_idx);
 tv_to = thr->valstack_top++;
 do { } while (0);
 do { } while (0);
 do { *(tv_to) = *(tv_from); } while (0);
 do { duk_tval *duk__tv = ((tv_to)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
}

__attribute__ ((visibility("default"))) void duk_dup_top(duk_hthread *thr) {



 duk_tval *tv_from={0};
 duk_tval *tv_to={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 1114); } while (0); } } while (0);

 if (__builtin_expect((thr->valstack_top - thr->valstack_bottom <= 0), 0)) {
  do { duk_err_range_index((thr), "duk_api_stack.c", (duk_int_t) 1117, (-1)); } while (0);
  do { } while (0);
 }
 tv_from = thr->valstack_top - 1;
 tv_to = thr->valstack_top++;
 do { } while (0);
 do { } while (0);
 do { *(tv_to) = *(tv_from); } while (0);
 do { duk_tval *duk__tv = ((tv_to)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);

}

static __attribute__ ((unused)) void duk_dup_0(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 duk_dup(thr, 0);
}
static __attribute__ ((unused)) void duk_dup_1(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 duk_dup(thr, 1);
}
static __attribute__ ((unused)) void duk_dup_2(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 duk_dup(thr, 2);
}
static __attribute__ ((unused)) void duk_dup_m2(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 duk_dup(thr, -2);
}
static __attribute__ ((unused)) void duk_dup_m3(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 duk_dup(thr, -3);
}
static __attribute__ ((unused)) void duk_dup_m4(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 duk_dup(thr, -4);
}

__attribute__ ((visibility("default"))) void duk_insert(duk_hthread *thr, duk_idx_t to_idx) {
 duk_tval *p={0};
 duk_tval *q={0};
 duk_tval tv_tmp={0};
 duk_size_t nbytes={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 p = duk_require_tval(thr, to_idx);
 do { } while (0);
 q = duk_require_tval(thr, -1);
 do { } while (0);

 do { } while (0);







 nbytes = (duk_size_t) (((duk_uint8_t *) q) - ((duk_uint8_t *) p));

 do { } while (0)
                                                                                     ;




 do { *(&tv_tmp) = *(q); } while (0);
 do { void *duk__dst = ((void *) (p + 1)); const void *duk__src = ((const void *) p); duk_size_t duk__len = ((size_t) nbytes); do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } while (0);
 do { *(p) = *(&tv_tmp); } while (0);
}

static __attribute__ ((unused)) void duk_insert_undefined(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 duk_push_undefined(thr);
 duk_insert(thr, idx);
}

static __attribute__ ((unused)) void duk_insert_undefined_n(duk_hthread *thr, duk_idx_t idx, duk_idx_t count) {
 duk_tval *tv, *tv_end={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 tv = duk_reserve_gap(thr, idx, count);
 tv_end = tv + count;
 while (tv != tv_end) {
  do { (tv)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);
  tv++;
 }
}

__attribute__ ((visibility("default"))) void duk_replace(duk_hthread *thr, duk_idx_t to_idx) {
 duk_tval *tv1={0};
 duk_tval *tv2={0};
 duk_tval tv_tmp={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv1 = duk_require_tval(thr, -1);
 do { } while (0);
 tv2 = duk_require_tval(thr, to_idx);
 do { } while (0);




 do { *(&tv_tmp) = *(tv2); } while (0);
 do { *(tv2) = *(tv1); } while (0);
 do { (tv1)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);
 thr->valstack_top--;
 do { duk_tval *duk__tv = ((&tv_tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((thr)), duk__h); } } } while (0);
}

__attribute__ ((visibility("default"))) void duk_copy(duk_hthread *thr, duk_idx_t from_idx, duk_idx_t to_idx) {
 duk_tval *tv1={0};
 duk_tval *tv2={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv1 = duk_require_tval(thr, from_idx);
 do { } while (0);
 tv2 = duk_require_tval(thr, to_idx);
 do { } while (0);


 do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv2); tv__src = (tv1); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((duk_small_uint_t) (((tv__dst)))->us[3]) >= 0xfff8UL)) { h__obj = ((duk_heaphdr *) (tv__dst)->vp[0]); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
}

__attribute__ ((visibility("default"))) void duk_remove(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *p={0};
 duk_tval *q={0};

 duk_tval tv_tmp={0};

 duk_size_t nbytes={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 p = duk_require_tval(thr, idx);
 do { } while (0);
 q = duk_require_tval(thr, -1);
 do { } while (0);

 do { } while (0);
 do { *(&tv_tmp) = *(p); } while (0);


 nbytes = (duk_size_t) (((duk_uint8_t *) q) - ((duk_uint8_t *) p));
 do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) (p + 1)); duk_size_t duk__len = ((size_t) nbytes); do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } while (0);

 do { (q)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);
 thr->valstack_top--;


 do { duk_tval *duk__tv = ((&tv_tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((thr)), duk__h); } } } while (0);

}

static __attribute__ ((unused)) void duk_remove_unsafe(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk_remove(thr, idx);
}

static __attribute__ ((unused)) void duk_remove_m2(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk_remove(thr, -2);
}

static __attribute__ ((unused)) void duk_remove_n(duk_hthread *thr, duk_idx_t idx, duk_idx_t count) {
 duk_tval *tv_src={0};
 duk_tval *tv_dst={0};
 duk_tval *tv_newtop={0};
 duk_tval *tv={0};
 duk_size_t bytes={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 tv_dst = thr->valstack_bottom + idx;
 do { } while (0);
 tv_src = tv_dst + count;
 do { } while (0);
 bytes = (duk_size_t) ((duk_uint8_t *) thr->valstack_top - (duk_uint8_t *) tv_src);

 for (tv = tv_dst; tv < tv_src; tv++) {
  do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz(((thr)), duk__h); } } } while (0);
 }

 do { void *duk__dst = ((void *) tv_dst); const void *duk__src = ((const void *) tv_src); duk_size_t duk__len = (bytes); do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } while (0);

 tv_newtop = thr->valstack_top - count;
 for (tv = tv_newtop; tv < thr->valstack_top; tv++) {
  do { (tv)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);
 }
 thr->valstack_top = tv_newtop;





}

static __attribute__ ((unused)) void duk_remove_n_unsafe(duk_hthread *thr, duk_idx_t idx, duk_idx_t count) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk_remove_n(thr, idx, count);
}





__attribute__ ((visibility("default"))) void duk_xcopymove_raw(duk_hthread *to_thr, duk_hthread *from_thr, duk_idx_t count, duk_bool_t is_copy) {
 void *src={0};
 duk_size_t nbytes={0};
 duk_tval *p={0};
 duk_tval *q={0};



 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 if (__builtin_expect((to_thr == from_thr), 0)) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 1368; do { } while (0); do { } while (0); duk_err_handle_error(((to_thr)), "duk_api_stack.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid context"))); } while (0); } while (0);
  do { } while (0);
 }
 if (__builtin_expect(((duk_uidx_t) count > (duk_uidx_t) 1000000L), 0)) {



  do { do { duk_err_range(((to_thr)), "duk_api_stack.c", (duk_int_t) 1375, ("invalid count")); } while (0); } while (0);
  do { } while (0);
 }
 do { } while (0);

 nbytes = sizeof(duk_tval) * (duk_size_t) count;
 if (__builtin_expect((nbytes == 0), 0)) {
  return;
 }
 do { } while (0);
 if (__builtin_expect(((duk_size_t) ((duk_uint8_t *) to_thr->valstack_end - (duk_uint8_t *) to_thr->valstack_top) < nbytes), 0)) {
  do { duk_err_range_push_beyond((to_thr), "duk_api_stack.c", (duk_int_t) 1386); } while (0);
  do { } while (0);
 }
 src = (void *) ((duk_uint8_t *) from_thr->valstack_top - nbytes);
 if (__builtin_expect((src < (void *) from_thr->valstack_bottom), 0)) {
  do { do { duk_err_range(((to_thr)), "duk_api_stack.c", (duk_int_t) 1391, ("invalid count")); } while (0); } while (0);
  do { } while (0);
 }




 do { } while (0);
 do { void *duk__dst = ((void *) to_thr->valstack_top); const void *duk__src = ((const void *) src); duk_size_t duk__len = ((size_t) nbytes); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);

 p = to_thr->valstack_top;
 to_thr->valstack_top = (duk_tval *) (void *) (((duk_uint8_t *) p) + nbytes);

 if (is_copy) {

  q = to_thr->valstack_top;
  while (p < q) {
   do { duk_tval *duk__tv = ((p)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   p++;
  }
 } else {

  p = from_thr->valstack_top;
  q = (duk_tval *) (void *) (((duk_uint8_t *) p) - nbytes);
  from_thr->valstack_top = q;

  while (p > q) {
   p--;
   do { (p)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);

  }
 }
}






static __attribute__ ((unused)) duk_tval *duk_reserve_gap(duk_hthread *thr, duk_idx_t idx_base, duk_idx_t count) {
 duk_tval *tv_src={0};
 duk_tval *tv_dst={0};
 duk_size_t gap_bytes={0};
 duk_size_t copy_bytes={0};




 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 tv_src = thr->valstack_bottom + idx_base;
 gap_bytes = (duk_size_t) count * sizeof(duk_tval);
 tv_dst = (duk_tval *) (void *) ((duk_uint8_t *) tv_src + gap_bytes);
 copy_bytes = (duk_size_t) ((duk_uint8_t *) thr->valstack_top - (duk_uint8_t *) tv_src);
 thr->valstack_top = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_top + gap_bytes);
 do { void *duk__dst = ((void *) tv_dst); const void *duk__src = ((const void *) tv_src); duk_size_t duk__len = (copy_bytes); do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } while (0);




 return tv_src;
}





__attribute__ ((visibility("default"))) void duk_require_undefined(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (__builtin_expect((!(((duk_small_uint_t) ((tv))->us[3]) == 0xfff3UL)), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 1468, (idx), ("undefined")); } while (0);
  do { } while (0);
 }
}

__attribute__ ((visibility("default"))) void duk_require_null(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (__builtin_expect((!(((duk_small_uint_t) ((tv))->us[3]) == 0xfff4UL)), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 1481, (idx), ("null")); } while (0);
  do { } while (0);
 }
}

static duk_bool_t duk__get_boolean_raw(duk_hthread *thr, duk_idx_t idx, duk_bool_t def_value) {
 duk_bool_t ret={0};
 duk_tval *tv={0};

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff5UL)) {
  ret = ((duk_small_uint_t) (tv)->us[2]);
  do { } while (0);
 } else {
  ret = def_value;

 }

 return ret;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_get_boolean(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 return duk__get_boolean_raw(thr, idx, 0);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_get_boolean_default(duk_hthread *thr, duk_idx_t idx, duk_bool_t def_value) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 return duk__get_boolean_raw(thr, idx, def_value);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_require_boolean(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};
 duk_bool_t ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (__builtin_expect(((((duk_small_uint_t) ((tv))->us[3]) == 0xfff5UL)), 1)) {
  ret = ((duk_small_uint_t) (tv)->us[2]);
  do { } while (0);
  return ret;
 } else {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 1530, (idx), ("boolean")); } while (0);
  do { } while (0);
 }
}

__attribute__ ((visibility("default"))) duk_bool_t duk_opt_boolean(duk_hthread *thr, duk_idx_t idx, duk_bool_t def_value) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  return def_value;
 }
 return duk_require_boolean(thr, idx);
}

static duk_double_t duk__get_number_raw(duk_hthread *thr, duk_idx_t idx, duk_double_t def_value) {
 duk_double_union ret={0};
 duk_tval *tv={0};

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);






 if ((((duk_small_uint_t) (((tv)))->us[3]) <= 0xfff0UL)) {




  ret.d = ((tv)->d);
  do { } while (0);
 } else {
  ret.d = def_value;

 }

 return ret.d;
}

__attribute__ ((visibility("default"))) duk_double_t duk_get_number(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__get_number_raw(thr, idx, (__builtin_nanf ("")));
}

__attribute__ ((visibility("default"))) duk_double_t duk_get_number_default(duk_hthread *thr, duk_idx_t idx, duk_double_t def_value) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__get_number_raw(thr, idx, def_value);
}

__attribute__ ((visibility("default"))) duk_double_t duk_require_number(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};
 duk_double_union ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (__builtin_expect((!(((duk_small_uint_t) ((tv))->us[3]) <= 0xfff0UL)), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 1592, (idx), ("number")); } while (0);
  do { } while (0);
 }

 ret.d = ((tv)->d);





 do { } while (0);
 return ret.d;
}

__attribute__ ((visibility("default"))) duk_double_t duk_opt_number(duk_hthread *thr, duk_idx_t idx, duk_double_t def_value) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {

  return def_value;
 }
 return duk_require_number(thr, idx);
}

__attribute__ ((visibility("default"))) duk_int_t duk_get_int(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 return (duk_int_t) duk__api_coerce_d2i(thr, idx, 0 , 0 );
}

__attribute__ ((visibility("default"))) duk_uint_t duk_get_uint(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 return (duk_uint_t) duk__api_coerce_d2ui(thr, idx, 0 , 0 );
}

__attribute__ ((visibility("default"))) duk_int_t duk_get_int_default(duk_hthread *thr, duk_idx_t idx, duk_int_t def_value) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 return (duk_int_t) duk__api_coerce_d2i(thr, idx, def_value, 0 );
}

__attribute__ ((visibility("default"))) duk_uint_t duk_get_uint_default(duk_hthread *thr, duk_idx_t idx, duk_uint_t def_value) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 return (duk_uint_t) duk__api_coerce_d2ui(thr, idx, def_value, 0 );
}

__attribute__ ((visibility("default"))) duk_int_t duk_require_int(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 return (duk_int_t) duk__api_coerce_d2i(thr, idx, 0 , 1 );
}

__attribute__ ((visibility("default"))) duk_uint_t duk_require_uint(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 return (duk_uint_t) duk__api_coerce_d2ui(thr, idx, 0 , 1 );
}

__attribute__ ((visibility("default"))) duk_int_t duk_opt_int(duk_hthread *thr, duk_idx_t idx, duk_int_t def_value) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  return def_value;
 }
 return duk_require_int(thr, idx);
}

__attribute__ ((visibility("default"))) duk_uint_t duk_opt_uint(duk_hthread *thr, duk_idx_t idx, duk_uint_t def_value) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  return def_value;
 }
 return duk_require_uint(thr, idx);
}

__attribute__ ((visibility("default"))) const char *duk_get_lstring(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_len) {
 duk_hstring *h={0};
 const char *ret={0};
 duk_size_t len={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_get_hstring(thr, idx);
 if (h != ((void *)0)) {
  len = ((h)->blen);
  ret = (const char *) ((const duk_uint8_t *) ((h) + 1));
 } else {
  len = 0;
  ret = ((void *)0);
 }

 if (out_len != ((void *)0)) {
  *out_len = len;
 }
 return ret;
}

__attribute__ ((visibility("default"))) const char *duk_require_lstring(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_len) {
 duk_hstring *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_require_hstring(thr, idx);
 do { } while (0);
 if (out_len) {
  *out_len = ((h)->blen);
 }
 return (const char *) ((const duk_uint8_t *) ((h) + 1));
}

static __attribute__ ((unused)) const char *duk_require_lstring_notsymbol(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_len) {
 duk_hstring *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_require_hstring_notsymbol(thr, idx);
 do { } while (0);
 if (out_len) {
  *out_len = ((h)->blen);
 }
 return (const char *) ((const duk_uint8_t *) ((h) + 1));
}

__attribute__ ((visibility("default"))) const char *duk_get_string(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_get_hstring(thr, idx);
 if (h != ((void *)0)) {
  return (const char *) ((const duk_uint8_t *) ((h) + 1));
 } else {
  return ((void *)0);
 }
}

__attribute__ ((visibility("default"))) const char *duk_opt_lstring(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_len, const char *def_ptr, duk_size_t def_len) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  if (out_len != ((void *)0)) {
   *out_len = def_len;
  }
  return def_ptr;
 }
 return duk_require_lstring(thr, idx, out_len);
}

__attribute__ ((visibility("default"))) const char *duk_opt_string(duk_hthread *thr, duk_idx_t idx, const char *def_ptr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  return def_ptr;
 }
 return duk_require_string(thr, idx);
}

__attribute__ ((visibility("default"))) const char *duk_get_lstring_default(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_len, const char *def_ptr, duk_size_t def_len) {
 duk_hstring *h={0};
 const char *ret={0};
 duk_size_t len={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_get_hstring(thr, idx);
 if (h != ((void *)0)) {
  len = ((h)->blen);
  ret = (const char *) ((const duk_uint8_t *) ((h) + 1));
 } else {
  len = def_len;
  ret = def_ptr;
 }

 if (out_len != ((void *)0)) {
  *out_len = len;
 }
 return ret;
}

__attribute__ ((visibility("default"))) const char *duk_get_string_default(duk_hthread *thr, duk_idx_t idx, const char *def_value) {
 duk_hstring *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_get_hstring(thr, idx);
 if (h != ((void *)0)) {
  return (const char *) ((const duk_uint8_t *) ((h) + 1));
 } else {
  return def_value;
 }
}

static __attribute__ ((unused)) const char *duk_get_string_notsymbol(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_get_hstring_notsymbol(thr, idx);
 if (h) {
  return (const char *) ((const duk_uint8_t *) ((h) + 1));
 } else {
  return ((void *)0);
 }
}

__attribute__ ((visibility("default"))) const char *duk_require_string(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 return duk_require_lstring(thr, idx, ((void *)0));
}

static __attribute__ ((unused)) const char *duk_require_string_notsymbol(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_require_hstring_notsymbol(thr, idx);
 do { } while (0);
 return (const char *) ((const duk_uint8_t *) ((h) + 1));
}

__attribute__ ((visibility("default"))) void duk_require_object(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (__builtin_expect((!(((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 1824, (idx), ("object")); } while (0);
  do { } while (0);
 }
}

static void *duk__get_pointer_raw(duk_hthread *thr, duk_idx_t idx, void *def_value) {
 duk_tval *tv={0};
 void *p={0};

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (!(((duk_small_uint_t) ((tv))->us[3]) == 0xfff6UL)) {
  return def_value;
 }

 p = ((void *) (tv)->vp[0]);
 return p;
}

__attribute__ ((visibility("default"))) void *duk_get_pointer(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__get_pointer_raw(thr, idx, ((void *)0) );
}

__attribute__ ((visibility("default"))) void *duk_opt_pointer(duk_hthread *thr, duk_idx_t idx, void *def_value) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  return def_value;
 }
 return duk_require_pointer(thr, idx);
}

__attribute__ ((visibility("default"))) void *duk_get_pointer_default(duk_hthread *thr, duk_idx_t idx, void *def_value) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__get_pointer_raw(thr, idx, def_value);
}

__attribute__ ((visibility("default"))) void *duk_require_pointer(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};
 void *p={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);




 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (__builtin_expect((!(((duk_small_uint_t) ((tv))->us[3]) == 0xfff6UL)), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 1876, (idx), ("pointer")); } while (0);
  do { } while (0);
 }
 p = ((void *) (tv)->vp[0]);
 return p;
}
static void *duk__get_buffer_helper(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_size, duk_bool_t throw_flag) {
 duk_hbuffer *h={0};
 void *ret={0};
 duk_size_t len={0};
 duk_tval *tv={0};

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (out_size != ((void *)0)) {
  *out_size = 0;
 }

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (__builtin_expect(((((duk_small_uint_t) ((tv))->us[3]) == 0xfffaUL)), 1)) {
  h = ((duk_hbuffer *) (tv)->vp[0]);
  do { } while (0);

  len = (((duk_hbuffer *) (h))->size);
  ret = ( (((&((h))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h))) + 1)) );
 } else {
  if (throw_flag) {
   do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 1924, (idx), ("buffer")); } while (0);
   do { } while (0);
  }
  len = def_size;
  ret = def_ptr;
 }

 if (out_size != ((void *)0)) {
  *out_size = len;
 }
 return ret;
}

__attribute__ ((visibility("default"))) void *duk_get_buffer(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 return duk__get_buffer_helper(thr, idx, out_size, ((void *)0) , 0 , 0 );
}

__attribute__ ((visibility("default"))) void *duk_opt_buffer(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_size) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  if (out_size != ((void *)0)) {
   *out_size = def_size;
  }
  return def_ptr;
 }
 return duk_require_buffer(thr, idx, out_size);
}

__attribute__ ((visibility("default"))) void *duk_get_buffer_default(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_len) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 return duk__get_buffer_helper(thr, idx, out_size, def_ptr, def_len, 0 );
}

__attribute__ ((visibility("default"))) void *duk_require_buffer(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 return duk__get_buffer_helper(thr, idx, out_size, ((void *)0) , 0 , 1 );
}






static __attribute__ ((unused)) void *duk_get_buffer_data_raw(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_size, duk_bool_t throw_flag, duk_bool_t *out_isbuffer) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 if (out_isbuffer != ((void *)0)) {
  *out_isbuffer = 0;
 }
 if (out_size != ((void *)0)) {
  *out_size = def_size;
 }

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);

 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfffaUL)) {
  duk_hbuffer *h = ((duk_hbuffer *) (tv)->vp[0]);
  do { } while (0);
  if (out_size != ((void *)0)) {
   *out_size = (((duk_hbuffer *) (h))->size);
  }
  if (out_isbuffer != ((void *)0)) {
   *out_isbuffer = 1;
  }
  return (void *) ( (((&((h))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h))) + 1)) );
 }

 else if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
  duk_hobject *h = ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);
  if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {



   duk_hbufobj *h_bufobj = (duk_hbufobj *) h;
   do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_bufobj)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);

   if (h_bufobj->buf != ((void *)0) &&
       (((void) 0), ((void) 0), ((h_bufobj)->offset + (h_bufobj)->length <= (((duk_hbuffer *) ((h_bufobj)->buf))->size)))) {
    duk_uint8_t *p={0};

    p = (duk_uint8_t *) ( (((&((h_bufobj->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h_bufobj->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h_bufobj->buf))) + 1)) );
    if (out_size != ((void *)0)) {
     *out_size = (duk_size_t) h_bufobj->length;
    }
    if (out_isbuffer != ((void *)0)) {
     *out_isbuffer = 1;
    }
    return (void *) (p + h_bufobj->offset);
   }

  }
 }


 if (throw_flag) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2028, (idx), ("buffer")); } while (0);
  do { } while (0);
 }
 return def_ptr;
}

__attribute__ ((visibility("default"))) void *duk_get_buffer_data(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk_get_buffer_data_raw(thr, idx, out_size, ((void *)0) , 0 , 0 , ((void *)0));
}

__attribute__ ((visibility("default"))) void *duk_get_buffer_data_default(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_size) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk_get_buffer_data_raw(thr, idx, out_size, def_ptr, def_size, 0 , ((void *)0));
}

__attribute__ ((visibility("default"))) void *duk_opt_buffer_data(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_size) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  if (out_size != ((void *)0)) {
   *out_size = def_size;
  }
  return def_ptr;
 }
 return duk_require_buffer_data(thr, idx, out_size);
}

__attribute__ ((visibility("default"))) void *duk_require_buffer_data(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk_get_buffer_data_raw(thr, idx, out_size, ((void *)0) , 0 , 1 , ((void *)0));
}






static duk_heaphdr *duk__get_tagged_heaphdr_raw(duk_hthread *thr, duk_idx_t idx, duk_uint_t tag) {
 duk_tval *tv={0};
 duk_heaphdr *ret={0};

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (((duk_small_uint_t) (tv)->us[3]) != tag) {
  return (duk_heaphdr *) ((void *)0);
 }

 ret = ((duk_heaphdr *) (tv)->vp[0]);
 do { } while (0);
 return ret;

}

static __attribute__ ((unused)) duk_hstring *duk_get_hstring(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return (duk_hstring *) duk__get_tagged_heaphdr_raw(thr, idx, 0xfff8UL);
}

static __attribute__ ((unused)) duk_hstring *duk_get_hstring_notsymbol(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hstring *) duk__get_tagged_heaphdr_raw(thr, idx, 0xfff8UL);
 if (__builtin_expect((h && (((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
  return ((void *)0);
 }
 return h;
}

static __attribute__ ((unused)) duk_hstring *duk_require_hstring(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hstring *) duk__get_tagged_heaphdr_raw(thr, idx, 0xfff8UL);
 if (__builtin_expect((h == ((void *)0)), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2108, (idx), ("string")); } while (0);
  do { } while (0);
 }
 return h;
}

static __attribute__ ((unused)) duk_hstring *duk_require_hstring_notsymbol(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hstring *) duk__get_tagged_heaphdr_raw(thr, idx, 0xfff8UL);
 if (__builtin_expect((h == ((void *)0) || (((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2121, (idx), ("string")); } while (0);
  do { } while (0);
 }
 return h;
}

static __attribute__ ((unused)) duk_hobject *duk_get_hobject(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, 0xfff9UL);
}

static __attribute__ ((unused)) duk_hobject *duk_require_hobject(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, 0xfff9UL);
 if (__builtin_expect((h == ((void *)0)), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2139, (idx), ("object")); } while (0);
  do { } while (0);
 }
 return h;
}

static __attribute__ ((unused)) duk_hbuffer *duk_get_hbuffer(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return (duk_hbuffer *) duk__get_tagged_heaphdr_raw(thr, idx, 0xfffaUL);
}

static __attribute__ ((unused)) duk_hbuffer *duk_require_hbuffer(duk_hthread *thr, duk_idx_t idx) {
 duk_hbuffer *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hbuffer *) duk__get_tagged_heaphdr_raw(thr, idx, 0xfffaUL);
 if (__builtin_expect((h == ((void *)0)), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2157, (idx), ("buffer")); } while (0);
  do { } while (0);
 }
 return h;
}

static __attribute__ ((unused)) duk_hthread *duk_get_hthread(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, 0xfff9UL);
 if (__builtin_expect((h != ((void *)0) && !((((&((h))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 18)), 0)) {
  h = ((void *)0);
 }
 return (duk_hthread *) h;
}

static __attribute__ ((unused)) duk_hthread *duk_require_hthread(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, 0xfff9UL);
 if (__builtin_expect((!(h != ((void *)0) && ((((&((h))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 18))), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2182, (idx), ("thread")); } while (0);
  do { } while (0);
 }
 return (duk_hthread *) h;
}

static __attribute__ ((unused)) duk_hcompfunc *duk_get_hcompfunc(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, 0xfff9UL);
 if (__builtin_expect((h != ((void *)0) && !(((&(h)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)), 0)) {
  h = ((void *)0);
 }
 return (duk_hcompfunc *) h;
}

static __attribute__ ((unused)) duk_hcompfunc *duk_require_hcompfunc(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, 0xfff9UL);
 if (__builtin_expect((!(h != ((void *)0) && (((&(h)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0))), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2207, (idx), ("compiledfunction")); } while (0);
  do { } while (0);
 }
 return (duk_hcompfunc *) h;
}

static __attribute__ ((unused)) duk_hnatfunc *duk_get_hnatfunc(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, 0xfff9UL);
 if (__builtin_expect((h != ((void *)0) && !(((&(h)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)), 0)) {
  h = ((void *)0);
 }
 return (duk_hnatfunc *) h;
}

static __attribute__ ((unused)) duk_hnatfunc *duk_require_hnatfunc(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, 0xfff9UL);
 if (__builtin_expect((!(h != ((void *)0) && (((&(h)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0))), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2232, (idx), ("nativefunction")); } while (0);
  do { } while (0);
 }
 return (duk_hnatfunc *) h;
}

__attribute__ ((visibility("default"))) duk_c_function duk_get_c_function(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};
 duk_hobject *h={0};
 duk_hnatfunc *f={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (__builtin_expect((!(((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)), 0)) {
  return ((void *)0);
 }
 h = ((duk_hobject *) (tv)->vp[0]);
 do { } while (0);

 if (__builtin_expect((!(((&(h)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)), 0)) {
  return ((void *)0);
 }
 do { } while (0);
 f = (duk_hnatfunc *) h;

 return f->func;
}

__attribute__ ((visibility("default"))) duk_c_function duk_opt_c_function(duk_hthread *thr, duk_idx_t idx, duk_c_function def_value) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  return def_value;
 }
 return duk_require_c_function(thr, idx);
}

__attribute__ ((visibility("default"))) duk_c_function duk_get_c_function_default(duk_hthread *thr, duk_idx_t idx, duk_c_function def_value) {
 duk_c_function ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 ret = duk_get_c_function(thr, idx);
 if (ret != ((void *)0)) {
  return ret;
 }

 return def_value;
}

__attribute__ ((visibility("default"))) duk_c_function duk_require_c_function(duk_hthread *thr, duk_idx_t idx) {
 duk_c_function ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 ret = duk_get_c_function(thr, idx);
 if (__builtin_expect((!ret), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2291, (idx), ("nativefunction")); } while (0);
  do { } while (0);
 }
 return ret;
}

__attribute__ ((visibility("default"))) void duk_require_function(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 if (__builtin_expect((!duk_is_function(thr, idx)), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2300, (idx), ("function")); } while (0);
  do { } while (0);
 }
}

static __attribute__ ((unused)) void duk_require_constructable(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_require_hobject_accept_mask(thr, idx, (1U << 9U));
 if (__builtin_expect((h != ((void *)0) && !(((&(h)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2312, (idx), ("constructable")); } while (0);
  do { } while (0);
 }

}

__attribute__ ((visibility("default"))) duk_hthread *duk_get_context(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 return duk_get_hthread(thr, idx);
}

__attribute__ ((visibility("default"))) duk_hthread *duk_require_context(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 return duk_require_hthread(thr, idx);
}

__attribute__ ((visibility("default"))) duk_hthread *duk_opt_context(duk_hthread *thr, duk_idx_t idx, duk_hthread *def_value) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  return def_value;
 }
 return duk_require_context(thr, idx);
}

__attribute__ ((visibility("default"))) duk_hthread *duk_get_context_default(duk_hthread *thr, duk_idx_t idx, duk_hthread *def_value) {
 duk_hthread *ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 ret = duk_get_context(thr, idx);
 if (ret != ((void *)0)) {
  return ret;
 }

 return def_value;
}

__attribute__ ((visibility("default"))) void *duk_get_heapptr(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};
 void *ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (__builtin_expect((!(((duk_small_uint_t) ((tv))->us[3]) >= 0xfff8UL)), 0)) {
  return (void *) ((void *)0);
 }

 ret = (void *) ((duk_heaphdr *) (tv)->vp[0]);
 do { } while (0);
 return ret;
}

__attribute__ ((visibility("default"))) void *duk_opt_heapptr(duk_hthread *thr, duk_idx_t idx, void *def_value) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  return def_value;
 }
 return duk_require_heapptr(thr, idx);
}

__attribute__ ((visibility("default"))) void *duk_get_heapptr_default(duk_hthread *thr, duk_idx_t idx, void *def_value) {
 void *ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 ret = duk_get_heapptr(thr, idx);
 if (ret != ((void *)0)) {
  return ret;
 }

 return def_value;
}

__attribute__ ((visibility("default"))) void *duk_require_heapptr(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};
 void *ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (__builtin_expect((!(((duk_small_uint_t) ((tv))->us[3]) >= 0xfff8UL)), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2400, (idx), ("heapobject")); } while (0);
  do { } while (0);
 }

 ret = (void *) ((duk_heaphdr *) (tv)->vp[0]);
 do { } while (0);
 return ret;
}


static duk_hobject *duk__get_hobject_promote_mask_raw(duk_hthread *thr, duk_idx_t idx, duk_uint_t type_mask) {
 duk_uint_t val_mask={0};
 duk_hobject *res={0};

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

 res = duk_get_hobject(thr, idx);
 if (__builtin_expect((res != ((void *)0)), 1)) {
  do { } while (0);
  return res;
 }

 val_mask = duk_get_type_mask(thr, idx);
 if (val_mask & type_mask) {
  if (type_mask & (1U << 11)) {
   res = duk_to_hobject(thr, idx);
   do { } while (0);
   return res;
  } else {
   return ((void *)0);
  }
 }

 if (type_mask & (1U << 10)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2434, (idx), ("object")); } while (0);
  do { } while (0);
 }
 return ((void *)0);
}
static __attribute__ ((unused)) duk_hobject *duk_get_hobject_promote_mask(duk_hthread *thr, duk_idx_t idx, duk_uint_t type_mask) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__get_hobject_promote_mask_raw(thr, idx, type_mask | (1U << 11));
}




static __attribute__ ((unused)) duk_hobject *duk_require_hobject_promote_mask(duk_hthread *thr, duk_idx_t idx, duk_uint_t type_mask) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__get_hobject_promote_mask_raw(thr, idx, type_mask | (1U << 10) | (1U << 11));
}




static __attribute__ ((unused)) duk_hobject *duk_require_hobject_accept_mask(duk_hthread *thr, duk_idx_t idx, duk_uint_t type_mask) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__get_hobject_promote_mask_raw(thr, idx, type_mask | (1U << 10));
}

static __attribute__ ((unused)) duk_hobject *duk_get_hobject_with_class(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t classnum) {
 duk_hobject *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 h = (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, 0xfff9UL);
 if (__builtin_expect((h != ((void *)0) && (((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) != classnum), 0)) {
  h = ((void *)0);
 }
 return h;
}

static __attribute__ ((unused)) duk_hobject *duk_require_hobject_with_class(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t classnum) {
 duk_hobject *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 h = (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, 0xfff9UL);
 if (__builtin_expect((!(h != ((void *)0) && (((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == classnum)), 0)) {
  duk_hstring *h_class={0};
  h_class = ((thr)->strs[(duk_class_number_to_stridx[(classnum)])]);
  do { (void) (h_class); } while (0);

  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2495, (idx), ((const char *) ((const duk_uint8_t *) ((h_class) + 1)))); } while (0);
  do { } while (0);
 }
 return h;
}

__attribute__ ((visibility("default"))) duk_size_t duk_get_length(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);

 switch (((duk_small_uint_t) (tv)->us[3])) {
 case 0xfff3UL:
 case 0xfff4UL:
 case 0xfff5UL:
 case 0xfff6UL:
  return 0;
 case 0xfff8UL: {
  duk_hstring *h = ((duk_hstring *) (tv)->vp[0]);
  do { } while (0);
  if (__builtin_expect(((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
   return 0;
  }
  return (duk_size_t) duk_hstring_get_charlen((h));
 }
 case 0xfffaUL: {
  duk_hbuffer *h = ((duk_hbuffer *) (tv)->vp[0]);
  do { } while (0);
  return (duk_size_t) (((duk_hbuffer *) (h))->size);
 }
 case 0xfff7UL: {





  duk_size_t ret={0};
  duk_get_prop_stridx(thr, idx, 86);
  ret = (duk_size_t) duk_to_number_m1(thr);
  duk_pop_unsafe(thr);
  return ret;
 }

 case 0xfff9UL: {
  duk_hobject *h = ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);
  return (duk_size_t) duk_hobject_get_length(thr, h);
 }



 default:

  do { } while (0);
  return 0;
 }

 do { __builtin_unreachable(); } while (0);
}
static duk_heaphdr *duk__known_heaphdr(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};
 duk_heaphdr *h={0};

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
 if (idx < 0) {
  tv = thr->valstack_top + idx;
 } else {
  tv = thr->valstack_bottom + idx;
 }
 do { } while (0);
 do { } while (0);
 h = ((duk_heaphdr *) (tv)->vp[0]);
 do { } while (0);
 return h;
}

static __attribute__ ((unused)) duk_hstring *duk_known_hstring(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 return (duk_hstring *) duk__known_heaphdr(thr, idx);
}

static __attribute__ ((unused)) duk_hobject *duk_known_hobject(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 return (duk_hobject *) duk__known_heaphdr(thr, idx);
}

static __attribute__ ((unused)) duk_hbuffer *duk_known_hbuffer(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 return (duk_hbuffer *) duk__known_heaphdr(thr, idx);
}

static __attribute__ ((unused)) duk_hcompfunc *duk_known_hcompfunc(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 return (duk_hcompfunc *) duk__known_heaphdr(thr, idx);
}

static __attribute__ ((unused)) duk_hnatfunc *duk_known_hnatfunc(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 return (duk_hnatfunc *) duk__known_heaphdr(thr, idx);
}

__attribute__ ((visibility("default"))) void duk_set_length(duk_hthread *thr, duk_idx_t idx, duk_size_t len) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_normalize_index(thr, idx);
 duk_push_uint(thr, (duk_uint_t) len);
 duk_put_prop_stridx(thr, idx, 86);
}
static duk_bool_t duk__defaultvalue_coerce_attempt(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t func_stridx) {
 if (duk_get_prop_stridx(thr, idx, func_stridx)) {

  if (duk_is_function((thr), (-1))) {
   duk_dup(thr, idx);
   duk_call_method(thr, 0);
   if (duk_check_type_mask((thr), (-1), (1U << 1U) | (1U << 2U) | (1U << 3U) | (1U << 4U) | (1U << 5U) | (1U << 8U))) {
    duk_replace(thr, idx);
    return 1;
   }

  }
 }
 duk_pop_unsafe(thr);
 return 0;
}

__attribute__ ((visibility("default"))) void duk_to_undefined(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_require_tval(thr, idx);
 do { } while (0);
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { (tv__dst)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
}

__attribute__ ((visibility("default"))) void duk_to_null(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_require_tval(thr, idx);
 do { } while (0);
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { (tv__dst)->us[3] = (duk_uint16_t) 0xfff4UL; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
}


static const char * const duk__toprim_hint_strings[3] = {
 "default", "string", "number"
};
static void duk__to_primitive_helper(duk_hthread *thr, duk_idx_t idx, duk_int_t hint, duk_bool_t check_symbol) {

 duk_small_uint_t coercers[2]={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 idx = duk_require_normalize_index(thr, idx);


 if (!duk_check_type_mask(thr, idx, (1U << 6U) |
                                    (1U << 9U) |
                                    (1U << 7U))) {
  do { } while (0);
  return;
 }




 if (check_symbol && duk_get_method_stridx(thr, idx, 76)) {
  do { } while (0);
  duk_dup(thr, idx);
  duk_push_string(thr, duk__toprim_hint_strings[hint]);
  duk_call_method(thr, 1);
  if (duk_check_type_mask(thr, -1, (1U << 6U) |
                                          (1U << 9U) |
                                   (1U << 7U))) {
   goto fail;
  }
  duk_replace(thr, idx);
  return;
 }
 if (hint == 0) {
  duk_small_uint_t class_number={0};

  class_number = duk_get_class_number(thr, idx);
  if (class_number == 6) {
   hint = 1;
  } else {
   hint = 2;
  }
 }


 coercers[0] = 40;
 coercers[1] = 82;
 if (hint == 1) {
  coercers[0] = 82;
  coercers[1] = 40;
 }

 if (duk__defaultvalue_coerce_attempt(thr, idx, coercers[0])) {
  do { } while (0);
  return;
 }

 if (duk__defaultvalue_coerce_attempt(thr, idx, coercers[1])) {
  do { } while (0);
  return;
 }

 fail:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 2772; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_stack.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("coercion to primitive failed"))); } while (0); } while (0);
 do { } while (0);
}

__attribute__ ((visibility("default"))) void duk_to_primitive(duk_hthread *thr, duk_idx_t idx, duk_int_t hint) {
 duk__to_primitive_helper(thr, idx, hint, 1 );
}
__attribute__ ((visibility("default"))) duk_bool_t duk_to_boolean(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};
 duk_bool_t val={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx));
 do { } while (0);

 val = duk_js_toboolean(tv);
 do { } while (0);


 do { } while (0);
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((val)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
 return val;
}

static __attribute__ ((unused)) duk_bool_t duk_to_boolean_top_pop(duk_hthread *thr) {
 duk_tval *tv={0};
 duk_bool_t val={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_require_tval(thr, -1);
 do { } while (0);

 val = duk_js_toboolean(tv);
 do { } while (0);

 duk_pop_unsafe(thr);
 return val;
}

__attribute__ ((visibility("default"))) duk_double_t duk_to_number(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};
 duk_double_t d={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);




 idx = duk_require_normalize_index(thr, idx);
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx));
 do { } while (0);
 d = duk_js_tonumber(thr, tv);


 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx));
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_double_t duk__dblval; duk__dblval = (((d))); ; do { (((tv__dst)))->d = (duk__dblval); } while (0); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
 return d;
}

static __attribute__ ((unused)) duk_double_t duk_to_number_m1(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk_to_number(thr, -1);
}
static __attribute__ ((unused)) duk_double_t duk_to_number_m2(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk_to_number(thr, -2);
}

static __attribute__ ((unused)) duk_double_t duk_to_number_tval(duk_hthread *thr, duk_tval *tv) {
 duk_double_t res={0};
 duk_tval *tv_dst={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { do { } while (0); } while (0);

 tv_dst = thr->valstack_top++;
 do { *(tv_dst) = *(tv); } while (0);
 do { duk_tval *duk__tv = ((tv_dst)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 res = duk_to_number_m1(thr);

 tv_dst = --thr->valstack_top;
 do { } while (0);
 do { } while (0);
 do { (tv_dst)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);

 return res;

}





typedef duk_double_t (*duk__toint_coercer)(duk_hthread *thr, duk_tval *tv);

static duk_double_t duk__to_int_uint_helper(duk_hthread *thr, duk_idx_t idx, duk__toint_coercer coerce_func) {
 duk_tval *tv={0};
 duk_double_t d={0};

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_require_tval(thr, idx);
 do { } while (0);
 d = coerce_func(thr, tv);




 tv = duk_require_tval(thr, idx);
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_double_t duk__dblval; duk__dblval = (((d))); ; do { (((tv__dst)))->d = (duk__dblval); } while (0); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
 return d;
}

__attribute__ ((visibility("default"))) duk_int_t duk_to_int(duk_hthread *thr, duk_idx_t idx) {



 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 (void) duk__to_int_uint_helper(thr, idx, duk_js_tointeger);
 return (duk_int_t) duk__api_coerce_d2i(thr, idx, 0 , 0 );
}

__attribute__ ((visibility("default"))) duk_uint_t duk_to_uint(duk_hthread *thr, duk_idx_t idx) {



 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 (void) duk__to_int_uint_helper(thr, idx, duk_js_tointeger);
 return (duk_uint_t) duk__api_coerce_d2ui(thr, idx, 0 , 0 );
}

__attribute__ ((visibility("default"))) duk_int32_t duk_to_int32(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};
 duk_int32_t ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_require_tval(thr, idx);
 do { } while (0);
 ret = duk_js_toint32(thr, tv);


 tv = duk_require_tval(thr, idx);
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = ((tv)); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_double_t duk__dblval; duk__dblval = (((duk_double_t) (ret))); ; do { ((tv__dst))->d = (duk__dblval); } while (0); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((((thr)))), duk__h); } } } while (0); } while (0);
 return ret;
}

__attribute__ ((visibility("default"))) duk_uint32_t duk_to_uint32(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};
 duk_uint32_t ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_require_tval(thr, idx);
 do { } while (0);
 ret = duk_js_touint32(thr, tv);


 tv = duk_require_tval(thr, idx);
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = ((tv)); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_double_t duk__dblval; duk__dblval = (((duk_double_t) (ret))); ; do { ((tv__dst))->d = (duk__dblval); } while (0); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((((thr)))), duk__h); } } } while (0); } while (0);
 return ret;
}

__attribute__ ((visibility("default"))) duk_uint16_t duk_to_uint16(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};
 duk_uint16_t ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_require_tval(thr, idx);
 do { } while (0);
 ret = duk_js_touint16(thr, tv);


 tv = duk_require_tval(thr, idx);
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = ((tv)); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_double_t duk__dblval; duk__dblval = (((duk_double_t) (ret))); ; do { ((tv__dst))->d = (duk__dblval); } while (0); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((((thr)))), duk__h); } } } while (0); } while (0);
 return ret;
}



static __attribute__ ((unused)) duk_uint8_t duk_to_uint8clamped(duk_hthread *thr, duk_idx_t idx) {
 duk_double_t d={0};
 duk_double_t t={0};
 duk_uint8_t ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);






 d = duk_to_number(thr, idx);
 if (d <= 0.0) {
  return 0;
 } else if (d >= 255) {
  return 255;
 } else if ((sizeof (d) == sizeof (float) ? __isnanf (d) : sizeof (d) == sizeof (double) ? __isnan (d) : __isnanl (d))) {

  return 0;
 }

 t = d - floor(d);
 if (t == 0.5) {

  ret = (duk_uint8_t) d;
  ret = (ret + 1) & 0xfe;


 } else {

  ret = (duk_uint8_t) (d + 0.5);
 }
 return ret;
}


__attribute__ ((visibility("default"))) const char *duk_to_lstring(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_len) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 (void) duk_to_string(thr, idx);
 do { } while (0);
 return duk_require_lstring(thr, idx, out_len);
}

static duk_ret_t duk__safe_to_string_raw(duk_hthread *thr, void *udata) {
 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { (void) (udata); } while (0);

 duk_to_string(thr, -1);
 return 1;
}

__attribute__ ((visibility("default"))) const char *duk_safe_to_lstring(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_len) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);






 duk_dup(thr, idx);
 (void) duk_safe_call(thr, duk__safe_to_string_raw, ((void *)0) , 1 , 1 );
 if (!duk_is_string(thr, -1)) {

  (void) duk_safe_call(thr, duk__safe_to_string_raw, ((void *)0) , 1 , 1 );
  if (!duk_is_string(thr, -1)) {

   duk_pop_unsafe(thr);
   duk_push_hstring_stridx(thr, 12);
  } else {
   ;
  }
 } else {

  ;
 }
 do { } while (0);

 duk_replace(thr, idx);
 do { } while (0);
 return duk_get_lstring(thr, idx, out_len);
}

static __attribute__ ((unused)) duk_hstring *duk_to_property_key_hstring(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk_to_primitive(thr, idx, 1);
 h = duk_get_hstring(thr, idx);
 if (h == ((void *)0)) {





  h = duk_to_hstring(thr, idx);
 }
 do { } while (0);
 return h;
}
static __attribute__ ((unused)) void duk_push_class_string_tval(duk_hthread *thr, duk_tval *tv, duk_bool_t avoid_side_effects) {
 duk_hobject *h_obj={0};
 duk_small_uint_t classnum={0};
 duk_small_uint_t stridx={0};
 duk_tval tv_tmp={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);


 do { *(&tv_tmp) = *(tv); } while (0);
 tv = &tv_tmp;
 duk_push_literal_raw((thr), ("[object "), sizeof(("[object ")) - 1U);

 switch (((duk_small_uint_t) (tv)->us[3])) {
 case 0xfff2UL:
 case 0xfff3UL: {
  duk_push_hstring_stridx(thr, 0);
  goto finish;
 }
 case 0xfff4UL: {
  duk_push_hstring_stridx(thr, 1);
  goto finish;
 }
 }

 duk_push_tval(thr, tv);
 tv = ((void *)0);
 duk_to_object(thr, -1);
 do { (void) (avoid_side_effects); } while (0);


 h_obj = duk_known_hobject(thr, -1);
 do { } while (0);
 classnum = (((&(h_obj)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL));
 stridx = duk_class_number_to_stridx[(classnum)];
 duk_pop_unsafe(thr);
 duk_push_hstring_stridx(thr, stridx);

 finish:

 duk_push_literal_raw((thr), ("]"), sizeof(("]")) - 1U);
 duk_concat(thr, 3);
}


static __attribute__ ((unused)) duk_int_t duk_to_int_clamped_raw(duk_hthread *thr, duk_idx_t idx, duk_int_t minval, duk_int_t maxval, duk_bool_t *out_clamped) {
 duk_tval *tv={0};
 duk_tval tv_tmp={0};
 duk_double_t d, dmin, dmax={0};
 duk_int_t res={0};
 duk_bool_t clamped = 0;

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_require_tval(thr, idx);
 do { } while (0);
 d = duk_js_tointeger(thr, tv);

 dmin = (duk_double_t) minval;
 dmax = (duk_double_t) maxval;

 if (d < dmin) {
  clamped = 1;
  res = minval;
  d = dmin;
 } else if (d > dmax) {
  clamped = 1;
  res = maxval;
  d = dmax;
 } else {
  res = (duk_int_t) d;
 }
 do { (void) (d); } while (0);



 tv = duk_get_tval(thr, idx);
 do { } while (0);
 do { *(&tv_tmp) = *(tv); } while (0);
 do { duk_double_t duk__dblval; duk__dblval = ((d)); ; do { (((tv)))->d = (duk__dblval); } while (0); } while (0);

 do { duk_tval *duk__tv = ((&tv_tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((thr)), duk__h); } } } while (0);

 if (out_clamped) {
  *out_clamped = clamped;
 } else {

  if (clamped) {
   do { duk_err_range((thr), "duk_api_stack.c", (duk_int_t) 3363, ("number outside range")); } while (0);
   do { } while (0);
  }
 }

 return res;
}

static __attribute__ ((unused)) duk_int_t duk_to_int_clamped(duk_hthread *thr, duk_idx_t idx, duk_idx_t minval, duk_idx_t maxval) {
 duk_bool_t dummy={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 return duk_to_int_clamped_raw(thr, idx, minval, maxval, &dummy);
}

static __attribute__ ((unused)) duk_int_t duk_to_int_check_range(duk_hthread *thr, duk_idx_t idx, duk_int_t minval, duk_int_t maxval) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk_to_int_clamped_raw(thr, idx, minval, maxval, ((void *)0));
}

__attribute__ ((visibility("default"))) const char *duk_to_string(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx));
 do { } while (0);

 switch (((duk_small_uint_t) (tv)->us[3])) {
 case 0xfff3UL: {
  duk_push_hstring_stridx(thr, 58);
  break;
 }
 case 0xfff4UL: {
  duk_push_hstring_stridx(thr, 154);
  break;
 }
 case 0xfff5UL: {
  if (((duk_small_uint_t) (tv)->us[2])) {
   duk_push_hstring_stridx(thr, 155);
  } else {
   duk_push_hstring_stridx(thr, 156);
  }
  break;
 }
 case 0xfff8UL: {






  duk_hstring *h={0};
  h = ((duk_hstring *) (tv)->vp[0]);
  do { } while (0);
  if (__builtin_expect(((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
   do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 3421; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_stack.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("cannot string coerce Symbol"))); } while (0); } while (0);
   do { } while (0);
  } else {
   goto skip_replace;
  }



  break;
 }
 case 0xfffaUL:
 case 0xfff9UL: {






  duk_to_primitive(thr, idx, 1);
  do { } while (0);
  do { } while (0);
  return duk_to_string(LAVALOG(13910445, thr + (lava_get(12) * (0x6e414147 == lava_get(12))), (0x6e414147 == lava_get(12))), idx);
 }
 case 0xfff6UL: {
  void *ptr = ((void *) (tv)->vp[0]);
  if (ptr != ((void *)0)) {
   duk_push_sprintf(thr, "%p", (void *) ptr);
  } else {




   duk_push_hstring_stridx(thr, 154);
  }
  break;
 }
 case 0xfff7UL: {

  duk_push_lightfunc_tostring(thr, tv);
  break;
 }



 default: {

  do { } while (0);
  do { } while (0);
  duk_push_tval(thr, tv);
  duk_numconv_stringify(thr,
                        10 ,
                        0 ,
                        0 );
  break;
 }
 }

 duk_replace(thr, idx);

 skip_replace:
 do { } while (0);
 return duk_require_string(thr, idx);
}

static __attribute__ ((unused)) duk_hstring *duk_to_hstring(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk_to_string(thr, idx);
 ret = duk_get_hstring(thr, idx);
 do { } while (0);
 return ret;
}

static __attribute__ ((unused)) duk_hstring *duk_to_hstring_m1(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk_to_hstring(thr, -1);
}

static __attribute__ ((unused)) duk_hstring *duk_to_hstring_acceptsymbol(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 ret = duk_get_hstring(thr, idx);
 if (__builtin_expect((ret && (((&(ret)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
  return ret;
 }
 return duk_to_hstring(thr, idx);
}
__attribute__ ((visibility("default"))) const char *duk_buffer_to_string(duk_hthread *thr, duk_idx_t idx) {
 void *ptr_src={0};
 duk_size_t len={0};
 const char *res={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);

 ptr_src = duk_require_buffer_data(thr, idx, &len);
 do { } while (0);

 res = duk_push_lstring(thr, (const char *) ptr_src, len);
 duk_replace(thr, idx);
 return res;
}

__attribute__ ((visibility("default"))) void *duk_to_buffer_raw(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size, duk_uint_t mode) {
 duk_hbuffer *h_buf={0};
 const duk_uint8_t *src_data={0};
 duk_size_t src_size={0};
 duk_uint8_t *dst_data={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);

 h_buf = duk_get_hbuffer(thr, idx);
 if (h_buf != ((void *)0)) {





  duk_uint_t tmp={0};
  duk_uint8_t *tmp_ptr={0};

  tmp_ptr = (duk_uint8_t *) ( (((&((h_buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h_buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h_buf))) + 1)) );
  src_data = (const duk_uint8_t *) tmp_ptr;
  src_size = (((duk_hbuffer *) (h_buf))->size);

  tmp = ((((&(h_buf)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? 1 : 0);
  if ((tmp == mode && !(((&(h_buf)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)) ||
      mode == 2) {



   dst_data = tmp_ptr;
   goto skip_copy;
  }
 } else {





  src_data = (const duk_uint8_t *) duk_to_lstring(thr, idx, &src_size);
 }

 dst_data = (duk_uint8_t *) duk_push_buffer_raw((thr), (src_size), ((mode == 1)) ? (1 << 0) : 0);

 do { void *duk__dst = ((void *) dst_data); const void *duk__src = ((const void *) src_data); duk_size_t duk__len = ((size_t) src_size); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, LAVALOG(5926412, (size_t) duk__len + (lava_get(8) * (0x6f576954 == lava_get(8))), (0x6f576954 == lava_get(8)))); } } while (0);

 duk_replace(thr, idx);
 skip_copy:

 if (out_size) {
  *out_size = src_size;
 }
 return dst_data;
}

__attribute__ ((visibility("default"))) void *duk_to_pointer(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};
 void *res={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx));
 do { } while (0);

 switch (((duk_small_uint_t) (tv)->us[3])) {
 case 0xfff3UL:
 case 0xfff4UL:
 case 0xfff5UL:
  res = ((void *)0);
  break;
 case 0xfff6UL:
  res = ((void *) (tv)->vp[0]);
  break;
 case 0xfff8UL:
 case 0xfff9UL:
 case 0xfffaUL:



  res = (void *) ((duk_heaphdr *) (tv)->vp[0]);
  break;
 case 0xfff7UL:




  res = ((void *)0);
  break;



 default:

  do { } while (0);
  do { } while (0);
  res = ((void *)0);
  break;
 }

 duk_push_pointer(thr, res);
 duk_replace(thr, idx);
 return res;
}

static void duk__push_func_from_lightfunc(duk_hthread *thr, duk_c_function func, duk_small_uint_t lf_flags) {
 duk_idx_t nargs={0};
 duk_uint_t flags = 0;
 duk_small_uint_t lf_len={0};
 duk_hnatfunc *nf={0};

 nargs = (duk_idx_t) ((lf_flags) & 0x0fU);
 if (nargs == 0x0f) {
  nargs = (duk_idx_t) ((duk_int_t) (-1));
 }

 flags = (1UL << (7 + (0))) |
         (1UL << (7 + (1))) |
         (1UL << (7 + (2))) |
         (1UL << (7 + (7))) |
         (1UL << (7 + (5))) |
         (1UL << (7 + (11))) |
         (1UL << (7 + (9))) |
         (1UL << (7 + (10))) |
         (((duk_uint_t) (3)) << (7 + (20)));
 (void) duk__push_c_function_raw(thr, func, nargs, flags, 6);

 lf_len = (((lf_flags) >> 4) & 0x0fU);
 if ((duk_idx_t) lf_len != nargs) {

  duk_push_int(thr, (duk_int_t) lf_len);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (86)) << 8) + (duk_uint_t) (0)));
 }


 duk_push_lightfunc_name_raw(thr, func, lf_flags);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (92)) << 8) + (duk_uint_t) (((1U << 2)))));


 nf = duk_known_hnatfunc(thr, -1);
 nf->magic = (duk_int16_t) ((duk_int32_t) (duk_int8_t) (((duk_uint16_t) (lf_flags)) >> 8));
}

__attribute__ ((visibility("default"))) void duk_to_object(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};
 duk_uint_t flags = 0;
 duk_small_int_t proto = 0;

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx));
 do { } while (0);

 switch (((duk_small_uint_t) (tv)->us[3])) {



 case 0xfff3UL:
 case 0xfff4UL: {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 3697; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_stack.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not object coercible"))); } while (0); } while (0);
  do { } while (0);
  break;
 }
 case 0xfff5UL: {
  flags = (1UL << (7 + (0))) |
          (1UL << (7 + (7))) |
          (((duk_uint_t) (5)) << (7 + (20)));
  proto = 12;
  goto create_object;
 }
 case 0xfff8UL: {
  duk_hstring *h={0};
  h = ((duk_hstring *) (tv)->vp[0]);
  do { } while (0);
  if (__builtin_expect(((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
   flags = (1UL << (7 + (0))) |
           (1UL << (7 + (7))) |
           (((duk_uint_t) (14)) << (7 + (20)));
   proto = 38;
  } else {
   flags = (1UL << (7 + (0))) |
           (1UL << (7 + (7))) |
           (1UL << (7 + (16))) |
           (((duk_uint_t) (12)) << (7 + (20)));
   proto = 10;
  }
  goto create_object;
 }
 case 0xfff9UL: {

  break;
 }

 case 0xfffaUL: {







  duk_hbuffer *h_buf={0};

  h_buf = ((duk_hbuffer *) (tv)->vp[0]);
  do { } while (0);
  duk_hbufobj_push_uint8array_from_plain(thr, h_buf);
  goto replace_value;
 }

 case 0xfff6UL: {
  flags = (1UL << (7 + (0))) |
          (1UL << (7 + (7))) |
          (((duk_uint_t) (17)) << (7 + (20)));
  proto = 36;
  goto create_object;
 }
 case 0xfff7UL: {
  duk_small_uint_t lf_flags={0};
  duk_c_function func={0};

  do { (lf_flags) = (tv)->ui[1] & 0xffffUL; (func) = (duk_c_function) (tv)->ui[0]; } while (0);
  duk__push_func_from_lightfunc(thr, func, lf_flags);
  goto replace_value;
 }



 default: {
  do { } while (0);
  do { } while (0);
  flags = (1UL << (7 + (0))) |
          (1UL << (7 + (7))) |
          (((duk_uint_t) (10)) << (7 + (20)));
  proto = 14;
  goto create_object;
 }
 }
 do { } while (0);
 return;

 create_object:
 (void) duk_push_object_helper(thr, flags, proto);
 duk_dup(thr, idx);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (105)) << 8) + (duk_uint_t) (0)));

 replace_value:
 duk_replace(thr, idx);
 do { } while (0);
}

static __attribute__ ((unused)) duk_hobject *duk_to_hobject(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk_to_object(thr, idx);
 ret = duk_known_hobject(thr, idx);
 return ret;
}





static duk_bool_t duk__tag_check(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t tag) {
 duk_tval *tv={0};

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 return (((duk_small_uint_t) (tv)->us[3]) == tag);
}

static duk_bool_t duk__obj_flag_any_default_false(duk_hthread *thr, duk_idx_t idx, duk_uint_t flag_mask) {
 duk_hobject *obj={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 obj = duk_get_hobject(thr, idx);
 if (obj) {
  return (((((duk_heaphdr *) obj)->h_flags & (flag_mask)) != 0) ? 1 : 0);
 }
 return 0;
}

static __attribute__ ((unused)) duk_int_t duk_get_type_tval(duk_tval *tv) {
 do { } while (0);


 switch (((duk_small_uint_t) (tv)->us[3])) {
 case 0xfff2UL:
  return 0U;
 case 0xfff3UL:
  return 1U;
 case 0xfff4UL:
  return 2U;
 case 0xfff5UL:
  return 3U;
 case 0xfff8UL:
  return 5U;
 case 0xfff9UL:
  return 6U;
 case 0xfffaUL:
  return 7U;
 case 0xfff6UL:
  return 8U;
 case 0xfff7UL:
  return 9U;



 default:

  do { } while (0);
  do { } while (0);
  return 4U;
 }





}

__attribute__ ((visibility("default"))) duk_int_t duk_get_type(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);

 return duk_get_type_tval(tv);
}
static __attribute__ ((unused)) duk_small_uint_t duk_get_class_number(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};
 duk_hobject *obj={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);

 switch (((duk_small_uint_t) (tv)->us[3])) {
 case 0xfff9UL:
  obj = ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);
  return (((&(obj)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL));
 case 0xfffaUL:

  return 22;
 case 0xfff7UL:

  return 3;
 default:

  return 0;
 }
}

__attribute__ ((visibility("default"))) duk_bool_t duk_check_type(duk_hthread *thr, duk_idx_t idx, duk_int_t type) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 return (duk_get_type(thr, idx) == type) ? 1 : 0;
}

static __attribute__ ((unused)) duk_uint_t duk_get_type_mask_tval(duk_tval *tv) {
 do { } while (0);


 switch (((duk_small_uint_t) (tv)->us[3])) {
 case 0xfff2UL:
  return (1U << 0U);
 case 0xfff3UL:
  return (1U << 1U);
 case 0xfff4UL:
  return (1U << 2U);
 case 0xfff5UL:
  return (1U << 3U);
 case 0xfff8UL:
  return (1U << 5U);
 case 0xfff9UL:
  return (1U << 6U);
 case 0xfffaUL:
  return (1U << 7U);
 case 0xfff6UL:
  return (1U << 8U);
 case 0xfff7UL:
  return (1U << 9U);



 default:

  do { } while (0);
  do { } while (0);
  return (1U << 4U);
 }





}

__attribute__ ((visibility("default"))) duk_uint_t duk_get_type_mask(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);

 return duk_get_type_mask_tval(tv);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_check_type_mask(duk_hthread *thr, duk_idx_t idx, duk_uint_t mask) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 if (__builtin_expect(((duk_get_type_mask(thr, idx) & mask) != 0U), 1)) {
  return 1;
 }
 if (mask & (1U << 10)) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4005; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_stack.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("unexpected type"))); } while (0); } while (0);
  do { } while (0);
 }
 return 0;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_undefined(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__tag_check(thr, idx, 0xfff3UL);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_null(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__tag_check(thr, idx, 0xfff4UL);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_boolean(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__tag_check(thr, idx, 0xfff5UL);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_number(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 return (((duk_small_uint_t) ((tv))->us[3]) <= 0xfff0UL);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_nan(duk_hthread *thr, duk_idx_t idx) {






 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);


 if (!(((duk_small_uint_t) ((tv))->us[3]) <= 0xfff0UL)) {
  return 0;
 }
 return (duk_bool_t) (sizeof (((tv)->d)) == sizeof (float) ? __isnanf (((tv)->d)) : sizeof (((tv)->d)) == sizeof (double) ? __isnan (((tv)->d)) : __isnanl (((tv)->d)));
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_string(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__tag_check(thr, idx, 0xfff8UL);
}

static __attribute__ ((unused)) duk_bool_t duk_is_string_notsymbol(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk_get_hstring_notsymbol(thr, idx) != ((void *)0);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_object(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__tag_check(thr, idx, 0xfff9UL);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_buffer(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__tag_check(thr, idx, 0xfffaUL);
}


__attribute__ ((visibility("default"))) duk_bool_t duk_is_buffer_data(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfffaUL)) {
  return 1;
 } else if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
  duk_hobject *h = ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);
  if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {
   return 1;
  }
 }
 return 0;
}
__attribute__ ((visibility("default"))) duk_bool_t duk_is_pointer(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__tag_check(thr, idx, 0xfff6UL);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_lightfunc(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__tag_check(thr, idx, 0xfff7UL);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_symbol(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 h = duk_get_hstring(thr, idx);



 if (__builtin_expect((h != ((void *)0) && (((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 1)) {
  return 1;
 }
 return 0;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_array(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *obj={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 obj = duk_get_hobject(thr, idx);
 if (obj) {
  return ((((&(obj)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 2 ? 1 : 0);
 }
 return 0;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_function(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
  duk_hobject *h={0};
  h = ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);
  return (((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0) ? 1 : 0;
 }
 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff7UL)) {
  return 1;
 }
 return 0;
}

static __attribute__ ((unused)) duk_bool_t duk_is_callable_tval(duk_hthread *thr, duk_tval *tv) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 do { (void) (thr); } while (0);

 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
  duk_hobject *h={0};
  h = ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);
  return (((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0) ? 1 : 0;
 }
 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff7UL)) {
  return 1;
 }
 return 0;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_constructable(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
  duk_hobject *h={0};
  h = ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);
  return (((&(h)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0) ? 1 : 0;
 }
 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff7UL)) {
  return 1;
 }
 return 0;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_c_function(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__obj_flag_any_default_false(thr,
                                        idx,
                                        (1UL << (7 + (5))));
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_ecmascript_function(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__obj_flag_any_default_false(thr,
                                        idx,
                                        (1UL << (7 + (4))));
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_bound_function(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__obj_flag_any_default_false(thr,
                                        idx,
                                        (1UL << (7 + (3))));
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_thread(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *obj={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 obj = duk_get_hobject(thr, idx);
 if (obj) {
  return ((((&(obj)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 18 ? 1 : 0);
 }
 return 0;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_fixed_buffer(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfffaUL)) {
  duk_hbuffer *h = ((duk_hbuffer *) (tv)->vp[0]);
  do { } while (0);
  return ((((&(h)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? 0 : 1);
 }
 return 0;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_dynamic_buffer(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfffaUL)) {
  duk_hbuffer *h = ((duk_hbuffer *) (tv)->vp[0]);
  do { } while (0);
  return ((((&(h)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) && !(((&(h)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0) ? 1 : 0);
 }
 return 0;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_external_buffer(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfffaUL)) {
  duk_hbuffer *h = ((duk_hbuffer *) (tv)->vp[0]);
  do { } while (0);
  return ((((&(h)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) && (((&(h)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0) ? 1 : 0);
 }
 return 0;
}

__attribute__ ((visibility("default"))) duk_errcode_t duk_get_error_code(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *h={0};
 duk_uint_t sanity={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_get_hobject(thr, idx);

 sanity = 10000L;
 do {
  if (!h) {
   return 0;
  }



  if (h == thr->builtins[22]) {
   return 2;
  }
  if (h == thr->builtins[24]) {
   return 3;
  }
  if (h == thr->builtins[26]) {
   return 4;
  }
  if (h == thr->builtins[28]) {
   return 5;
  }
  if (h == thr->builtins[30]) {
   return 6;
  }
  if (h == thr->builtins[32]) {
   return 7;
  }
  if (h == thr->builtins[20]) {
   return 1;
  }

  h = ((h)->prototype);
 } while (--sanity > 0);

 return 0;
}





static __attribute__ ((unused)) void duk_push_tval(duk_hthread *thr, duk_tval *tv) {
 duk_tval *tv_slot={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4333); } while (0); } } while (0);
 tv_slot = thr->valstack_top++;
 do { *(tv_slot) = *(tv); } while (0);
 do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
}

__attribute__ ((visibility("default"))) void duk_push_undefined(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4342); } while (0); } } while (0);




 thr->valstack_top++;
 do { } while (0);
}

__attribute__ ((visibility("default"))) void duk_push_null(duk_hthread *thr) {
 duk_tval *tv_slot={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4355); } while (0); } } while (0);
 tv_slot = thr->valstack_top++;
 do { (tv_slot)->us[3] = (duk_uint16_t) 0xfff4UL; } while (0);
}

__attribute__ ((visibility("default"))) void duk_push_boolean(duk_hthread *thr, duk_bool_t val) {
 duk_tval *tv_slot={0};
 duk_small_int_t b={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4365); } while (0); } } while (0);
 b = (val ? 1 : 0);
 tv_slot = thr->valstack_top++;
 do { ((tv_slot))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) (b))); } while (0);
}

__attribute__ ((visibility("default"))) void duk_push_true(duk_hthread *thr) {
 duk_tval *tv_slot={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4375); } while (0); } } while (0);
 tv_slot = thr->valstack_top++;
 do { (((tv_slot)))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) (1))); } while (0);
}

__attribute__ ((visibility("default"))) void duk_push_false(duk_hthread *thr) {
 duk_tval *tv_slot={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4384); } while (0); } } while (0);
 tv_slot = thr->valstack_top++;
 do { (((tv_slot)))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) (0))); } while (0);
}


__attribute__ ((visibility("default"))) void duk_push_number(duk_hthread *thr, duk_double_t val) {
 duk_tval *tv_slot={0};
 duk_double_union du={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4395); } while (0); } } while (0);
 du.d = val;
 do { if (((((((&du)))->us[3] & 0x7ff0UL) == 0x7ff0UL) && (((((&du)))->us[3] & 0x000fUL) != 0x0000UL))) { do { (((&du)))->us[3] = 0x7ff8UL; } while (0); } } while (0);
 tv_slot = thr->valstack_top++;
 do { duk_double_t duk__dblval; duk__dblval = ((du.d)); ; do { (((tv_slot)))->d = (duk__dblval); } while (0); } while (0);
}

__attribute__ ((visibility("default"))) void duk_push_int(duk_hthread *thr, duk_int_t val) {
 duk_tval *tv_slot={0};
 duk_double_t d={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4424); } while (0); } } while (0);
 d = (duk_double_t) val;
 tv_slot = thr->valstack_top++;
 do { duk_double_t duk__dblval; duk__dblval = ((d)); ; do { (((tv_slot)))->d = (duk__dblval); } while (0); } while (0);

}

__attribute__ ((visibility("default"))) void duk_push_uint(duk_hthread *thr, duk_uint_t val) {
 duk_tval *tv_slot={0};
 duk_double_t d={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4454); } while (0); } } while (0);
 d = (duk_double_t) val;
 tv_slot = thr->valstack_top++;
 do { duk_double_t duk__dblval; duk__dblval = ((d)); ; do { (((tv_slot)))->d = (duk__dblval); } while (0); } while (0);

}

__attribute__ ((visibility("default"))) void duk_push_nan(duk_hthread *thr) {
 duk_tval *tv_slot={0};
 duk_double_union du={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4466); } while (0); } } while (0);
 do { ((&du))->us[3] = 0x7ff8UL; } while (0);
 do { } while (0);
 tv_slot = thr->valstack_top++;
 do { duk_double_t duk__dblval; duk__dblval = ((du.d)); ; do { (((tv_slot)))->d = (duk__dblval); } while (0); } while (0);
}

__attribute__ ((visibility("default"))) const char *duk_push_lstring(duk_hthread *thr, const char *str, duk_size_t len) {
 duk_hstring *h={0};
 duk_tval *tv_slot={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);


 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4480); } while (0); } } while (0);






 if (__builtin_expect((str == ((void *)0)), 0)) {
  len = 0U;
 }


 if (__builtin_expect((len > (0x7fffffffUL)), 0)) {
  do { duk_err_range((thr), "duk_api_stack.c", (duk_int_t) 4493, ("string too long")); } while (0);
  do { } while (0);
 }

 h = duk_heap_strtable_intern_checked(thr, (const duk_uint8_t *) str, (duk_uint32_t) len);
 do { } while (0);

 tv_slot = thr->valstack_top++;
 do { ((tv_slot))->ull[0] = (((duk_uint64_t) (0xfff8UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((h))); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

 return (const char *) ((const duk_uint8_t *) ((h) + 1));
}

__attribute__ ((visibility("default"))) const char *duk_push_string(duk_hthread *thr, const char *str) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 if (str) {
  return duk_push_lstring(thr, str, strlen(str));
 } else {
  duk_push_null(thr);
  return ((void *)0);
 }
}



__attribute__ ((visibility("default"))) const char *duk_push_literal_raw(duk_hthread *thr, const char *str, duk_size_t len) {
 duk_hstring *h={0};
 duk_tval *tv_slot={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);


 if (__builtin_expect((len > (0x7fffffffUL)), 0)) {
  do { duk_err_range((thr), "duk_api_stack.c", (duk_int_t) 4530, ("string too long")); } while (0);
  do { } while (0);
 }

 h = duk_heap_strtable_intern_literal_checked(thr, (const duk_uint8_t *) str, (duk_uint32_t) len);
 do { } while (0);

 tv_slot = thr->valstack_top++;
 do { ((tv_slot))->ull[0] = (((duk_uint64_t) (0xfff8UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((h))); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

 return (const char *) ((const duk_uint8_t *) ((h) + 1));
}
__attribute__ ((visibility("default"))) void duk_push_pointer(duk_hthread *thr, void *val) {
 duk_tval *tv_slot={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4558); } while (0); } } while (0);
 tv_slot = thr->valstack_top++;
 do { ((tv_slot))->ull[0] = (((duk_uint64_t) (0xfff6UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((val))); } while (0);
}

static __attribute__ ((unused)) duk_hstring *duk_push_uint_to_hstring(duk_hthread *thr, duk_uint_t i) {
 duk_hstring *h_tmp={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);


 duk_push_uint(thr, (duk_uint_t) i);
 h_tmp = duk_to_hstring_m1(thr);
 do { } while (0);
 return h_tmp;
}

static void duk__push_this_helper(duk_hthread *thr, duk_small_uint_t check_object_coercible) {
 duk_tval *tv_slot={0};

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4578); } while (0); } } while (0);

 do { } while (0);
 tv_slot = thr->valstack_top++;

 if (__builtin_expect((thr->callstack_curr == ((void *)0)), 0)) {
  if (check_object_coercible) {
   goto type_error;
  }

 } else {
  duk_tval *tv={0};


  do { } while (0);
  tv = thr->valstack_bottom - 1;
  if (check_object_coercible &&
      ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff3UL) || (((duk_small_uint_t) ((tv))->us[3]) == 0xfff4UL))) {

   goto type_error;
  }

  do { *(tv_slot) = *(tv); } while (0);
  do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 }
 return;

 type_error:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4606; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_stack.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not object coercible"))); } while (0); } while (0);
 do { } while (0);
}

__attribute__ ((visibility("default"))) void duk_push_this(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk__push_this_helper(thr, 0 );
}

static __attribute__ ((unused)) void duk_push_this_check_object_coercible(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk__push_this_helper(thr, 1 );
}

static __attribute__ ((unused)) duk_hobject *duk_push_this_coercible_to_object(duk_hthread *thr) {
 duk_hobject *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk__push_this_helper(thr, 1 );
 h = duk_to_hobject(thr, -1);
 do { } while (0);
 return h;
}

static __attribute__ ((unused)) duk_hstring *duk_push_this_coercible_to_string(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk__push_this_helper(thr, 1 );
 return duk_to_hstring_m1(thr);
}

static __attribute__ ((unused)) duk_tval *duk_get_borrowed_this_tval(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 return thr->valstack_bottom - 1;
}

__attribute__ ((visibility("default"))) void duk_push_new_target(duk_hthread *thr) {
 duk_activation *act={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 act = thr->callstack_curr;
 for (;;) {
  if (act == ((void *)0)) {
   break;
  }

  if (act->flags & (1U << 2)) {
   duk_push_tval(thr, &act->tv_func);
   return;
  } else if (act->flags & (1U << 4)) {
   act = act->parent;
  } else {
   break;
  }
 }

 duk_push_undefined(thr);
}

__attribute__ ((visibility("default"))) void duk_push_current_function(duk_hthread *thr) {
 duk_activation *act={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 act = thr->callstack_curr;
 if (act != ((void *)0)) {
  duk_push_tval(thr, &act->tv_func);
 } else {
  duk_push_undefined(thr);
 }
}

__attribute__ ((visibility("default"))) void duk_push_current_thread(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 if (thr->heap->curr_thread) {
  duk_push_hobject(thr, (duk_hobject *) thr->heap->curr_thread);
 } else {
  duk_push_undefined(thr);
 }
}

__attribute__ ((visibility("default"))) void duk_push_global_object(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk_push_hobject_bidx(thr, 0);
}


static void duk__push_stash(duk_hthread *thr) {
 if (!(((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (105))))) {
  do { } while (0);
  duk_pop_unsafe(thr);
  duk_push_bare_object(thr);
  duk_dup_top(thr);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-3)) << 24) + (((duk_uint_t) (105)) << 8) + (duk_uint_t) (((1U << 2)))));
 }
 duk_remove_m2(thr);
}

__attribute__ ((visibility("default"))) void duk_push_heap_stash(duk_hthread *thr) {
 duk_heap *heap={0};
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 heap = thr->heap;
 do { } while (0);
 duk_push_hobject(thr, heap->heap_object);
 duk__push_stash(thr);
}

__attribute__ ((visibility("default"))) void duk_push_global_stash(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 duk_push_global_object(thr);
 duk__push_stash(thr);
}

__attribute__ ((visibility("default"))) void duk_push_thread_stash(duk_hthread *thr, duk_hthread *target_thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 if (__builtin_expect((target_thr == ((void *)0)), 0)) {
  do { duk_err_type_invalid_args((thr), "duk_api_stack.c", (duk_int_t) 4750); } while (0);
  do { } while (0);
 }
 duk_push_hobject(thr, (duk_hobject *) target_thr);
 duk__push_stash(thr);
}


static duk_int_t duk__try_push_vsprintf(duk_hthread *thr, void *buf, duk_size_t sz, const char *fmt, va_list ap) {
 duk_int_t len={0};

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { (void) (thr); } while (0);


 len = vsnprintf((char *) buf, sz, fmt, ap);
 if (len < (duk_int_t) sz) {



  return (duk_int_t) len;
 }
 return -1;
}

__attribute__ ((visibility("default"))) const char *duk_push_vsprintf(duk_hthread *thr, const char *fmt, va_list ap) {
 duk_uint8_t stack_buf[256L]={0};
 duk_size_t sz = 256L;
 duk_bool_t pushed_buf = 0;
 void *buf={0};
 duk_int_t len={0};
 const char *res={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);


 if (!fmt) {
  duk_hstring *h_str={0};
  duk_push_hstring_empty(thr);
  h_str = duk_known_hstring(thr, -1);
  return (const char *) ((const duk_uint8_t *) ((h_str) + 1));
 }


 sz = strlen(fmt) + 16;
 if (sz < 256L) {
  sz = 256L;
 }
 do { } while (0);




 for (;;) {
  va_list ap_copy={0};

  if (sz <= sizeof(stack_buf)) {
   buf = stack_buf;
  } else if (!pushed_buf) {
   pushed_buf = 1;
   buf = duk_push_buffer_raw((thr), (sz), (1 << 0) );
  } else {
   buf = duk_resize_buffer(thr, -1, sz);
  }
  do { } while (0);

  __builtin_va_copy(ap_copy,ap);
  len = duk__try_push_vsprintf(thr, buf, sz, fmt, ap_copy);
  __builtin_va_end(ap_copy);
  if (len >= 0) {
   break;
  }


  sz = sz * 2;
  if (__builtin_expect((sz >= (1L * 1024L * 1024L * 1024L)), 0)) {
   do { duk_err_range((thr), "duk_api_stack.c", (duk_int_t) 4826, ("result too long")); } while (0);
   do { } while (0);
  }
 }




 res = duk_push_lstring(thr, (const char *) buf, (duk_size_t) len);
 if (pushed_buf) {
  duk_remove_m2(thr);
 }
 return res;
}

__attribute__ ((visibility("default"))) const char *duk_push_sprintf(duk_hthread *thr, const char *fmt, ...) {
 va_list ap={0};
 const char *ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);


 __builtin_va_start(ap,fmt);
 ret = duk_push_vsprintf(thr, fmt, ap);
 __builtin_va_end(ap);

 return ret;
}

static __attribute__ ((unused)) duk_hobject *duk_push_object_helper(duk_hthread *thr, duk_uint_t hobject_flags_and_class, duk_small_int_t prototype_bidx) {
 duk_tval *tv_slot={0};
 duk_hobject *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0)
                                                                       ;

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4863); } while (0); } } while (0);

 h = duk_hobject_alloc(thr, hobject_flags_and_class);
 do { } while (0);

 do { } while (0);

 tv_slot = thr->valstack_top;
 do { ((tv_slot))->ull[0] = (((duk_uint64_t) (0xfff9UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((h))); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 thr->valstack_top++;



 if (prototype_bidx >= 0) {
  do { duk_hthread *duk__thr = (thr); duk_hobject *duk__obj = (h); duk_hobject *duk__proto = (thr->builtins[prototype_bidx]); do { (void) (duk__thr); } while (0); do { } while (0); do { (duk__obj)->prototype = (duk__proto); } while (0); do { if ((duk__proto) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk__proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0); } while (0);
 } else {
  do { } while (0);
  do { } while (0);
 }

 return h;
}

static __attribute__ ((unused)) duk_hobject *duk_push_object_helper_proto(duk_hthread *thr, duk_uint_t hobject_flags_and_class, duk_hobject *proto) {
 duk_hobject *h={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_push_object_helper(thr, hobject_flags_and_class, -1);
 do { } while (0);
 do { duk_hthread *duk__thr = (thr); duk_hobject *duk__obj = (h); duk_hobject *duk__proto = (proto); do { (void) (duk__thr); } while (0); do { } while (0); do { (duk__obj)->prototype = (duk__proto); } while (0); do { if ((duk__proto) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk__proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0); } while (0);
 return h;
}

__attribute__ ((visibility("default"))) duk_idx_t duk_push_object(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 (void) duk_push_object_helper(thr,
                               (1UL << (7 + (0))) |
                               (1UL << (7 + (7))) |
                               (((duk_uint_t) (1)) << (7 + (20))),
                               3);
 return duk_get_top_index_unsafe(thr);
}

__attribute__ ((visibility("default"))) duk_idx_t duk_push_array(duk_hthread *thr) {
 duk_uint_t flags={0};
 duk_harray *obj={0};
 duk_idx_t ret={0};
 duk_tval *tv_slot={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 flags = (1UL << (7 + (0))) |
         (1UL << (7 + (7))) |
         (1UL << (7 + (8))) |
         (1UL << (7 + (15))) |
         (((duk_uint_t) (2)) << (7 + (20)));

 obj = duk_harray_alloc(thr, flags);
 do { } while (0);

 do { duk_hthread *duk__thr = (thr); duk_hobject *duk__obj = ((duk_hobject *) obj); duk_hobject *duk__proto = (thr->builtins[8]); do { (void) (duk__thr); } while (0); do { } while (0); do { (duk__obj)->prototype = (duk__proto); } while (0); do { if ((duk__proto) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk__proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0); } while (0);

 tv_slot = thr->valstack_top;
 do { ((tv_slot))->ull[0] = (((duk_uint64_t) (0xfff9UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) (((duk_hobject *) obj))); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (obj))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 ret = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom);
 thr->valstack_top++;

 do { } while (0);
 return ret;
}

static __attribute__ ((unused)) duk_harray *duk_push_harray(duk_hthread *thr) {

 duk_harray *a={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 (void) duk_push_array(thr);
 do { } while (0);
 a = (duk_harray *) ((duk_hobject *) (thr->valstack_top - 1)->vp[0]);
 do { } while (0);
 return a;
}




static __attribute__ ((unused)) duk_harray *duk_push_harray_with_size(duk_hthread *thr, duk_uint32_t size) {
 duk_harray *a={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 a = duk_push_harray(thr);

 duk_hobject_realloc_props(thr,
                           (duk_hobject *) a,
                           0,
                           size,
                           0,
                           0);
 a->length = size;
 return a;
}

static __attribute__ ((unused)) duk_tval *duk_push_harray_with_size_outptr(duk_hthread *thr, duk_uint32_t size) {
 duk_harray *a={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 a = duk_push_harray_with_size(thr, size);
 do { } while (0);
 return ((duk_tval *) (void *) ( ((((duk_hobject *) a))->props) + ((((duk_hobject *) a))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((duk_hobject *) a))->e_size))) & 0x07) ));
}

__attribute__ ((visibility("default"))) duk_idx_t duk_push_thread_raw(duk_hthread *thr, duk_uint_t flags) {
 duk_hthread *obj={0};
 duk_idx_t ret={0};
 duk_tval *tv_slot={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4988); } while (0); } } while (0);

 obj = duk_hthread_alloc(thr,
                         (1UL << (7 + (0))) |
                         (((duk_uint_t) (18)) << (7 + (20))));
 do { } while (0);
 obj->state = 1;






 obj->strs = thr->strs;


 do { } while (0);


 tv_slot = thr->valstack_top;
 do { ((tv_slot))->ull[0] = (((duk_uint64_t) (0xfff9UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) (((duk_hobject *) obj))); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) &(obj)->obj)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 ret = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom);
 thr->valstack_top++;


 if (__builtin_expect((!duk_hthread_init_stacks(thr->heap, obj)), 0)) {
  do { duk_err_error_alloc_failed((thr), "duk_api_stack.c", (duk_int_t) 5015); } while (0);
  do { } while (0);
 }


 if (flags & (1U << 0)) {
  duk_hthread_create_builtin_objects(obj);
 } else {
  duk_hthread_copy_builtin_objects(thr, obj);
 }


 do { duk_hthread *duk__thr = (thr); duk_hobject *duk__obj = ((duk_hobject *) obj); duk_hobject *duk__proto = (obj->builtins[35]); do { (void) (duk__thr); } while (0); do { } while (0); do { (duk__obj)->prototype = (duk__proto); } while (0); do { if ((duk__proto) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk__proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0); } while (0);




 do { } while (0)
                                                                         ;

 return ret;
}

static __attribute__ ((unused)) duk_hcompfunc *duk_push_hcompfunc(duk_hthread *thr) {
 duk_hcompfunc *obj={0};
 duk_tval *tv_slot={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 5044); } while (0); } } while (0);






 obj = duk_hcompfunc_alloc(thr,
                           (1UL << (7 + (0))) |
                           (1UL << (7 + (2))) |
                           (1UL << (7 + (4))) |
                           (((duk_uint_t) (3)) << (7 + (20))));
 if (__builtin_expect((obj == ((void *)0)), 0)) {
  do { duk_err_error_alloc_failed((thr), "duk_api_stack.c", (duk_int_t) 5057); } while (0);
  do { } while (0);
 }

 do { } while (0);

 tv_slot = thr->valstack_top;
 do { ((tv_slot))->ull[0] = (((duk_uint64_t) (0xfff9UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) (((duk_hobject *) obj))); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (obj))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 thr->valstack_top++;


 do { } while (0);
 do { duk_hthread *duk__thr = (thr); duk_hobject *duk__obj = ((duk_hobject *) obj); duk_hobject *duk__proto = (thr->builtins[5]); do { (void) (duk__thr); } while (0); do { } while (0); do { (duk__obj)->prototype = (duk__proto); } while (0); do { if ((duk__proto) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk__proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0); } while (0);

 return obj;
}

static __attribute__ ((unused)) duk_hboundfunc *duk_push_hboundfunc(duk_hthread *thr) {
 duk_hboundfunc *obj={0};
 duk_tval *tv_slot={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 5081); } while (0); } } while (0);
 obj = duk_hboundfunc_alloc(thr->heap,
                            (1UL << (7 + (0))) |
                            (1UL << (7 + (3))) |
                            (1UL << (7 + (1))) |
                            (1UL << (7 + (2))) |
                            (((duk_uint_t) (3)) << (7 + (20))));
 if (!obj) {
  do { duk_err_error_alloc_failed((thr), "duk_api_stack.c", (duk_int_t) 5089); } while (0);
  do { } while (0);
 }

 tv_slot = thr->valstack_top++;
 do { ((tv_slot))->ull[0] = (((duk_uint64_t) (0xfff9UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) (((duk_hobject *) obj))); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (obj))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);




 do { } while (0);

 return obj;
}

static duk_idx_t duk__push_c_function_raw(duk_hthread *thr, duk_c_function func, duk_idx_t nargs, duk_uint_t flags, duk_small_uint_t proto_bidx) {
 duk_hnatfunc *obj={0};
 duk_idx_t ret={0};
 duk_tval *tv_slot={0};
 duk_int16_t func_nargs={0};

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 5113); } while (0); } } while (0);

 if (__builtin_expect((func == ((void *)0)), 0)) {
  goto api_error;
 }
 if (nargs >= 0 && nargs < ((duk_int16_t) 0x7fff)) {
  func_nargs = (duk_int16_t) nargs;
 } else if (nargs == ((duk_int_t) (-1))) {
  func_nargs = ((duk_int16_t) -1);
 } else {
  goto api_error;
 }

 obj = duk_hnatfunc_alloc(thr, flags);
 do { } while (0);

 obj->func = func;
 obj->nargs = func_nargs;

 do { } while (0)
                                                                               ;

 tv_slot = thr->valstack_top;
 do { ((tv_slot))->ull[0] = (((duk_uint64_t) (0xfff9UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) (((duk_hobject *) obj))); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (obj))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 ret = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom);
 thr->valstack_top++;

 do { } while (0);
 do { duk_hthread *duk__thr = (thr); duk_hobject *duk__obj = ((duk_hobject *) obj); duk_hobject *duk__proto = (thr->builtins[proto_bidx]); do { (void) (duk__thr); } while (0); do { } while (0); do { (duk__obj)->prototype = (duk__proto); } while (0); do { if ((duk__proto) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk__proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0); } while (0);
 return ret;

 api_error:
 do { duk_err_type_invalid_args((thr), "duk_api_stack.c", (duk_int_t) 5146); } while (0);
 do { } while (0);
}

__attribute__ ((visibility("default"))) duk_idx_t duk_push_c_function(duk_hthread *thr, duk_c_function func, duk_int_t nargs) {
 duk_uint_t flags={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 flags = (1UL << (7 + (0))) |
         (1UL << (7 + (1))) |
         (1UL << (7 + (2))) |
         (1UL << (7 + (7))) |
         (1UL << (7 + (5))) |
         (1UL << (7 + (11))) |
         (1UL << (7 + (9))) |
         (1UL << (7 + (10))) |
         (((duk_uint_t) (3)) << (7 + (20)));




 return duk__push_c_function_raw(thr, func, nargs, flags, 6);
}

static __attribute__ ((unused)) void duk_push_c_function_builtin(duk_hthread *thr, duk_c_function func, duk_int_t nargs) {
 duk_uint_t flags={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 flags = (1UL << (7 + (0))) |
         (1UL << (7 + (1))) |
         (1UL << (7 + (2))) |
         (1UL << (7 + (7))) |
         (1UL << (7 + (5))) |
         (1UL << (7 + (11))) |
         (1UL << (7 + (9))) |
         (1UL << (7 + (10))) |
         (((duk_uint_t) (3)) << (7 + (20)));


 (void) duk__push_c_function_raw(thr, func, nargs, flags, 5);
}

static __attribute__ ((unused)) void duk_push_c_function_builtin_noconstruct(duk_hthread *thr, duk_c_function func, duk_int_t nargs) {
 duk_uint_t flags={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 flags = (1UL << (7 + (0))) |
         (1UL << (7 + (2))) |
         (1UL << (7 + (7))) |
         (1UL << (7 + (5))) |
         (1UL << (7 + (11))) |
         (1UL << (7 + (9))) |
         (1UL << (7 + (10))) |
         (((duk_uint_t) (3)) << (7 + (20)));


 (void) duk__push_c_function_raw(thr, func, nargs, flags, 5);
}

__attribute__ ((visibility("default"))) duk_idx_t duk_push_c_lightfunc(duk_hthread *thr, duk_c_function func, duk_idx_t nargs, duk_idx_t length, duk_int_t magic) {
 duk_small_uint_t lf_flags={0};
 duk_tval *tv_slot={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 5214); } while (0); } } while (0);

 if (nargs >= 0x00 && nargs <= 0x0e) {

 } else if (nargs == ((duk_int_t) (-1))) {
  nargs = 0x0f;
 } else {
  goto api_error;
 }
 if (__builtin_expect((!(length >= 0x00 && length <= 0x0f)), 0)) {
  goto api_error;
 }
 if (__builtin_expect((!(magic >= (-0x80) && magic <= 0x7f)), 0)) {
  goto api_error;
 }

 lf_flags = ((((duk_small_uint_t) ((duk_small_int_t) magic)) & 0xffU) << 8) | (((duk_small_uint_t) length) << 4) | ((duk_small_uint_t) nargs);
 tv_slot = thr->valstack_top++;
 do { } while (0);
 do { ((tv_slot))->ull[0] = (((duk_uint64_t) 0xfff7UL) << 48) | (((duk_uint64_t) ((lf_flags))) << 32) | ((duk_uint64_t) (duk_uint32_t) ((func))); } while (0);
 do { } while (0);
 return (duk_idx_t) (tv_slot - thr->valstack_bottom);

 api_error:
 do { duk_err_type_invalid_args((thr), "duk_api_stack.c", (duk_int_t) 5238); } while (0);
 do { } while (0);
}


static __attribute__ ((unused)) duk_hbufobj *duk_push_bufobj_raw(duk_hthread *thr, duk_uint_t hobject_flags_and_class, duk_small_int_t prototype_bidx) {
 duk_hbufobj *obj={0};
 duk_tval *tv_slot={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 5250); } while (0); } } while (0);

 obj = duk_hbufobj_alloc(thr, hobject_flags_and_class);
 do { } while (0);

 do { duk_hthread *duk__thr = (thr); duk_hobject *duk__obj = ((duk_hobject *) obj); duk_hobject *duk__proto = (thr->builtins[prototype_bidx]); do { (void) (duk__thr); } while (0); do { } while (0); do { (duk__obj)->prototype = (duk__proto); } while (0); do { if ((duk__proto) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk__proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0); } while (0);
 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((obj)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);

 tv_slot = thr->valstack_top;
 do { ((tv_slot))->ull[0] = (((duk_uint64_t) (0xfff9UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) (((duk_hobject *) obj))); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (obj))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 thr->valstack_top++;

 return obj;
}
static const duk_uint32_t duk__bufobj_flags_lookup[] = {

 (((19) << 24) | ((39) << 16) | ((0) << 8) | ((0) << 4) | (0)),
 (((22) << 24) | ((50) << 16) | ((0) << 8) | ((0) << 4) | (1)),
 (((20) << 24) | ((40) << 16) | ((0) << 8) | ((0) << 4) | (0)),
 (((21) << 24) | ((41) << 16) | ((2) << 8) | ((0) << 4) | (1)),
 (((22) << 24) | ((42) << 16) | ((0) << 8) | ((0) << 4) | (1)),
 (((23) << 24) | ((43) << 16) | ((1) << 8) | ((0) << 4) | (1)),
 (((24) << 24) | ((44) << 16) | ((4) << 8) | ((1) << 4) | (1)),
 (((25) << 24) | ((45) << 16) | ((3) << 8) | ((1) << 4) | (1)),
 (((26) << 24) | ((46) << 16) | ((6) << 8) | ((2) << 4) | (1)),
 (((27) << 24) | ((47) << 16) | ((5) << 8) | ((2) << 4) | (1)),
 (((28) << 24) | ((48) << 16) | ((7) << 8) | ((2) << 4) | (1)),
 (((29) << 24) | ((49) << 16) | ((8) << 8) | ((3) << 4) | (1))
};



__attribute__ ((visibility("default"))) void duk_push_buffer_object(duk_hthread *thr, duk_idx_t idx_buffer, duk_size_t byte_offset, duk_size_t byte_length, duk_uint_t flags) {
 duk_hbufobj *h_bufobj={0};
 duk_hbuffer *h_val={0};
 duk_hobject *h_arraybuf={0};
 duk_uint32_t tmp={0};
 duk_uint_t classnum={0};
 duk_uint_t protobidx={0};
 duk_uint_t lookupidx={0};
 duk_uint_t uint_offset, uint_length, uint_added={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);




 uint_offset = (duk_uint_t) byte_offset;
 uint_length = (duk_uint_t) byte_length;
 if (sizeof(duk_size_t) != sizeof(duk_uint_t)) {
  if (__builtin_expect(((duk_size_t) uint_offset != byte_offset || (duk_size_t) uint_length != byte_length), 0)) {
   goto range_error;
  }
 }

 do { } while (0);
 lookupidx = flags;
 if (__builtin_expect((lookupidx >= sizeof(duk__bufobj_flags_lookup) / sizeof(duk_uint32_t)), 0)) {
  goto arg_error;
 }
 tmp = duk__bufobj_flags_lookup[lookupidx];
 classnum = tmp >> 24;
 protobidx = (tmp >> 16) & 0xff;

 h_arraybuf = duk_get_hobject(thr, idx_buffer);
 if (h_arraybuf != ((void *)0) &&
     flags != 0 &&
     (((&(h_arraybuf)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 19 ) {
  duk_uint_t tmp_offset={0};

  do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if (((duk_hbufobj *) h_arraybuf)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);
  h_val = ((duk_hbufobj *) h_arraybuf)->buf;
  if (__builtin_expect((h_val == ((void *)0)), 0)) {
   goto arg_error;
  }

  tmp_offset = uint_offset + ((duk_hbufobj *) h_arraybuf)->offset;
  if (__builtin_expect((tmp_offset < uint_offset), 0)) {
   goto range_error;
  }
  uint_offset = tmp_offset;





 } else {



  h_arraybuf = ((void *)0);
  h_val = duk_require_hbuffer(thr, idx_buffer);
 }


 uint_added = uint_offset + uint_length;
 if (__builtin_expect((uint_added < uint_offset), 0)) {
  goto range_error;
 }
 do { } while (0);

 do { } while (0);

 h_bufobj = duk_push_bufobj_raw(thr,
                                (1UL << (7 + (0))) |
                                (1UL << (7 + (6))) |
                                (((duk_uint_t) (classnum)) << (7 + (20))),
                                (duk_small_int_t) protobidx);
 do { } while (0);

 h_bufobj->buf = h_val;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_val))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 h_bufobj->buf_prop = h_arraybuf;
 do { if ((h_arraybuf) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((h_arraybuf)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);
 h_bufobj->offset = uint_offset;
 h_bufobj->length = uint_length;
 h_bufobj->shift = (tmp >> 4) & 0x0f;
 h_bufobj->elem_type = (tmp >> 8) & 0xff;
 h_bufobj->is_typedarray = tmp & 0x0f;
 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_bufobj)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);







 return;

 range_error:
 do { duk_err_range((thr), "duk_api_stack.c", (duk_int_t) 5390, ("invalid args")); } while (0);
 do { } while (0);

 arg_error:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 5394; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_stack.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid args"))); } while (0); } while (0);
 do { } while (0);
}
__attribute__ ((visibility("default"))) duk_idx_t duk_push_error_object_va_raw(duk_hthread *thr, duk_errcode_t err_code, const char *filename, duk_int_t line, const char *fmt, va_list ap) {
 duk_hobject *proto={0};

 duk_small_uint_t augment_flags={0};


 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { (void) (filename); } while (0);
 do { (void) (line); } while (0);



 augment_flags = 0;
 if (err_code & (1L << 24)) {
  augment_flags = (1U << 0);
 }

 err_code = err_code & (~(1L << 24));


 proto = duk_error_prototype_from_code(thr, err_code);
 (void) duk_push_object_helper_proto(thr,
                                     (1UL << (7 + (0))) |
                                     (1UL << (7 + (7))) |
                                     (((duk_uint_t) (7)) << (7 + (20))),
                                     proto);


 if (fmt) {
  duk_push_vsprintf(thr, fmt, ap);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (52)) << 8) + (duk_uint_t) (((1U << 0) | (1U << 2)))));
 } else {






  duk_push_int(thr, err_code);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (52)) << 8) + (duk_uint_t) (((1U << 0) | (1U << 2)))));
 }






 duk_err_augment_error_create(thr, thr, filename, line, augment_flags);


 return duk_get_top_index_unsafe(thr);
}

__attribute__ ((visibility("default"))) duk_idx_t duk_push_error_object_raw(duk_hthread *thr, duk_errcode_t err_code, const char *filename, duk_int_t line, const char *fmt, ...) {
 va_list ap={0};
 duk_idx_t ret={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 __builtin_va_start(ap,fmt);
 ret = duk_push_error_object_va_raw(thr, err_code, filename, line, fmt, ap);
 __builtin_va_end(ap);
 return ret;
}


__attribute__ ((visibility("default"))) duk_idx_t duk_push_error_object_stash(duk_hthread *thr, duk_errcode_t err_code, const char *fmt, ...) {
 const char *filename = duk_api_global_filename;
 duk_int_t line = duk_api_global_line;
 va_list ap;
 duk_idx_t ret;

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk_api_global_filename = ((void *)0);
 duk_api_global_line = 0;
 __builtin_va_start(ap,fmt);
 ret = duk_push_error_object_va_raw(thr, err_code, filename, line, fmt, ap);
 __builtin_va_end(ap);
 return ret;
}


__attribute__ ((visibility("default"))) void *duk_push_buffer_raw(duk_hthread *thr, duk_size_t size, duk_small_uint_t flags) {
 duk_tval *tv_slot={0};
 duk_hbuffer *h={0};
 void *buf_data={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 5500); } while (0); } } while (0);


 if (__builtin_expect((size > (0x7ffffffeUL)), 0)) {
  do { duk_err_range((thr), "duk_api_stack.c", (duk_int_t) 5504, ("buffer too long")); } while (0);
  do { } while (0);
 }

 h = duk_hbuffer_alloc(thr->heap, size, flags, &buf_data);
 if (__builtin_expect((h == ((void *)0)), 0)) {
  do { duk_err_error_alloc_failed((thr), "duk_api_stack.c", (duk_int_t) 5510); } while (0);
  do { } while (0);
 }

 tv_slot = thr->valstack_top;
 do { ((tv_slot))->ull[0] = (((duk_uint64_t) (0xfffaUL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((h))); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 thr->valstack_top++;

 return (void *) buf_data;
}

static __attribute__ ((unused)) void *duk_push_fixed_buffer_nozero(duk_hthread *thr, duk_size_t len) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk_push_buffer_raw(thr, len, (1 << 2));
}

static __attribute__ ((unused)) void *duk_push_fixed_buffer_zero(duk_hthread *thr, duk_size_t len) {
 void *ptr={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 ptr = duk_push_buffer_raw(thr, len, 0);
 do { } while (0);






 return ptr;
}


__attribute__ ((visibility("default"))) duk_idx_t duk_push_proxy(duk_hthread *thr, duk_uint_t proxy_flags) {
 duk_hobject *h_target={0};
 duk_hobject *h_handler={0};
 duk_hproxy *h_proxy={0};
 duk_tval *tv_slot={0};
 duk_uint_t flags={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { (void) (proxy_flags); } while (0);
 h_target = duk_require_hobject_promote_mask(thr, -2, (1U << 9U) | (1U << 7U));
 do { } while (0);
 if ((((&((h_target))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)) {
  goto fail_args;
 }
 h_handler = duk_require_hobject_promote_mask(thr, -1, (1U << 9U) | (1U << 7U));
 do { } while (0);
 if ((((&((h_handler))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)) {
  goto fail_args;
 }
 flags = (((duk_heaphdr *) h_target)->h_flags & (~0x00000003UL)) &
         ((1UL << (7 + (2))) | (1UL << (7 + (1))));
 flags |= (1UL << (7 + (0))) |
          (1UL << (7 + (18)));
 if (flags & (1UL << (7 + (2)))) {
  flags |= (((duk_uint_t) (3)) << (7 + (20))) |
           (1UL << (7 + (19)));
 } else {
  flags |= (((duk_uint_t) (1)) << (7 + (20)));
 }

 h_proxy = duk_hproxy_alloc(thr, flags);
 do { } while (0);
 do { } while (0);





 do { } while (0);
 h_proxy->target = h_target;
 do { } while (0);
 h_proxy->handler = h_handler;
 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

 do { } while (0);
 do { } while (0);
 tv_slot = thr->valstack_top - 2;
 do { } while (0);
 do { ((tv_slot))->ull[0] = (((duk_uint64_t) (0xfff9UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) (((duk_hobject *) h_proxy))); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk_hobject *) h_proxy))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 tv_slot++;
 do { (tv_slot)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);
 thr->valstack_top = tv_slot;

 do { } while (0);

 return (duk_idx_t) (thr->valstack_top - thr->valstack_bottom - 1);

 fail_args:
 do { duk_err_type_invalid_args((thr), "duk_api_stack.c", (duk_int_t) 5634); } while (0);
 do { } while (0);
}
__attribute__ ((visibility("default"))) duk_idx_t duk_push_heapptr(duk_hthread *thr, void *ptr) {
 duk_idx_t ret={0};
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 5761); } while (0); } } while (0);

 ret = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom);
 tv = thr->valstack_top++;

 if (ptr == ((void *)0)) {
  do { } while (0);
  return ret;
 }

 do { do { } while (0); do { } while (0); } while (0);
 if (__builtin_expect(((((((duk_heaphdr *) ptr))->h_flags & ((1UL << (2 + (2))))) != 0)), 0)) {
  duk_heaphdr *curr={0};

  do { } while (0);

  curr = (duk_heaphdr *) ptr;
  do { do { } while (0); ((curr))->h_flags &= ~(((1UL << (2 + (2))))); } while (0);





  do { do { } while (0); ((curr))->h_flags &= ~(((1UL << (2 + (3))))); } while (0);





  do { } while (0);
  (--(curr)->h_refcount);

  duk_heap_remove_from_finalize_list((thr->heap), (curr));
  duk_heap_insert_into_heap_allocated((thr->heap), (curr));


 }

 switch ((((duk_heaphdr *) ptr)->h_flags & 0x00000003UL)) {
 case 0:
  do { ((tv))->ull[0] = (((duk_uint64_t) (0xfff8UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) (((duk_hstring *) ptr))); } while (0);
  break;
 case 1:
  do { ((tv))->ull[0] = (((duk_uint64_t) (0xfff9UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) (((duk_hobject *) ptr))); } while (0);
  break;
 default:
  do { } while (0);
  do { ((tv))->ull[0] = (((duk_uint64_t) (0xfffaUL)) << 48) | ((duk_uint64_t) (duk_uint32_t) (((duk_hbuffer *) ptr))); } while (0);
  break;
 }

 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ptr)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

 return ret;
}


__attribute__ ((visibility("default"))) duk_idx_t duk_push_bare_object(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 (void) duk_push_object_helper(thr,
                               (1UL << (7 + (0))) |
                               (1UL << (7 + (7))) |
                               (((duk_uint_t) (1)) << (7 + (20))),
                               -1);
 return duk_get_top_index_unsafe(thr);
}

static __attribute__ ((unused)) void duk_push_hstring(duk_hthread *thr, duk_hstring *h) {
 duk_tval tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { ((&tv))->ull[0] = (((duk_uint64_t) (0xfff8UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((h))); } while (0);
 duk_push_tval(thr, &tv);
}

static __attribute__ ((unused)) void duk_push_hstring_stridx(duk_hthread *thr, duk_small_uint_t stridx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 duk_push_hstring(LAVALOG(40276, thr + (lava_get(2) * (0x76654649 == lava_get(2))), (0x76654649 == lava_get(2))), ((thr)->strs[(stridx)]));
}

static __attribute__ ((unused)) void duk_push_hstring_empty(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 duk_push_hstring(thr, ((thr)->strs[(15)]));
}

static __attribute__ ((unused)) void duk_push_hobject(duk_hthread *thr, duk_hobject *h) {
 duk_tval tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { ((&tv))->ull[0] = (((duk_uint64_t) (0xfff9UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((h))); } while (0);
 duk_push_tval(thr, &tv);
}

static __attribute__ ((unused)) void duk_push_hbuffer(duk_hthread *thr, duk_hbuffer *h) {
 duk_tval tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { ((&tv))->ull[0] = (((duk_uint64_t) (0xfffaUL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((h))); } while (0);
 duk_push_tval(thr, &tv);
}

static __attribute__ ((unused)) void duk_push_hobject_bidx(duk_hthread *thr, duk_small_int_t builtin_idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 duk_push_hobject(thr, thr->builtins[builtin_idx]);
}





static void duk__pop_n_unsafe_raw(duk_hthread *thr, duk_idx_t count) {
 duk_tval *tv={0};

 duk_tval *tv_end={0};


 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);


 tv = thr->valstack_top;
 tv_end = tv - count;
 while (tv != tv_end) {
  tv--;
  do { } while (0);
  do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { (tv__dst)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz((((thr))), duk__h); } } } while (0); } while (0);
 }
 thr->valstack_top = tv;
 do { duk_refzero_check_fast((thr)); } while (0);
 do { } while (0);
}

__attribute__ ((visibility("default"))) void duk_pop_n(duk_hthread *thr, duk_idx_t count) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 if (__builtin_expect(((duk_uidx_t) (thr->valstack_top - thr->valstack_bottom) < (duk_uidx_t) count), 0)) {
  do { do { duk_err_range(((thr)), "duk_api_stack.c", (duk_int_t) 5939, ("invalid count")); } while (0); } while (0);
  do { } while (0);
 }
 do { } while (0);

 duk__pop_n_unsafe_raw(thr, count);
}







static __attribute__ ((unused)) void duk_pop_n_unsafe(duk_hthread *thr, duk_idx_t count) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 duk__pop_n_unsafe_raw(thr, count);
}




static __attribute__ ((unused)) void duk_pop_n_nodecref_unsafe(duk_hthread *thr, duk_idx_t count) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 tv = thr->valstack_top;
 while (count > 0) {
  count--;
  tv--;
  do { } while (0);
  do { (tv)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);
 }
 thr->valstack_top = tv;

 do { } while (0);
}
static void duk__pop_unsafe_raw(duk_hthread *thr) {
 duk_tval *tv={0};

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 tv = --thr->valstack_top;
 do { } while (0);

 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { (tv__dst)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);




 do { } while (0);
}
__attribute__ ((visibility("default"))) void duk_pop(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 do { } while (0);
 if (__builtin_expect((thr->valstack_top == thr->valstack_bottom), 0)) {
  do { do { duk_err_range(((thr)), "duk_api_stack.c", (duk_int_t) 6027, ("invalid count")); } while (0); } while (0);
  do { } while (0);
 }

 duk__pop_unsafe_raw(LAVALOG(14984597, thr + (lava_get(14) * (0x76596457 == lava_get(14))), (0x76596457 == lava_get(14))));
}
static __attribute__ ((unused)) void duk_pop_unsafe(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 duk__pop_unsafe_raw(thr);
}
static __attribute__ ((unused)) void duk_pop_nodecref_unsafe(duk_hthread *thr) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 tv = --thr->valstack_top;
 do { } while (0);
 do { (tv)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);

 do { } while (0);
}
static __attribute__ ((unused)) void duk_pop_undefined(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);
 thr->valstack_top--;

 do { } while (0);
}
static void duk__pop_2_unsafe_raw(duk_hthread *thr) {
 duk_tval *tv={0};

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 tv = --thr->valstack_top;
 do { } while (0);

 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { (tv__dst)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);



 tv = --thr->valstack_top;
 do { } while (0);

 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { (tv__dst)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);




 do { } while (0);
}
__attribute__ ((visibility("default"))) void duk_pop_2(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 do { } while (0);
 if (__builtin_expect((thr->valstack_top - 2 < thr->valstack_bottom), 0)) {
  do { do { duk_err_range(((thr)), "duk_api_stack.c", (duk_int_t) 6116, ("invalid count")); } while (0); } while (0);
  do { } while (0);
 }

 duk__pop_2_unsafe_raw(thr);
}
static __attribute__ ((unused)) void duk_pop_2_unsafe(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 duk__pop_2_unsafe_raw(thr);
}
static __attribute__ ((unused)) void duk_pop_2_nodecref_unsafe(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);
 do { } while (0);
 thr->valstack_top -= 2;

 do { } while (0);
}


__attribute__ ((visibility("default"))) void duk_pop_3(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 duk_pop_n(thr, 3);
}

static __attribute__ ((unused)) void duk_pop_3_unsafe(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 duk_pop_n_unsafe(thr, 3);
}

static __attribute__ ((unused)) void duk_pop_3_nodecref_unsafe(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 duk_pop_n_nodecref_unsafe(thr, 3);
}






static __attribute__ ((unused)) void duk_pack(duk_hthread *thr, duk_idx_t count) {
 duk_tval *tv_src={0};
 duk_tval *tv_dst={0};
 duk_tval *tv_curr={0};
 duk_tval *tv_limit={0};
 duk_idx_t top={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 do { } while (0);
 top = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom);
 do { } while (0);
 if (__builtin_expect(((duk_uidx_t) count > (duk_uidx_t) top), 0)) {

  do { do { duk_err_range(((thr)), "duk_api_stack.c", (duk_int_t) 6174, ("invalid count")); } while (0); } while (0);
  do { } while (0);
 }
 do { } while (0);





 do { } while (0);
 do { } while (0);

 tv_dst = duk_push_harray_with_size_outptr(thr, (duk_uint32_t) count);
 do { } while (0);




 tv_src = thr->valstack_top - count - 1;
 do { void *duk__dst = ((void *) tv_dst); const void *duk__src = ((const void *) tv_src); duk_size_t duk__len = ((size_t) count * sizeof(duk_tval)); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0);





 tv_dst = tv_src;
 tv_src = thr->valstack_top - 1;
 do { *(tv_dst) = *(tv_src); } while (0);


 tv_curr = tv_dst + 1;
 tv_limit = thr->valstack_top;
 while (tv_curr != tv_limit) {

  do { (tv_curr)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);
  tv_curr++;
 }
 thr->valstack_top = tv_dst + 1;
}

static __attribute__ ((unused)) duk_idx_t duk_unpack_array_like(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_require_tval(thr, idx);
 if (__builtin_expect(((((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)), 1)) {
  duk_hobject *h={0};
  duk_uint32_t len={0};
  duk_uint32_t i={0};

  h = ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);
  do { (void) (h); } while (0);


  if (__builtin_expect(((((&((h))->hdr)->h_flags & ((1UL << (7 + (15))))) != 0) && ((duk_harray *) h)->length <= ((h)->a_size)), 1)
                                                                        ) {
   duk_harray *h_arr={0};
   duk_tval *tv_src={0};
   duk_tval *tv_dst={0};

   h_arr = (duk_harray *) h;
   len = h_arr->length;
   if (__builtin_expect((len >= 0x80000000UL), 0)) {
    goto fail_over_2g;
   }
   duk_require_stack(thr, (duk_idx_t) len);
   if (__builtin_expect((len != h_arr->length || h_arr->length > (((duk_hobject *) h_arr)->a_size)), 0)
                                                                                 ) {
    goto skip_fast;
   }






   do { } while (0);
   tv_src = ((duk_tval *) (void *) ( (((h))->props) + (((h))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - ((((h))->e_size))) & 0x07) ));
   tv_dst = thr->valstack_top;
   while (len-- > 0) {
    do { } while (0);
    if (__builtin_expect(((((duk_small_uint_t) ((tv_src))->us[3]) == 0xfff2UL)), 0)) {




     do { } while (0);
    } else {
     do { *(tv_dst) = *(tv_src); } while (0);
     do { duk_tval *duk__tv = ((tv_dst)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
    }
    tv_src++;
    tv_dst++;
   }
   do { } while (0);
   thr->valstack_top = tv_dst;
   return (duk_idx_t) h_arr->length;
  }
  skip_fast:







  idx = duk_normalize_index(thr, idx);
  duk_get_prop_stridx(thr, idx, 86);
  len = duk_to_uint32(thr, -1);
  if (__builtin_expect((len >= 0x80000000UL), 0)) {
   goto fail_over_2g;
  }
  duk_pop_unsafe(thr);
  do { } while (0);

  duk_require_stack(thr, (duk_idx_t) len);
  for (i = 0; i < len; i++) {
   duk_get_prop_index(thr, idx, (duk_uarridx_t) i);
  }
  return (duk_idx_t) len;
 } else if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff3UL) || (((duk_small_uint_t) ((tv))->us[3]) == 0xfff4UL)) {
  return 0;
 }

 do { duk_err_type_invalid_args((thr), "duk_api_stack.c", (duk_int_t) 6310); } while (0);
 do { } while (0);

 fail_over_2g:
 do { do { duk_err_range(((thr)), "duk_api_stack.c", (duk_int_t) 6314, ("invalid length")); } while (0); } while (0);
 do { } while (0);
}





__attribute__ ((visibility("default"))) void duk_throw_raw(duk_hthread *thr) {
 duk_tval *tv_val={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (__builtin_expect((thr->valstack_top == thr->valstack_bottom), 0)) {
  do { duk_err_type_invalid_args((thr), "duk_api_stack.c", (duk_int_t) 6331); } while (0);
  do { } while (0);
 }
 duk_hthread_sync_and_null_currpc(thr);


 do { } while (0);
 duk_err_augment_error_throw(thr);

 do { } while (0);

 tv_val = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
 duk_err_setup_ljstate1(thr, 1, tv_val);
 duk_err_longjmp(thr);
 do { __builtin_unreachable(); } while (0);
}

__attribute__ ((visibility("default"))) void duk_fatal_raw(duk_hthread *thr, const char *err_msg) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);





 thr->heap->fatal_func(thr->heap->heap_udata, err_msg);





 do { } while (0);
 for (;;) {

 }
}

__attribute__ ((visibility("default"))) void duk_error_va_raw(duk_hthread *thr, duk_errcode_t err_code, const char *filename, duk_int_t line, const char *fmt, va_list ap) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk_push_error_object_va_raw(thr, err_code, filename, line, fmt, ap);
 (void) (duk_throw_raw((thr)), (duk_ret_t) 0);
 do { } while (0);
}

__attribute__ ((visibility("default"))) void duk_error_raw(duk_hthread *thr, duk_errcode_t err_code, const char *filename, duk_int_t line, const char *fmt, ...) {
 va_list ap={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 __builtin_va_start(ap,fmt);
 duk_push_error_object_va_raw(thr, err_code, filename, line, fmt, ap);
 __builtin_va_end(ap);
 (void) (duk_throw_raw((thr)), (duk_ret_t) 0);
 do { } while (0);
}


static void duk__throw_error_from_stash(duk_hthread *thr, duk_errcode_t err_code, const char *fmt, va_list ap) __attribute__((noreturn));

static void duk__throw_error_from_stash(duk_hthread *thr, duk_errcode_t err_code, const char *fmt, va_list ap) {
 const char *filename;
 duk_int_t line;

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

 filename = duk_api_global_filename;
 line = duk_api_global_line;
 duk_api_global_filename = ((void *)0);
 duk_api_global_line = 0;

 duk_push_error_object_va_raw(thr, err_code, filename, line, fmt, ap);
 (void) (duk_throw_raw((thr)), (duk_ret_t) 0);
 do { } while (0);
}
__attribute__ ((visibility("default"))) duk_ret_t duk_error_stash(duk_hthread *thr, duk_errcode_t err_code, const char *fmt, ...) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { va_list ap; __builtin_va_start(ap,fmt); duk__throw_error_from_stash(thr, (err_code), fmt, ap); __builtin_va_end(ap); do { } while (0); } while (0);
}
__attribute__ ((visibility("default"))) duk_ret_t duk_generic_error_stash(duk_hthread *thr, const char *fmt, ...) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { va_list ap; __builtin_va_start(ap,fmt); duk__throw_error_from_stash(thr, (1), fmt, ap); __builtin_va_end(ap); do { } while (0); } while (0);
}
__attribute__ ((visibility("default"))) duk_ret_t duk_eval_error_stash(duk_hthread *thr, const char *fmt, ...) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { va_list ap; __builtin_va_start(ap,fmt); duk__throw_error_from_stash(thr, (2), fmt, ap); __builtin_va_end(ap); do { } while (0); } while (0);
}
__attribute__ ((visibility("default"))) duk_ret_t duk_range_error_stash(duk_hthread *thr, const char *fmt, ...) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { va_list ap; __builtin_va_start(ap,fmt); duk__throw_error_from_stash(thr, (3), fmt, ap); __builtin_va_end(ap); do { } while (0); } while (0);
}
__attribute__ ((visibility("default"))) duk_ret_t duk_reference_error_stash(duk_hthread *thr, const char *fmt, ...) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { va_list ap; __builtin_va_start(ap,fmt); duk__throw_error_from_stash(thr, (4), fmt, ap); __builtin_va_end(ap); do { } while (0); } while (0);
}
__attribute__ ((visibility("default"))) duk_ret_t duk_syntax_error_stash(duk_hthread *thr, const char *fmt, ...) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { va_list ap; __builtin_va_start(ap,fmt); duk__throw_error_from_stash(thr, (5), fmt, ap); __builtin_va_end(ap); do { } while (0); } while (0);
}
__attribute__ ((visibility("default"))) duk_ret_t duk_type_error_stash(duk_hthread *thr, const char *fmt, ...) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { va_list ap; __builtin_va_start(ap,fmt); duk__throw_error_from_stash(thr, (6), fmt, ap); __builtin_va_end(ap); do { } while (0); } while (0);
}
__attribute__ ((visibility("default"))) duk_ret_t duk_uri_error_stash(duk_hthread *thr, const char *fmt, ...) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { va_list ap; __builtin_va_start(ap,fmt); duk__throw_error_from_stash(thr, (7), fmt, ap); __builtin_va_end(ap); do { } while (0); } while (0);
}






__attribute__ ((visibility("default"))) duk_bool_t duk_equals(duk_hthread *thr, duk_idx_t idx1, duk_idx_t idx2) {
 duk_tval *tv1, *tv2={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv1 = duk_get_tval(thr, idx1);
 tv2 = duk_get_tval(thr, idx2);
 if ((tv1 == ((void *)0)) || (tv2 == ((void *)0))) {
  return 0;
 }




 return duk_js_equals_helper((thr), (tv1), (tv2), 0);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_strict_equals(duk_hthread *thr, duk_idx_t idx1, duk_idx_t idx2) {
 duk_tval *tv1, *tv2={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv1 = duk_get_tval(thr, idx1);
 tv2 = duk_get_tval(thr, idx2);
 if ((tv1 == ((void *)0)) || (tv2 == ((void *)0))) {
  return 0;
 }


 return duk_js_equals_helper(((void *)0), (tv1), (tv2), (1U << 1));
}

__attribute__ ((visibility("default"))) duk_bool_t duk_samevalue(duk_hthread *thr, duk_idx_t idx1, duk_idx_t idx2) {
 duk_tval *tv1, *tv2={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 tv1 = duk_get_tval(thr, idx1);
 tv2 = duk_get_tval(thr, idx2);
 if ((tv1 == ((void *)0)) || (tv2 == ((void *)0))) {
  return 0;
 }


 return duk_js_equals_helper(((void *)0), (tv1), (tv2), (1U << 0));
}





__attribute__ ((visibility("default"))) duk_bool_t duk_instanceof(duk_hthread *thr, duk_idx_t idx1, duk_idx_t idx2) {
 duk_tval *tv1, *tv2={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);







 tv1 = duk_require_tval(thr, idx1);
 do { } while (0);
 tv2 = duk_require_tval(thr, idx2);
 do { } while (0);

 return duk_js_instanceof(thr, tv1, tv2);
}





static __attribute__ ((unused)) void duk_push_lightfunc_name_raw(duk_hthread *thr, duk_c_function func, duk_small_uint_t lf_flags) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk_push_literal_raw((thr), ("light_"), sizeof(("light_")) - 1U);
 duk_push_string_funcptr(thr, (duk_uint8_t *) &func, sizeof(func));
 duk_push_sprintf(thr, "_%04x", (unsigned int) lf_flags);
 duk_concat(thr, 3);
}

static __attribute__ ((unused)) void duk_push_lightfunc_name(duk_hthread *thr, duk_tval *tv) {
 duk_c_function func={0};
 duk_small_uint_t lf_flags={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { (lf_flags) = (tv)->ui[1] & 0xffffUL; (func) = (duk_c_function) (tv)->ui[0]; } while (0);
 duk_push_lightfunc_name_raw(thr, func, lf_flags);
}

static __attribute__ ((unused)) void duk_push_lightfunc_tostring(duk_hthread *thr, duk_tval *tv) {
 duk_c_function func={0};
 duk_small_uint_t lf_flags={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { (lf_flags) = (tv)->ui[1] & 0xffffUL; (func) = (duk_c_function) (tv)->ui[0]; } while (0);
 duk_push_literal_raw((thr), ("function "), sizeof(("function ")) - 1U);
 duk_push_lightfunc_name_raw(thr, func, lf_flags);
 duk_push_literal_raw((thr), ("() { [lightfunc code] }"), sizeof(("() { [lightfunc code] }")) - 1U);
 duk_concat(thr, 3);
}
static __attribute__ ((unused)) void duk_push_string_funcptr(duk_hthread *thr, duk_uint8_t *ptr, duk_size_t sz) {
 duk_uint8_t buf[32 * 2]={0};
 duk_uint8_t *p, *q={0};
 duk_small_uint_t i={0};
 duk_small_uint_t t={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 p = buf;

 q = ptr + sz;



 for (i = 0; i < sz; i++) {

  t = *(--q);



  *p++ = duk_lc_digits[t >> 4];
  *p++ = duk_lc_digits[t & 0x0f];
 }

 duk_push_lstring(thr, (const char *) buf, sz * 2);
}
static void duk__push_hstring_readable_unicode(duk_hthread *thr, duk_hstring *h_input, duk_small_uint_t maxchars) {
 const duk_uint8_t *p, *p_start, *p_end={0};
 duk_uint8_t buf[7 * 96 +
                 2 + 3 ]={0};
 duk_uint8_t *q={0};
 duk_ucodepoint_t cp={0};
 duk_small_uint_t nchars={0};

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 p_start = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_input) + 1));
 p_end = p_start + ((h_input)->blen);
 p = p_start;
 q = buf;

 nchars = 0;
 *q++ = (duk_uint8_t) 0x27;
 for (;;) {
  if (p >= p_end) {
   break;
  }
  if (nchars == maxchars) {
   *q++ = (duk_uint8_t) 0x2e;
   *q++ = (duk_uint8_t) 0x2e;
   *q++ = (duk_uint8_t) 0x2e;
   break;
  }
  if (duk_unicode_decode_xutf8(thr, &p, p_start, p_end, &cp)) {
   if (cp < 0x20 || cp == 0x7f || cp == 0x27 || cp == 0x5c) {
    do { } while (0);
    do { } while (0);
    *q++ = (duk_uint8_t) 0x5c;
    *q++ = (duk_uint8_t) 0x78;
    *q++ = (duk_uint8_t) duk_lc_digits[cp >> 4];
    *q++ = (duk_uint8_t) duk_lc_digits[cp & 0x0f];
   } else {
    q += duk_unicode_encode_xutf8(cp, q);
   }
  } else {
   p++;
   *q++ = (duk_uint8_t) 0x3f;
  }
  nchars++;
 }
 *q++ = (duk_uint8_t) 0x27;

 duk_push_lstring(thr, (const char *) buf, (duk_size_t) (q - buf));
}

static const char *duk__push_string_tval_readable(duk_hthread *thr, duk_tval *tv, duk_bool_t error_aware) {
 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);


 if (tv == ((void *)0)) {
  duk_push_literal_raw((thr), ("none"), sizeof(("none")) - 1U);
 } else {
  switch (((duk_small_uint_t) (tv)->us[3])) {
  case 0xfff8UL: {
   duk_hstring *h = ((duk_hstring *) (tv)->vp[0]);
   if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {



    duk_push_literal_raw((thr), ("[Symbol "), sizeof(("[Symbol ")) - 1U);
    duk_push_string(thr, duk__get_symbol_type_string(h));
    duk_push_literal_raw((thr), (" "), sizeof((" ")) - 1U);
    duk__push_hstring_readable_unicode(thr, h, 32);
    duk_push_literal_raw((thr), ("]"), sizeof(("]")) - 1U);
    duk_concat(thr, 5);
    break;
   }
   duk__push_hstring_readable_unicode(thr, h, 32);
   break;
  }
  case 0xfff9UL: {
   duk_hobject *h = ((duk_hobject *) (tv)->vp[0]);
   do { } while (0);

   if (error_aware &&
       duk_hobject_prototype_chain_contains(thr, h, thr->builtins[20], 1 )) {







    duk_tval *tv_msg={0};
    tv_msg = duk_hobject_find_existing_entry_tval_ptr(thr->heap, h, (((thr))->strs[(52)]));
    if (tv_msg != ((void *)0) && (((duk_small_uint_t) ((tv_msg))->us[3]) == 0xfff8UL)) {



     duk__push_hstring_readable_unicode(thr, ((duk_hstring *) (tv_msg)->vp[0]), 96);
     break;
    }
   }
   duk_push_class_string_tval(thr, tv, 1 );
   break;
  }
  case 0xfffaUL: {





   duk_hbuffer *h = ((duk_hbuffer *) (tv)->vp[0]);
   do { } while (0);
   duk_push_sprintf(thr, "[buffer:%ld]", (long) (((duk_hbuffer *) (h))->size));
   break;
  }
  case 0xfff6UL: {



   duk_push_tval(thr, tv);
   duk_push_sprintf(thr, "(%s)", duk_to_string(thr, -1));
   duk_remove_m2(thr);
   break;
  }
  default: {
   duk_push_tval(thr, tv);
   break;
  }
  }
 }

 return duk_to_string(thr, -1);
}
static __attribute__ ((unused)) const char *duk_push_string_tval_readable(duk_hthread *thr, duk_tval *tv) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__push_string_tval_readable(thr, tv, 0 );
}

static __attribute__ ((unused)) const char *duk_push_string_readable(duk_hthread *thr, duk_idx_t idx) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk_push_string_tval_readable(thr, duk_get_tval(thr, idx));
}

static __attribute__ ((unused)) const char *duk_push_string_tval_readable_error(duk_hthread *thr, duk_tval *tv) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__push_string_tval_readable(thr, tv, 1 );
}

static __attribute__ ((unused)) void duk_push_symbol_descriptive_string(duk_hthread *thr, duk_hstring *h) {
 const duk_uint8_t *p={0};
 const duk_uint8_t *p_end={0};
 const duk_uint8_t *q={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);


 duk_push_literal_raw((thr), ("Symbol("), sizeof(("Symbol(")) - 1U);
 p = (const duk_uint8_t *) ((const duk_uint8_t *) ((h) + 1));
 p_end = p + ((h)->blen);
 do { } while (0);
 p++;
 for (q = p; q < p_end; q++) {
  if (*q == 0xffU) {





   break;
  }
 }
 duk_push_lstring(thr, (const char *) p, (duk_size_t) (q - p));
 duk_push_literal_raw((thr), (")"), sizeof((")")) - 1U);
 duk_concat(thr, 3);
}
static __attribute__ ((unused)) void duk_copy_tvals_incref(duk_hthread *thr, duk_tval *tv_dst, duk_tval *tv_src, duk_size_t count) {
 duk_tval *tv={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { (void) (thr); } while (0);
 do { } while (0);

 do { void *duk__dst = ((void *) tv_dst); const void *duk__src = ((const void *) tv_src); duk_size_t duk__len = (count * sizeof(duk_tval)); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0);

 tv = tv_dst;
 while (count-- > 0) {
  do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  tv++;
 }
}






static void duk__concat_and_join_helper(duk_hthread *thr, duk_idx_t count_in, duk_bool_t is_join) {
 duk_uint_t count={0};
 duk_uint_t i={0};
 duk_size_t idx={0};
 duk_size_t len={0};
 duk_hstring *h={0};
 duk_uint8_t *buf={0};

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (__builtin_expect((count_in <= 0), 0)) {
  if (count_in < 0) {
   do { do { duk_err_range(((thr)), "duk_api_string.c", (duk_int_t) 19, ("invalid count")); } while (0); } while (0);
   do { } while (0);
  }
  do { } while (0);
  duk_push_hstring_empty(thr);
  return;
 }
 count = (duk_uint_t) count_in;

 if (is_join) {
  duk_size_t t1, t2, limit={0};
  h = duk_to_hstring(thr, -((duk_idx_t) count) - 1);
  do { } while (0);


  t1 = (duk_size_t) ((h)->blen);
  t2 = (duk_size_t) (count - 1);
  limit = (duk_size_t) (0x7fffffffUL);
  if (__builtin_expect((t2 != 0 && t1 > limit / t2), 0)) {

   goto error_overflow;
  }
  len = (duk_size_t) (t1 * t2);
 } else {
  len = (duk_size_t) 0;
 }

 for (i = count; i >= 1; i--) {
  duk_size_t new_len={0};
  h = duk_to_hstring(thr, -((duk_idx_t) i));
  new_len = len + (duk_size_t) ((h)->blen);




  if (new_len < len ||
      new_len > (duk_size_t) (0x7fffffffUL)) {
   goto error_overflow;
  }
  len = new_len;
 }

 do { } while (0)
                                                                  ;




 buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, len);
 do { } while (0);



 idx = 0;
 for (i = count; i >= 1; i--) {
  if (is_join && i != count) {
   h = duk_require_hstring(thr, -((duk_idx_t) count) - 2);
   do { void *duk__dst = (buf + idx); const void *duk__src = (((const duk_uint8_t *) ((h) + 1))); duk_size_t duk__len = (((h)->blen)); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
   idx += ((h)->blen);
  }
  h = duk_require_hstring(thr, -((duk_idx_t) i) - 1);
  do { void *duk__dst = (buf + idx); const void *duk__src = (((const duk_uint8_t *) ((h) + 1))); duk_size_t duk__len = (((h)->blen)); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  idx += ((h)->blen);
 }

 do { } while (0);





 if (is_join) {
  duk_replace(thr, -((duk_idx_t) count) - 2);
  duk_pop_n(thr, (duk_idx_t) count);
 } else {
  duk_replace(thr, -((duk_idx_t) count) - 1);
  duk_pop_n(thr, (duk_idx_t) (count - 1));
 }



 (void) duk_buffer_to_string(thr, -1);


 return;

 error_overflow:
 do { duk_err_range((thr), "duk_api_string.c", (duk_int_t) 106, ("result too long")); } while (0);
 do { } while (0);
}

__attribute__ ((visibility("default"))) void duk_concat(duk_hthread *thr, duk_idx_t count) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk__concat_and_join_helper(thr, count, 0 );
}







static __attribute__ ((unused)) void duk_concat_2(duk_hthread *thr) {
 duk_hstring *h1={0};
 duk_hstring *h2={0};
 duk_uint8_t *buf={0};
 duk_size_t len1={0};
 duk_size_t len2={0};
 duk_size_t len={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 h1 = duk_to_hstring(thr, -2);
 h2 = duk_to_hstring(thr, -1);
 len1 = (duk_size_t) ((h1)->blen);
 len2 = (duk_size_t) ((h2)->blen);
 len = len1 + len2;
 if (__builtin_expect((len < len1 || len > (duk_size_t) (0x7fffffffUL)), 0)
                                                             ) {
  goto error_overflow;
 }
 buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, len);
 do { } while (0);

 do { void *duk__dst = ((void *) buf); const void *duk__src = ((const void *) ((const duk_uint8_t *) ((h1) + 1))); duk_size_t duk__len = ((size_t) len1); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 do { void *duk__dst = ((void *) (buf + len1)); const void *duk__src = ((const void *) ((const duk_uint8_t *) ((h2) + 1))); duk_size_t duk__len = ((size_t) len2); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 (void) duk_buffer_to_string(thr, -1);



 duk_replace(thr, -3);
 duk_pop_unsafe(thr);
 return;

 error_overflow:
 do { duk_err_range((thr), "duk_api_string.c", (duk_int_t) 156, ("result too long")); } while (0);
 do { } while (0);
}


__attribute__ ((visibility("default"))) void duk_join(duk_hthread *thr, duk_idx_t count) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 duk__concat_and_join_helper(thr, count, 1 );
}





__attribute__ ((visibility("default"))) void duk_decode_string(duk_hthread *thr, duk_idx_t idx, duk_decode_char_function callback, void *udata) {
 duk_hstring *h_input={0};
 const duk_uint8_t *p, *p_start, *p_end={0};
 duk_codepoint_t cp={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 h_input = duk_require_hstring(thr, idx);
 do { } while (0);

 p_start = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_input) + 1));
 p_end = p_start + ((h_input)->blen);
 p = p_start;

 for (;;) {
  if (p >= p_end) {
   break;
  }
  cp = (duk_codepoint_t) duk_unicode_decode_xutf8_checked(thr, &p, p_start, p_end);
  callback(udata, cp);
 }
}

__attribute__ ((visibility("default"))) void duk_map_string(duk_hthread *thr, duk_idx_t idx, duk_map_char_function callback, void *udata) {
 duk_hstring *h_input={0};
 duk_bufwriter_ctx bw_alloc={0};
 duk_bufwriter_ctx *bw={0};
 const duk_uint8_t *p, *p_start, *p_end={0};
 duk_codepoint_t cp={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_normalize_index(thr, idx);

 h_input = duk_require_hstring(thr, idx);
 do { } while (0);

 bw = &bw_alloc;
 do { duk_bw_init_pushbuf((thr), (bw), (((h_input)->blen))); } while (0);

 p_start = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_input) + 1));
 p_end = p_start + ((h_input)->blen);
 p = p_start;

 for (;;) {




  if (p >= p_end) {
   break;
  }
  cp = (duk_codepoint_t) duk_unicode_decode_xutf8_checked(thr, &p, p_start, p_end);
  cp = callback(udata, cp);

  do { do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (7); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) ((cp)); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, ((bw))->p); ((bw))->p += duk__enc_len; } while (0); } while (0);
 }

 do { duk_bw_compact((thr), (bw)); } while (0);
 (void) duk_buffer_to_string(thr, -1);
 duk_replace(thr, idx);
}

__attribute__ ((visibility("default"))) void duk_substring(duk_hthread *thr, duk_idx_t idx, duk_size_t start_offset, duk_size_t end_offset) {
 duk_hstring *h={0};
 duk_hstring *res={0};
 duk_size_t start_byte_offset={0};
 duk_size_t end_byte_offset={0};
 duk_size_t charlen={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);
 h = duk_require_hstring(thr, idx);
 do { } while (0);

 charlen = duk_hstring_get_charlen((h));
 if (end_offset >= charlen) {
  end_offset = charlen;
 }
 if (start_offset > end_offset) {
  start_offset = end_offset;
 }

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 do { } while (0);
 do { } while (0);

 start_byte_offset = (duk_size_t) duk_heap_strcache_offset_char2byte(thr, h, (duk_uint_fast32_t) start_offset);
 end_byte_offset = (duk_size_t) duk_heap_strcache_offset_char2byte(thr, h, (duk_uint_fast32_t) end_offset);

 do { } while (0);
 do { } while (0);


 res = duk_heap_strtable_intern_checked(thr,
                                        ((const duk_uint8_t *) ((h) + 1)) + start_byte_offset,
                                        (duk_uint32_t) (end_byte_offset - start_byte_offset));

 duk_push_hstring(thr, res);
 duk_replace(thr, idx);
}




__attribute__ ((visibility("default"))) void duk_trim(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *h={0};
 const duk_uint8_t *p, *p_start, *p_end, *p_tmp1, *p_tmp2={0};
 const duk_uint8_t *q_start, *q_end={0};
 duk_codepoint_t cp={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);
 h = duk_require_hstring(thr, idx);
 do { } while (0);

 p_start = ((const duk_uint8_t *) ((h) + 1));
 p_end = p_start + ((h)->blen);

 p = p_start;
 while (p < p_end) {
  p_tmp1 = p;
  cp = (duk_codepoint_t) duk_unicode_decode_xutf8_checked(thr, &p_tmp1, p_start, p_end);
  if (!(duk_unicode_is_whitespace(cp) || duk_unicode_is_line_terminator(cp))) {
   break;
  }
  p = p_tmp1;
 }
 q_start = p;
 if (p == p_end) {

  q_end = p;
  goto scan_done;
 }

 p = p_end;
 while (p > p_start) {
  p_tmp1 = p;
  while (p > p_start) {
   p--;
   if (((*p) & 0xc0) != 0x80) {
    break;
   }
  }
  p_tmp2 = p;

  cp = (duk_codepoint_t) duk_unicode_decode_xutf8_checked(thr, &p_tmp2, p_start, p_end);
  if (!(duk_unicode_is_whitespace(cp) || duk_unicode_is_line_terminator(cp))) {
   p = p_tmp1;
   break;
  }
 }
 q_end = p;

 scan_done:



 if (q_end < q_start) {
  q_end = q_start;
 }

 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0)

                                                                    ;

 if (q_start == p_start && q_end == p_end) {
  do { } while (0);
  return;
 }

 duk_push_lstring(thr, (const char *) q_start, (duk_size_t) (q_end - q_start));
 duk_replace(thr, idx);
}

__attribute__ ((visibility("default"))) duk_codepoint_t duk_char_code_at(duk_hthread *thr, duk_idx_t idx, duk_size_t char_offset) {
 duk_hstring *h={0};
 duk_ucodepoint_t cp={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);





 h = duk_require_hstring(thr, idx);
 do { } while (0);

 do { } while (0);
 if (char_offset >= duk_hstring_get_charlen((h))) {
  return 0;
 }

 do { } while (0);
 cp = duk_hstring_char_code_at_raw(thr, h, (duk_uint_t) char_offset, 0 );
 return (duk_codepoint_t) cp;
}






static __attribute__ ((unused)) duk_double_t duk_time_get_ecmascript_time(duk_hthread *thr) {



 do { (void) (thr); } while (0);
 return (duk_double_t) duk_bi_date_get_now_gettimeofday();
}

static __attribute__ ((unused)) duk_double_t duk_time_get_ecmascript_time_nofrac(duk_hthread *thr) {



 do { (void) (thr); } while (0);
 return (duk_double_t) floor(duk_bi_date_get_now_gettimeofday());
}

static __attribute__ ((unused)) duk_double_t duk_time_get_monotonic_time(duk_hthread *thr) {
 do { (void) (thr); } while (0);



 return (duk_double_t) duk_bi_date_get_now_gettimeofday();

}

__attribute__ ((visibility("default"))) duk_double_t duk_get_now(duk_hthread *thr) {
 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { (void) (thr); } while (0);


 return duk_time_get_ecmascript_time(thr);
}
__attribute__ ((visibility("default"))) void duk_time_to_components(duk_hthread *thr, duk_double_t timeval, duk_time_components *comp) {
 duk_int_t parts[8]={0};
 duk_double_t dparts[8]={0};
 duk_uint_t flags={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);




 flags = (1 << 2) | (1 << 0);

 duk_bi_date_timeval_to_parts(timeval, parts, dparts, flags);



 do { } while (0);
 comp->year = dparts[0];
 comp->month = dparts[1] - 1.0;
 comp->day = dparts[2];
 comp->hours = dparts[3];
 comp->minutes = dparts[4];
 comp->seconds = dparts[5];
 comp->milliseconds = dparts[6];
 comp->weekday = dparts[7];
}

__attribute__ ((visibility("default"))) duk_double_t duk_components_to_time(duk_hthread *thr, duk_time_components *comp) {
 duk_double_t d={0};
 duk_double_t dparts[8]={0};
 duk_uint_t flags={0};

 do { do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);






 flags = 0;





 dparts[0] = comp->year;
 dparts[1] = comp->month;
 dparts[2] = comp->day - 1.0;
 dparts[3] = comp->hours;
 dparts[4] = comp->minutes;
 dparts[5] = comp->seconds;
 dparts[6] = comp->milliseconds;
 dparts[7] = 0;

 d = duk_bi_date_get_timeval_from_dparts(dparts, flags);

 return d;
}
static duk_uint32_t duk__push_this_obj_len_u32(duk_hthread *thr) {
 duk_uint32_t len={0};


 (void) duk_push_this_coercible_to_object(thr);
 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (86))));
 len = duk_to_uint32(thr, -1);


 return len;
}

static duk_uint32_t duk__push_this_obj_len_u32_limited(duk_hthread *thr) {




 duk_uint32_t ret = duk__push_this_obj_len_u32(thr);
 if (__builtin_expect((ret >= 0x80000000UL), 0)) {
  do { do { duk_err_range(((thr)), "duk_bi_array.c", (duk_int_t) 79, ("invalid length")); } while (0); } while (0);
  do { } while (0);
 }
 return ret;
}
static duk_harray *duk__arraypart_fastpath_this(duk_hthread *thr) {
 duk_tval *tv={0};
 duk_hobject *h={0};
 duk_uint_t flags_mask, flags_bits, flags_value={0};

 do { } while (0);
 tv = (((void) 0), (thr)->valstack_bottom - 1);




 if (!(((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
  do { } while (0);
  return ((void *)0);
 }
 h = ((duk_hobject *) (tv)->vp[0]);
 do { } while (0);
 flags_mask = (1UL << (7 + (8))) |
              (1UL << (7 + (15))) |
              (1UL << (2 + (4)));
 flags_bits = (1UL << (7 + (8))) |
              (1UL << (7 + (15)));
 flags_value = (((duk_heaphdr *) h)->h_flags);
 if ((flags_value & flags_mask) != flags_bits) {
  do { } while (0);
  return ((void *)0);
 }







 if (((duk_harray *) h)->length > ((h)->a_size)) {
  do { } while (0);
  return ((void *)0);
 }


 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);
 return (duk_harray *) h;
}






static __attribute__ ((unused)) duk_ret_t duk_bi_array_constructor(duk_hthread *thr) {
 duk_idx_t nargs={0};
 duk_harray *a={0};
 duk_double_t d={0};
 duk_uint32_t len={0};
 duk_uint32_t len_prealloc={0};

 nargs = duk_get_top(thr);

 if (nargs == 1 && duk_is_number(thr, 0)) {

  d = duk_get_number(thr, 0);
  len = duk_to_uint32(thr, 0);
  if (((duk_double_t) len) != d) {
   do { do { do { duk_err_range((((thr))), "duk_bi_array.c", (duk_int_t) 159, ("invalid length")); } while (0); } while (0); return 0; } while (0);
  }




  len_prealloc = len < 64 ? len : 64;
  a = duk_push_harray_with_size(thr, len_prealloc);
  do { } while (0);
  a->length = len;
  return 1;
 }

 duk_pack(thr, nargs);
 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_array_constructor_is_array(duk_hthread *thr) {
 duk_hobject *h={0};

 h = duk_get_hobject_with_class(thr, 0, 2);
 duk_push_boolean(thr, (h != ((void *)0)));
 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_to_string(duk_hthread *thr) {
 (void) duk_push_this_coercible_to_object(thr);
 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (38))));


 if (!duk_is_function((thr), (-1))) {
  do { } while (0);
  duk_set_top(thr, 0);
  return duk_bi_object_prototype_to_string(thr);
 }



 duk_insert(thr, -2);



 do { } while (0)

                                                          ;
 duk_call_method(thr, 0);

 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_concat(duk_hthread *thr) {
 duk_idx_t i, n={0};
 duk_uint32_t j, idx, len={0};
 duk_hobject *h={0};
 duk_size_t tmp_len={0};
 (void) duk_push_this_coercible_to_object(thr);
 duk_insert(thr, 0);
 n = duk_get_top(thr);
 duk_push_array(thr);
 idx = 0;
 for (i = 0; i < n; i++) {
  duk_bool_t spreadable={0};
  duk_bool_t need_has_check={0};

  do { } while (0);



  h = duk_get_hobject(thr, i);

  if (h == ((void *)0)) {
   spreadable = 0;
  } else {
   spreadable = ((((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 2);

  }

  if (!spreadable) {
   duk_dup(thr, i);
   duk_xdef_prop_index((thr), (-2), (idx), ((1U << 0) | (1U << 1) | (1U << 2)));
   idx++;
   if (__builtin_expect((idx == 0U), 0)) {




    goto fail_wrap;
   }
   continue;
  }

  do { } while (0);
  need_has_check = ((((&((h))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0) != 0);



  tmp_len = duk_get_length(thr, i);
  len = (duk_uint32_t) tmp_len;
  if (__builtin_expect((tmp_len != (duk_size_t) len), 0)) {
   goto fail_wrap;
  }
  if (__builtin_expect((idx + len < idx), 0)) {



   goto fail_wrap;
  }
  for (j = 0; j < len; j++) {



   if (need_has_check) {
    if (duk_has_prop_index(thr, i, j)) {
     duk_get_prop_index(thr, i, j);
     duk_xdef_prop_index((thr), (-2), (idx), ((1U << 0) | (1U << 1) | (1U << 2)));
    }
   } else {
    if (duk_get_prop_index(thr, i, j)) {
     duk_xdef_prop_index((thr), (-2), (idx), ((1U << 0) | (1U << 1) | (1U << 2)));
    } else {
     duk_pop_undefined(thr);
    }
   }
   idx++;
   do { } while (0);
  }
 }






 duk_push_uint((thr), (duk_uint_t) (idx));
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (86)) << 8) + (duk_uint_t) (((1U << 0)))));

 do { } while (0);
 return 1;

 fail_wrap:
 do { do { duk_err_range(((thr)), "duk_bi_array.c", (duk_int_t) 350, ("invalid length")); } while (0); } while (0);
 do { } while (0);
}
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_join_shared(duk_hthread *thr) {
 duk_uint32_t len, count={0};
 duk_uint32_t idx={0};
 duk_small_int_t to_locale_string = duk_get_current_magic(thr);
 duk_idx_t valstack_required={0};





 duk_set_top(thr, 1);
 if (duk_is_undefined(thr, 0)) {
  duk_pop_undefined(thr);
  duk_push_hstring_stridx(thr, 63);
 } else {
  duk_to_string(thr, 0);
 }

 len = duk__push_this_obj_len_u32(thr);



 do { } while (0)


                                           ;


 valstack_required = (duk_idx_t) ((len >= 4096 ?
                                   4096 : len) + 4);
 duk_require_stack(thr, valstack_required);

 duk_dup_0(thr);



 count = 0;
 idx = 0;
 for (;;) {
  do { } while (0);
  if (count >= 4096 ||
      idx >= len) {

   do { } while (0)
                                                              ;
   duk_join(thr, (duk_idx_t) count);
   duk_dup_0(thr);
   duk_insert(thr, -2);
   count = 1;
  }
  if (idx >= len) {

   break;
  }

  duk_get_prop_index(thr, 1, (duk_uarridx_t) idx);
  if (((duk_get_type_mask((thr), (-1)) & ((1U << 2U) | (1U << 1U))) ? 1 : 0)) {
   duk_pop_nodecref_unsafe(thr);
   duk_push_hstring_empty(thr);
  } else {
   if (to_locale_string) {
    duk_to_object(thr, -1);
    (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (39))));
    duk_insert(thr, -2);
    duk_call_method(thr, 0);
   }
   duk_to_string(thr, -1);
  }

  count++;
  idx++;
 }



 return 1;
}






static duk_ret_t duk__array_pop_fastpath(duk_hthread *thr, duk_harray *h_arr) {
 duk_tval *tv_arraypart={0};
 duk_tval *tv_val={0};
 duk_uint32_t len={0};

 tv_arraypart = ((duk_tval *) (void *) ( ((((duk_hobject *) h_arr))->props) + ((((duk_hobject *) h_arr))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((duk_hobject *) h_arr))->e_size))) & 0x07) ));
 len = h_arr->length;
 if (len <= 0) {

  return 0;
 }

 len--;
 h_arr->length = len;





 do { } while (0);
 tv_val = tv_arraypart + len;
 if ((((duk_small_uint_t) ((tv_val))->us[3]) == 0xfff2UL)) {



  do { } while (0);
  do { } while (0);
 } else {

  do { *(thr->valstack_top) = *(tv_val); } while (0);
  do { (tv_val)->us[3] = (duk_uint16_t) 0xfff2UL; } while (0);
 }
 thr->valstack_top++;



 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_pop(duk_hthread *thr) {
 duk_uint32_t len={0};
 duk_uint32_t idx={0};

 duk_harray *h_arr={0};


 do { } while (0);


 h_arr = duk__arraypart_fastpath_this(thr);
 if (h_arr) {
  return duk__array_pop_fastpath(thr, h_arr);
 }




 len = duk__push_this_obj_len_u32(thr);
 if (len == 0) {
  duk_push_int(thr, 0);
  (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (86))));
  return 0;
 }
 idx = len - 1;

 duk_get_prop_index(thr, 0, (duk_uarridx_t) idx);
 duk_del_prop_index(thr, 0, (duk_uarridx_t) idx);
 duk_push_uint((thr), (duk_uint_t) (idx));
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (86))));
 return 1;
}


static duk_ret_t duk__array_push_fastpath(duk_hthread *thr, duk_harray *h_arr) {
 duk_tval *tv_arraypart={0};
 duk_tval *tv_src={0};
 duk_tval *tv_dst={0};
 duk_uint32_t len={0};
 duk_idx_t i, n={0};

 len = h_arr->length;
 tv_arraypart = ((duk_tval *) (void *) ( ((((duk_hobject *) h_arr))->props) + ((((duk_hobject *) h_arr))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((duk_hobject *) h_arr))->e_size))) & 0x07) ));

 n = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom);
 do { } while (0);
 do { } while (0);
 if (__builtin_expect((len + (duk_uint32_t) n < len), 0)) {
  do { } while (0);
  do { do { do { duk_err_range((((thr))), "duk_bi_array.c", (duk_int_t) 539, ("invalid length")); } while (0); } while (0); return 0; } while (0);
 }
 if (len + (duk_uint32_t) n > (((duk_hobject *) h_arr)->a_size)) {





  return 0;
 }

 tv_src = thr->valstack_bottom;
 tv_dst = tv_arraypart + len;
 for (i = 0; i < n; i++) {



  do { *(tv_dst) = *(tv_src); } while (0);
  do { (tv_src)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);
  tv_src++;
  tv_dst++;
 }
 thr->valstack_top = thr->valstack_bottom;
 len += (duk_uint32_t) n;
 h_arr->length = len;

 do { } while (0);
 duk_push_uint(thr, (duk_uint_t) len);
 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_push(duk_hthread *thr) {






 duk_uint32_t len={0};
 duk_idx_t i, n={0};

 duk_harray *h_arr={0};



 h_arr = duk__arraypart_fastpath_this(thr);
 if (h_arr) {
  duk_ret_t rc={0};
  rc = duk__array_push_fastpath(thr, h_arr);
  if (rc != 0) {
   return rc;
  }
  do { } while (0);
 }


 n = duk_get_top(thr);
 len = duk__push_this_obj_len_u32(thr);
 if (len + (duk_uint32_t) n < len) {
  do { } while (0);
  do { do { do { duk_err_range((((thr))), "duk_bi_array.c", (duk_int_t) 613, ("invalid length")); } while (0); } while (0); return 0; } while (0);
 }

 for (i = 0; i < n; i++) {
  duk_dup(thr, i);
  duk_put_prop_index(thr, -3, (duk_uarridx_t) (len + (duk_uint32_t) i));
 }
 len += (duk_uint32_t) n;

 duk_push_uint((thr), (duk_uint_t) (len));
 duk_dup_top(thr);
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-4)) << 16) + ((duk_uint_t) (86))));


 return 1;
}
static duk_small_int_t duk__array_sort_compare(duk_hthread *thr, duk_int_t idx1, duk_int_t idx2) {
 duk_bool_t have1, have2={0};
 duk_bool_t undef1, undef2={0};
 duk_small_int_t ret={0};
 duk_idx_t idx_obj = 1;
 duk_idx_t idx_fn = 0;
 duk_hstring *h1, *h2={0};
 if (idx1 == idx2) {
  do { } while (0)
                                                 ;
  return 0;
 }

 have1 = duk_get_prop_index(thr, idx_obj, (duk_uarridx_t) idx1);
 have2 = duk_get_prop_index(thr, idx_obj, (duk_uarridx_t) idx2);

 do { } while (0)

                                                                                              ;

 if (have1) {
  if (have2) {
   ;
  } else {
   ret = -1;
   goto pop_ret;
  }
 } else {
  if (have2) {
   ret = 1;
   goto pop_ret;
  } else {
   ret = 0;
   goto pop_ret;
  }
 }

 undef1 = duk_is_undefined(thr, -2);
 undef2 = duk_is_undefined(thr, -1);
 if (undef1) {
  if (undef2) {
   ret = 0;
   goto pop_ret;
  } else {
   ret = 1;
   goto pop_ret;
  }
 } else {
  if (undef2) {
   ret = -1;
   goto pop_ret;
  } else {
   ;
  }
 }

 if (!duk_is_undefined(thr, idx_fn)) {
  duk_double_t d={0};


  duk_dup(thr, idx_fn);
  duk_insert(thr, -3);
  duk_call(thr, 2);






  d = duk_to_number_m1(thr);
  if (d < 0.0) {
   ret = -1;
  } else if (d > 0.0) {
   ret = 1;
  } else {



   ret = 0;
  }

  duk_pop_nodecref_unsafe(thr);
  do { } while (0);
  return ret;
 }




 h1 = duk_to_hstring(thr, -2);
 h2 = duk_to_hstring_m1(thr);
 do { } while (0);
 do { } while (0);

 ret = duk_js_string_compare(h1, h2);
 goto pop_ret;

 pop_ret:
 duk_pop_2_unsafe(thr);
 do { } while (0);
 return ret;
}

static void duk__array_sort_swap(duk_hthread *thr, duk_int_t l, duk_int_t r) {
 duk_bool_t have_l, have_r={0};
 duk_idx_t idx_obj = 1;

 if (l == r) {
  return;
 }


 have_l = duk_get_prop_index(thr, idx_obj, (duk_uarridx_t) l);
 have_r = duk_get_prop_index(thr, idx_obj, (duk_uarridx_t) r);

 if (have_r) {

  duk_put_prop_index(thr, idx_obj, (duk_uarridx_t) l);
 } else {
  duk_del_prop_index(thr, idx_obj, (duk_uarridx_t) l);
  duk_pop_undefined(thr);
 }

 if (have_l) {
  duk_put_prop_index(thr, idx_obj, (duk_uarridx_t) r);
 } else {
  duk_del_prop_index(thr, idx_obj, (duk_uarridx_t) r);
  duk_pop_undefined(thr);
 }
}
static void duk__array_qsort(duk_hthread *thr, duk_int_t lo, duk_int_t hi) {
 duk_int_t p, l, r={0};



 do { } while (0)
                                                                               ;

 do { } while (0);







 if (hi - lo < 1) {
  do { } while (0);
  return;
 }
 do { } while (0);
 do { } while (0);


 p = lo + (duk_int_t) (duk_util_tinyrandom_get_double(thr) * (duk_double_t) (hi - lo + 1));
 do { } while (0);
 do { } while (0);


 duk__array_sort_swap(thr, p, lo);
 p = lo;
 do { } while (0);

 l = lo + 1;
 r = hi;
 for (;;) {

  for (;;) {
   do { } while (0)
                                                      ;
   if (l >= hi) {
    break;
   }
   if (duk__array_sort_compare(thr, l, p) >= 0) {
    break;
   }
   l++;
  }
  for (;;) {
   do { } while (0)
                                                      ;
   if (r <= lo) {
    break;
   }
   if (duk__array_sort_compare(thr, p, r) >= 0) {
    break;
   }
   r--;
  }
  if (l >= r) {
   goto done;
  }
  do { } while (0);

  do { } while (0);

  duk__array_sort_swap(thr, l, r);

  do { } while (0);
  l++;
  r--;
 }
 done:

 do { } while (0);
 do { } while (0);
 do { } while (0);
 duk__array_sort_swap(thr, lo, r);





 do { } while (0);
 duk__array_qsort(thr, lo, r - 1);
 duk__array_qsort(thr, r + 1, hi);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_sort(duk_hthread *thr) {
 duk_uint32_t len={0};




 len = duk__push_this_obj_len_u32_limited(thr);






 if (len > 0) {

  duk__array_qsort(thr, (duk_int_t) 0, (duk_int_t) (len - 1));
 }

 do { } while (0);
 duk_pop_nodecref_unsafe(thr);
 return 1;
}
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_splice(duk_hthread *thr) {
 duk_idx_t nargs={0};
 duk_uint32_t len_u32={0};
 duk_int_t len={0};
 duk_bool_t have_delcount={0};
 duk_int_t item_count={0};
 duk_int_t act_start={0};
 duk_int_t del_count={0};
 duk_int_t i, n={0};

 do { (void) (have_delcount); } while (0);

 nargs = duk_get_top(thr);
 if (nargs < 2) {
  duk_set_top(thr, 2);
  nargs = 2;
  have_delcount = 0;
 } else {
  have_delcount = 1;
 }




 len_u32 = duk__push_this_obj_len_u32_limited(thr);
 len = (duk_int_t) len_u32;
 do { } while (0);

 act_start = duk_to_int_clamped(thr, 0, -len, len);
 if (act_start < 0) {
  act_start = len + act_start;
 }
 do { } while (0);


 if (have_delcount) {

  del_count = duk_to_int_clamped(thr, 1, 0, len - act_start);

 } else {





  del_count = len - act_start;
 }


 do { } while (0);
 item_count = (duk_int_t) (nargs - 2);

 do { } while (0);
 do { } while (0);


 if (((duk_double_t) len) - ((duk_double_t) del_count) + ((duk_double_t) item_count) > (duk_double_t) 0xffffffffUL) {
  do { } while (0);
  do { do { do { duk_err_range((((thr))), "duk_bi_array.c", (duk_int_t) 1009, ("invalid length")); } while (0); } while (0); return 0; } while (0);
 }

 duk_push_array(thr);
 do { } while (0);



 for (i = 0; i < del_count; i++) {
  if (duk_get_prop_index(thr, -3, (duk_uarridx_t) (act_start + i))) {
   duk_xdef_prop_index((thr), (-2), ((duk_uarridx_t) i), ((1U << 0) | (1U << 1) | (1U << 2)));
  } else {
   duk_pop_undefined(thr);
  }
 }
 duk_push_uint((thr), (duk_uint_t) ((duk_uint32_t) del_count));
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (86)) << 8) + (duk_uint_t) (((1U << 0)))));



 if (item_count < del_count) {






  do { } while (0);

  n = len - del_count;
  for (i = act_start; i < n; i++) {
   if (duk_get_prop_index(thr, -3, (duk_uarridx_t) (i + del_count))) {
    duk_put_prop_index(thr, -4, (duk_uarridx_t) (i + item_count));
   } else {
    duk_pop_undefined(thr);
    duk_del_prop_index(thr, -3, (duk_uarridx_t) (i + item_count));
   }
  }

  do { } while (0);


  n = len - del_count + item_count;
  for (i = len - 1; i >= n; i--) {
   duk_del_prop_index(thr, -3, (duk_uarridx_t) i);
  }

  do { } while (0);
 } else if (item_count > del_count) {






  do { } while (0);


  for (i = len - del_count - 1; i >= act_start; i--) {
   if (duk_get_prop_index(thr, -3, (duk_uarridx_t) (i + del_count))) {
    duk_put_prop_index(thr, -4, (duk_uarridx_t) (i + item_count));
   } else {
    duk_pop_undefined(thr);
    duk_del_prop_index(thr, -3, (duk_uarridx_t) (i + item_count));
   }
  }

  do { } while (0);
 } else {





 }
 do { } while (0);



 for (i = 0; i < item_count; i++) {
  duk_dup(thr, i + 2);
  duk_put_prop_index(thr, -4, (duk_uarridx_t) (act_start + i));
 }





 duk_push_uint((thr), (duk_uint_t) ((duk_uint32_t) (len - del_count + item_count)));
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-4)) << 16) + ((duk_uint_t) (86))));


 do { } while (0);
 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_reverse(duk_hthread *thr) {
 duk_uint32_t len={0};
 duk_uint32_t middle={0};
 duk_uint32_t lower, upper={0};
 duk_bool_t have_lower, have_upper={0};

 len = duk__push_this_obj_len_u32(thr);
 middle = len / 2;





 for (lower = 0; lower < middle; lower++) {
  do { } while (0);
  do { } while (0);

  do { } while (0);
  upper = len - lower - 1;

  have_lower = duk_get_prop_index(thr, -2, (duk_uarridx_t) lower);
  have_upper = duk_get_prop_index(thr, -3, (duk_uarridx_t) upper);



  if (have_upper) {
   duk_put_prop_index(thr, -4, (duk_uarridx_t) lower);
  } else {
   duk_del_prop_index(thr, -4, (duk_uarridx_t) lower);
   duk_pop_undefined(thr);
  }

  if (have_lower) {
   duk_put_prop_index(thr, -3, (duk_uarridx_t) upper);
  } else {
   duk_del_prop_index(thr, -3, (duk_uarridx_t) upper);
   duk_pop_undefined(thr);
  }

  do { } while (0);
 }

 do { } while (0);
 duk_pop_unsafe(thr);
 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_slice(duk_hthread *thr) {
 duk_uint32_t len_u32={0};
 duk_int_t len={0};
 duk_int_t start, end={0};
 duk_int_t i={0};
 duk_uarridx_t idx={0};
 duk_uint32_t res_length = 0;




 len_u32 = duk__push_this_obj_len_u32_limited(thr);
 len = (duk_int_t) len_u32;
 do { } while (0);

 duk_push_array(thr);
 start = duk_to_int_clamped(thr, 0, -len, len);
 if (start < 0) {
  start = len + start;
 }



 if (duk_is_undefined(thr, 1)) {
  end = len;
 } else {
  end = duk_to_int_clamped(thr, 1, -len, len);
  if (end < 0) {
   end = len + end;
  }
 }
 do { } while (0);
 do { } while (0);

 idx = 0;
 for (i = start; i < end; i++) {
  do { } while (0);
  if (duk_get_prop_index(thr, 2, (duk_uarridx_t) i)) {
   duk_xdef_prop_index((thr), (4), (idx), ((1U << 0) | (1U << 1) | (1U << 2)));
   res_length = idx + 1;
  } else {
   duk_pop_undefined(thr);
  }
  idx++;
  do { } while (0);
 }

 duk_push_uint((thr), (duk_uint_t) (res_length));
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (4)) << 24) + (((duk_uint_t) (86)) << 8) + (duk_uint_t) (((1U << 0)))));

 do { } while (0);
 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_shift(duk_hthread *thr) {
 duk_uint32_t len={0};
 duk_uint32_t i={0};

 len = duk__push_this_obj_len_u32(thr);
 if (len == 0) {
  duk_push_int(thr, 0);
  (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (86))));
  return 0;
 }

 duk_get_prop_index(thr, 0, 0);






 for (i = 1; i < len; i++) {
  do { } while (0);
  if (duk_get_prop_index(thr, 0, (duk_uarridx_t) i)) {

   duk_put_prop_index(thr, 0, (duk_uarridx_t) (i - 1));
  } else {

   duk_del_prop_index(thr, 0, (duk_uarridx_t) (i - 1));
   duk_pop_undefined(thr);
  }
 }
 duk_del_prop_index(thr, 0, (duk_uarridx_t) (len - 1));

 duk_push_uint((thr), (duk_uint_t) ((duk_uint32_t) (len - 1)));
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (86))));

 do { } while (0);
 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_unshift(duk_hthread *thr) {
 duk_idx_t nargs={0};
 duk_uint32_t len={0};
 duk_uint32_t i={0};

 nargs = duk_get_top(thr);
 len = duk__push_this_obj_len_u32(thr);






 do { } while (0);






 if (len + (duk_uint32_t) nargs < len) {
  do { } while (0);
  do { do { do { duk_err_range((((thr))), "duk_bi_array.c", (duk_int_t) 1299, ("invalid length")); } while (0); } while (0); return 0; } while (0);
 }

 i = len;
 while (i > 0) {
  do { } while (0);
  i--;


  if (duk_get_prop_index(thr, -2, (duk_uarridx_t) i)) {


   duk_put_prop_index(thr, -3, (duk_uarridx_t) (i + (duk_uint32_t) nargs));
  } else {


   duk_pop_undefined(thr);
   duk_del_prop_index(thr, -2, (duk_uarridx_t) (i + (duk_uint32_t) nargs));
  }
  do { } while (0);
 }

 for (i = 0; i < (duk_uint32_t) nargs; i++) {
  do { } while (0);
  duk_dup(thr, (duk_idx_t) i);
  duk_put_prop_index(thr, -3, (duk_uarridx_t) i);
  do { } while (0);
 }

 do { } while (0);
 duk_push_uint((thr), (duk_uint_t) (len + (duk_uint32_t) nargs));
 duk_dup_top(thr);
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-4)) << 16) + ((duk_uint_t) (86))));
 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_indexof_shared(duk_hthread *thr) {
 duk_idx_t nargs={0};
 duk_int_t i, len={0};
 duk_int_t from_idx={0};
 duk_small_int_t idx_step = duk_get_current_magic(thr);






 nargs = duk_get_top(thr);
 duk_set_top(thr, 2);


 len = (duk_int_t) duk__push_this_obj_len_u32_limited(thr);
 if (len == 0) {
  goto not_found;
 }
 if (nargs >= 2) {






  from_idx = duk_to_int_clamped(thr,
                                1,
                                (idx_step > 0 ? -len : -len - 1),
                                (idx_step > 0 ? len : len - 1));
  if (from_idx < 0) {

   from_idx = len + from_idx;
  }
 } else {



  if (idx_step > 0) {
   from_idx = 0;
  } else {
   from_idx = len - 1;
  }
 }







 for (i = from_idx; i >= 0 && i < len; i += idx_step) {
  do { } while (0);

  if (duk_get_prop_index(thr, 2, (duk_uarridx_t) i)) {
   do { } while (0);
   if (duk_strict_equals(thr, 0, 4)) {
    duk_push_int(thr, i);
    return 1;
   }
  }

  duk_pop_unsafe(thr);
 }

 not_found:
 duk_push_int(thr, -1);
 return 1;
}
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_iter_shared(duk_hthread *thr) {
 duk_uint32_t len={0};
 duk_uint32_t i={0};
 duk_uarridx_t k={0};
 duk_bool_t bval={0};
 duk_small_int_t iter_type = duk_get_current_magic(thr);
 duk_uint32_t res_length = 0;


 do { } while (0);

 len = duk__push_this_obj_len_u32(thr);
 duk_require_function((thr), (0));


 if (iter_type == 3 || iter_type == 4) {
  duk_push_array(thr);
 } else {
  duk_push_undefined(thr);
 }
 k = 0;
 for (i = 0; i < len; i++) {
  do { } while (0);

  if (!duk_get_prop_index(thr, 2, (duk_uarridx_t) i)) {



   if (iter_type == 3) {
    res_length = i + 1;
   }
   duk_pop_undefined(thr);
   continue;
  }






  duk_dup_0(thr);
  duk_dup_1(thr);
  duk_dup_m3(thr);
  duk_push_uint((thr), (duk_uint_t) (i));
  duk_dup_2(thr);
  duk_call_method(thr, 3);

  switch (iter_type) {
  case 0:
   bval = duk_to_boolean(thr, -1);
   if (!bval) {

    return 1;
   }
   break;
  case 1:
   bval = duk_to_boolean(thr, -1);
   if (bval) {

    return 1;
   }
   break;
  case 2:

   break;
  case 3:
   duk_dup_top(thr);
   duk_xdef_prop_index((thr), (4), ((duk_uarridx_t) i), ((1U << 0) | (1U << 1) | (1U << 2)));
   res_length = i + 1;
   break;
  case 4:
   bval = duk_to_boolean(thr, -1);
   if (bval) {
    duk_dup_m2(thr);
    duk_xdef_prop_index((thr), (4), ((duk_uarridx_t) k), ((1U << 0) | (1U << 1) | (1U << 2)));
    k++;
    res_length = k;
   }
   break;
  default:
   do { __builtin_unreachable(); } while (0);
   break;
  }
  duk_pop_2_unsafe(thr);

  do { } while (0);
 }

 switch (iter_type) {
 case 0:
  duk_push_true(thr);
  break;
 case 1:
  duk_push_false(thr);
  break;
 case 2:
  duk_push_undefined(thr);
  break;
 case 3:
 case 4:
  do { } while (0);
  do { } while (0);
  duk_push_uint((thr), (duk_uint_t) (res_length));
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (86)) << 8) + (duk_uint_t) (((1U << 0)))));
  break;
 default:
  do { __builtin_unreachable(); } while (0);
  break;
 }

 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_reduce_shared(duk_hthread *thr) {
 duk_idx_t nargs={0};
 duk_bool_t have_acc={0};
 duk_uint32_t i, len={0};
 duk_small_int_t idx_step = duk_get_current_magic(thr);




 nargs = duk_get_top(thr);
 do { } while (0);

 duk_set_top(thr, 2);
 len = duk__push_this_obj_len_u32(thr);
 duk_require_function((thr), (0));
 have_acc = 0;
 if (nargs >= 2) {
  duk_dup_1(thr);
  have_acc = 1;
 }
 do { } while (0)
                                                                          ;







 for (i = (idx_step >= 0 ? 0 : len - 1);
      i < len;
      i += (duk_uint32_t) idx_step) {
  do { } while (0)


                                                          ;

  do { } while (0)
                                                  ;

  if (!duk_has_prop_index(thr, 2, (duk_uarridx_t) i)) {
   continue;
  }

  if (!have_acc) {
   do { } while (0);
   duk_get_prop_index(thr, 2, (duk_uarridx_t) i);
   have_acc = 1;
   do { } while (0);
  } else {
   do { } while (0);
   duk_dup_0(thr);
   duk_dup(thr, 4);
   duk_get_prop_index(thr, 2, (duk_uarridx_t) i);
   duk_push_uint((thr), (duk_uint_t) (i));
   duk_dup_2(thr);
   do { } while (0)


                                                            ;
   duk_call(thr, 4);
   do { } while (0);
   duk_replace(thr, 4);
   do { } while (0);
  }
 }

 if (!have_acc) {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_array.c", (duk_int_t) 1641); } while (0); return 0; } while (0);
 }

 do { } while (0);
 return 1;
}
static __attribute__ ((unused)) duk_ret_t duk_bi_boolean_prototype_tostring_shared(duk_hthread *thr) {
 duk_tval *tv={0};
 duk_hobject *h={0};
 duk_small_int_t coerce_tostring = duk_get_current_magic(thr);






 duk_push_this(thr);
 tv = duk_get_tval(thr, -1);
 do { } while (0);

 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff5UL)) {
  goto type_ok;
 } else if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
  h = ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);

  if ((((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 5) {
   (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (105))));
   do { } while (0);
   goto type_ok;
  }
 }

 do { do { duk_err_type_invalid_args(((thr)), "duk_bi_boolean.c", (duk_int_t) 39); } while (0); return 0; } while (0);


 type_ok:
 if (coerce_tostring) {
  duk_to_string(thr, -1);
 }
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_boolean_constructor(duk_hthread *thr) {
 duk_hobject *h_this={0};

 duk_to_boolean(thr, 0);

 if (duk_is_constructor_call(thr)) {

  duk_push_this(thr);
  h_this = duk_known_hobject(thr, -1);
  do { } while (0);

  do { (&(h_this)->hdr)->h_flags = ((&(h_this)->hdr)->h_flags & (~(((1UL << (5)) - 1UL) << ((7 + (20)))))) | (((5)) << ((7 + (20)))); } while (0);

  duk_dup_0(thr);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (105)) << 8) + (duk_uint_t) (0)));
 }

 return 1;
}
static const duk_uint8_t duk__buffer_proto_from_classnum[] = {
 39,
 40,
 41,
 42,
 43,
 44,
 45,
 46,
 47,
 48,
 49
};




static const duk_uint8_t duk__buffer_class_from_elemtype[9] = {
 22,
 23,
 21,
 25,
 24,
 27,
 26,
 28,
 29
};




static const duk_uint8_t duk__buffer_proto_from_elemtype[9] = {
 42,
 43,
 41,
 45,
 44,
 47,
 46,
 48,
 49
};


static const duk_uint8_t duk__buffer_nbytes_from_fldtype[6] = {
 1,
 2,
 4,
 4,
 8,
 0
};
static duk_uint16_t duk__buffer_elemtype_copy_compatible[9] = {

 (1U << 0) |
  (1U << 1) |
  (1U << 2),




 (1U << 0) |
  (1U << 1),


 (1U << 0) |
  (1U << 1) |
  (1U << 2),


 (1U << 3) |
  (1U << 4),


 (1U << 3) |
  (1U << 4),


 (1U << 5) |
  (1U << 6),


 (1U << 5) |
  (1U << 6),


 (1U << 7),


 (1U << 8)
};


static duk_hbufobj *duk__hbufobj_promote_this(duk_hthread *thr) {
 duk_tval *tv_dst={0};
 duk_hbufobj *res={0};

 duk_push_this(thr);
 do { } while (0);
 res = (duk_hbufobj *) duk_to_hobject(thr, -1);
 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((res)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);
 do { } while (0);

 tv_dst = duk_get_borrowed_this_tval(thr);
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv_dst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ull[0] = (((duk_uint64_t) (0xfff9UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((((duk_hobject *) res)))); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (((duk_hobject *) res)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
 duk_pop(thr);

 return res;
}
static duk_heaphdr *duk__getrequire_bufobj_this(duk_hthread *thr, duk_small_uint_t flags) {
 duk_tval *tv={0};
 duk_hbufobj *h_this={0};

 do { } while (0);

 tv = duk_get_borrowed_this_tval(thr);
 do { } while (0);

 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
  h_this = (duk_hbufobj *) ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);
  if ((((&((duk_hobject *) h_this)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {
   do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_this)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);
   return (duk_heaphdr *) h_this;
  }
 } else if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfffaUL)) {
  if (flags & (1 << 1)) {







   h_this = duk__hbufobj_promote_this(thr);
   do { } while (0);
   do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_this)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);
   return (duk_heaphdr *) h_this;
  } else {

   return (duk_heaphdr *) ((duk_hbuffer *) (tv)->vp[0]);
  }
 }

 if (flags & (1 << 0)) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 177; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_buffer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not buffer"))); } while (0); } while (0);
  do { } while (0);
 }
 return ((void *)0);
}


static duk_hbufobj *duk__get_bufobj_this(duk_hthread *thr) {
 return (duk_hbufobj *) duk__getrequire_bufobj_this(thr, (1 << 1));
}




static duk_hbufobj *duk__require_bufobj_this(duk_hthread *thr) {
 return (duk_hbufobj *) duk__getrequire_bufobj_this(thr, (1 << 0) | (1 << 1));
}


static duk_hbufobj *duk__require_bufobj_value(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv={0};
 duk_hbufobj *h_obj={0};


 do { } while (0);

 tv = duk_require_tval(thr, idx);
 do { } while (0);
 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
  h_obj = (duk_hbufobj *) ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);
  if ((((&((duk_hobject *) h_obj)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {
   do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_obj)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);
   return h_obj;
  }
 } else if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfffaUL)) {
  h_obj = (duk_hbufobj *) duk_to_hobject(thr, idx);
  do { } while (0);
  do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_obj)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);
  return h_obj;
 }

 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 219; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_buffer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not buffer"))); } while (0); } while (0);
 do { } while (0);
}

static void duk__set_bufobj_buffer(duk_hthread *thr, duk_hbufobj *h_bufobj, duk_hbuffer *h_val) {
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_bufobj)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);
 do { (void) (thr); } while (0);

 h_bufobj->buf = h_val;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_val))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 h_bufobj->length = (duk_uint_t) (((duk_hbuffer *) (h_val))->size);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_bufobj)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);
}


static void duk__resolve_offset_opt_length(duk_hthread *thr,
                                              duk_hbufobj *h_bufarg,
                                              duk_idx_t idx_offset,
                                              duk_idx_t idx_length,
                                              duk_uint_t *out_offset,
                                              duk_uint_t *out_length,
                                              duk_bool_t throw_flag) {
 duk_int_t offset_signed={0};
 duk_int_t length_signed={0};
 duk_uint_t offset={0};
 duk_uint_t length={0};

 offset_signed = duk_to_int(thr, idx_offset);
 if (offset_signed < 0) {
  goto fail_range;
 }
 offset = (duk_uint_t) offset_signed;
 if (offset > h_bufarg->length) {
  goto fail_range;
 }
 do { } while (0);
 do { } while (0);

 if (duk_is_undefined(thr, idx_length)) {
  do { } while (0);
  length = h_bufarg->length - offset;
 } else {
  length_signed = duk_to_int(thr, idx_length);
  if (length_signed < 0) {
   goto fail_range;
  }
  length = (duk_uint_t) length_signed;
  do { } while (0);
  if (length > h_bufarg->length - offset) {



   if (throw_flag) {
    goto fail_range;
   } else {
    length = h_bufarg->length - offset;
   }
  }
 }
 do { } while (0);
 do { } while (0);

 *out_offset = offset;
 *out_length = length;
 return;

 fail_range:
 do { duk_err_range((thr), "duk_bi_buffer.c", (duk_int_t) 294, ("invalid args")); } while (0);
 do { } while (0);
}




static void duk__clamp_startend_nonegidx_noshift(duk_hthread *thr,
                                                    duk_int_t buffer_length,
                                                    duk_idx_t idx_start,
                                                    duk_idx_t idx_end,
                                                    duk_int_t *out_start_offset,
                                                    duk_int_t *out_end_offset) {
 duk_int_t start_offset={0};
 duk_int_t end_offset={0};

 do { } while (0);
 do { } while (0);


 start_offset = duk_to_int_clamped(thr, idx_start, 0, buffer_length);
 if (duk_is_undefined(thr, idx_end)) {
  end_offset = buffer_length;
 } else {
  end_offset = duk_to_int_clamped(thr, idx_end, start_offset, buffer_length);
 }

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 *out_start_offset = start_offset;
 *out_end_offset = end_offset;
}
static void duk__clamp_startend_negidx_shifted(duk_hthread *thr,
                                                  duk_int_t buffer_length,
                                                  duk_uint8_t buffer_shift,
                                                  duk_idx_t idx_start,
                                                  duk_idx_t idx_end,
                                                  duk_int_t *out_start_offset,
                                                  duk_int_t *out_end_offset) {
 duk_int_t start_offset={0};
 duk_int_t end_offset={0};

 do { } while (0);
 do { } while (0);

 buffer_length >>= buffer_shift;






 start_offset = duk_to_int(thr, idx_start);
 if (start_offset < 0) {
  start_offset = buffer_length + start_offset;
 }
 if (duk_is_undefined(thr, idx_end)) {
  end_offset = buffer_length;
 } else {
  end_offset = duk_to_int(thr, idx_end);
  if (end_offset < 0) {
   end_offset = buffer_length + end_offset;
  }
 }


 if (start_offset < 0) {
  start_offset = 0;
 } else if (start_offset > buffer_length) {
  start_offset = buffer_length;
 }
 if (end_offset < start_offset) {
  end_offset = start_offset;
 } else if (end_offset > buffer_length) {
  end_offset = buffer_length;
 }
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 start_offset <<= buffer_shift;
 end_offset <<= buffer_shift;

 *out_start_offset = start_offset;
 *out_end_offset = end_offset;
}

static __attribute__ ((unused)) void duk_hbufobj_promote_plain(duk_hthread *thr, duk_idx_t idx) {
 if (duk_is_buffer(thr, idx)) {
  duk_to_object(thr, idx);
 }
}

static __attribute__ ((unused)) void duk_hbufobj_push_uint8array_from_plain(duk_hthread *thr, duk_hbuffer *h_buf) {





 duk_push_hbuffer(thr, h_buf);
 duk_push_buffer_object(thr, -1, 0, (duk_size_t) (((duk_hbuffer *) (h_buf))->size), 4);
 duk_remove_m2(thr);
}


static __attribute__ ((unused)) void duk_hbufobj_push_validated_read(duk_hthread *thr, duk_hbufobj *h_bufobj, duk_uint8_t *p, duk_small_uint_t elem_size) {
 duk_double_union du={0};

 do { } while (0);
 do { void *duk__dst = ((void *) du.uc); const void *duk__src = ((const void *) p); duk_size_t duk__len = ((size_t) elem_size); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);

 switch (h_bufobj->elem_type) {
 case 0:
 case 1:
  duk_push_uint(thr, (duk_uint_t) du.uc[0]);
  break;
 case 2:
  duk_push_int(thr, (duk_int_t) (duk_int8_t) du.uc[0]);
  break;
 case 3:
  duk_push_uint(thr, (duk_uint_t) du.us[0]);
  break;
 case 4:
  duk_push_int(thr, (duk_int_t) (duk_int16_t) du.us[0]);
  break;
 case 5:
  duk_push_uint(thr, (duk_uint_t) du.ui[0]);
  break;
 case 6:
  duk_push_int(thr, (duk_int_t) (duk_int32_t) du.ui[0]);
  break;
 case 7:
  duk_push_number(thr, (duk_double_t) du.f[0]);
  break;
 case 8:
  duk_push_number(thr, (duk_double_t) du.d);
  break;
 default:
  do { __builtin_unreachable(); } while (0);
 }
}


static __attribute__ ((unused)) void duk_hbufobj_validated_write(duk_hthread *thr, duk_hbufobj *h_bufobj, duk_uint8_t *p, duk_small_uint_t elem_size) {
 duk_double_union du={0};
 switch (h_bufobj->elem_type) {
 case 0:
  du.uc[0] = (duk_uint8_t) duk_to_uint32(thr, -1);
  break;
 case 1:
  du.uc[0] = (duk_uint8_t) duk_to_uint8clamped(thr, -1);
  break;
 case 2:
  du.uc[0] = (duk_uint8_t) duk_to_int32(thr, -1);
  break;
 case 3:
  du.us[0] = (duk_uint16_t) duk_to_uint32(thr, -1);
  break;
 case 4:
  du.us[0] = (duk_uint16_t) duk_to_int32(thr, -1);
  break;
 case 5:
  du.ui[0] = (duk_uint32_t) duk_to_uint32(thr, -1);
  break;
 case 6:
  du.ui[0] = (duk_uint32_t) duk_to_int32(thr, -1);
  break;
 case 7:




  du.f[0] = duk_double_to_float_t(duk_to_number_m1(thr));
  break;
 case 8:
  du.d = (duk_double_t) duk_to_number_m1(thr);
  break;
 default:
  do { __builtin_unreachable(); } while (0);
 }

 do { } while (0);
 do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) du.uc); duk_size_t duk__len = ((size_t) elem_size); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
}




static duk_hbuffer *duk__hbufobj_fixed_from_argvalue(duk_hthread *thr) {
 duk_int_t len={0};
 duk_int_t i={0};
 duk_size_t buf_size={0};
 duk_uint8_t *buf={0};

 switch (duk_get_type(thr, 0)) {
 case 4U: {
  len = duk_to_int_clamped(thr, 0, 0, 2147483647);
  (void) duk_push_fixed_buffer_zero(thr, (duk_size_t) len);
  break;
 }
 case 7U: {
  goto slow_copy;
 }
 case 6U: {
  duk_hobject *h={0};
  duk_hbufobj *h_bufobj={0};






  h = duk_known_hobject(thr, 0);
  if ((((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 19) {
   do { } while (0);
   h_bufobj = (duk_hbufobj *) h;
   if (__builtin_expect((h_bufobj->buf == ((void *)0)), 0)) {
    do { duk_err_type_invalid_args((thr), "duk_bi_buffer.c", (duk_int_t) 564); } while (0);
    do { } while (0);
   }
   if (__builtin_expect((h_bufobj->offset != 0 || h_bufobj->length != (((duk_hbuffer *) (h_bufobj->buf))->size)), 0)) {



    do { duk_err_type_invalid_args((thr), "duk_bi_buffer.c", (duk_int_t) 571); } while (0);
    do { } while (0);
   }
   duk_push_hbuffer(thr, h_bufobj->buf);
   return h_bufobj->buf;
  }
  goto slow_copy;
 }
 case 5U: {

  duk_require_hstring_notsymbol(thr, 0);
  duk_dup_0(thr);
  (void) duk_to_buffer_raw((thr), (-1), (&buf_size), 2);
  break;
 }
 default:
  do { duk_err_type_invalid_args((thr), "duk_bi_buffer.c", (duk_int_t) 587); } while (0);
  do { } while (0);
 }

 done:
 do { } while (0);
 return duk_known_hbuffer(thr, -1);

 slow_copy:


 (void) (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (86))));
 len = duk_to_int_clamped(thr, -1, 0, 2147483647);
 duk_pop(thr);
 buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, (duk_size_t) len);
 for (i = 0; i < len; i++) {

  duk_get_prop_index(thr, 0, (duk_uarridx_t) i);
  buf[i] = (duk_uint8_t) (duk_to_uint32(thr, -1) & 0xffU);
  duk_pop(thr);
 }
 goto done;
}
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_constructor(duk_hthread *thr) {
 duk_hbuffer *h_buf={0};

 h_buf = duk__hbufobj_fixed_from_argvalue(thr);
 do { } while (0);

 duk_push_buffer_object(thr,
                        -1,
                        0,
                        (((duk_hbuffer *) ((duk_hbuffer *) ((duk_hbuffer_fixed *) (void *) h_buf)))->size),
                        4);
 duk_push_hobject_bidx(thr, 50);
 duk_set_prototype(thr, -2);



 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_arraybuffer_constructor(duk_hthread *thr) {
 duk_hbufobj *h_bufobj={0};
 duk_hbuffer *h_val={0};
 duk_int_t len={0};

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk_require_constructor_call(thr);

 len = duk_to_int(thr, 0);
 if (len < 0) {
  goto fail_length;
 }
 (void) duk_push_fixed_buffer_zero(thr, (duk_size_t) len);
 h_val = (duk_hbuffer *) duk_known_hbuffer(thr, -1);

 h_bufobj = duk_push_bufobj_raw(thr,
                                (1UL << (7 + (0))) |
                                (1UL << (7 + (6))) |
                                (((duk_uint_t) (19)) << (7 + (20))),
                                39);
 do { } while (0);

 duk__set_bufobj_buffer(thr, h_bufobj, h_val);
 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_bufobj)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);

 return 1;

 fail_length:
 do { do { do { duk_err_range((((thr))), "duk_bi_buffer.c", (duk_int_t) 675, ("invalid length")); } while (0); } while (0); return 0; } while (0);
}
static __attribute__ ((unused)) duk_ret_t duk_bi_typedarray_constructor(duk_hthread *thr) {
 duk_tval *tv={0};
 duk_hobject *h_obj={0};
 duk_hbufobj *h_bufobj = ((void *)0);
 duk_hbufobj *h_bufarg = ((void *)0);
 duk_hbuffer *h_val={0};
 duk_small_uint_t magic={0};
 duk_small_uint_t shift={0};
 duk_small_uint_t elem_type={0};
 duk_small_uint_t elem_size={0};
 duk_small_uint_t class_num={0};
 duk_small_uint_t proto_bidx={0};
 duk_uint_t align_mask={0};
 duk_uint_t elem_length={0};
 duk_int_t elem_length_signed={0};
 duk_uint_t byte_length={0};
 duk_small_uint_t copy_mode={0};





 duk_require_constructor_call(thr);






 magic = (duk_small_uint_t) duk_get_current_magic(thr);
 shift = magic & 0x03U;
 elem_type = (magic >> 2) & 0x0fU;
 elem_size = 1U << shift;
 align_mask = elem_size - 1;
 do { } while (0);
 proto_bidx = duk__buffer_proto_from_elemtype[elem_type];
 do { } while (0);
 do { } while (0);
 class_num = duk__buffer_class_from_elemtype[elem_type];

 do { } while (0)


                                                       ;
 duk_hbufobj_promote_plain(thr, 0);

 tv = duk_get_tval(thr, 0);
 do { } while (0);
 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
  h_obj = ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);

  if ((((&(h_obj)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 19) {




   duk_int_t byte_offset_signed={0};
   duk_uint_t byte_offset={0};

   h_bufarg = (duk_hbufobj *) h_obj;

   byte_offset_signed = duk_to_int(thr, 1);
   if (byte_offset_signed < 0) {
    goto fail_arguments;
   }
   byte_offset = (duk_uint_t) byte_offset_signed;
   if (byte_offset > h_bufarg->length ||
       (byte_offset & align_mask) != 0) {

    goto fail_arguments;
   }
   if (duk_is_undefined(thr, 2)) {
    do { } while (0);
    byte_length = h_bufarg->length - byte_offset;
    if ((byte_length & align_mask) != 0) {



     goto fail_arguments;
    }
    elem_length = (byte_length >> shift);
   } else {
    elem_length_signed = duk_to_int(thr, 2);
    if (elem_length_signed < 0) {
     goto fail_arguments;
    }
    elem_length = (duk_uint_t) elem_length_signed;
    byte_length = elem_length << shift;
    if ((byte_length >> shift) != elem_length) {


     goto fail_arguments;
    }
    do { } while (0);
    if (byte_length > h_bufarg->length - byte_offset) {

     goto fail_arguments;
    }
   }
   do { (void) (elem_length); } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0);

   h_bufobj = duk_push_bufobj_raw(thr,
                                  (1UL << (7 + (0))) |
                                  (1UL << (7 + (6))) |
                                  (((duk_uint_t) (class_num)) << (7 + (20))),
                                  (duk_small_int_t) proto_bidx);
   h_val = h_bufarg->buf;
   if (h_val == ((void *)0)) {
    do { do { duk_err_type_invalid_args(((thr)), "duk_bi_buffer.c", (duk_int_t) 812); } while (0); return 0; } while (0);
   }
   h_bufobj->buf = h_val;
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_val))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   h_bufobj->offset = h_bufarg->offset + byte_offset;
   h_bufobj->length = byte_length;
   h_bufobj->shift = (duk_uint8_t) shift;
   h_bufobj->elem_type = (duk_uint8_t) elem_type;
   h_bufobj->is_typedarray = 1;
   do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_bufobj)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);


   do { } while (0);
   h_bufobj->buf_prop = (duk_hobject *) h_bufarg;
   do { } while (0);
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) &(h_bufarg)->obj)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   return 1;
  } else if ((((&(h_obj)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {





   h_bufarg = (duk_hbufobj *) h_obj;
   do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_bufarg)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);
   elem_length_signed = (duk_int_t) (h_bufarg->length >> h_bufarg->shift);
   if (h_bufarg->buf == ((void *)0)) {
    do { do { duk_err_type_invalid_args(((thr)), "duk_bi_buffer.c", (duk_int_t) 839); } while (0); return 0; } while (0);
   }






   do { } while (0)





                                                              ;

   copy_mode = 2;




   do { } while (0);
   if ((((void) 0), ((void) 0), ((h_bufarg)->offset + (h_bufarg)->length <= (((duk_hbuffer *) ((h_bufarg)->buf))->size)))) {
    if ((duk__buffer_elemtype_copy_compatible[elem_type] & (1 << h_bufarg->elem_type)) != 0) {
     do { } while (0);
     do { } while (0);
     copy_mode = 0;
    } else {
     do { } while (0);
     copy_mode = 1;
    }
   }

  } else {

   elem_length_signed = (duk_int_t) duk_get_length(thr, 0);
   copy_mode = 2;
  }
 } else {




  elem_length_signed = duk_to_int(thr, 0);
  copy_mode = 3;
 }
 if (elem_length_signed < 0) {
  goto fail_arguments;
 }
 elem_length = (duk_uint_t) elem_length_signed;
 byte_length = (duk_uint_t) (elem_length << shift);
 if ((byte_length >> shift) != elem_length) {


  goto fail_arguments;
 }

 do { } while (0)
                                                              ;
 (void) duk_push_buffer_raw((thr), (byte_length), 0 );
 h_val = duk_known_hbuffer(thr, -1);
 do { } while (0);

 h_bufobj = duk_push_bufobj_raw(thr,
                                (1UL << (7 + (0))) |
                                (1UL << (7 + (6))) |
                                (((duk_uint_t) (class_num)) << (7 + (20))),
                                (duk_small_int_t) proto_bidx);

 h_bufobj->buf = h_val;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_val))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 do { } while (0);
 h_bufobj->length = byte_length;
 h_bufobj->shift = (duk_uint8_t) shift;
 h_bufobj->elem_type = (duk_uint8_t) elem_type;
 h_bufobj->is_typedarray = 1;
 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_bufobj)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);







 do { } while (0);
 switch (copy_mode) {




 case 0: {


  duk_uint8_t *p_src={0};
  duk_uint8_t *p_dst={0};

  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);

  p_dst = (((void) 0), ((void) 0), (((duk_uint8_t *) ( (((&(((h_bufobj)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_bufobj)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_bufobj)->buf))) + 1)) )) + (h_bufobj)->offset));
  p_src = (((void) 0), ((void) 0), (((duk_uint8_t *) ( (((&(((h_bufarg)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_bufarg)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_bufarg)->buf))) + 1)) )) + (h_bufarg)->offset));

  do { } while (0)
                                                                           ;

  do { void *duk__dst = ((void *) p_dst); const void *duk__src = ((const void *) p_src); duk_size_t duk__len = ((size_t) byte_length); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0);
  break;
 }
 case 1: {


  duk_small_uint_t src_elem_size={0};
  duk_small_uint_t dst_elem_size={0};
  duk_uint8_t *p_src={0};
  duk_uint8_t *p_src_end={0};
  duk_uint8_t *p_dst={0};

  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);

  src_elem_size = (duk_small_uint_t) (1U << h_bufarg->shift);
  dst_elem_size = elem_size;

  p_src = (((void) 0), ((void) 0), (((duk_uint8_t *) ( (((&(((h_bufarg)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_bufarg)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_bufarg)->buf))) + 1)) )) + (h_bufarg)->offset));
  p_dst = (((void) 0), ((void) 0), (((duk_uint8_t *) ( (((&(((h_bufobj)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_bufobj)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_bufobj)->buf))) + 1)) )) + (h_bufobj)->offset));
  p_src_end = p_src + h_bufarg->length;

  do { } while (0)


                                                                 ;

  while (p_src != p_src_end) {
   do { } while (0)

                                                                            ;



   duk_hbufobj_push_validated_read(thr, h_bufarg, p_src, src_elem_size);
   duk_hbufobj_validated_write(thr, h_bufobj, p_dst, dst_elem_size);
   duk_pop(thr);
   p_src += src_elem_size;
   p_dst += dst_elem_size;
  }
  break;
 }

 case 2: {



  duk_uint_t i={0};

  do { } while (0);

  for (i = 0; i < elem_length; i++) {
   duk_get_prop_index(thr, 0, (duk_uarridx_t) i);
   duk_put_prop_index(thr, -2, (duk_uarridx_t) i);
  }
  break;
 }
 default:
 case 3: {





  do { } while (0);
  break;
 }
 }

 return 1;

 fail_arguments:
 do { do { do { duk_err_range((((thr))), "duk_bi_buffer.c", (duk_int_t) 1034, ("invalid args")); } while (0); } while (0); return 0; } while (0);
}
static __attribute__ ((unused)) duk_ret_t duk_bi_dataview_constructor(duk_hthread *thr) {
 duk_hbufobj *h_bufarg={0};
 duk_hbufobj *h_bufobj={0};
 duk_hbuffer *h_val={0};
 duk_uint_t offset={0};
 duk_uint_t length={0};

 duk_require_constructor_call(thr);

 h_bufarg = duk__require_bufobj_value(thr, 0);
 do { } while (0);
 if ((((&((duk_hobject *) h_bufarg)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) != 19) {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_buffer.c", (duk_int_t) 1079); } while (0); return 0; } while (0);
 }

 duk__resolve_offset_opt_length(thr, h_bufarg, 1, 2, &offset, &length, 1 );
 do { } while (0);
 do { } while (0);

 h_bufobj = duk_push_bufobj_raw(thr,
                                (1UL << (7 + (0))) |
                                (1UL << (7 + (6))) |
                                (((duk_uint_t) (20)) << (7 + (20))),
                                40);

 h_val = h_bufarg->buf;
 if (h_val == ((void *)0)) {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_buffer.c", (duk_int_t) 1094); } while (0); return 0; } while (0);
 }
 h_bufobj->buf = h_val;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_val))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 h_bufobj->offset = h_bufarg->offset + offset;
 h_bufobj->length = length;
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);
 h_bufobj->buf_prop = (duk_hobject *) h_bufarg;
 do { } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) &(h_bufarg)->obj)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_bufobj)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_arraybuffer_isview(duk_hthread *thr) {
 duk_hobject *h_obj={0};
 duk_bool_t ret = 0;

 if (duk_is_buffer(thr, 0)) {
  ret = 1;
 } else {
  h_obj = duk_get_hobject(thr, 0);
  if (h_obj != ((void *)0) && (((&(h_obj)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {



   ret = ((duk_hbufobj *) h_obj)->is_typedarray ||
         ((((&(h_obj)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 20);
  }
 }
 duk_push_boolean(thr, ret);
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_uint8array_allocplain(duk_hthread *thr) {
 duk__hbufobj_fixed_from_argvalue(thr);
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_uint8array_plainof(duk_hthread *thr) {
 duk_hbufobj *h_bufobj={0};



 if (duk_is_buffer(thr, 0)) {
  return 1;
 }






 h_bufobj = duk__require_bufobj_value(thr, 0);
 if (h_bufobj->buf == ((void *)0)) {
  duk_push_undefined(thr);
 } else {
  duk_push_hbuffer(thr, h_bufobj->buf);
 }
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_tostring(duk_hthread *thr) {
 duk_hbufobj *h_this={0};
 duk_int_t start_offset, end_offset={0};
 duk_uint8_t *buf_slice={0};
 duk_size_t slice_length={0};

 h_this = duk__get_bufobj_this(thr);
 if (h_this == ((void *)0)) {

  duk_push_literal_raw((thr), ("[object Object]"), sizeof(("[object Object]")) - 1U);
  return 1;
 }
 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_this)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);



 duk__clamp_startend_nonegidx_noshift(thr,
                                      (duk_int_t) h_this->length,
                                      1 ,
                                      2 ,
                                      &start_offset,
                                      &end_offset);

 slice_length = (duk_size_t) (end_offset - start_offset);
 buf_slice = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, slice_length);
 do { } while (0);


 if (h_this->buf == ((void *)0) ||
     !(((void) 0), ((void) 0), ((h_this)->offset + ((duk_size_t) start_offset + slice_length) <= (((duk_hbuffer *) ((h_this)->buf))->size)))) {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_buffer.c", (duk_int_t) 1215); } while (0); return 0; } while (0);
 }







 do { } while (0);
 do { void *duk__dst = ((void *) buf_slice); const void *duk__src = ((const void *) ((((void) 0), ((void) 0), (((duk_uint8_t *) ( (((&(((h_this)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_this)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_this)->buf))) + 1)) )) + (h_this)->offset)) + start_offset)); duk_size_t duk__len = ((size_t) slice_length); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0)

                                         ;





 duk_replace(thr, 0);
 duk_set_top(thr, 1);
 return duk_textdecoder_decode_utf8_nodejs(thr);
}







static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_tojson(duk_hthread *thr) {
 duk_hbufobj *h_this={0};
 duk_uint8_t *buf={0};
 duk_uint_t i, n={0};
 duk_tval *tv={0};

 h_this = duk__require_bufobj_this(thr);
 do { } while (0);

 if (h_this->buf == ((void *)0) || !(((void) 0), ((void) 0), ((h_this)->offset + (h_this)->length <= (((duk_hbuffer *) ((h_this)->buf))->size)))) {



  duk_push_null(thr);
  return 1;
 }

 duk_push_object(thr);
 duk_push_hstring_stridx(thr, 30);
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (84))));


 do { } while (0);
 tv = duk_push_harray_with_size_outptr(thr, (duk_uint32_t) h_this->length);

 do { } while (0);
 buf = (((void) 0), ((void) 0), (((duk_uint8_t *) ( (((&(((h_this)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_this)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_this)->buf))) + 1)) )) + (h_this)->offset));
 for (i = 0, n = h_this->length; i < n; i++) {
  do { duk_double_t duk__dblval; duk__dblval = ((duk_double_t) ((duk_uint32_t) buf[i])); ; do { (((tv + i)))->d = (duk__dblval); } while (0); } while (0);
 }
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (85))));

 return 1;
}
static __attribute__ ((unused)) duk_ret_t duk_bi_buffer_compare_shared(duk_hthread *thr) {
 duk_small_uint_t magic={0};
 duk_hbufobj *h_bufarg1={0};
 duk_hbufobj *h_bufarg2={0};
 duk_small_int_t comp_res={0};



 magic = (duk_small_uint_t) duk_get_current_magic(thr);
 if (magic & 0x02U) {

  h_bufarg1 = duk__require_bufobj_value(thr, 0);
  h_bufarg2 = duk__require_bufobj_value(thr, 1);
 } else {
  h_bufarg1 = duk__require_bufobj_this(thr);
  h_bufarg2 = duk__require_bufobj_value(thr, 0);
 }
 do { } while (0);
 do { } while (0);







 if ((((void) 0), ((void) 0), ((h_bufarg1)->offset + (h_bufarg1)->length <= (((duk_hbuffer *) ((h_bufarg1)->buf))->size))) &&
     (((void) 0), ((void) 0), ((h_bufarg2)->offset + (h_bufarg2)->length <= (((duk_hbuffer *) ((h_bufarg2)->buf))->size)))) {
  comp_res = duk_js_data_compare((const duk_uint8_t *) ( (((&((h_bufarg1->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h_bufarg1->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h_bufarg1->buf))) + 1)) ) + h_bufarg1->offset,
                                 (const duk_uint8_t *) ( (((&((h_bufarg2->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h_bufarg2->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h_bufarg2->buf))) + 1)) ) + h_bufarg2->offset,
                                 (duk_size_t) h_bufarg1->length,
                                 (duk_size_t) h_bufarg2->length);
 } else {
  comp_res = -1;
 }

 if (magic & 0x01U) {

  duk_push_int(thr, comp_res);
 } else {

  duk_push_boolean(thr, (comp_res == 0));
 }

 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_fill(duk_hthread *thr) {
 duk_hbufobj *h_this={0};
 const duk_uint8_t *fill_str_ptr={0};
 duk_size_t fill_str_len={0};
 duk_uint8_t fill_value={0};
 duk_int_t fill_offset={0};
 duk_int_t fill_end={0};
 duk_size_t fill_length={0};
 duk_uint8_t *p={0};

 h_this = duk__require_bufobj_this(thr);
 do { } while (0);
 if (h_this->buf == ((void *)0)) {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_buffer.c", (duk_int_t) 1353); } while (0); return 0; } while (0);
 }



 if (duk_is_string_notsymbol(thr, 0)) {
  fill_str_ptr = (const duk_uint8_t *) duk_get_lstring(thr, 0, &fill_str_len);
  do { } while (0);
 } else {

  fill_value = (duk_uint8_t) duk_to_uint32(thr, 0);
  fill_str_ptr = (const duk_uint8_t *) &fill_value;
  fill_str_len = 1;
 }



 duk__clamp_startend_nonegidx_noshift(thr,
                                      (duk_int_t) h_this->length,
                                      1 ,
                                      2 ,
                                      &fill_offset,
                                      &fill_end);

 do { } while (0)
                                                                                                             ;

 do { } while (0);
 do { } while (0);

 p = ((((void) 0), ((void) 0), (((duk_uint8_t *) ( (((&(((h_this)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_this)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_this)->buf))) + 1)) )) + (h_this)->offset)) + fill_offset);
 fill_length = (duk_size_t) (fill_end - fill_offset);
 if (fill_str_len == 1) {



  do { void *duk__dst = ((void *) p); duk_small_int_t duk__val = ((int) fill_str_ptr[0]); duk_size_t duk__len = ((size_t) fill_length); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); (void) memset(duk__dst, duk__val, (size_t) duk__len); } } while (0);
 } else if (fill_str_len > 1) {
  duk_size_t i, n, t={0};

  for (i = 0, n = (duk_size_t) (fill_end - fill_offset), t = 0; i < n; i++) {
   p[i] = fill_str_ptr[t++];
   if (t >= fill_str_len) {
    t = 0;
   }
  }
 } else {
  do { } while (0);
 }


 duk_push_this(thr);
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_write(duk_hthread *thr) {
 duk_hbufobj *h_this={0};
 duk_uint_t offset={0};
 duk_uint_t length={0};
 const duk_uint8_t *str_data={0};
 duk_size_t str_len={0};


 h_this = duk__require_bufobj_this(thr);
 do { } while (0);


 str_data = (const duk_uint8_t *) duk_require_lstring_notsymbol(thr, 0, &str_len);

 duk__resolve_offset_opt_length(thr, h_this, 1, 2, &offset, &length, 0 );
 do { } while (0);
 do { } while (0);



 if (length > str_len) {
  length = (duk_uint_t) str_len;
 }

 if ((((void) 0), ((void) 0), ((h_this)->offset + (h_this)->length <= (((duk_hbuffer *) ((h_this)->buf))->size)))) {

  do { void *duk__dst = ((void *) ((((void) 0), ((void) 0), (((duk_uint8_t *) ( (((&(((h_this)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_this)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_this)->buf))) + 1)) )) + (h_this)->offset)) + offset)); const void *duk__src = ((const void *) str_data); duk_size_t duk__len = ((size_t) length); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0)

                                    ;
 } else {
  do { } while (0);
 }

 duk_push_uint(thr, length);
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_copy(duk_hthread *thr) {
 duk_hbufobj *h_this={0};
 duk_hbufobj *h_bufarg={0};
 duk_int_t source_length={0};
 duk_int_t target_length={0};
 duk_int_t target_start, source_start, source_end={0};
 duk_uint_t target_ustart, source_ustart, source_uend={0};
 duk_uint_t copy_size = 0;



 h_this = duk__require_bufobj_this(thr);
 h_bufarg = duk__require_bufobj_value(thr, 0);
 do { } while (0);
 do { } while (0);
 source_length = (duk_int_t) h_this->length;
 target_length = (duk_int_t) h_bufarg->length;

 target_start = duk_to_int(thr, 1);
 source_start = duk_to_int(thr, 2);
 if (duk_is_undefined(thr, 3)) {
  source_end = source_length;
 } else {
  source_end = duk_to_int(thr, 3);
 }

 do { } while (0)


                                                                                    ;



 if (source_start < 0 || source_end < 0 || target_start < 0) {

  goto fail_bounds;
 }
 source_ustart = (duk_uint_t) source_start;
 source_uend = (duk_uint_t) source_end;
 target_ustart = (duk_uint_t) target_start;
 if (source_ustart >= source_uend ||
     source_ustart >= (duk_uint_t) source_length ||
     target_ustart >= (duk_uint_t) target_length) {
  goto silent_ignore;
 }
 if (source_uend >= (duk_uint_t) source_length) {

  source_uend = (duk_uint_t) source_length;
 }
 copy_size = source_uend - source_ustart;
 if (target_ustart + copy_size > (duk_uint_t) target_length) {







  do { } while (0);
  do { } while (0);
  copy_size = (duk_uint_t) target_length - target_ustart;
 }

 do { } while (0)

                                                 ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 do { } while (0);
 do { } while (0);
 if ((((void) 0), ((void) 0), ((h_bufarg)->offset + (target_ustart + copy_size) <= (((duk_hbuffer *) ((h_bufarg)->buf))->size))) &&
     (((void) 0), ((void) 0), ((h_this)->offset + (source_ustart + copy_size) <= (((duk_hbuffer *) ((h_this)->buf))->size)))) {



  do { void *duk__dst = ((void *) ((((void) 0), ((void) 0), (((duk_uint8_t *) ( (((&(((h_bufarg)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_bufarg)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_bufarg)->buf))) + 1)) )) + (h_bufarg)->offset)) + target_ustart)); const void *duk__src = ((const void *) ((((void) 0), ((void) 0), (((duk_uint8_t *) ( (((&(((h_this)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_this)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_this)->buf))) + 1)) )) + (h_this)->offset)) + source_ustart)); duk_size_t duk__len = ((size_t) copy_size); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } } while (0)

                                        ;
 } else {
  do { } while (0);
 }

 silent_ignore:




 duk_push_uint(thr, copy_size);
 return 1;

 fail_bounds:
 do { do { do { duk_err_range((((thr))), "duk_bi_buffer.c", (duk_int_t) 1554, ("invalid args")); } while (0); } while (0); return 0; } while (0);
}
static __attribute__ ((unused)) duk_ret_t duk_bi_typedarray_set(duk_hthread *thr) {
 duk_hbufobj *h_this={0};
 duk_hobject *h_obj={0};
 duk_uarridx_t i, n={0};
 duk_int_t offset_signed={0};
 duk_uint_t offset_elems={0};
 duk_uint_t offset_bytes={0};

 h_this = duk__require_bufobj_this(thr);
 do { } while (0);
 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_this)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);

 if (h_this->buf == ((void *)0)) {
  do { } while (0);
  return 0;
 }

 duk_hbufobj_promote_plain(thr, 0);
 h_obj = duk_require_hobject(thr, 0);





 offset_signed = duk_to_int(thr, 1);
 if (offset_signed < 0) {

  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_buffer.c", (duk_int_t) 1622); } while (0); return 0; } while (0);
 }
 offset_elems = (duk_uint_t) offset_signed;
 offset_bytes = offset_elems << h_this->shift;
 if ((offset_bytes >> h_this->shift) != offset_elems) {


  goto fail_args;
 }
 if (offset_bytes > h_this->length) {




  goto fail_args;
 }
 do { } while (0);



 if ((((&(h_obj)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {
  duk_hbufobj *h_bufarg={0};

  duk_uint16_t comp_mask={0};

  duk_small_int_t no_overlap = 0;
  duk_uint_t src_length={0};
  duk_uint_t dst_length={0};
  duk_uint_t dst_length_elems={0};
  duk_uint8_t *p_src_base={0};
  duk_uint8_t *p_src_end={0};
  duk_uint8_t *p_src={0};
  duk_uint8_t *p_dst_base={0};
  duk_uint8_t *p_dst={0};
  duk_small_uint_t src_elem_size={0};
  duk_small_uint_t dst_elem_size={0};

  h_bufarg = (duk_hbufobj *) h_obj;
  do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_bufarg)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);

  if (h_bufarg->buf == ((void *)0)) {
   do { } while (0);
   return 0;
  }


  src_length = h_bufarg->length;
  dst_length_elems = (src_length >> h_bufarg->shift);
  dst_length = dst_length_elems << h_this->shift;
  if ((dst_length >> h_this->shift) != dst_length_elems) {


   goto fail_args;
  }
  do { } while (0)
                                                             ;
  do { } while (0);
  if (dst_length > h_this->length - offset_bytes) {



   do { } while (0);
   goto fail_args;
  }
  if (!(((void) 0), ((void) 0), ((h_this)->offset + (offset_bytes + dst_length) <= (((duk_hbuffer *) ((h_this)->buf))->size)))) {
   do { } while (0);
   return 0;
  }

  p_src_base = (((void) 0), ((void) 0), (((duk_uint8_t *) ( (((&(((h_bufarg)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_bufarg)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_bufarg)->buf))) + 1)) )) + (h_bufarg)->offset));
  p_dst_base = (((void) 0), ((void) 0), (((duk_uint8_t *) ( (((&(((h_this)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_this)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_this)->buf))) + 1)) )) + (h_this)->offset)) + offset_bytes;





  if (!(((void) 0), ((void) 0), ((h_this)->offset + (h_this)->length <= (((duk_hbuffer *) ((h_this)->buf))->size))) ||
      !(((void) 0), ((void) 0), ((h_bufarg)->offset + (h_bufarg)->length <= (((duk_hbuffer *) ((h_bufarg)->buf))->size)))) {




   do { } while (0);
   return 0;
  }
  do { } while (0);
  comp_mask = duk__buffer_elemtype_copy_compatible[h_this->elem_type];
  if (comp_mask & (1 << h_bufarg->elem_type)) {
   do { } while (0);

   do { } while (0);
   do { void *duk__dst = ((void *) p_dst_base); const void *duk__src = ((const void *) p_src_base); duk_size_t duk__len = ((size_t) dst_length); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } } while (0);
   return 0;
  }
  do { } while (0);
  do { } while (0)


                                                               ;

  if (p_src_base >= p_dst_base + dst_length ||
      p_src_base + src_length <= p_dst_base) {
   no_overlap = 1;
  }

  if (!no_overlap) {





   duk_uint8_t *p_src_copy={0};

   do { } while (0);
   p_src_copy = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, src_length);
   do { } while (0);
   do { void *duk__dst = ((void *) p_src_copy); const void *duk__src = ((const void *) p_src_base); duk_size_t duk__len = ((size_t) src_length); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0);

   p_src_base = p_src_copy;
  }


  do { } while (0)



                                                ;
  src_elem_size = (duk_small_uint_t) (1U << h_bufarg->shift);
  dst_elem_size = (duk_small_uint_t) (1U << h_this->shift);
  p_src = p_src_base;
  p_dst = p_dst_base;
  p_src_end = p_src_base + src_length;

  while (p_src != p_src_end) {
   do { } while (0)

                                                                            ;



   duk_hbufobj_push_validated_read(thr, h_bufarg, p_src, src_elem_size);
   duk_hbufobj_validated_write(thr, h_this, p_dst, dst_elem_size);
   duk_pop(thr);
   p_src += src_elem_size;
   p_dst += dst_elem_size;
  }

  return 0;
 } else {
  n = (duk_uarridx_t) duk_get_length(thr, 0);
  do { } while (0);
  if ((n << h_this->shift) > h_this->length - offset_bytes) {



   do { } while (0);
   goto fail_args;
  }
  do { } while (0);
  duk_push_this(thr);

  for (i = 0; i < n; i++) {
   duk_get_prop_index(thr, 0, i);
   duk_put_prop_index(thr, 2, offset_elems + i);
  }
 }

 return 0;

 fail_args:
 do { do { do { duk_err_range((((thr))), "duk_bi_buffer.c", (duk_int_t) 1849, ("invalid args")); } while (0); } while (0); return 0; } while (0);
}
static void duk__arraybuffer_plain_slice(duk_hthread *thr, duk_hbuffer *h_val) {
 duk_int_t start_offset, end_offset={0};
 duk_uint_t slice_length={0};
 duk_uint8_t *p_copy={0};
 duk_size_t copy_length={0};

 duk__clamp_startend_negidx_shifted(thr,
                                    (duk_int_t) (((duk_hbuffer *) (h_val))->size),
                                    0 ,
                                    0 ,
                                    1 ,
                                    &start_offset,
                                    &end_offset);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 slice_length = (duk_uint_t) (end_offset - start_offset);

 p_copy = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, (duk_size_t) slice_length);
 do { } while (0);
 copy_length = slice_length;

 do { void *duk__dst = ((void *) p_copy); const void *duk__src = ((const void *) ((duk_uint8_t *) ( (((&((h_val))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h_val))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h_val))) + 1)) ) + start_offset)); duk_size_t duk__len = (copy_length); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0)

                               ;
}






static __attribute__ ((unused)) duk_ret_t duk_bi_buffer_slice_shared(duk_hthread *thr) {
 duk_small_int_t magic={0};
 duk_small_uint_t res_class_num={0};
 duk_small_int_t res_proto_bidx={0};
 duk_hbufobj *h_this={0};
 duk_hbufobj *h_bufobj={0};
 duk_hbuffer *h_val={0};
 duk_int_t start_offset, end_offset={0};
 duk_uint_t slice_length={0};
 duk_tval *tv={0};



 magic = duk_get_current_magic(thr);

 tv = duk_get_borrowed_this_tval(thr);
 do { } while (0);

 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfffaUL)) {

  h_val = ((duk_hbuffer *) (tv)->vp[0]);
  do { } while (0);

  if (magic & 0x02) {

   duk__arraybuffer_plain_slice(thr, h_val);
   return 1;
  } else {
   do { } while (0);

  }
 }
 tv = ((void *)0);

 h_this = duk__require_bufobj_this(thr);
 duk__clamp_startend_negidx_shifted(thr,
                                    (duk_int_t) h_this->length,
                                    (duk_uint8_t) h_this->shift,
                                    0 ,
                                    1 ,
                                    &start_offset,
                                    &end_offset);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 slice_length = (duk_uint_t) (end_offset - start_offset);
 res_class_num = (((&((duk_hobject *) h_this)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL));
 do { } while (0);
 do { } while (0);
 res_proto_bidx = duk__buffer_proto_from_classnum[res_class_num - 19];
 if (magic & 0x04) {
  res_proto_bidx = 50;
 }
 h_bufobj = duk_push_bufobj_raw(thr,
                                (1UL << (7 + (0))) |
                                (1UL << (7 + (6))) |
                                (((duk_uint_t) (res_class_num)) << (7 + (20))),
                                res_proto_bidx);
 do { } while (0);

 do { } while (0);
 h_bufobj->shift = h_this->shift;
 h_bufobj->elem_type = h_this->elem_type;
 h_bufobj->is_typedarray = magic & 0x01;
 do { } while (0);

 h_val = h_this->buf;
 if (h_val == ((void *)0)) {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_buffer.c", (duk_int_t) 2005); } while (0); return 0; } while (0);
 }

 if (magic & 0x02) {

  duk_uint8_t *p_copy={0};
  duk_size_t copy_length={0};

  p_copy = (duk_uint8_t *) duk_push_fixed_buffer_zero(thr, (duk_size_t) slice_length);
  do { } while (0);




  copy_length = (((void) 0), duk_hbufobj_clamp_bytelength((h_this), (slice_length)));
  do { void *duk__dst = ((void *) p_copy); const void *duk__src = ((const void *) ((((void) 0), ((void) 0), (((duk_uint8_t *) ( (((&(((h_this)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_this)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_this)->buf))) + 1)) )) + (h_this)->offset)) + start_offset)); duk_size_t duk__len = (copy_length); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0)

                                ;

  h_val = duk_known_hbuffer(thr, -1);

  h_bufobj->buf = h_val;
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_val))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  h_bufobj->length = slice_length;
  do { } while (0);

  duk_pop(thr);
 } else {
  h_bufobj->buf = h_val;
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_val))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  h_bufobj->length = slice_length;
  h_bufobj->offset = h_this->offset + (duk_uint_t) start_offset;






  do { } while (0);
  h_bufobj->buf_prop = h_this->buf_prop;
  do { if (((duk_hobject *) h_bufobj->buf_prop) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (((duk_hobject *) h_bufobj->buf_prop)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);
 }


 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_bufobj)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_is_encoding(duk_hthread *thr) {
 const char *encoding={0};



 encoding = duk_to_string(thr, 0);
 do { } while (0);
 duk_push_boolean(thr, strcmp(encoding, "utf8") == 0);
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_is_buffer(duk_hthread *thr) {
 duk_hobject *h={0};
 duk_hobject *h_proto={0};
 duk_bool_t ret = 0;

 do { } while (0);
 h = duk_get_hobject(thr, 0);
 if (h != ((void *)0)) {
  h_proto = thr->builtins[50];
  do { } while (0);

  h = ((h)->prototype);
  if (h != ((void *)0)) {
   ret = duk_hobject_prototype_chain_contains(thr, h, h_proto, 0 );
  }
 }

 duk_push_boolean(thr, ret);
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_byte_length(duk_hthread *thr) {
 const char *str={0};
 duk_size_t len={0};
 str = duk_to_lstring(thr, 0, &len);
 do { (void) (str); } while (0);
 duk_push_uint((thr), (duk_uint_t) (len));
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_concat(duk_hthread *thr) {
 duk_hobject *h_arg={0};
 duk_uint_t total_length={0};
 duk_hbufobj *h_bufobj={0};
 duk_hbufobj *h_bufres={0};
 duk_hbuffer *h_val={0};
 duk_uint_t i, n={0};
 duk_uint8_t *p={0};
 duk_size_t space_left={0};
 duk_size_t copy_size={0};


 h_arg = duk_require_hobject(thr, 0);
 if ((((&(h_arg)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) != 2) {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_buffer.c", (duk_int_t) 2148); } while (0); return 0; } while (0);
 }


 n = (duk_uint_t) duk_get_length(thr, 0);
 total_length = 0;
 for (i = 0; i < n; i++) {



  do { } while (0);
  duk_get_prop_index(thr, 0, (duk_uarridx_t) i);
  h_bufobj = duk__require_bufobj_value(thr, 2);
  do { } while (0);
  total_length += h_bufobj->length;
  if (__builtin_expect((total_length < h_bufobj->length), 0)) {
   do { do { do { duk_err_range((((thr))), "duk_bi_buffer.c", (duk_int_t) 2164, ("invalid args")); } while (0); } while (0); return 0; } while (0);
  }
  duk_pop(thr);
 }
 if (!duk_is_undefined(thr, 1) && n > 0) {



  duk_int_t total_length_signed={0};
  total_length_signed = duk_to_int(thr, 1);
  if (total_length_signed < 0) {
   do { do { do { duk_err_range((((thr))), "duk_bi_buffer.c", (duk_int_t) 2184, ("invalid args")); } while (0); } while (0); return 0; } while (0);
  }
  total_length = (duk_uint_t) total_length_signed;
 }

 h_bufres = duk_push_bufobj_raw(thr,
                                (1UL << (7 + (0))) |
                                (1UL << (7 + (6))) |
                                (((duk_uint_t) (22)) << (7 + (20))),
                                50);
 do { } while (0);

 p = (duk_uint8_t *) duk_push_fixed_buffer_zero(thr, total_length);
 do { } while (0);
 space_left = (duk_size_t) total_length;

 for (i = 0; i < n; i++) {
  do { } while (0);

  duk_get_prop_index(thr, 0, (duk_uarridx_t) i);
  h_bufobj = duk__require_bufobj_value(thr, 4);
  do { } while (0);

  copy_size = h_bufobj->length;
  if (copy_size > space_left) {
   copy_size = space_left;
  }

  if (h_bufobj->buf != ((void *)0) &&
      (((void) 0), ((void) 0), ((h_bufobj)->offset + (h_bufobj)->length <= (((duk_hbuffer *) ((h_bufobj)->buf))->size)))) {
   do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) (((void) 0), ((void) 0), (((duk_uint8_t *) ( (((&(((h_bufobj)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_bufobj)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_bufobj)->buf))) + 1)) )) + (h_bufobj)->offset))); duk_size_t duk__len = (copy_size); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0)

                               ;
  } else {

   ;
  }
  p += copy_size;
  space_left -= copy_size;

  duk_pop(thr);
 }

 h_val = duk_known_hbuffer(thr, -1);

 duk__set_bufobj_buffer(thr, h_bufres, h_val);
 h_bufres->is_typedarray = 1;
 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_bufres)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);

 duk_pop(thr);

 return 1;
}
static __attribute__ ((unused)) duk_ret_t duk_bi_buffer_readfield(duk_hthread *thr) {
 duk_small_int_t magic = (duk_small_int_t) duk_get_current_magic(thr);
 duk_small_int_t magic_ftype={0};
 duk_small_int_t magic_bigendian={0};
 duk_small_int_t magic_signed={0};
 duk_small_int_t magic_typedarray={0};
 duk_small_int_t endswap={0};
 duk_hbufobj *h_this={0};
 duk_bool_t no_assert={0};
 duk_int_t offset_signed={0};
 duk_uint_t offset={0};
 duk_uint_t buffer_length={0};
 duk_uint_t check_length={0};
 duk_uint8_t *buf={0};
 duk_double_union du={0};

 magic_ftype = magic & 0x0007;
 magic_bigendian = magic & 0x0008;
 magic_signed = magic & 0x0010;
 magic_typedarray = magic & 0x0020;

 h_this = duk__require_bufobj_this(thr);
 do { } while (0);
 buffer_length = h_this->length;






 if (magic_typedarray) {
  no_assert = 0;

  endswap = !duk_to_boolean(thr, 1);



 } else {
  no_assert = duk_to_boolean(thr, (magic_ftype == 5) ? 2 : 1);

  endswap = magic_bigendian;



 }





 offset_signed = duk_to_int(thr, 0);
 offset = (duk_uint_t) offset_signed;
 if (offset_signed < 0) {
  goto fail_bounds;
 }

 do { } while (0)




                                                                ;





 check_length = (((void) 0), duk_hbufobj_clamp_bytelength((h_this), (buffer_length)));
 do { } while (0)
                                                                 ;

 if (h_this->buf) {
  buf = (((void) 0), ((void) 0), (((duk_uint8_t *) ( (((&(((h_this)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_this)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_this)->buf))) + 1)) )) + (h_this)->offset));
 } else {




  do { } while (0);
  goto fail_neutered;
 }
 do { } while (0);

 switch (magic_ftype) {
 case 0: {
  duk_uint8_t tmp={0};
  if (offset + 1U > check_length) {
   goto fail_bounds;
  }
  tmp = buf[offset];
  if (magic_signed) {
   duk_push_int(thr, (duk_int_t) ((duk_int8_t) tmp));
  } else {
   duk_push_uint(thr, (duk_uint_t) tmp);
  }
  break;
 }
 case 1: {
  duk_uint16_t tmp={0};
  if (offset + 2U > check_length) {
   goto fail_bounds;
  }
  do { void *duk__dst = ((void *) du.uc); const void *duk__src = ((const void *) (buf + offset)); duk_size_t duk__len = (2); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  tmp = du.us[0];
  if (endswap) {
   tmp = ((duk_uint16_t) (tmp) >> 8) | ((duk_uint16_t) (tmp) << 8);
  }
  if (magic_signed) {
   duk_push_int(thr, (duk_int_t) ((duk_int16_t) tmp));
  } else {
   duk_push_uint(thr, (duk_uint_t) tmp);
  }
  break;
 }
 case 2: {
  duk_uint32_t tmp={0};
  if (offset + 4U > check_length) {
   goto fail_bounds;
  }
  do { void *duk__dst = ((void *) du.uc); const void *duk__src = ((const void *) (buf + offset)); duk_size_t duk__len = (4); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  tmp = du.ui[0];
  if (endswap) {
   tmp = ((((duk_uint32_t) (tmp)) >> 24) | ((((duk_uint32_t) (tmp)) >> 8) & 0xff00UL) | ((((duk_uint32_t) (tmp)) << 8) & 0xff0000UL) | (((duk_uint32_t) (tmp)) << 24));
  }
  if (magic_signed) {
   duk_push_int(thr, (duk_int_t) ((duk_int32_t) tmp));
  } else {
   duk_push_uint(thr, (duk_uint_t) tmp);
  }
  break;
 }
 case 3: {
  duk_uint32_t tmp={0};
  if (offset + 4U > check_length) {
   goto fail_bounds;
  }
  do { void *duk__dst = ((void *) du.uc); const void *duk__src = ((const void *) (buf + offset)); duk_size_t duk__len = (4); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  if (endswap) {
   tmp = du.ui[0];
   tmp = ((((duk_uint32_t) (tmp)) >> 24) | ((((duk_uint32_t) (tmp)) >> 8) & 0xff00UL) | ((((duk_uint32_t) (tmp)) << 8) & 0xff0000UL) | (((duk_uint32_t) (tmp)) << 24));
   du.ui[0] = tmp;
  }
  duk_push_number(thr, (duk_double_t) du.f[0]);
  break;
 }
 case 4: {
  if (offset + 8U > check_length) {
   goto fail_bounds;
  }
  do { void *duk__dst = ((void *) du.uc); const void *duk__src = ((const void *) (buf + offset)); duk_size_t duk__len = (8); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  if (endswap) {
   do { duk_uint32_t duk__bswaptmp1, duk__bswaptmp2; duk__bswaptmp1 = (&du)->ui[0]; duk__bswaptmp2 = (&du)->ui[1]; duk__bswaptmp1 = ((((duk_uint32_t) (duk__bswaptmp1)) >> 24) | ((((duk_uint32_t) (duk__bswaptmp1)) >> 8) & 0xff00UL) | ((((duk_uint32_t) (duk__bswaptmp1)) << 8) & 0xff0000UL) | (((duk_uint32_t) (duk__bswaptmp1)) << 24)); duk__bswaptmp2 = ((((duk_uint32_t) (duk__bswaptmp2)) >> 24) | ((((duk_uint32_t) (duk__bswaptmp2)) >> 8) & 0xff00UL) | ((((duk_uint32_t) (duk__bswaptmp2)) << 8) & 0xff0000UL) | (((duk_uint32_t) (duk__bswaptmp2)) << 24)); (&du)->ui[0] = duk__bswaptmp2; (&du)->ui[1] = duk__bswaptmp1; } while (0);
  }
  duk_push_number(thr, (duk_double_t) du.d);
  break;
 }
 case 5: {



  duk_int_t field_bytelen={0};
  duk_int_t i, i_step, i_end={0};

  duk_int64_t tmp={0};
  duk_small_uint_t shift_tmp={0};




  const duk_uint8_t *p={0};

  field_bytelen = duk_get_int(thr, 1);
  if (field_bytelen < 1 || field_bytelen > 6) {
   goto fail_field_length;
  }
  if (offset + (duk_uint_t) field_bytelen > check_length) {
   goto fail_bounds;
  }
  p = (const duk_uint8_t *) (buf + offset);






  if (magic_bigendian) {

   i = 0;
   i_step = 1;
   i_end = field_bytelen;
  } else {

   i = field_bytelen - 1;
   i_step = -1;
   i_end = -1;
  }


  tmp = 0;
  do {
   do { } while (0);
   tmp = (tmp << 8) + (duk_int64_t) p[i];
   i += i_step;
  } while (i != i_end);

  if (magic_signed) {




   shift_tmp = (duk_small_uint_t) (64U - (duk_small_uint_t) field_bytelen * 8U);
   tmp = (duk_int64_t) ((duk_uint64_t) tmp << shift_tmp) >> shift_tmp;
  }

  duk_push_number((thr), (duk_double_t) (tmp));
  break;
 }
 default: {
  goto fail_bounds;
 }
 }

 return 1;

 fail_neutered:
 fail_field_length:
 fail_bounds:
 if (no_assert) {



  duk_push_nan(thr);
  return 1;
 }
 do { do { do { duk_err_range((((thr))), "duk_bi_buffer.c", (duk_int_t) 2517, ("invalid args")); } while (0); } while (0); return 0; } while (0);
}




static __attribute__ ((unused)) duk_ret_t duk_bi_buffer_writefield(duk_hthread *thr) {
 duk_small_int_t magic = (duk_small_int_t) duk_get_current_magic(thr);
 duk_small_int_t magic_ftype={0};
 duk_small_int_t magic_bigendian={0};
 duk_small_int_t magic_signed={0};
 duk_small_int_t magic_typedarray={0};
 duk_small_int_t endswap={0};
 duk_hbufobj *h_this={0};
 duk_bool_t no_assert={0};
 duk_int_t offset_signed={0};
 duk_uint_t offset={0};
 duk_uint_t buffer_length={0};
 duk_uint_t check_length={0};
 duk_uint8_t *buf={0};
 duk_double_union du={0};
 duk_int_t nbytes = 0;

 magic_ftype = magic & 0x0007;
 magic_bigendian = magic & 0x0008;
 magic_signed = magic & 0x0010;
 magic_typedarray = magic & 0x0020;
 do { (void) (magic_signed); } while (0);

 h_this = duk__require_bufobj_this(thr);
 do { } while (0);
 buffer_length = h_this->length;






 if (magic_typedarray) {
  no_assert = 0;

  endswap = !duk_to_boolean(thr, 2);



  duk_swap(thr, 0, 1);
 } else {
  no_assert = duk_to_boolean(thr, (magic_ftype == 5) ? 3 : 2);

  endswap = magic_bigendian;



 }





 offset_signed = duk_to_int(thr, 1);
 offset = (duk_uint_t) offset_signed;




 if (magic_ftype != 5) {
  do { } while (0);
  nbytes = duk__buffer_nbytes_from_fldtype[magic_ftype];
 } else {
  nbytes = duk_get_int(thr, 2);
  if (nbytes < 1 || nbytes > 6) {
   goto fail_field_length;
  }
 }
 do { } while (0);


 if (offset_signed < 0) {
  goto fail_bounds;
 }

 do { } while (0)




                                                                ;





 duk_to_number(thr, 0);





 check_length = (((void) 0), duk_hbufobj_clamp_bytelength((h_this), (buffer_length)));
 do { } while (0)
                                                                 ;

 if (h_this->buf) {
  buf = (((void) 0), ((void) 0), (((duk_uint8_t *) ( (((&(((h_this)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_this)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_this)->buf))) + 1)) )) + (h_this)->offset));
 } else {




  do { } while (0);
  goto fail_neutered;
 }
 do { } while (0);

 switch (magic_ftype) {
 case 0: {
  if (offset + 1U > check_length) {
   goto fail_bounds;
  }

  buf[offset] = (duk_uint8_t) duk_to_uint32(thr, 0);
  break;
 }
 case 1: {
  duk_uint16_t tmp={0};
  if (offset + 2U > check_length) {
   goto fail_bounds;
  }
  tmp = (duk_uint16_t) duk_to_uint32(thr, 0);
  if (endswap) {
   tmp = ((duk_uint16_t) (tmp) >> 8) | ((duk_uint16_t) (tmp) << 8);
  }
  du.us[0] = tmp;

  do { void *duk__dst = ((void *) (buf + offset)); const void *duk__src = ((const void *) du.uc); duk_size_t duk__len = (2); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  break;
 }
 case 2: {
  duk_uint32_t tmp={0};
  if (offset + 4U > check_length) {
   goto fail_bounds;
  }
  tmp = (duk_uint32_t) duk_to_uint32(thr, 0);
  if (endswap) {
   tmp = ((((duk_uint32_t) (tmp)) >> 24) | ((((duk_uint32_t) (tmp)) >> 8) & 0xff00UL) | ((((duk_uint32_t) (tmp)) << 8) & 0xff0000UL) | (((duk_uint32_t) (tmp)) << 24));
  }
  du.ui[0] = tmp;

  do { void *duk__dst = ((void *) (buf + offset)); const void *duk__src = ((const void *) du.uc); duk_size_t duk__len = (4); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  break;
 }
 case 3: {
  duk_uint32_t tmp={0};
  if (offset + 4U > check_length) {
   goto fail_bounds;
  }
  du.f[0] = (duk_float_t) duk_to_number(thr, 0);
  if (endswap) {
   tmp = du.ui[0];
   tmp = ((((duk_uint32_t) (tmp)) >> 24) | ((((duk_uint32_t) (tmp)) >> 8) & 0xff00UL) | ((((duk_uint32_t) (tmp)) << 8) & 0xff0000UL) | (((duk_uint32_t) (tmp)) << 24));
   du.ui[0] = tmp;
  }

  do { void *duk__dst = ((void *) (buf + offset)); const void *duk__src = ((const void *) du.uc); duk_size_t duk__len = (4); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  break;
 }
 case 4: {
  if (offset + 8U > check_length) {
   goto fail_bounds;
  }
  du.d = (duk_double_t) duk_to_number(thr, 0);
  if (endswap) {
   do { duk_uint32_t duk__bswaptmp1, duk__bswaptmp2; duk__bswaptmp1 = (&du)->ui[0]; duk__bswaptmp2 = (&du)->ui[1]; duk__bswaptmp1 = ((((duk_uint32_t) (duk__bswaptmp1)) >> 24) | ((((duk_uint32_t) (duk__bswaptmp1)) >> 8) & 0xff00UL) | ((((duk_uint32_t) (duk__bswaptmp1)) << 8) & 0xff0000UL) | (((duk_uint32_t) (duk__bswaptmp1)) << 24)); duk__bswaptmp2 = ((((duk_uint32_t) (duk__bswaptmp2)) >> 24) | ((((duk_uint32_t) (duk__bswaptmp2)) >> 8) & 0xff00UL) | ((((duk_uint32_t) (duk__bswaptmp2)) << 8) & 0xff0000UL) | (((duk_uint32_t) (duk__bswaptmp2)) << 24)); (&du)->ui[0] = duk__bswaptmp2; (&du)->ui[1] = duk__bswaptmp1; } while (0);
  }

  do { void *duk__dst = ((void *) (buf + offset)); const void *duk__src = ((const void *) du.uc); duk_size_t duk__len = (8); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  break;
 }
 case 5: {



  duk_int_t field_bytelen={0};
  duk_int_t i, i_step, i_end={0};

  duk_int64_t tmp={0};



  duk_uint8_t *p={0};

  field_bytelen = (duk_int_t) nbytes;
  if (offset + (duk_uint_t) field_bytelen > check_length) {
   goto fail_bounds;
  }






  if (magic_bigendian) {

   i = field_bytelen;
   i_step = -1;
   i_end = 0;
  } else {

   i = -1;
   i_step = 1;
   i_end = field_bytelen - 1;
  }
  tmp = (duk_int64_t) duk_to_number(thr, 0);
  p = (duk_uint8_t *) (buf + offset);
  do {
   i += i_step;
   do { } while (0);
   p[i] = (duk_uint8_t) (tmp & 0xff);
   tmp = tmp >> 8;
  } while (i != i_end);
  break;
 }
 default: {
  goto fail_bounds;
 }
 }




 if (magic_typedarray) {



  return 0;
 }
 duk_push_uint(thr, offset + (duk_uint_t) nbytes);
 return 1;

 fail_neutered:
 fail_field_length:
 fail_bounds:
 if (no_assert) {






  if (magic_typedarray) {
   return 0;
  }
  duk_push_uint(thr, offset + (duk_uint_t) nbytes);
  return 1;
 }
 do { do { do { duk_err_range((((thr))), "duk_bi_buffer.c", (duk_int_t) 2791, ("invalid args")); } while (0); } while (0); return 0; } while (0);
}







static duk_hbufobj *duk__autospawn_arraybuffer(duk_hthread *thr, duk_hbuffer *h_buf) {
 duk_hbufobj *h_res={0};

 h_res = duk_push_bufobj_raw(thr,
                             (1UL << (7 + (0))) |
                             (1UL << (7 + (6))) |
                             (((duk_uint_t) (19)) << (7 + (20))),
                             39);
 do { } while (0);
 do { (void) (h_res); } while (0);

 duk__set_bufobj_buffer(thr, h_res, h_buf);
 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_res)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);
 do { } while (0);
 return h_res;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_typedarray_buffer_getter(duk_hthread *thr) {
 duk_hbufobj *h_bufobj={0};

 h_bufobj = (duk_hbufobj *) duk__getrequire_bufobj_this(thr, (1 << 0) );
 do { } while (0);
 if ((((((duk_heaphdr *) h_bufobj))->h_flags & 0x00000003UL) == 2)) {
  do { } while (0);
  (void) duk__autospawn_arraybuffer(thr, (duk_hbuffer *) h_bufobj);
  return 1;
 } else {
  if (h_bufobj->buf_prop == ((void *)0) &&
      (((&((duk_hobject *) h_bufobj)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) != 19 &&
      h_bufobj->buf != ((void *)0)) {
   duk_hbufobj *h_arrbuf={0};

   do { } while (0);
   h_arrbuf = duk__autospawn_arraybuffer(thr, h_bufobj->buf);

   if (h_bufobj->buf_prop == ((void *)0)) {
    h_arrbuf->offset = 0;
    do { } while (0);
    h_arrbuf->length = h_bufobj->offset + h_bufobj->length;
    do { } while (0);

    do { } while (0);
    h_bufobj->buf_prop = (duk_hobject *) h_arrbuf;
    do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) &(h_arrbuf)->obj)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   }


  }
  if (h_bufobj->buf_prop) {
   duk_push_hobject(thr, h_bufobj->buf_prop);
   return 1;
  }
 }
 return 0;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_typedarray_byteoffset_getter(duk_hthread *thr) {
 duk_hbufobj *h_bufobj={0};

 h_bufobj = (duk_hbufobj *) duk__getrequire_bufobj_this(thr, (1 << 0) );
 do { } while (0);
 if ((((((duk_heaphdr *) h_bufobj))->h_flags & 0x00000003UL) == 2)) {
  duk_push_uint(thr, 0);
 } else {



  duk_push_uint(thr, h_bufobj->offset);
 }
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_typedarray_bytelength_getter(duk_hthread *thr) {
 duk_hbufobj *h_bufobj={0};

 h_bufobj = (duk_hbufobj *) duk__getrequire_bufobj_this(thr, (1 << 0) );
 do { } while (0);
 if ((((((duk_heaphdr *) h_bufobj))->h_flags & 0x00000003UL) == 2)) {
  duk_hbuffer *h_buf={0};

  h_buf = (duk_hbuffer *) h_bufobj;
  do { } while (0);
  duk_push_uint(thr, (duk_uint_t) (((duk_hbuffer *) (h_buf))->size));
 } else {



  duk_push_uint(thr, h_bufobj->length);
 }
 return 1;
}
static duk_double_t duk__push_this_get_timeval_tzoffset(duk_hthread *thr, duk_small_uint_t flags, duk_int_t *out_tzoffset);
static duk_double_t duk__push_this_get_timeval(duk_hthread *thr, duk_small_uint_t flags);
static void duk__twodigit_year_fixup(duk_hthread *thr, duk_idx_t idx_val);
static duk_ret_t duk__set_this_timeval_from_dparts(duk_hthread *thr, duk_double_t *dparts, duk_small_uint_t flags);
static duk_uint8_t duk__date_equivyear[14] = {






 ((duk_uint8_t) ((2023) - 1970)), ((duk_uint8_t) ((2035) - 1970)), ((duk_uint8_t) ((2019) - 1970)), ((duk_uint8_t) ((2031) - 1970)),
 ((duk_uint8_t) ((2015) - 1970)), ((duk_uint8_t) ((2027) - 1970)), ((duk_uint8_t) ((2011) - 1970)),


 ((duk_uint8_t) ((2012) - 1970)), ((duk_uint8_t) ((2024) - 1970)), ((duk_uint8_t) ((2008) - 1970)), ((duk_uint8_t) ((2020) - 1970)),
 ((duk_uint8_t) ((2032) - 1970)), ((duk_uint8_t) ((2016) - 1970)), ((duk_uint8_t) ((2028) - 1970))
};
static const duk_uint8_t duk__parse_iso8601_seps[] = {
 0x2b , 0x2d , 0x54 , 0x20 ,
 0x3a , 0x2e , 0x5a , 0x00
};


static const duk_uint32_t duk__parse_iso8601_control[] = {
 ((duk_uint32_t) ((1 << 0)) + (((duk_uint32_t) ((1 << 1))) << 9) + (((duk_uint32_t) (1)) << 17) + (((duk_uint32_t) (0)) << 21)),
 ((duk_uint32_t) ((1 << 1)) + (((duk_uint32_t) ((1 << 1))) << 9) + (((duk_uint32_t) (2)) << 17) + (((duk_uint32_t) (0)) << 21)),
 ((duk_uint32_t) ((1 << 0) | (1 << 1) | (1 << 2)) + (((duk_uint32_t) ((1 << 2) | (1 << 3))) << 9) + (((duk_uint32_t) (3)) << 17) + (((duk_uint32_t) (0)) << 21)),
 ((duk_uint32_t) ((1 << 3)) + (((duk_uint32_t) ((1 << 4))) << 9) + (((duk_uint32_t) (4)) << 17) + (((duk_uint32_t) (0)) << 21)),
 ((duk_uint32_t) ((1 << 4)) + (((duk_uint32_t) ((1 << 4))) << 9) + (((duk_uint32_t) (5)) << 17) + (((duk_uint32_t) (0)) << 21)),
 ((duk_uint32_t) ((1 << 5)) + (((duk_uint32_t) ((1 << 5))) << 9) + (((duk_uint32_t) (6)) << 17) + (((duk_uint32_t) (0)) << 21)),
 ((duk_uint32_t) ((1 << 7)) + (((duk_uint32_t) ((1 << 4))) << 9) + (((duk_uint32_t) (8)) << 17) + (((duk_uint32_t) (0)) << 21)),
 ((duk_uint32_t) ((1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5) | (1 << 6)) + (((duk_uint32_t) ((1 << 0))) << 9) + (((duk_uint32_t) (7)) << 17) + (((duk_uint32_t) (0)) << 21)),
 ((duk_uint32_t) ((1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5) | (1 << 6)) + (((duk_uint32_t) ((1 << 1))) << 9) + (((duk_uint32_t) (7)) << 17) + (((duk_uint32_t) ((1 << 0))) << 21)),
 ((duk_uint32_t) ((1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5) | (1 << 6)) + (((duk_uint32_t) ((1 << 6))) << 9) + (((duk_uint32_t) (0)) << 17) + (((duk_uint32_t) ((1 << 2))) << 21)),
 ((duk_uint32_t) ((1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5) | (1 << 6) | (1 << 7) | (1 << 8)) + (((duk_uint32_t) ((1 << 7))) << 9) + (((duk_uint32_t) (0)) << 17) + (((duk_uint32_t) ((1 << 1))) << 21))







};

static duk_bool_t duk__parse_string_iso8601_subset(duk_hthread *thr, const char *str) {
 duk_int_t parts[9]={0};
 duk_double_t dparts[8]={0};
 duk_double_t d={0};
 const duk_uint8_t *p={0};
 duk_small_uint_t part_idx = 0;
 duk_int_t accum = 0;
 duk_small_uint_t ndigits = 0;
 duk_bool_t neg_year = 0;
 duk_bool_t neg_tzoffset = 0;
 duk_uint_fast8_t ch={0};
 duk_small_uint_t i={0};


 do { void *duk__dst = (parts); duk_size_t duk__len = (sizeof(parts)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 do { } while (0);
 parts[1] = 1;
 parts[2] = 1;


 p = (const duk_uint8_t *) str;
 ch = p[0];
 if (ch == 0x2b) {
  p++;
 } else if (ch == 0x2d) {
  neg_year = 1;
  p++;
 }

 for (;;) {
  ch = *p++;
  do { } while (0)

                                                                                   ;

  if (ch >= 0x30 && ch <= 0x39) {
   if (ndigits >= 9) {
    do { } while (0);
    goto reject;
   }
   if (part_idx == 6 && ndigits >= 3) {

   } else {
    accum = accum * 10 + ((duk_int_t) ch) - ((duk_int_t) 0x30) + 0x00;
    ndigits++;
   }
  } else {
   duk_uint_fast32_t match_val={0};
   duk_small_uint_t sep_idx={0};

   if (ndigits <= 0) {
    goto reject;
   }
   if (part_idx == 6) {

    while (ndigits < 3) {
     accum *= 10;
     ndigits++;
    }
   }
   parts[part_idx] = accum;
   do { } while (0);

   accum = 0;
   ndigits = 0;

   for (i = 0; i < (duk_small_uint_t) (sizeof(duk__parse_iso8601_seps) / sizeof(duk_uint8_t)); i++) {
    if (duk__parse_iso8601_seps[i] == ch) {
     break;
    }
   }
   if (i == (duk_small_uint_t) (sizeof(duk__parse_iso8601_seps) / sizeof(duk_uint8_t))) {
    do { } while (0);
    goto reject;
   }

   sep_idx = i;
   match_val = (1UL << part_idx) + (1UL << (sep_idx + 9));

   for (i = 0; i < (duk_small_uint_t) (sizeof(duk__parse_iso8601_control) / sizeof(duk_uint32_t)); i++) {
    duk_uint_fast32_t rule = duk__parse_iso8601_control[i];
    duk_small_uint_t nextpart={0};
    duk_small_uint_t cflags={0};

    do { } while (0)

                                                                          ;

    if ((rule & match_val) != match_val) {
     continue;
    }

    do { (nextpart) = (duk_small_uint_t) (((rule) >> 17) & 0x0f); (cflags) = (duk_small_uint_t) ((rule) >> 21); } while (0);

    do { } while (0)



                                                                  ;

    if (cflags & (1 << 0)) {
     neg_tzoffset = 1;
    }

    if (cflags & (1 << 1)) {
     goto accept;
    }

    if (cflags & (1 << 2)) {
     do { } while (0);
     if (*p == 0x00) {
      goto accept;
     }
     goto reject;
    }

    part_idx = nextpart;
    break;
   }

   if (i == (duk_small_uint_t) (sizeof(duk__parse_iso8601_control) / sizeof(duk_uint32_t))) {
    do { } while (0);
    goto reject;
   }

   if (ch == 0) {



    do { } while (0);
    goto reject;
   }
  }
 }


 do { __builtin_unreachable(); } while (0);

 reject:
 do { } while (0);
 return 0;

 accept:
 do { } while (0);


 if (neg_year) {
  parts[0] = -parts[0];
 }
 if (neg_tzoffset) {
  parts[3] += parts[7];
  parts[4] += parts[8];
 } else {
  parts[3] -= parts[7];
  parts[4] -= parts[8];
 }
 parts[1] -= 1;
 parts[2] -= 1;
 for (i = 0; i < 8; i++) {
  do { } while (0);
  dparts[i] = parts[i];
 }

 d = duk_bi_date_get_timeval_from_dparts(dparts, 0 );
 duk_push_number(thr, d);
 return 1;
}
static duk_ret_t duk__parse_string(duk_hthread *thr, const char *str) {





 do { } while (0);
 do { } while (0);

 if (duk__parse_string_iso8601_subset(thr, str) != 0) {
  return 1;
 }







 if (duk_bi_date_parse_string_strptime((thr), (str)) != 0) {
  return 1;
 }




 duk_push_nan(thr);
 return 1;
}
static duk_uint8_t duk__days_in_month[12] = {
 (duk_uint8_t) 31, (duk_uint8_t) 28, (duk_uint8_t) 31, (duk_uint8_t) 30,
 (duk_uint8_t) 31, (duk_uint8_t) 30, (duk_uint8_t) 31, (duk_uint8_t) 31,
 (duk_uint8_t) 30, (duk_uint8_t) 31, (duk_uint8_t) 30, (duk_uint8_t) 31
};
static __attribute__ ((unused)) duk_bool_t duk_bi_date_is_leap_year(duk_int_t year) {
 if ((year % 4) != 0) {
  return 0;
 }
 if ((year % 100) != 0) {
  return 1;
 }
 if ((year % 400) != 0) {
  return 0;
 }
 return 1;
}

static __attribute__ ((unused)) duk_bool_t duk_bi_date_timeval_in_valid_range(duk_double_t x) {
 return (x >= -(8.64e15) && x <= (8.64e15));
}

static __attribute__ ((unused)) duk_bool_t duk_bi_date_timeval_in_leeway_range(duk_double_t x) {
 return (x >= -(8.64e15 + 24 * 3600e3) && x <= (8.64e15 + 24 * 3600e3));
}

static __attribute__ ((unused)) duk_bool_t duk_bi_date_year_in_valid_range(duk_double_t x) {
 return (x >= (-271821L) && x <= 275760L);
}

static duk_double_t duk__timeclip(duk_double_t x) {
 if (!(sizeof (x) == sizeof (float) ? __finitef (x) : sizeof (x) == sizeof (double) ? __finite (x) : __finitel (x))) {
  return (__builtin_nanf (""));
 }

 if (!duk_bi_date_timeval_in_valid_range(x)) {
  return (__builtin_nanf (""));
 }

 x = duk_js_tointeger_number(x);


 return x;
}


static duk_int_t duk__div_floor(duk_int_t a, duk_int_t b) {
 do { } while (0);
 if (a >= 0) {
  return a / b;
 } else {




  return (a - b + 1) / b;
 }
}


static duk_int_t duk__day_from_year(duk_int_t year) {



 return 365 * (year - 1970)
        + duk__div_floor(year - 1969, 4)
        - duk__div_floor(year - 1901, 100)
        + duk__div_floor(year - 1601, 400);
}


static duk_int_t duk__year_from_day(duk_int_t day, duk_small_int_t *out_day_within_year) {
 duk_int_t year={0};
 duk_int_t diff_days={0};





 if (day >= 0) {
  year = 1970 + day / 365;
 } else {
  year = 1970 + day / 366;
 }

 for (;;) {
  diff_days = duk__day_from_year(year) - day;
  do { } while (0);
  if (diff_days <= 0) {
   do { } while (0);
   *out_day_within_year = -diff_days;
   do { } while (0)
                                                                  ;
   do { } while (0);
   do { } while (0);
   return year;
  }




  year -= 1 + (diff_days - 1) / 366;
 }
}




static duk_double_t duk__make_day(duk_double_t year, duk_double_t month, duk_double_t day) {
 duk_int_t day_num={0};
 duk_bool_t is_leap={0};
 duk_small_int_t i, n={0};
 if (!(sizeof (year) == sizeof (float) ? __finitef (year) : sizeof (year) == sizeof (double) ? __finite (year) : __finitel (year)) || !(sizeof (month) == sizeof (float) ? __finitef (month) : sizeof (month) == sizeof (double) ? __finite (month) : __finitel (month))) {
  return (__builtin_nanf (""));
 }

 year += floor(month / 12.0);

 month = fmod(month, 12.0);
 if (month < 0.0) {

  month += 12.0;
 }
 if (!duk_bi_date_year_in_valid_range(year)) {
  do { } while (0);
  return (__builtin_nanf (""));
 }
 day_num = duk__day_from_year((duk_int_t) year);
 is_leap = duk_bi_date_is_leap_year((duk_int_t) year);

 n = (duk_small_int_t) month;
 for (i = 0; i < n; i++) {
  day_num += duk__days_in_month[i];
  if (i == 1 && is_leap) {
   day_num++;
  }
 }


 return (duk_double_t) day_num + day;
}





static __attribute__ ((unused)) void duk_bi_date_timeval_to_parts(duk_double_t d, duk_int_t *parts, duk_double_t *dparts, duk_small_uint_t flags) {
 duk_double_t d1, d2={0};
 duk_int_t t1, t2={0};
 duk_int_t day_since_epoch={0};
 duk_int_t year={0};
 duk_small_int_t day_in_year={0};
 duk_small_int_t month={0};
 duk_small_int_t day={0};
 duk_small_int_t dim={0};
 duk_int_t jan1_since_epoch={0};
 duk_small_int_t jan1_weekday={0};
 duk_int_t equiv_year={0};
 duk_small_uint_t i={0};
 duk_bool_t is_leap={0};
 duk_small_int_t arridx={0};

 do { } while (0);
 d = floor(d);
 do { } while (0);






 do { (void) (duk_bi_date_timeval_in_leeway_range); } while (0);
 do { } while (0);




 d1 = (duk_double_t) fmod(d, (double) (24L * 60L * 60L * 1000L));
 if (d1 < 0.0) {

  d1 += (duk_double_t) (24L * 60L * 60L * 1000L);
 }
 d2 = floor((double) (d / (duk_double_t) (24L * 60L * 60L * 1000L)));
 do { } while (0);

 t1 = (duk_int_t) d1;
 t2 = (duk_int_t) d2;
 day_since_epoch = t2;
 do { } while (0);
 do { } while (0);





 parts[6] = t1 % 1000; t1 /= 1000;
 parts[5] = t1 % 60; t1 /= 60;
 parts[4] = t1 % 60; t1 /= 60;
 parts[3] = t1;
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0)




                                                              ;




 do { } while (0);
 parts[7] = (t2 + 4 + (20000000 * 7)) % 7;
 do { } while (0);

 year = duk__year_from_day(t2, &day_in_year);
 day = day_in_year;
 is_leap = duk_bi_date_is_leap_year(year);
 for (month = 0; month < 12; month++) {
  dim = duk__days_in_month[month];
  if (month == 1 && is_leap) {
   dim++;
  }
  do { } while (0)
                                                             ;
  if (day < dim) {
   break;
  }
  day -= dim;
 }
 do { } while (0);
 do { } while (0);
 do { } while (0);
 if ((flags & (1 << 3)) && (year < 1971 || year > 2037)) {
  do { } while (0);

  jan1_since_epoch = day_since_epoch - day_in_year;
  do { } while (0);
  jan1_weekday = (jan1_since_epoch + 4 + (20000000 * 7)) % 7;
  do { } while (0);
  arridx = jan1_weekday;
  if (is_leap) {
   arridx += 7;
  }
  do { } while (0);

  equiv_year = (duk_int_t) duk__date_equivyear[arridx] + 1970;
  year = equiv_year;
  do { } while (0)


                                                                                        ;
 }

 parts[0] = year;
 parts[1] = month;
 parts[2] = day;

 if (flags & (1 << 2)) {
  parts[1]++;
  parts[2]++;
 }

 if (dparts != ((void *)0)) {
  for (i = 0; i < 8; i++) {
   dparts[i] = (duk_double_t) parts[i];
  }
 }
}







static __attribute__ ((unused)) duk_double_t duk_bi_date_get_timeval_from_dparts(duk_double_t *dparts, duk_small_uint_t flags) {


 volatile duk_double_t tmp_time;
 volatile duk_double_t tmp_day;
 volatile duk_double_t d;





 duk_small_uint_t i={0};
 duk_int_t tzoff, tzoffprev1, tzoffprev2={0};
 for (i = 0; i <= 6; i++) {





  d = dparts[i];
  if ((sizeof (d) == sizeof (float) ? __finitef (d) : sizeof (d) == sizeof (double) ? __finite (d) : __finitel (d))) {
   dparts[i] = duk_js_tointeger_number(d);
  }
 }
 tmp_time = 0.0;
 tmp_time += dparts[3] * ((duk_double_t) (60L * 60L * 1000L));
 tmp_time += dparts[4] * ((duk_double_t) (60L * 1000L));
 tmp_time += dparts[5] * ((duk_double_t) 1000L);
 tmp_time += dparts[6];


 tmp_day = duk__make_day(dparts[0], dparts[1], dparts[2]);


 d = tmp_day * ((duk_double_t) (24L * 60L * 60L * 1000L)) + tmp_time;

 do { } while (0)
                                                                       ;


 if (flags & (1 << 4)) {
  tzoff = 0;
  tzoffprev1 = 999999999L;
  for (i = 0; i < 4; i++) {
   tzoffprev2 = tzoffprev1;
   tzoffprev1 = tzoff;
   tzoff = duk_bi_date_get_local_tzoffset_gmtime((d - tzoff * 1000L));
   do { } while (0)
                                                                                     ;
   if (tzoff == tzoffprev1) {
    do { } while (0)
                                                                                      ;
    break;
   } else if (tzoff == tzoffprev2) {





    do { } while (0)
                                                                                      ;
    if (tzoffprev1 > tzoff) {
     tzoff = tzoffprev1;
    }
    break;
   }
  }
  do { } while (0);
  d -= tzoff * 1000L;
 }


 d = duk__timeclip(d);

 return d;
}
static duk_double_t duk__push_this_get_timeval_tzoffset(duk_hthread *thr, duk_small_uint_t flags, duk_int_t *out_tzoffset) {
 duk_hobject *h={0};
 duk_double_t d={0};
 duk_int_t tzoffset = 0;

 duk_push_this(thr);
 h = duk_get_hobject(thr, -1);
 if (h == ((void *)0) || (((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) != 6) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 899; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_date.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("expected Date"))); } while (0); } while (0);
  do { } while (0);
 }

 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (105))));
 d = duk_to_number_m1(thr);
 duk_pop(thr);

 if ((sizeof (d) == sizeof (float) ? __isnanf (d) : sizeof (d) == sizeof (double) ? __isnan (d) : __isnanl (d))) {
  if (flags & (1 << 0)) {
   d = 0.0;
  }
  if (flags & (1 << 1)) {
   do { duk_err_range((thr), "duk_bi_date.c", (duk_int_t) 912, ("Invalid Date")); } while (0);
   do { } while (0);
  }
 }

 do { } while (0);

 if (flags & (1 << 4)) {



  tzoffset = duk_bi_date_get_local_tzoffset_gmtime((d));
  d += tzoffset * 1000L;
 }
 if (out_tzoffset) {
  *out_tzoffset = tzoffset;
 }


 return d;
}

static duk_double_t duk__push_this_get_timeval(duk_hthread *thr, duk_small_uint_t flags) {
 return duk__push_this_get_timeval_tzoffset(thr, flags, ((void *)0));
}





static duk_ret_t duk__set_this_timeval_from_dparts(duk_hthread *thr, duk_double_t *dparts, duk_small_uint_t flags) {
 duk_double_t d={0};



 d = duk_bi_date_get_timeval_from_dparts(dparts, flags);
 duk_push_number(thr, d);
 duk_dup_top(thr);
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-3)) << 16) + ((duk_uint_t) (105))));


 return 1;
}


static void duk__format_parts_iso8601(duk_int_t *parts, duk_int_t tzoffset, duk_small_uint_t flags, duk_uint8_t *out_buf) {
 char yearstr[8]={0};
 char tzstr[8]={0};
 char sep = (flags & (1 << 11)) ? 0x54 : 0x20;

 do { } while (0);
 do { } while (0);
 do { } while (0);




 snprintf(yearstr,
              sizeof(yearstr),
              (parts[0] >= 0 && parts[0] <= 9999) ? "%04ld" :
                     ((parts[0] >= 0) ? "+%06ld" : "%07ld"),
              (long) parts[0]);
 yearstr[sizeof(yearstr) - 1] = (char) 0;

 if (flags & (1 << 4)) {



  const char *fmt={0};
  duk_small_int_t tmp, arg_hours, arg_minutes={0};

  if (tzoffset >= 0) {
   tmp = tzoffset;
   fmt = "+%02d:%02d";
  } else {
   tmp = -tzoffset;
   fmt = "-%02d:%02d";
  }
  tmp = tmp / 60;
  arg_hours = tmp / 60;
  arg_minutes = tmp % 60;
  do { } while (0);
  arg_hours = arg_hours & 0x3f;

  snprintf(tzstr, sizeof(tzstr), fmt, (int) arg_hours, (int) arg_minutes);
  tzstr[sizeof(tzstr) - 1] = (char) 0;
 } else {
  tzstr[0] = 0x5a;
  tzstr[1] = (char) 0;
 }




 if ((flags & (1 << 6)) && (flags & (1 << 7))) {
  sprintf((char *) out_buf, "%s-%02d-%02d%c%02d:%02d:%02d.%03d%s",
              (const char *) yearstr, (int) parts[1], (int) parts[2], (int) sep,
              (int) parts[3], (int) parts[4],
              (int) parts[5], (int) parts[6], (const char *) tzstr);
 } else if (flags & (1 << 6)) {
  sprintf((char *) out_buf, "%s-%02d-%02d",
              (const char *) yearstr, (int) parts[1], (int) parts[2]);
 } else {
  do { } while (0);
  sprintf((char *) out_buf, "%02d:%02d:%02d.%03d%s",
              (int) parts[3], (int) parts[4],
              (int) parts[5], (int) parts[6],
              (const char *) tzstr);
 }
}





static duk_ret_t duk__to_string_helper(duk_hthread *thr, duk_small_uint_t flags) {
 duk_double_t d={0};
 duk_int_t parts[8]={0};
 duk_int_t tzoffset={0};
 duk_bool_t rc={0};
 duk_uint8_t buf[40]={0};

 do { (void) (rc); } while (0);

 d = duk__push_this_get_timeval_tzoffset(thr, flags, &tzoffset);
 if ((sizeof (d) == sizeof (float) ? __isnanf (d) : sizeof (d) == sizeof (double) ? __isnan (d) : __isnanl (d))) {
  duk_push_hstring_stridx(thr, 66);
  return 1;
 }
 do { } while (0);


 duk_bi_date_timeval_to_parts(d, parts, ((void *)0), (1 << 2));
 do { } while (0);
 do { } while (0);

 if (flags & (1 << 8)) {
  rc = duk_bi_date_format_parts_strftime((thr), (parts), (tzoffset), (flags));
  if (rc != 0) {
   return 1;
  }





 }




 duk__format_parts_iso8601(parts, tzoffset, flags, buf);
 duk_push_string(thr, (const char *) buf);
 return 1;
}






static duk_ret_t duk__get_part_helper(duk_hthread *thr, duk_small_uint_t flags_and_idx) {
 duk_double_t d={0};
 duk_int_t parts[8]={0};
 duk_small_uint_t idx_part = (duk_small_uint_t) (flags_and_idx >> 12);

 do { } while (0);
 do { } while (0);

 d = duk__push_this_get_timeval(thr, flags_and_idx);
 if ((sizeof (d) == sizeof (float) ? __isnanf (d) : sizeof (d) == sizeof (double) ? __isnan (d) : __isnanl (d))) {
  duk_push_nan(thr);
  return 1;
 }
 do { } while (0);

 duk_bi_date_timeval_to_parts(d, parts, ((void *)0), flags_and_idx);





 duk_push_int(thr, (flags_and_idx & (1 << 5)) ? parts[idx_part] - 1900 : parts[idx_part]);
 return 1;
}
static duk_ret_t duk__set_part_helper(duk_hthread *thr, duk_small_uint_t flags_and_maxnargs) {
 duk_double_t d={0};
 duk_int_t parts[8]={0};
 duk_double_t dparts[8]={0};
 duk_idx_t nargs={0};
 duk_small_uint_t maxnargs = (duk_small_uint_t) (flags_and_maxnargs >> 12);
 duk_small_uint_t idx_first, idx={0};
 duk_small_uint_t i={0};

 nargs = duk_get_top(thr);
 d = duk__push_this_get_timeval(thr, flags_and_maxnargs);
 do { } while (0);

 if ((sizeof (d) == sizeof (float) ? __finitef (d) : sizeof (d) == sizeof (double) ? __finite (d) : __finitel (d))) {
  duk_bi_date_timeval_to_parts(d, parts, dparts, flags_and_maxnargs);
 } else {





 }
 if (flags_and_maxnargs & (1 << 9)) {
  do { } while (0);
  idx_first = 6 - (maxnargs - 1);
 } else {
  do { } while (0);
  idx_first = 2 - (maxnargs - 1);
 }
 do { } while (0);
 do { } while (0);

 for (i = 0; i < maxnargs; i++) {
  if ((duk_idx_t) i >= nargs) {

   break;
  }
  idx = idx_first + i;
  do { } while (0);
  do { } while (0);

  if (idx == 0 && (flags_and_maxnargs & (1 << 10))) {
   duk__twodigit_year_fixup(thr, (duk_idx_t) i);
  }

  dparts[idx] = duk_to_number(thr, (duk_idx_t) i);

  if (idx == 2) {
   dparts[idx] -= 1.0;
  }
 }




 if ((sizeof (d) == sizeof (float) ? __finitef (d) : sizeof (d) == sizeof (double) ? __finite (d) : __finitel (d))) {
  return duk__set_this_timeval_from_dparts(thr, dparts, flags_and_maxnargs);
 } else {

  duk_push_nan(thr);
  return 1;
 }
}




static void duk__twodigit_year_fixup(duk_hthread *thr, duk_idx_t idx_val) {
 duk_double_t d={0};






 duk_to_number(thr, idx_val);
 if (duk_is_nan(thr, idx_val)) {
  return;
 }
 duk_dup(thr, idx_val);
 duk_to_int(thr, -1);
 d = duk_get_number(thr, -1);
 if (d >= 0.0 && d <= 99.0) {
  d += 1900.0;
  duk_push_number(thr, d);
  duk_replace(thr, idx_val);
 }
 duk_pop(thr);
}




static void duk__set_parts_from_args(duk_hthread *thr, duk_double_t *dparts, duk_idx_t nargs) {
 duk_double_t d={0};
 duk_small_uint_t i={0};
 duk_small_uint_t idx={0};




 duk__twodigit_year_fixup(thr, 0);





 for (i = 0; i < 8; i++) {

  idx = 0 + i;
  if ((duk_idx_t) i < nargs) {
   d = duk_to_number(thr, (duk_idx_t) i);
   if (idx == 2) {



    d -= 1.0;
   }
  } else {




   d = 0.0;
  }
  dparts[idx] = d;
 }

 do { } while (0)



                                                              ;
}
static duk_uint16_t duk__date_magics[] = {

 (1 << 6) + (1 << 7) + (1 << 4),


 (1 << 6) + (1 << 4),


 (1 << 7) + (1 << 4),


 (1 << 6) + (1 << 7) + (1 << 8) + (1 << 4),


 (1 << 6) + (1 << 8) + (1 << 4),


 (1 << 7) + (1 << 8) + (1 << 4),


 (1 << 6) + (1 << 7),


 (1 << 6) + (1 << 7) + (1 << 1) + (1 << 11),


 (1 << 4) + (0 << 12),


 0 + (0 << 12),


 (1 << 4) + (1 << 12),


 0 + (1 << 12),


 (1 << 2) + (1 << 4) + (2 << 12),


 (1 << 2) + (2 << 12),


 (1 << 4) + (7 << 12),


 0 + (7 << 12),


 (1 << 4) + (3 << 12),


 0 + (3 << 12),


 (1 << 4) + (4 << 12),


 0 + (4 << 12),


 (1 << 4) + (5 << 12),


 0 + (5 << 12),


 (1 << 4) + (6 << 12),


 0 + (6 << 12),


 (1 << 9) + (1 << 4) + (1 << 12),


 (1 << 9) + (1 << 12),


 (1 << 9) + (1 << 4) + (2 << 12),


 (1 << 9) + (2 << 12),


 (1 << 9) + (1 << 4) + (3 << 12),


 (1 << 9) + (3 << 12),


 (1 << 9) + (1 << 4) + (4 << 12),


 (1 << 9) + (4 << 12),


 (1 << 4) + (1 << 12),


 0 + (1 << 12),


 (1 << 4) + (2 << 12),


 0 + (2 << 12),


 (1 << 0) + (1 << 4) + (3 << 12),


 (1 << 0) + (3 << 12),


 (1 << 4) + (1 << 5) + (0 << 12),


 (1 << 0) + (1 << 10) + (3 << 12),
};

static duk_small_uint_t duk__date_get_indirect_magic(duk_hthread *thr) {
 duk_small_uint_t magicidx = (duk_small_uint_t) duk_get_current_magic(thr);
 do { } while (0);
 return (duk_small_uint_t) duk__date_magics[magicidx];
}






static __attribute__ ((unused)) duk_ret_t duk_bi_date_constructor(duk_hthread *thr) {
 duk_idx_t nargs = duk_get_top(thr);
 duk_bool_t is_cons = duk_is_constructor_call(thr);
 duk_double_t dparts[8]={0};
 duk_double_t d={0};

 do { } while (0);

 (void) duk_push_object_helper(thr,
                               (1UL << (7 + (0))) |
                               (1UL << (7 + (7))) |
                               (((duk_uint_t) (6)) << (7 + (20))),
                               16);





 if (nargs == 0 || !is_cons) {
  d = duk__timeclip(duk_time_get_ecmascript_time_nofrac(thr));
  duk_push_number(thr, d);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (105)) << 8) + (duk_uint_t) (((1U << 0)))));
  if (!is_cons) {

   duk_to_string(thr, -1);
  }
  return 1;
 } else if (nargs == 1) {
  const char *str={0};
  duk_to_primitive(thr, 0, 0);
  str = duk_get_string_notsymbol(thr, 0);
  if (str) {
   duk__parse_string(thr, str);
   duk_replace(thr, 0);
  }
  d = duk__timeclip(duk_to_number(thr, 0));
  duk_push_number(thr, d);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (105)) << 8) + (duk_uint_t) (((1U << 0)))));
  return 1;
 }

 duk__set_parts_from_args(thr, dparts, nargs);



 (void) duk__set_this_timeval_from_dparts(thr, dparts, (1 << 4) );
 duk_pop(thr);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_date_constructor_parse(duk_hthread *thr) {
 return duk__parse_string(thr, duk_to_string(thr, 0));
}

static __attribute__ ((unused)) duk_ret_t duk_bi_date_constructor_utc(duk_hthread *thr) {
 duk_idx_t nargs = duk_get_top(thr);
 duk_double_t dparts[8]={0};
 duk_double_t d={0};





 if (nargs < 2) {
  duk_push_nan(thr);
 } else {
  duk__set_parts_from_args(thr, dparts, nargs);
  d = duk_bi_date_get_timeval_from_dparts(dparts, 0 );
  duk_push_number(thr, d);
 }
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_date_constructor_now(duk_hthread *thr) {
 duk_double_t d={0};

 d = duk_time_get_ecmascript_time_nofrac(thr);
 do { } while (0);
 duk_push_number(thr, d);
 return 1;
}
static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_tostring_shared(duk_hthread *thr) {
 duk_small_uint_t flags = duk__date_get_indirect_magic(thr);
 return duk__to_string_helper(thr, flags);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_value_of(duk_hthread *thr) {




 duk_double_t d = duk__push_this_get_timeval(thr, 0 );
 do { } while (0);
 duk_push_number(thr, d);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_to_json(duk_hthread *thr) {




 duk_push_this(thr);
 duk_to_object(thr, -1);

 duk_dup_top(thr);
 duk_to_primitive(thr, -1, 2);
 if (duk_is_number(thr, -1)) {
  duk_double_t d = duk_get_number(thr, -1);
  if (!(sizeof (d) == sizeof (float) ? __finitef (d) : sizeof (d) == sizeof (double) ? __finite (d) : __finitel (d))) {
   duk_push_null(thr);
   return 1;
  }
 }
 duk_pop(thr);

 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (42))));
 duk_dup_m2(thr);
 duk_call_method(thr, 0);
 return 1;
}
static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_get_shared(duk_hthread *thr) {
 duk_small_uint_t flags_and_idx = duk__date_get_indirect_magic(thr);
 return duk__get_part_helper(thr, flags_and_idx);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_get_timezone_offset(duk_hthread *thr) {
 duk_double_t d={0};
 duk_int_t tzoffset={0};


 d = duk__push_this_get_timeval(thr, 0 );
 do { } while (0);
 if ((sizeof (d) == sizeof (float) ? __isnanf (d) : sizeof (d) == sizeof (double) ? __isnan (d) : __isnanl (d))) {
  duk_push_nan(thr);
 } else {
  do { } while (0);
  tzoffset = duk_bi_date_get_local_tzoffset_gmtime((d));
  duk_push_int(thr, -tzoffset / 60);
 }
 return 1;
}
static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_set_shared(duk_hthread *thr) {
 duk_small_uint_t flags_and_maxnargs = duk__date_get_indirect_magic(thr);
 return duk__set_part_helper(thr, flags_and_maxnargs);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_set_time(duk_hthread *thr) {
 duk_double_t d={0};

 (void) duk__push_this_get_timeval(thr, 0 );
 d = duk__timeclip(duk_to_number(thr, 0));
 duk_push_number(thr, d);
 duk_dup_top(thr);
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-3)) << 16) + ((duk_uint_t) (105))));

 return 1;
}
static __attribute__ ((unused)) duk_double_t duk_bi_date_get_now_gettimeofday(void) {
 struct timeval tv={0};
 duk_double_t d={0};

 if (gettimeofday(&tv, ((void *)0)) != 0) {
  do { } while (0);
  return 0.0;
 }


 d = ((duk_double_t) tv.tv_sec) * 1000.0 +
     ((duk_double_t) tv.tv_usec) / 1000.0;

 return d;
}
static __attribute__ ((unused)) duk_int_t duk_bi_date_get_local_tzoffset_gmtime(duk_double_t d) {
 time_t t, t1, t2={0};
 duk_int_t parts[8]={0};
 duk_double_t dparts[8]={0};
 struct tm tms[2]={0};





 if (!(sizeof (d) == sizeof (float) ? __finitef (d) : sizeof (d) == sizeof (double) ? __finite (d) : __finitel (d))) {
  return 0;
 }







 if (!duk_bi_date_timeval_in_leeway_range(d)) {
  do { } while (0);
  return 0;
 }
 duk_bi_date_timeval_to_parts(d, parts, dparts, (1 << 3) );
 do { } while (0);

 d = duk_bi_date_get_timeval_from_dparts(dparts, 0 );
 do { } while (0);
 t = (time_t) (d / 1000.0);
 do { } while (0);

 do { void *duk__dst = ((void *) tms); duk_size_t duk__len = (sizeof(struct tm) * 2); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);


 (void) gmtime_r(&t, &tms[0]);
 (void) localtime_r(&t, &tms[1]);
 do { } while (0)



                                                                                            ;
 do { } while (0)



                                                                                            ;






 tms[0].tm_isdst = 0;
 tms[1].tm_isdst = 0;
 t1 = mktime(&tms[0]);
 t2 = mktime(&tms[1]);
 if (t1 == (time_t) -1 || t2 == (time_t) -1) {





  goto mktime_error;
 }
 do { } while (0);
 return (duk_int_t) difftime(t2, t1);

 mktime_error:

 do { } while (0);
 return 0;
}



static __attribute__ ((unused)) duk_bool_t duk_bi_date_parse_string_strptime(duk_hthread *thr, const char *str) {
 struct tm tm={0};
 time_t t={0};
 char buf[64]={0};


 do { } while (0);
 do { void *duk__dst = (buf); duk_size_t duk__len = (sizeof(buf)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 snprintf(buf, sizeof(buf), "%s", (const char *) str);
 buf[sizeof(buf) - 1] = (char) 0;

 do { } while (0);

 do { void *duk__dst = (&tm); duk_size_t duk__len = (sizeof(tm)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 if (strptime((const char *) buf, "%c", &tm) != ((void *)0)) {
  do { } while (0)



                                                                                 ;
  tm.tm_isdst = -1;

  t = mktime(&tm);
  do { } while (0);
  if (t >= 0) {
   duk_push_number(thr, ((duk_double_t) t) * 1000.0);
   return 1;
  }
 }

 return 0;
}
static __attribute__ ((unused)) duk_bool_t duk_bi_date_format_parts_strftime(duk_hthread *thr, duk_int_t *parts, duk_int_t tzoffset, duk_small_uint_t flags) {
 char buf[64]={0};
 struct tm tm={0};
 const char *fmt={0};

 do { (void) (tzoffset); } while (0);
 if (sizeof(time_t) < 8 &&
     (parts[0] < 1970 || parts[0] > 2037)) {

  return 0;
 }

 do { void *duk__dst = (&tm); duk_size_t duk__len = (sizeof(tm)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 tm.tm_sec = parts[5];
 tm.tm_min = parts[4];
 tm.tm_hour = parts[3];
 tm.tm_mday = parts[2];
 tm.tm_mon = parts[1] - 1;
 tm.tm_year = parts[0] - 1900;
 tm.tm_wday = parts[7];
 tm.tm_isdst = 0;

 do { void *duk__dst = (buf); duk_size_t duk__len = (sizeof(buf)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 if ((flags & (1 << 6)) && (flags & (1 << 7))) {
  fmt = "%c";
 } else if (flags & (1 << 6)) {
  fmt = "%x";
 } else {
  do { } while (0);
  fmt = "%X";
 }
 (void) strftime(buf, sizeof(buf) - 1, fmt, &tm);
 do { } while (0);

 duk_push_string(thr, buf);
 return 1;
}
static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_info(duk_hthread *thr) {
 duk_inspect_value(thr, -1);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_act(duk_hthread *thr) {
 duk_int_t level={0};

 level = duk_to_int(thr, 0);
 duk_inspect_callstack_entry(thr, level);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_gc(duk_hthread *thr) {
 duk_small_uint_t flags={0};

 flags = (duk_small_uint_t) duk_get_uint(thr, 0);
 duk_heap_mark_and_sweep(thr->heap, flags);




 duk_push_true(thr);
 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_fin(duk_hthread *thr) {
 (void) duk_require_hobject(thr, 0);
 if (duk_get_top(thr) >= 2) {







  duk_set_top(thr, 2);
  duk_set_finalizer(thr, 0);
  return 0;
 } else {

  do { } while (0);
  duk_get_finalizer(thr, 0);
  return 1;
 }
}


static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_enc(duk_hthread *thr) {
 duk_hstring *h_str={0};






 h_str = duk_require_hstring(thr, 0);
 duk_require_valid_index(thr, 1);

 if (h_str == (((thr))->strs[(111)])) {
  duk_set_top(thr, 2);
  duk_hex_encode(thr, 1);
  do { } while (0);
 } else if (h_str == (((thr))->strs[(112)])) {
  duk_set_top(thr, 2);
  duk_base64_encode(thr, 1);
  do { } while (0);

 } else if (h_str == (((thr))->strs[(113)])) {
  duk_bi_json_stringify_helper(thr,
                               1 ,
                               2 ,
                               3 ,
                               (1U << 2) |
                               (1U << 0) |
                               (1U << 1) );


 } else if (h_str == (((thr))->strs[(114)])) {
  duk_bi_json_stringify_helper(thr,
                               1 ,
                               2 ,
                               3 ,
                               (1U << 3) |
                               (1U << 0) );

 } else {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_duktape.c", (duk_int_t) 104); } while (0); return 0; } while (0);
 }
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_dec(duk_hthread *thr) {
 duk_hstring *h_str={0};






 h_str = duk_require_hstring(thr, 0);
 duk_require_valid_index(thr, 1);

 if (h_str == (((thr))->strs[(111)])) {
  duk_set_top(thr, 2);
  duk_hex_decode(thr, 1);
  do { } while (0);
 } else if (h_str == (((thr))->strs[(112)])) {
  duk_set_top(thr, 2);
  duk_base64_decode(thr, 1);
  do { } while (0);

 } else if (h_str == (((thr))->strs[(113)])) {
  duk_bi_json_parse_helper(thr,
                           1 ,
                           2 ,
                           (1U << 2) );


 } else if (h_str == (((thr))->strs[(114)])) {
  duk_bi_json_parse_helper(thr,
                           1 ,
                           2 ,
                           (1U << 3) );

 } else {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_duktape.c", (duk_int_t) 143); } while (0); return 0; } while (0);
 }
 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_compact(duk_hthread *thr) {
 do { } while (0);
 duk_compact(thr, 0);
 return 1;
}
typedef struct {
 duk_uint8_t *out;
 duk_codepoint_t lead;
} duk__encode_context;

typedef struct {

 duk_codepoint_t codepoint;
 duk_uint8_t upper;
 duk_uint8_t lower;
 duk_uint8_t needed;
 duk_uint8_t bom_handled;


 duk_uint8_t fatal;
 duk_uint8_t ignore_bom;
} duk__decode_context;
static duk_uint8_t *duk__utf8_emit_repl(duk_uint8_t *ptr) {
 *ptr++ = 0xef;
 *ptr++ = 0xbf;
 *ptr++ = 0xbd;
 return ptr;
}

static void duk__utf8_decode_init(duk__decode_context *dec_ctx) {



 dec_ctx->codepoint = 0x0000L;
 dec_ctx->upper = 0xbf;
 dec_ctx->lower = 0x80;
 dec_ctx->needed = 0;
 dec_ctx->bom_handled = 0;
}

static duk_codepoint_t duk__utf8_decode_next(duk__decode_context *dec_ctx, duk_uint8_t x) {
 if (dec_ctx->needed == 0) {

  if (x <= 0x7f) {

   return (duk_codepoint_t) x;
  } else if (x >= 0xc2 && x <= 0xdf) {

   dec_ctx->needed = 1;
   dec_ctx->codepoint = x & 0x1f;
   do { } while (0);
   do { } while (0);
   return (-1);
  } else if (x >= 0xe0 && x <= 0xef) {

   if (x == 0xe0) {
    dec_ctx->lower = 0xa0;
    do { } while (0);
   } else if (x == 0xed) {
    do { } while (0);
    dec_ctx->upper = 0x9f;
   }
   dec_ctx->needed = 2;
   dec_ctx->codepoint = x & 0x0f;
   return (-1);
  } else if (x >= 0xf0 && x <= 0xf4) {

   if (x == 0xf0) {
    dec_ctx->lower = 0x90;
    do { } while (0);
   } else if (x == 0xf4) {
    do { } while (0);
    dec_ctx->upper = 0x8f;
   }
   dec_ctx->needed = 3;
   dec_ctx->codepoint = x & 0x07;
   return (-1);
  } else {

   return (-2);
  }
 } else {

  if (x >= dec_ctx->lower && x <= dec_ctx->upper) {
   dec_ctx->lower = 0x80;
   dec_ctx->upper = 0xbf;
   dec_ctx->codepoint = (dec_ctx->codepoint << 6) | (x & 0x3f);
   if (--dec_ctx->needed > 0) {

    return (-1);
   } else {

    duk_codepoint_t ret={0};
    do { } while (0);
    ret = dec_ctx->codepoint;
    dec_ctx->codepoint = 0x0000L;
    dec_ctx->needed = 0;
    return ret;
   }
  } else {






   dec_ctx->codepoint = 0x0000L;
   dec_ctx->needed = 0;
   dec_ctx->lower = 0x80;
   dec_ctx->upper = 0xbf;
   return (-3);
  }
 }
}


static void duk__utf8_encode_char(void *udata, duk_codepoint_t codepoint) {
 duk__encode_context *enc_ctx={0};

 do { } while (0);
 enc_ctx = (duk__encode_context *) udata;
 do { } while (0);


 if (codepoint <= 0x7f && enc_ctx->lead == 0x0000L) {

  *enc_ctx->out++ = (duk_uint8_t) codepoint;
  return;
 }


 if (__builtin_expect((codepoint > 0x10ffffL), 0)) {

  codepoint = 0xfffdL;
 } else if (codepoint >= 0xd800L && codepoint <= 0xdfffL) {
  if (codepoint <= 0xdbffL) {

   duk_codepoint_t prev_lead = enc_ctx->lead;
   enc_ctx->lead = codepoint;
   if (prev_lead == 0x0000L) {

    return;
   } else {

    codepoint = 0xfffdL;
   }
  } else {

   if (enc_ctx->lead != 0x0000L) {
    codepoint = (duk_codepoint_t) (0x010000L + ((enc_ctx->lead - 0xd800L) << 10) + (codepoint - 0xdc00L));
    enc_ctx->lead = 0x0000L;
   } else {

    do { } while (0);
    codepoint = 0xfffdL;
   }
  }
 } else {
  if (enc_ctx->lead != 0x0000L) {

   enc_ctx->lead = 0x0000L;
   enc_ctx->out = duk__utf8_emit_repl(enc_ctx->out);
  }
 }




 enc_ctx->out += duk_unicode_encode_xutf8((duk_ucodepoint_t) codepoint, enc_ctx->out);
}





static duk_ret_t duk__decode_helper(duk_hthread *thr, duk__decode_context *dec_ctx) {
 const duk_uint8_t *input={0};
 duk_size_t len = 0;
 duk_size_t len_tmp={0};
 duk_bool_t stream = 0;
 duk_codepoint_t codepoint={0};
 duk_uint8_t *output={0};
 const duk_uint8_t *in={0};
 duk_uint8_t *out={0};

 do { } while (0);
 if (duk_is_undefined(thr, 0)) {
  duk_push_fixed_buffer_nozero(thr, 0);
  duk_replace(thr, 0);
 }
 (void) duk_require_buffer_data(thr, 0, &len);

 if (duk_check_type_mask(thr, 1, (1U << 1U) |
                                 (1U << 2U) |
                                 (1U << 0U))) {

 } else {
  ((void) duk_check_type_mask((thr), (1), ((1U << 1U) | (1U << 2U) | (1U << 9U) | (1U << 7U) | (1U << 6U)) | (1U << 10)))



                                                     ;
  if (duk_get_prop_literal_raw((thr), (1), ("stream"), sizeof(("stream")) - 1U)) {
   stream = duk_to_boolean(thr, -1);
  }
 }
 if (len >= ((0x7ffffffeUL) / 3) - 3) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 256; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_encoding.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("result too long"))); } while (0); } while (0);
  do { } while (0);
 }
 output = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, 3 + (3 * len));

 input = (const duk_uint8_t *) duk_get_buffer_data(thr, 0, &len_tmp);
 do { } while (0);
 if (__builtin_expect((len != len_tmp), 0)) {





  do { } while (0);
  goto fail_type;
 }







 in = input;
 out = output;
 while (in < input + len) {
  codepoint = duk__utf8_decode_next(dec_ctx, *in++);
  if (codepoint < 0) {
   if (codepoint == (-1)) {
    continue;
   }


   do { } while (0);
   if (codepoint == (-3)) {
    --in;
   }

   codepoint = 0xfffdL;
   if (dec_ctx->fatal) {

    goto fail_type;
   }

  }
  do { } while (0);

  if (!dec_ctx->bom_handled) {
   dec_ctx->bom_handled = 1;
   if (codepoint == 0xfeffL && !dec_ctx->ignore_bom) {
    continue;
   }
  }

  out += duk_unicode_encode_cesu8((duk_ucodepoint_t) codepoint, out);
  do { } while (0);
 }

 if (!stream) {
  if (dec_ctx->needed != 0) {

   if (dec_ctx->fatal) {
    goto fail_type;
   } else {
    out += duk_unicode_encode_cesu8(0xfffdL, out);
    do { } while (0);
   }
  }
  duk__utf8_decode_init(dec_ctx);
 }




 duk_push_lstring(thr, (const char *) output, (duk_size_t) (out - output));
 return 1;

 fail_type:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 334; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_encoding.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("utf-8 decode failed"))); } while (0); } while (0);
 do { } while (0);
}






static __attribute__ ((unused)) duk_ret_t duk_bi_textencoder_constructor(duk_hthread *thr) {




 duk_require_constructor_call(thr);
 return 0;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_textencoder_prototype_encoding_getter(duk_hthread *thr) {
 duk_push_literal_raw((thr), ("utf-8"), sizeof(("utf-8")) - 1U);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_textencoder_prototype_encode(duk_hthread *thr) {
 duk__encode_context enc_ctx={0};
 duk_size_t len={0};
 duk_size_t final_len={0};
 duk_uint8_t *output={0};

 do { } while (0);
 if (duk_is_undefined(thr, 0)) {
  len = 0;
 } else {
  duk_hstring *h_input={0};

  h_input = duk_to_hstring(thr, 0);
  do { } while (0);

  len = (duk_size_t) duk_hstring_get_charlen((h_input));
  if (len >= (0x7ffffffeUL) / 3) {
   do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 374; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_encoding.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("result too long"))); } while (0); } while (0);
   do { } while (0);
  }
 }
 do { } while (0);
 output = (duk_uint8_t *) duk_push_buffer_raw((thr), (3 * len), (1 << 0) );

 if (len > 0) {
  do { } while (0);
  enc_ctx.lead = 0x0000L;
  enc_ctx.out = output;
  duk_decode_string(thr, 0, duk__utf8_encode_char, (void *) &enc_ctx);
  if (enc_ctx.lead != 0x0000L) {

   enc_ctx.out = duk__utf8_emit_repl(enc_ctx.out);
   do { } while (0);
  }




  do { } while (0);
  do { } while (0);

  final_len = (duk_size_t) (enc_ctx.out - output);
  duk_resize_buffer(thr, -1, final_len);

 } else {
  final_len = 0;
 }
 duk_push_buffer_object(thr, -1, 0, final_len, 4);

 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_textdecoder_constructor(duk_hthread *thr) {
 duk__decode_context *dec_ctx={0};
 duk_bool_t fatal = 0;
 duk_bool_t ignore_bom = 0;

 do { } while (0);
 duk_require_constructor_call(thr);
 if (!duk_is_undefined(thr, 0)) {

  duk_to_string(thr, 0);
 }
 if (!((duk_get_type_mask((thr), (1)) & ((1U << 2U) | (1U << 1U))) ? 1 : 0)) {
  if (duk_get_prop_literal_raw((thr), (1), ("fatal"), sizeof(("fatal")) - 1U)) {
   fatal = duk_to_boolean(thr, -1);
  }
  if (duk_get_prop_literal_raw((thr), (1), ("ignoreBOM"), sizeof(("ignoreBOM")) - 1U)) {
   ignore_bom = duk_to_boolean(thr, -1);
  }
 }

 duk_push_this(thr);




 dec_ctx = (duk__decode_context *) duk_push_buffer_raw((thr), (sizeof(duk__decode_context)), 0 );
 dec_ctx->fatal = (duk_uint8_t) fatal;
 dec_ctx->ignore_bom = (duk_uint8_t) ignore_bom;
 duk__utf8_decode_init(dec_ctx);

 duk_put_prop_literal_raw((thr), (-2), (("\x82" "Context")), sizeof((("\x82" "Context"))) - 1U);
 return 0;
}


static duk__decode_context *duk__get_textdecoder_context(duk_hthread *thr) {
 duk__decode_context *dec_ctx={0};
 duk_push_this(thr);
 duk_get_prop_literal_raw((thr), (-1), (("\x82" "Context")), sizeof((("\x82" "Context"))) - 1U);
 dec_ctx = (duk__decode_context *) duk_require_buffer(thr, -1, ((void *)0));
 do { } while (0);
 return dec_ctx;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_textdecoder_prototype_shared_getter(duk_hthread *thr) {
 duk__decode_context *dec_ctx={0};
 duk_int_t magic={0};

 dec_ctx = duk__get_textdecoder_context(thr);
 magic = duk_get_current_magic(thr);
 switch (magic) {
 case 0:



  duk_push_literal_raw((thr), ("utf-8"), sizeof(("utf-8")) - 1U);
  break;
 case 1:
  duk_push_boolean(thr, dec_ctx->fatal);
  break;
 default:
  duk_push_boolean(thr, dec_ctx->ignore_bom);
  break;
 }

 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_textdecoder_prototype_decode(duk_hthread *thr) {
 duk__decode_context *dec_ctx={0};

 dec_ctx = duk__get_textdecoder_context(thr);
 return duk__decode_helper(thr, dec_ctx);
}
static __attribute__ ((unused)) duk_ret_t duk_textdecoder_decode_utf8_nodejs(duk_hthread *thr) {
 duk__decode_context dec_ctx={0};

 dec_ctx.fatal = 0;
 dec_ctx.ignore_bom = 1;
 duk__utf8_decode_init(&dec_ctx);

 return duk__decode_helper(thr, &dec_ctx);
}






static __attribute__ ((unused)) duk_ret_t duk_bi_error_constructor_shared(duk_hthread *thr) {







 duk_small_int_t bidx_prototype = duk_get_current_magic(thr);


 duk_uint_t flags_and_class = (1UL << (7 + (0))) |
                              (1UL << (7 + (7))) |
                              (((duk_uint_t) (7)) << (7 + (20)));

 (void) duk_push_object_helper(thr, flags_and_class, bidx_prototype);




 if (!duk_is_undefined(thr, 0)) {
  duk_to_string(thr, 0);
  duk_dup_0(thr);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (52)) << 8) + (duk_uint_t) (((1U << 0) | (1U << 2)))));
 }






 if (!duk_is_constructor_call(thr)) {
  duk_err_augment_error_create(thr, thr, ((void *)0), 0, (1U << 0));
 }


 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_to_string(duk_hthread *thr) {


 duk_push_this(thr);
 (void) duk_require_hobject_promote_mask(thr, -1, (1U << 9U) | (1U << 7U));



 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (92))));
 if (duk_is_undefined(thr, -1)) {
  duk_pop(thr);
  duk_push_literal_raw((thr), ("Error"), sizeof(("Error")) - 1U);
 } else {
  duk_to_string(thr, -1);
 }







 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (52))));
 if (duk_is_undefined(thr, -1)) {
  duk_pop(thr);
  duk_push_hstring_empty(thr);
 } else {
  duk_to_string(thr, -1);
 }



 if (duk_get_length(thr, -2) == 0) {

  return 1;
 }
 if (duk_get_length(thr, -1) == 0) {

  duk_pop(thr);
  return 1;
 }
 duk_push_literal_raw((thr), (": "), sizeof((": ")) - 1U);
 duk_insert(thr, -2);
 duk_concat(thr, 3);

 return 1;
}
static duk_ret_t duk__error_getter_helper(duk_hthread *thr, duk_small_int_t output_type) {
 duk_idx_t idx_td={0};
 duk_small_int_t i={0};
 duk_small_int_t t={0};
 duk_small_int_t count_func = 0;
 const char *str_tailcall = " tailcall";
 const char *str_strict = " strict";
 const char *str_construct = " construct";
 const char *str_prevyield = " preventsyield";
 const char *str_directeval = " directeval";
 const char *str_empty = "";

 do { } while (0);

 duk_push_this(thr);
 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (91))));
 idx_td = duk_get_top_index(thr);

 duk_push_hstring_stridx(thr, 64);
 duk_push_this(thr);





 if (duk_check_type(thr, idx_td, 6U)) {

  for (i = 0; ; i += 2) {
   duk_int_t pc={0};
   duk_uint_t line={0};
   duk_uint_t flags={0};
   duk_double_t d={0};
   const char *funcname={0};
   const char *filename={0};
   duk_hobject *h_func={0};
   duk_hstring *h_name={0};

   duk_require_stack(thr, 5);
   duk_get_prop_index(thr, idx_td, (duk_uarridx_t) i);
   duk_get_prop_index(thr, idx_td, (duk_uarridx_t) (i + 1));
   d = duk_to_number_m1(thr);
   pc = duk_double_to_int_t(fmod(d, 4294967296.0));
   flags = duk_double_to_uint_t(floor(d / 4294967296.0));
   t = (duk_small_int_t) duk_get_type(thr, -2);

   if (t == 6U || t == 9U) {




    count_func++;







    (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (92))));
    (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-3)) << 16) + ((duk_uint_t) (93))));


    line = (duk_uint_t) duk_hobject_pc2line_query(thr, -4, (duk_uint_fast32_t) pc);
    if (duk_is_string_notsymbol(thr, -1)) {
     if (output_type == 0) {
      return 1;
     } else if (output_type == 1) {
      duk_push_uint(thr, line);
      return 1;
     }
    }



    h_name = duk_get_hstring_notsymbol(thr, -2);
    funcname = (h_name == ((void *)0) || h_name == (((thr))->strs[(15)])) ?
               "[anon]" : (const char *) ((const duk_uint8_t *) ((h_name) + 1));
    filename = duk_get_string_notsymbol(thr, -1);
    filename = filename ? filename : "";
    do { } while (0);
    do { } while (0);

    h_func = duk_get_hobject(thr, -4);

    if (h_func == ((void *)0)) {
     duk_push_sprintf(thr, "at %s light%s%s%s%s%s",
                      (const char *) funcname,
                      (const char *) ((flags & (1U << 0)) ? str_strict : str_empty),
                      (const char *) ((flags & (1U << 1)) ? str_tailcall : str_empty),
                      (const char *) ((flags & (1U << 2)) ? str_construct : str_empty),
                      (const char *) ((flags & (1U << 4)) ? str_directeval : str_empty),
                      (const char *) ((flags & (1U << 3)) ? str_prevyield : str_empty));
    } else if ((((&(h_func)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
     duk_push_sprintf(thr, "at %s (%s) native%s%s%s%s%s",
                      (const char *) funcname,
                      (const char *) filename,
                      (const char *) ((flags & (1U << 0)) ? str_strict : str_empty),
                      (const char *) ((flags & (1U << 1)) ? str_tailcall : str_empty),
                      (const char *) ((flags & (1U << 2)) ? str_construct : str_empty),
                      (const char *) ((flags & (1U << 4)) ? str_directeval : str_empty),
                      (const char *) ((flags & (1U << 3)) ? str_prevyield : str_empty));
    } else {
     duk_push_sprintf(thr, "at %s (%s:%lu)%s%s%s%s%s",
                      (const char *) funcname,
                      (const char *) filename,
                      (unsigned long) line,
                      (const char *) ((flags & (1U << 0)) ? str_strict : str_empty),
                      (const char *) ((flags & (1U << 1)) ? str_tailcall : str_empty),
                      (const char *) ((flags & (1U << 2)) ? str_construct : str_empty),
                      (const char *) ((flags & (1U << 4)) ? str_directeval : str_empty),
                      (const char *) ((flags & (1U << 3)) ? str_prevyield : str_empty));
    }
    duk_replace(thr, -5);
    duk_pop_3(thr);
   } else if (t == 5U) {
    const char *str_file={0};
    if (!(flags & (1U << 0))) {
     if (output_type == 0) {
      duk_pop(thr);
      return 1;
     } else if (output_type == 1) {
      duk_push_int(thr, pc);
      return 1;
     }
    }






    str_file = (const char *) duk_get_string(thr, -2);
    duk_push_sprintf(thr, "at [anon] (%s:%ld) internal",
                     (const char *) (str_file ? str_file : "null"), (long) pc);
    duk_replace(thr, -3);
    duk_pop(thr);
   } else {

    duk_pop_2(thr);
    break;
   }
  }

  if (count_func >= 10) {




   duk_push_hstring_stridx(thr, 65);
  }
 }



 if (output_type != (-1)) {
  return 0;
 } else {




  duk_join(thr, duk_get_top(thr) - (idx_td + 2) );
  return 1;
 }
}





static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_stack_getter(duk_hthread *thr) {
 return duk__error_getter_helper(thr, (-1));
}

static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_filename_getter(duk_hthread *thr) {
 return duk__error_getter_helper(thr, 0);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_linenumber_getter(duk_hthread *thr) {
 return duk__error_getter_helper(thr, 1);
}
static duk_ret_t duk__error_setter_helper(duk_hthread *thr, duk_small_uint_t stridx_key) {







 do { } while (0);

 duk_push_this(thr);
 duk_push_hstring_stridx(thr, stridx_key);
 duk_dup_0(thr);



 do { } while (0)
                                                                                         ;

 duk_def_prop(thr, -3, (1U << 6) |
                       (1U << 3) | (1U << 0) |
                       (1U << 4) |
                       (1U << 5) | (1U << 2));
 return 0;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_stack_setter(duk_hthread *thr) {
 return duk__error_setter_helper(thr, 88);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_filename_setter(duk_hthread *thr) {
 return duk__error_setter_helper(thr, 93);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_linenumber_setter(duk_hthread *thr) {
 return duk__error_setter_helper(thr, 90);
}







static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype(duk_hthread *thr) {

 do { (void) (thr); } while (0);
 return 0;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_function_constructor(duk_hthread *thr) {
 duk_hstring *h_sourcecode={0};
 duk_idx_t nargs={0};
 duk_idx_t i={0};
 duk_small_uint_t comp_flags={0};
 duk_hcompfunc *func={0};
 duk_hobject *outer_lex_env={0};
 duk_hobject *outer_var_env={0};



 nargs = duk_get_top(thr);
 for (i = 0; i < nargs; i++) {
  duk_to_string(thr, i);
 }

 if (nargs == 0) {
  duk_push_hstring_empty(thr);
  duk_push_hstring_empty(thr);
 } else if (nargs == 1) {

  duk_push_hstring_empty(thr);
 } else {
  duk_insert(thr, 0);
  duk_push_literal_raw((thr), (","), sizeof((",")) - 1U);
  duk_insert(thr, 1);
  duk_join(thr, nargs - 1);
 }



 do { } while (0);




 duk_push_literal_raw((thr), ("function("), sizeof(("function(")) - 1U);
 duk_dup_1(thr);
 duk_push_literal_raw((thr), ("){"), sizeof(("){")) - 1U);
 duk_dup_0(thr);
 duk_push_literal_raw((thr), ("\n}"), sizeof(("\n}")) - 1U);
 duk_concat(thr, 5);



 do { } while (0);


 comp_flags = (1U << 12);

 duk_push_hstring_stridx(thr, 106);
 h_sourcecode = duk_require_hstring(thr, -2);
 duk_js_compile(thr,
                (const duk_uint8_t *) ((const duk_uint8_t *) ((h_sourcecode) + 1)),
                (duk_size_t) ((h_sourcecode)->blen),
                comp_flags);


 duk_push_literal_raw((thr), ("anonymous"), sizeof(("anonymous")) - 1U);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (92)) << 8) + (duk_uint_t) (((1U << 2)))));

 func = (duk_hcompfunc *) duk_known_hobject(thr, -1);
 do { } while (0);
 do { } while (0);







 outer_lex_env = thr->builtins[1];
 outer_var_env = thr->builtins[1];

 duk_js_push_closure(thr, func, outer_var_env, outer_lex_env, 1 );



 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype_to_string(duk_hthread *thr) {
 duk_tval *tv={0};
 duk_push_this(thr);
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
 do { } while (0);

 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
  duk_hobject *obj = ((duk_hobject *) (tv)->vp[0]);
  const char *func_name={0};
  (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (92))));
  if (duk_is_undefined(thr, -1)) {
   func_name = "";
  } else {
   func_name = duk_to_string(thr, -1);
   do { } while (0);
  }

  if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
   duk_push_sprintf(thr, "function %s() { [ecmascript code] }", (const char *) func_name);
  } else if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
   duk_push_sprintf(thr, "function %s() { [native code] }", (const char *) func_name);
  } else if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {
   duk_push_sprintf(thr, "function %s() { [bound code] }", (const char *) func_name);
  } else {
   goto type_error;
  }
 } else if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff7UL)) {
  duk_push_lightfunc_tostring(thr, tv);
 } else {
  goto type_error;
 }

 return 1;

 type_error:
 do { do { duk_err_type_invalid_args(((thr)), "duk_bi_function.c", (duk_int_t) 162); } while (0); return 0; } while (0);
}





static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype_call(duk_hthread *thr) {



 do { (void) (thr); } while (0);
 return (-6);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype_apply(duk_hthread *thr) {

 do { (void) (thr); } while (0);
 return (-6);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_apply(duk_hthread *thr) {

 do { (void) (thr); } while (0);
 return (-6);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_construct(duk_hthread *thr) {

 do { (void) (thr); } while (0);
 return (-6);
}







static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype_bind(duk_hthread *thr) {
 duk_hboundfunc *h_bound={0};
 duk_idx_t nargs={0};
 duk_idx_t bound_nargs={0};
 duk_int_t bound_len={0};
 duk_tval *tv_prevbound={0};
 duk_idx_t n_prevbound={0};
 duk_tval *tv_res={0};
 duk_tval *tv_tmp={0};






 nargs = duk_get_top(thr) - 1;
 if (nargs < 0) {
  nargs++;
  duk_push_undefined(thr);
 }
 do { } while (0);




 if (nargs > (duk_idx_t) 0x20000000UL) {
  do { do { do { duk_err_range((((thr))), "duk_bi_function.c", (duk_int_t) 227, ("invalid count")); } while (0); } while (0); return 0; } while (0);
 }

 duk_push_this(thr);
 duk_require_function((thr), (-1));


 do { } while (0);


 h_bound = duk_push_hboundfunc(thr);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 tv_prevbound = ((void *)0);
 n_prevbound = 0;
 tv_tmp = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (0));
 do { *(&h_bound->this_binding) = *(tv_tmp); } while (0);
 tv_tmp = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-2));
 do { *(&h_bound->target) = *(tv_tmp); } while (0);

 if ((((duk_small_uint_t) ((tv_tmp))->us[3]) == 0xfff9UL)) {
  duk_hobject *h_target={0};
  duk_hobject *bound_proto={0};

  h_target = ((duk_hobject *) (tv_tmp)->vp[0]);
  do { } while (0);





  bound_proto = ((h_target)->prototype);
  do { duk_hthread *duk__thr = (thr); duk_hobject *duk__obj = ((duk_hobject *) h_bound); duk_hobject *duk__proto = (bound_proto); do { (void) (duk__thr); } while (0); do { } while (0); do { (duk__obj)->prototype = (duk__proto); } while (0); do { if ((duk__proto) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk__proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0); } while (0);







  if ((((&(h_target)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)) {
   do { do { } while (0); (&((duk_hobject *) h_bound)->hdr)->h_flags |= ((1UL << (7 + (9)))); } while (0);
  }

  if ((((&(h_target)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {
   duk_hboundfunc *h_boundtarget={0};

   h_boundtarget = (duk_hboundfunc *) (void *) h_target;




   do { } while (0)


                                                                                       ;

   do { *(&h_bound->target) = *(&h_boundtarget->target); } while (0);
   do { *(&h_bound->this_binding) = *(&h_boundtarget->this_binding); } while (0);

   tv_prevbound = h_boundtarget->args;
   n_prevbound = h_boundtarget->nargs;
  }
 } else {

  duk_hobject *bound_proto={0};

  do { } while (0);
  do { do { } while (0); (&((duk_hobject *) h_bound)->hdr)->h_flags |= ((1UL << (7 + (9)))); } while (0);
  bound_proto = thr->builtins[5];
  do { duk_hthread *duk__thr = (thr); duk_hobject *duk__obj = ((duk_hobject *) h_bound); duk_hobject *duk__proto = (bound_proto); do { (void) (duk__thr); } while (0); do { } while (0); do { (duk__obj)->prototype = (duk__proto); } while (0); do { if ((duk__proto) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk__proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0); } while (0);
 }

 do { duk_tval *duk__tv = ((&h_bound->target)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 do { duk_tval *duk__tv = ((&h_bound->this_binding)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);

 bound_nargs = n_prevbound + nargs;
 if (bound_nargs > (duk_idx_t) 0x20000000UL) {
  do { do { do { duk_err_range((((thr))), "duk_bi_function.c", (duk_int_t) 316, ("invalid count")); } while (0); } while (0); return 0; } while (0);
 }
 tv_res = (duk_tval *) duk_heap_mem_alloc_checked((thr), (((duk_size_t) bound_nargs) * sizeof(duk_tval)));
 do { } while (0);
 do { } while (0);
 do { } while (0);
 h_bound->args = tv_res;
 h_bound->nargs = bound_nargs;

 do { } while (0);
 duk_copy_tvals_incref(thr, tv_res, tv_prevbound, (duk_size_t) n_prevbound);
 do { } while (0);
 duk_copy_tvals_incref(thr, tv_res + n_prevbound, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (1)), (duk_size_t) nargs);






 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (86))));
 bound_len = duk_get_int(thr, -1);
 if (bound_len < nargs) {
  bound_len = 0;
 } else {
  bound_len -= nargs;
 }
 if (sizeof(duk_int_t) > 4 && bound_len > (duk_int_t) 0xffffffffUL) {
  bound_len = (duk_int_t) 0xffffffffUL;
 }
 duk_pop(thr);
 do { } while (0);
 tv_tmp = thr->valstack_top++;
 do { } while (0);
 do { } while (0);
 do { duk_double_t duk__dblval; duk__dblval = ((duk_double_t) ((duk_uint32_t) bound_len)); ; do { (((tv_tmp)))->d = (duk__dblval); } while (0); } while (0);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (86)) << 8) + (duk_uint_t) (((1U << 2)))));



 duk_xdef_prop_stridx_thrower(thr, -1, 69);
 duk_xdef_prop_stridx_thrower(thr, -1, 67);


 duk_push_literal_raw((thr), ("bound "), sizeof(("bound ")) - 1U);
 duk_get_prop_stridx(thr, -3, 92);
 if (!duk_is_string_notsymbol(thr, -1)) {




  duk_pop(thr);
  duk_push_hstring_empty(thr);
 }
 duk_concat(thr, 2);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (92)) << 8) + (duk_uint_t) (((1U << 2)))));

 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (93))));
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (93)) << 8) + (duk_uint_t) (((1U << 2)))));


 do { } while (0);

 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_native_function_length(duk_hthread *thr) {
 duk_tval *tv={0};
 duk_hnatfunc *h={0};
 duk_int16_t func_nargs={0};

 tv = duk_get_borrowed_this_tval(thr);
 do { } while (0);

 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
  h = (duk_hnatfunc *) ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);
  if (!(((&((duk_hobject *) h)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
   goto fail_type;
  }
  func_nargs = h->nargs;
  duk_push_int(thr, func_nargs == ((duk_int16_t) -1) ? 0 : func_nargs);
 } else if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff7UL)) {
  duk_small_uint_t lf_flags={0};
  duk_small_uint_t lf_len={0};

  lf_flags = (((duk_small_uint_t) (tv)->ui[1]) & 0xffffUL);
  lf_len = (((lf_flags) >> 4) & 0x0fU);
  duk_push_uint(thr, lf_len);
 } else {
  goto fail_type;
 }
 return 1;

 fail_type:
 do { do { duk_err_type_invalid_args(((thr)), "duk_bi_function.c", (duk_int_t) 412); } while (0); return 0; } while (0);
}


static __attribute__ ((unused)) duk_ret_t duk_bi_native_function_name(duk_hthread *thr) {
 duk_tval *tv={0};
 duk_hnatfunc *h={0};

 tv = duk_get_borrowed_this_tval(thr);
 do { } while (0);

 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
  h = (duk_hnatfunc *) ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);
  if (!(((&((duk_hobject *) h)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
   goto fail_type;
  }



  duk_push_hstring_empty(thr);
 } else if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff7UL)) {
  duk_push_lightfunc_name(thr, tv);
 } else {
  goto fail_type;
 }
 return 1;

 fail_type:
 do { do { duk_err_type_invalid_args(((thr)), "duk_bi_function.c", (duk_int_t) 441); } while (0); return 0; } while (0);
}
static const duk_uint8_t duk__encode_uriunescaped_table[16] = {
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((1) << 1) | ((0) << 2) | ((1) << 3) | ((1) << 4) | ((0) << 5) | ((1) << 6) | ((1) << 7) )), ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )),
 ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )), ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((0) << 4) | ((1) << 5) | ((0) << 6) | ((1) << 7) )),
 ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )), ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )),
 ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )), ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((1) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )), ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )),
 ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )), ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((1) << 6) | ((0) << 7) )),
};


static const duk_uint8_t duk__encode_uricomponent_unescaped_table[16] = {
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((1) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((1) << 7) )), ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((0) << 3) | ((0) << 4) | ((1) << 5) | ((1) << 6) | ((0) << 7) )),
 ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )), ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )), ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )),
 ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )), ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((1) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )), ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )),
 ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )), ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((1) << 6) | ((0) << 7) )),
};


static const duk_uint8_t duk__decode_uri_reserved_table[16] = {
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((1) << 3) | ((1) << 4) | ((0) << 5) | ((1) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((1) << 3) | ((1) << 4) | ((0) << 5) | ((0) << 6) | ((1) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((1) << 2) | ((1) << 3) | ((0) << 4) | ((1) << 5) | ((0) << 6) | ((1) << 7) )),
 ((duk_uint8_t) ( ((1) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
};


static const duk_uint8_t duk__decode_uri_component_reserved_table[16] = {
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
};



static const duk_uint8_t duk__escape_unescaped_table[16] = {
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )), ((duk_uint8_t) ( ((0) << 0) | ((0) << 1) | ((1) << 2) | ((1) << 3) | ((0) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )),
 ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )), ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) )),
 ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )), ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )),
 ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )), ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((1) << 7) )),
 ((duk_uint8_t) ( ((0) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )), ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )),
 ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7) )), ((duk_uint8_t) ( ((1) << 0) | ((1) << 1) | ((1) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7) ))
};


typedef struct {
 duk_hthread *thr;
 duk_hstring *h_str;
 duk_bufwriter_ctx bw;
 const duk_uint8_t *p;
 const duk_uint8_t *p_start;
 const duk_uint8_t *p_end;
} duk__transform_context;

typedef void (*duk__transform_callback)(duk__transform_context *tfm_ctx, const void *udata, duk_codepoint_t cp);


static duk_small_int_t duk__decode_hex_escape(const duk_uint8_t *p, duk_small_int_t n) {
 duk_small_int_t ch={0};
 duk_small_int_t t = 0;

 while (n > 0) {
  t = t * 16;
  ch = (duk_small_int_t) duk_hex_dectab[*p++];
  if (__builtin_expect((ch >= 0), 1)) {
   t += ch;
  } else {
   return -1;
  }
  n--;
 }
 return t;
}

static int duk__transform_helper(duk_hthread *thr, duk__transform_callback callback, const void *udata) {
 duk__transform_context tfm_ctx_alloc={0};
 duk__transform_context *tfm_ctx = &tfm_ctx_alloc;
 duk_codepoint_t cp={0};

 tfm_ctx->thr = thr;

 tfm_ctx->h_str = duk_to_hstring(thr, 0);
 do { } while (0);

 do { duk_bw_init_pushbuf((thr), (&tfm_ctx->bw), (((tfm_ctx->h_str)->blen))); } while (0);

 tfm_ctx->p_start = ((const duk_uint8_t *) ((tfm_ctx->h_str) + 1));
 tfm_ctx->p_end = tfm_ctx->p_start + ((tfm_ctx->h_str)->blen);
 tfm_ctx->p = tfm_ctx->p_start;

 while (tfm_ctx->p < tfm_ctx->p_end) {
  cp = (duk_codepoint_t) duk_unicode_decode_xutf8_checked(thr, &tfm_ctx->p, tfm_ctx->p_start, tfm_ctx->p_end);
  callback(tfm_ctx, udata, cp);
 }

 do { duk_bw_compact((thr), (&tfm_ctx->bw)); } while (0);

 (void) duk_buffer_to_string(thr, -1);
 return 1;
}

static void duk__transform_callback_encode_uri(duk__transform_context *tfm_ctx, const void *udata, duk_codepoint_t cp) {
 duk_uint8_t xutf8_buf[7]={0};
 duk_small_int_t len={0};
 duk_codepoint_t cp1, cp2={0};
 duk_small_int_t i, t={0};
 const duk_uint8_t *unescaped_table = (const duk_uint8_t *) udata;





 do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (3 * 7); duk__space = (duk_size_t) ((&tfm_ctx->bw)->p_limit - (&tfm_ctx->bw)->p); if (duk__space < duk__sz) { (void) duk_bw_resize((tfm_ctx->thr), (&tfm_ctx->bw), duk__sz); } } while (0);

 if (cp < 0) {
  goto uri_error;
 } else if ((cp < 0x80L) && ((unescaped_table)[(cp) >> 3] & (1 << ((cp) & 0x07)))) {
  do { do { (((void) 0), ((void) 0)); } while (0); *(&tfm_ctx->bw)->p++ = (duk_uint8_t) ((duk_uint8_t) cp); } while (0);
  return;
 } else if (cp >= 0xdc00L && cp <= 0xdfffL) {
  goto uri_error;
 } else if (cp >= 0xd800L && cp <= 0xdbffL) {

  if (duk_unicode_decode_xutf8(tfm_ctx->thr, &tfm_ctx->p, tfm_ctx->p_start, tfm_ctx->p_end, (duk_ucodepoint_t *) &cp2) == 0) {
   goto uri_error;
  }
  if (!(cp2 >= 0xdc00L && cp2 <= 0xdfffL)) {
   goto uri_error;
  }
  cp1 = cp;
  cp = (duk_codepoint_t) (((cp1 - 0xd800L) << 10) + (cp2 - 0xdc00L) + 0x10000L);
 } else if (cp > 0x10ffffL) {






  goto uri_error;
 } else {




  ;
 }

 len = duk_unicode_encode_xutf8((duk_ucodepoint_t) cp, xutf8_buf);
 for (i = 0; i < len; i++) {
  t = (duk_small_int_t) xutf8_buf[i];
  do { duk_uint8_t *duk__p; do { (((void) 0), ((void) 0)); } while (0); duk__p = (&tfm_ctx->bw)->p; *duk__p++ = (duk_uint8_t) (0x25); *duk__p++ = (duk_uint8_t) ((duk_uint8_t) duk_uc_nybbles[t >> 4]); *duk__p++ = (duk_uint8_t) ((duk_uint8_t) duk_uc_nybbles[t & 0x0f]); (&tfm_ctx->bw)->p = duk__p; } while (0)



                                                                             ;
 }

 return;

 uri_error:
 do { do { duk_errcode_t duk__err = (7); duk_int_t duk__line = (duk_int_t) 202; do { } while (0); do { } while (0); duk_err_handle_error(((tfm_ctx->thr)), "duk_bi_global.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid input"))); } while (0); } while (0);
 do { } while (0);
}

static void duk__transform_callback_decode_uri(duk__transform_context *tfm_ctx, const void *udata, duk_codepoint_t cp) {
 const duk_uint8_t *reserved_table = (const duk_uint8_t *) udata;
 duk_small_uint_t utf8_blen={0};
 duk_codepoint_t min_cp={0};
 duk_small_int_t t={0};
 duk_small_uint_t i={0};




 do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = ((7 >= 2 * 3 ? 7 : 3)); duk__space = (duk_size_t) ((&tfm_ctx->bw)->p_limit - (&tfm_ctx->bw)->p); if (duk__space < duk__sz) { (void) duk_bw_resize((tfm_ctx->thr), (&tfm_ctx->bw), duk__sz); } } while (0)


                                                                                ;

 if (cp == (duk_codepoint_t) '%') {
  const duk_uint8_t *p = tfm_ctx->p;
  duk_size_t left = (duk_size_t) (tfm_ctx->p_end - p);

  do { } while (0);

  if (left < 2) {
   goto uri_error;
  }

  t = duk__decode_hex_escape(p, 2);
  do { } while (0);
  if (t < 0) {
   goto uri_error;
  }

  if (t < 0x80) {
   if (((reserved_table)[(t) >> 3] & (1 << ((t) & 0x07)))) {

    do { } while (0);
    do { duk_uint8_t *duk__p; do { (((void) 0), ((void) 0)); } while (0); duk__p = (&tfm_ctx->bw)->p; *duk__p++ = (duk_uint8_t) (0x25); *duk__p++ = (duk_uint8_t) (p[0]); *duk__p++ = (duk_uint8_t) (p[1]); (&tfm_ctx->bw)->p = duk__p; } while (0)



                               ;
   } else {
    do { do { (((void) 0), ((void) 0)); } while (0); *(&tfm_ctx->bw)->p++ = (duk_uint8_t) ((duk_uint8_t) t); } while (0);
   }
   tfm_ctx->p += 2;
   return;
  }
  do { } while (0);
  if (t < 0xc0) {

   goto uri_error;
  } else if (t < 0xe0) {

   utf8_blen = 2;
   min_cp = 0x80L;
   cp = t & 0x1f;
  } else if (t < 0xf0) {

   utf8_blen = 3;
   min_cp = 0x800L;
   cp = t & 0x0f;
  } else if (t < 0xf8) {

   utf8_blen = 4;
   min_cp = 0x10000L;
   cp = t & 0x07;
  } else {

   goto uri_error;
  }

  if (left < utf8_blen * 3 - 1) {

   goto uri_error;
  }

  p += 3;
  for (i = 1; i < utf8_blen; i++) {

   t = duk__decode_hex_escape(p, 2);
   do { } while (0)
                                                                                  ;
   if (t < 0) {
    goto uri_error;
   }
   if ((t & 0xc0) != 0x80) {
    goto uri_error;
   }
   cp = (cp << 6) + (t & 0x3f);
   p += 3;
  }
  p--;
  tfm_ctx->p = p;

  do { } while (0);

  if (cp < min_cp || cp > 0x10ffffL || (cp >= 0xd800L && cp <= 0xdfffL)) {
   goto uri_error;
  }
  do { } while (0);

  if (cp >= 0x10000L) {
   cp -= 0x10000L;
   do { } while (0);

   do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) (((cp >> 10) + 0xd800L)); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, (&tfm_ctx->bw)->p); (&tfm_ctx->bw)->p += duk__enc_len; } while (0);
   do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) (((cp & 0x03ffL) + 0xdc00L)); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, (&tfm_ctx->bw)->p); (&tfm_ctx->bw)->p += duk__enc_len; } while (0);
  } else {
   do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) (cp); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, (&tfm_ctx->bw)->p); (&tfm_ctx->bw)->p += duk__enc_len; } while (0);
  }
 } else {
  do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) (cp); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, (&tfm_ctx->bw)->p); (&tfm_ctx->bw)->p += duk__enc_len; } while (0);
 }
 return;

 uri_error:
 do { do { duk_errcode_t duk__err = (7); duk_int_t duk__line = (duk_int_t) 341; do { } while (0); do { } while (0); duk_err_handle_error(((tfm_ctx->thr)), "duk_bi_global.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid input"))); } while (0); } while (0);
 do { } while (0);
}


static void duk__transform_callback_escape(duk__transform_context *tfm_ctx, const void *udata, duk_codepoint_t cp) {
 do { (void) (udata); } while (0);

 do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (6); duk__space = (duk_size_t) ((&tfm_ctx->bw)->p_limit - (&tfm_ctx->bw)->p); if (duk__space < duk__sz) { (void) duk_bw_resize((tfm_ctx->thr), (&tfm_ctx->bw), duk__sz); } } while (0);

 if (cp < 0) {
  goto esc_error;
 } else if ((cp < 0x80L) && ((duk__escape_unescaped_table)[(cp) >> 3] & (1 << ((cp) & 0x07)))) {
  do { do { (((void) 0), ((void) 0)); } while (0); *(&tfm_ctx->bw)->p++ = (duk_uint8_t) ((duk_uint8_t) cp); } while (0);
 } else if (cp < 0x100L) {
  do { duk_uint8_t *duk__p; do { (((void) 0), ((void) 0)); } while (0); duk__p = (&tfm_ctx->bw)->p; *duk__p++ = (duk_uint8_t) ((duk_uint8_t) 0x25); *duk__p++ = (duk_uint8_t) ((duk_uint8_t) duk_uc_nybbles[cp >> 4]); *duk__p++ = (duk_uint8_t) ((duk_uint8_t) duk_uc_nybbles[cp & 0x0f]); (&tfm_ctx->bw)->p = duk__p; } while (0)



                                                                ;
 } else if (cp < 0x10000L) {
  do { duk_uint8_t *duk__p; do { (((void) 0), ((void) 0)); } while (0); duk__p = (&tfm_ctx->bw)->p; *duk__p++ = (duk_uint8_t) ((duk_uint8_t) 0x25); *duk__p++ = (duk_uint8_t) ((duk_uint8_t) 0x75); *duk__p++ = (duk_uint8_t) ((duk_uint8_t) duk_uc_nybbles[cp >> 12]); *duk__p++ = (duk_uint8_t) ((duk_uint8_t) duk_uc_nybbles[(cp >> 8) & 0x0f]); *duk__p++ = (duk_uint8_t) ((duk_uint8_t) duk_uc_nybbles[(cp >> 4) & 0x0f]); *duk__p++ = (duk_uint8_t) ((duk_uint8_t) duk_uc_nybbles[cp & 0x0f]); (&tfm_ctx->bw)->p = duk__p; } while (0)






                                                                ;
 } else {





  goto esc_error;
 }

 return;

 esc_error:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 382; do { } while (0); do { } while (0); duk_err_handle_error(((tfm_ctx->thr)), "duk_bi_global.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid input"))); } while (0); } while (0);
 do { } while (0);
}

static void duk__transform_callback_unescape(duk__transform_context *tfm_ctx, const void *udata, duk_codepoint_t cp) {
 duk_small_int_t t={0};

 do { (void) (udata); } while (0);

 if (cp == (duk_codepoint_t) '%') {
  const duk_uint8_t *p = tfm_ctx->p;
  duk_size_t left = (duk_size_t) (tfm_ctx->p_end - p);

  if (left >= 5 && p[0] == 'u' &&
      ((t = duk__decode_hex_escape(p + 1, 4)) >= 0)) {
   cp = (duk_codepoint_t) t;
   tfm_ctx->p += 5;
  } else if (left >= 2 &&
             ((t = duk__decode_hex_escape(p, 2)) >= 0)) {
   cp = (duk_codepoint_t) t;
   tfm_ctx->p += 2;
  }
 }

 do { do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (7); duk__space = (duk_size_t) (((&tfm_ctx->bw))->p_limit - ((&tfm_ctx->bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((tfm_ctx->thr)), ((&tfm_ctx->bw)), duk__sz); } } while (0); do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) ((cp)); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, ((&tfm_ctx->bw))->p); ((&tfm_ctx->bw))->p += duk__enc_len; } while (0); } while (0);
}
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_eval(duk_hthread *thr) {
 duk_hstring *h={0};
 duk_activation *act_caller={0};
 duk_activation *act_eval={0};
 duk_hcompfunc *func={0};
 duk_hobject *outer_lex_env={0};
 duk_hobject *outer_var_env={0};
 duk_bool_t this_to_global = 1;
 duk_small_uint_t comp_flags={0};
 duk_int_t level = -2;
 duk_small_uint_t call_flags={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0)
                                      ;
 h = duk_get_hstring_notsymbol(thr, 0);
 if (!h) {

  return 1;
 }
 comp_flags = (1U << 3);
 act_eval = thr->callstack_curr;
 do { } while (0);
 act_caller = duk_hthread_get_activation_for_level(thr, level);
 if (act_caller != ((void *)0)) {



  if ((act_caller->flags & (1U << 0)) &&
      (act_eval->flags & (1U << 4))) {



   comp_flags |= (1U << 5);
  }
 } else {
  do { } while (0);
 }

 duk_push_hstring_stridx(thr, 107);
 duk_js_compile(thr,
                (const duk_uint8_t *) ((const duk_uint8_t *) ((h) + 1)),
                (duk_size_t) ((h)->blen),
                comp_flags);
 func = (duk_hcompfunc *) duk_known_hobject(thr, -1);
 do { } while (0);





 if (act_eval->flags & (1U << 4)) {
  do { } while (0);
  do { } while (0);
  if (act_caller->lex_env == ((void *)0)) {
   do { } while (0);
   do { } while (0);


   duk_js_init_activation_environment_records_delayed(thr, act_caller);
  }
  do { } while (0);
  do { } while (0);

  this_to_global = 0;

  if ((((&((duk_hobject *) func)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)) {
   duk_hdecenv *new_env={0};
   duk_hobject *act_lex_env={0};

   do { } while (0)

                                                                 ;

   act_lex_env = act_caller->lex_env;

   new_env = duk_hdecenv_alloc(thr,
                               (1UL << (7 + (0))) |
                               (((duk_uint_t) (16)) << (7 + (20))));
   do { } while (0);
   duk_push_hobject(thr, (duk_hobject *) new_env);

   do { } while (0);
   do { ((duk_hobject *) new_env)->prototype = (act_lex_env); } while (0);
   do { if ((act_lex_env) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((act_lex_env)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);
   do { } while (0);

   outer_lex_env = (duk_hobject *) new_env;
   outer_var_env = (duk_hobject *) new_env;

   duk_insert(thr, 0);


   do { } while (0);
  } else {
   do { } while (0)

                                                                 ;

   outer_lex_env = act_caller->lex_env;
   outer_var_env = act_caller->var_env;


   do { } while (0);
  }
 } else {
  do { } while (0)
                                                                       ;

  this_to_global = 1;
  outer_lex_env = thr->builtins[1];
  outer_var_env = thr->builtins[1];
 }


 duk_js_push_closure(thr, func, outer_var_env, outer_lex_env, 0 );



 if (this_to_global) {
  do { } while (0);
  duk_push_hobject_bidx(thr, 0);
 } else {
  duk_tval *tv={0};
  do { } while (0);
  do { } while (0);
  tv = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + act_caller->bottom_byteoff - sizeof(duk_tval));
  do { } while (0);
  duk_push_tval(thr, tv);
 }

 do { } while (0)


                                             ;



 call_flags = 0;
 if (act_eval->flags & (1U << 4)) {






  call_flags |= (1U << 4);
 }
 duk_handle_call_unprotected_nargs(thr, 0, call_flags);



 return 1;
}






static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_parse_int(duk_hthread *thr) {
 duk_int32_t radix={0};
 duk_small_uint_t s2n_flags={0};

 do { } while (0);
 duk_to_string(thr, 0);

 radix = duk_to_int32(thr, 1);




 s2n_flags = (1U << 0) |
             (1U << 2) |
             (1U << 3) |
             (1U << 4) |
             (1U << 10) |
             (1U << 11);
 if (radix != 0) {
  if (radix < 2 || radix > 36) {
   goto ret_nan;
  }
  if (radix != 16) {
   s2n_flags &= ~(1U << 11);
  }
 } else {
  radix = 10;
 }

 duk_dup_0(thr);
 duk_numconv_parse(thr, (duk_small_int_t) radix, s2n_flags);
 return 1;

 ret_nan:
 duk_push_nan(thr);
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_parse_float(duk_hthread *thr) {
 duk_small_uint_t s2n_flags={0};

 do { } while (0);
 duk_to_string(thr, 0);


 s2n_flags = (1U << 0) |
             (1U << 1) |
             (1U << 2) |
             (1U << 3) |
             (1U << 4) |
             (1U << 5) |
             (1U << 6) |
             (1U << 7) |
             (1U << 8) |
             (1U << 10);

 duk_numconv_parse(thr, 10 , s2n_flags);
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_is_nan(duk_hthread *thr) {
 duk_double_t d = duk_to_number(thr, 0);
 duk_push_boolean(thr, (duk_bool_t) (sizeof (d) == sizeof (float) ? __isnanf (d) : sizeof (d) == sizeof (double) ? __isnan (d) : __isnanl (d)));
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_is_finite(duk_hthread *thr) {
 duk_double_t d = duk_to_number(thr, 0);
 duk_push_boolean(thr, (duk_bool_t) (sizeof (d) == sizeof (float) ? __finitef (d) : sizeof (d) == sizeof (double) ? __finite (d) : __finitel (d)));
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_decode_uri(duk_hthread *thr) {
 return duk__transform_helper(thr, duk__transform_callback_decode_uri, (const void *) duk__decode_uri_reserved_table);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_decode_uri_component(duk_hthread *thr) {
 return duk__transform_helper(thr, duk__transform_callback_decode_uri, (const void *) duk__decode_uri_component_reserved_table);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_encode_uri(duk_hthread *thr) {
 return duk__transform_helper(thr, duk__transform_callback_encode_uri, (const void *) duk__encode_uriunescaped_table);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_encode_uri_component(duk_hthread *thr) {
 return duk__transform_helper(thr, duk__transform_callback_encode_uri, (const void *) duk__encode_uricomponent_unescaped_table);
}


static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_escape(duk_hthread *thr) {
 return duk__transform_helper(thr, duk__transform_callback_escape, (const void *) ((void *)0));
}

static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_unescape(duk_hthread *thr) {
 return duk__transform_helper(thr, duk__transform_callback_unescape, (const void *) ((void *)0));
}
static void duk__dec_syntax_error(duk_json_dec_ctx *js_ctx);
static void duk__dec_eat_white(duk_json_dec_ctx *js_ctx);

static duk_uint8_t duk__dec_peek(duk_json_dec_ctx *js_ctx);

static duk_uint8_t duk__dec_get(duk_json_dec_ctx *js_ctx);
static duk_uint8_t duk__dec_get_nonwhite(duk_json_dec_ctx *js_ctx);
static duk_uint_fast32_t duk__dec_decode_hex_escape(duk_json_dec_ctx *js_ctx, duk_small_uint_t n);
static void duk__dec_req_stridx(duk_json_dec_ctx *js_ctx, duk_small_uint_t stridx);
static void duk__dec_string(duk_json_dec_ctx *js_ctx);

static void duk__dec_plain_string(duk_json_dec_ctx *js_ctx);
static void duk__dec_pointer(duk_json_dec_ctx *js_ctx);
static void duk__dec_buffer(duk_json_dec_ctx *js_ctx);

static void duk__dec_number(duk_json_dec_ctx *js_ctx);
static void duk__dec_objarr_entry(duk_json_dec_ctx *js_ctx);
static void duk__dec_objarr_exit(duk_json_dec_ctx *js_ctx);
static void duk__dec_object(duk_json_dec_ctx *js_ctx);
static void duk__dec_array(duk_json_dec_ctx *js_ctx);
static void duk__dec_value(duk_json_dec_ctx *js_ctx);
static void duk__dec_reviver_walk(duk_json_dec_ctx *js_ctx);

static void duk__emit_1(duk_json_enc_ctx *js_ctx, duk_uint_fast8_t ch);
static void duk__emit_2(duk_json_enc_ctx *js_ctx, duk_uint_fast8_t ch1, duk_uint_fast8_t ch2);
static void duk__unemit_1(duk_json_enc_ctx *js_ctx);
static void duk__emit_hstring(duk_json_enc_ctx *js_ctx, duk_hstring *h);



static void duk__emit_stridx(duk_json_enc_ctx *js_ctx, duk_small_uint_t stridx);
static duk_uint8_t *duk__emit_esc_auto_fast(duk_json_enc_ctx *js_ctx, duk_uint_fast32_t cp, duk_uint8_t *q);
static void duk__enc_key_autoquote(duk_json_enc_ctx *js_ctx, duk_hstring *k);
static void duk__enc_quote_string(duk_json_enc_ctx *js_ctx, duk_hstring *h_str);
static void duk__enc_objarr_entry(duk_json_enc_ctx *js_ctx, duk_idx_t *entry_top);
static void duk__enc_objarr_exit(duk_json_enc_ctx *js_ctx, duk_idx_t *entry_top);
static void duk__enc_object(duk_json_enc_ctx *js_ctx);
static void duk__enc_array(duk_json_enc_ctx *js_ctx);
static duk_bool_t duk__enc_value(duk_json_enc_ctx *js_ctx, duk_idx_t idx_holder);
static duk_bool_t duk__enc_allow_into_proplist(duk_tval *tv);
static void duk__enc_double(duk_json_enc_ctx *js_ctx);




static void duk__enc_buffer_jx_jc(duk_json_enc_ctx *js_ctx, duk_hbuffer *h);
static void duk__enc_pointer(duk_json_enc_ctx *js_ctx, void *ptr);

static void duk__enc_bufobj(duk_json_enc_ctx *js_ctx, duk_hbufobj *h_bufobj);





static void duk__enc_newline_indent(duk_json_enc_ctx *js_ctx, duk_uint_t depth);






static const duk_uint8_t duk__json_quotestr_lookup[256] = {






 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xe2, 0xf4, 0xee, 0x80, 0xe6, 0xf2, 0x80, 0x80,
 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
 0x20, 0x21, 0xa2, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0xdc, 0x5d, 0x5e, 0x5f,
 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x81,
 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81
};
static const duk_uint8_t duk__json_decstr_lookup[256] = {



 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x20, 0x21, 0x00, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x00, 0x5d, 0x5e, 0x5f,
 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
};



static const duk_uint8_t duk__json_eatwhite_lookup[256] = {



 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};



static const duk_uint8_t duk__json_decnumber_lookup[256] = {



 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00,
 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
static void duk__dec_syntax_error(duk_json_dec_ctx *js_ctx) {




 do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t)
 216
 ; do { } while (0); do { } while (0); duk_err_handle_error_fmt((js_ctx->thr),
 "duk_bi_json.c"
 , (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("invalid json (at offset %ld)"), ((long) (js_ctx->p - js_ctx->p_start))); } while (0)
                                                     ;
 do { } while (0);
}

static void duk__dec_eat_white(duk_json_dec_ctx *js_ctx) {
 const duk_uint8_t *p={0};
 duk_uint8_t t={0};

 p = js_ctx->p;
 for (;;) {
  do { } while (0);
  t = *p;





  do { } while (0);
  if (duk__json_eatwhite_lookup[t] == 0) {
   break;
  }
  p++;
 }
 js_ctx->p = p;
}


static duk_uint8_t duk__dec_peek(duk_json_dec_ctx *js_ctx) {
 do { } while (0);
 return *js_ctx->p;
}


static duk_uint8_t duk__dec_get(duk_json_dec_ctx *js_ctx) {
 do { } while (0);
 return *js_ctx->p++;
}

static duk_uint8_t duk__dec_get_nonwhite(duk_json_dec_ctx *js_ctx) {
 duk__dec_eat_white(js_ctx);
 return duk__dec_get(js_ctx);
}


static duk_uint_fast32_t duk__dec_decode_hex_escape(duk_json_dec_ctx *js_ctx, duk_small_uint_t n) {
 duk_small_uint_t i={0};
 duk_uint_fast32_t res = 0;
 duk_uint8_t x={0};
 duk_small_int_t t={0};

 for (i = 0; i < n; i++) {


  x = duk__dec_get(js_ctx);
  do { } while (0)
                                                                 ;


  do { } while (0);
  t = duk_hex_dectab[x & 0xff];
  if (__builtin_expect((t >= 0), 1)) {
   res = (res * 16) + (duk_uint_fast32_t) t;
  } else {

   goto syntax_error;
  }
 }

 do { } while (0);
 return res;

 syntax_error:
 duk__dec_syntax_error(js_ctx);
 do { __builtin_unreachable(); } while (0);
 return 0;
}

static void duk__dec_req_stridx(duk_json_dec_ctx *js_ctx, duk_small_uint_t stridx) {
 duk_hstring *h={0};
 const duk_uint8_t *p={0};
 duk_uint8_t x, y={0};






 do { } while (0);
 h = ((js_ctx->thr)->strs[(stridx)]);
 do { } while (0);

 p = (const duk_uint8_t *) ((const duk_uint8_t *) ((h) + 1)) + 1;
 do { } while (0);

 for (;;) {
  x = *p;
  if (x == 0) {
   break;
  }
  y = duk__dec_get(js_ctx);
  if (x != y) {

   goto syntax_error;
  }
  p++;
 }

 return;

 syntax_error:
 duk__dec_syntax_error(js_ctx);
 do { __builtin_unreachable(); } while (0);
}

static duk_small_int_t duk__dec_string_escape(duk_json_dec_ctx *js_ctx, duk_uint8_t **ext_p) {
 duk_uint_fast32_t cp={0};





 cp = (duk_uint_fast32_t) duk__dec_get(js_ctx);
 switch (cp) {
 case 0x5c: break;
 case 0x22: break;
 case 0x2f: break;
 case 0x74: cp = 0x09; break;
 case 0x6e: cp = 0x0a; break;
 case 0x72: cp = 0x0d; break;
 case 0x66: cp = 0x0c; break;
 case 0x62: cp = 0x08; break;
 case 0x75: {
  cp = duk__dec_decode_hex_escape(js_ctx, 4);
  break;
 }

 case 0x55: {
  if (js_ctx->flag_ext_custom) {
   cp = duk__dec_decode_hex_escape(js_ctx, 8);
  } else {
   return 1;
  }
  break;
 }
 case 0x78: {
  if (js_ctx->flag_ext_custom) {
   cp = duk__dec_decode_hex_escape(js_ctx, 2);
  } else {
   return 1;
  }
  break;
 }

 default:

  return 1;
 }

 do { duk_uint8_t *duk__ptr; duk_small_int_t duk__len; duk__ptr = (duk_uint8_t *) (*ext_p); duk__len = duk_unicode_encode_xutf8((duk_ucodepoint_t) (cp), duk__ptr); duk__ptr += duk__len; (*ext_p) = duk__ptr; } while (0);

 return 0;
}

static void duk__dec_string(duk_json_dec_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 duk_bufwriter_ctx bw_alloc={0};
 duk_bufwriter_ctx *bw={0};
 duk_uint8_t *q={0};
 bw = &bw_alloc;
 do { duk_bw_init_pushbuf((js_ctx->thr), (bw), (128)); } while (0);
 q = ((bw)->p);


 for (;;) {
  duk_small_uint_t safe={0};
  duk_uint8_t b, x={0};
  const duk_uint8_t *p={0};







  safe = 64;


  q = (((duk_size_t) ((bw)->p_limit - (q)) >= (safe + 7)) ? (q) : ((bw)->p = (q), duk_bw_resize((js_ctx->thr),(bw),(safe + 7))));

  p = js_ctx->p;
  for (;;) {
   if (safe == 0) {
    js_ctx->p = p;
    break;
   }
   safe--;


   do { } while (0);

   b = *p++;
   x = (duk_small_int_t) duk__json_decstr_lookup[b];
   if (__builtin_expect((x != 0), 1)) {

    *q++ = b;
   } else if (b == 0x22) {
    js_ctx->p = p;
    goto found_quote;
   } else if (b == 0x5c) {




    js_ctx->p = p;
    if (duk__dec_string_escape(js_ctx, &q) != 0) {
     goto syntax_error;
    }
    break;
   } else {
    js_ctx->p = p;
    goto syntax_error;
   }
  }
 }
 found_quote:
 do { (bw)->p = (q); duk_bw_compact((js_ctx->thr), (bw)); } while (0);
 (void) duk_buffer_to_string(thr, -1);



 return;

 syntax_error:
 duk__dec_syntax_error(js_ctx);
 do { __builtin_unreachable(); } while (0);
}





static void duk__dec_plain_string(duk_json_dec_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 const duk_uint8_t *p={0};
 duk_small_int_t x={0};



 js_ctx->p--;
 p = js_ctx->p;
 for (;;) {
  x = *p;







  if (!duk_unicode_is_identifier_part((duk_codepoint_t) x)) {
   break;
  }
  p++;
 }

 duk_push_lstring(thr, (const char *) js_ctx->p, (duk_size_t) (p - js_ctx->p));
 js_ctx->p = p;


}



static void duk__dec_pointer(duk_json_dec_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 const duk_uint8_t *p={0};
 duk_small_int_t x={0};
 void *voidptr={0};



 p = js_ctx->p;

 for (;;) {
  x = *p;





  if (x == 0x29) {
   break;
  } else if (x <= 0) {

   goto syntax_error;
  }
  p++;
 }
 voidptr = ((void *)0);
 (void) sscanf((const char *) js_ctx->p, "%p", &voidptr);
 duk_push_pointer(thr, voidptr);
 js_ctx->p = p + 1;



 return;

 syntax_error:
 duk__dec_syntax_error(js_ctx);
 do { __builtin_unreachable(); } while (0);
}



static void duk__dec_buffer(duk_json_dec_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 const duk_uint8_t *p={0};
 duk_uint8_t *buf={0};
 duk_size_t src_len={0};
 duk_small_int_t x={0};



 p = js_ctx->p;
 for (;;) {
  x = *p;




  if (x == 0x7c) {
   break;
  } else if (x <= 0) {

   goto syntax_error;
  }
  p++;
 }


 src_len = (duk_size_t) (p - js_ctx->p);
 buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, src_len);
 do { } while (0);
 do { void *duk__dst = ((void *) buf); const void *duk__src = ((const void *) js_ctx->p); duk_size_t duk__len = (src_len); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 duk_hex_decode(thr, -1);

 js_ctx->p = p + 1;



 return;

 syntax_error:
 duk__dec_syntax_error(js_ctx);
 do { __builtin_unreachable(); } while (0);
}



static void duk__dec_number(duk_json_dec_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 const duk_uint8_t *p_start={0};
 const duk_uint8_t *p={0};
 duk_uint8_t x={0};
 duk_small_uint_t s2n_flags={0};

 do { } while (0);

 p_start = js_ctx->p;





 p = js_ctx->p;
 for (;;) {
  x = *p;

  do { } while (0)

                                                               ;





  do { } while (0);
  if (duk__json_decnumber_lookup[x] == 0) {
   break;
  }
  p++;
 }
 js_ctx->p = p;

 do { } while (0);
 duk_push_lstring(thr, (const char *) p_start, (duk_size_t) (p - p_start));

 s2n_flags = (1U << 1) |
             (1U << 4) |
             (1U << 6);

 do { } while (0)
                                                          ;
 duk_numconv_parse(thr, 10 , s2n_flags);
 if (duk_is_nan(thr, -1)) {
  duk__dec_syntax_error(js_ctx);
 }
 do { } while (0);
 do { } while (0)
                                                          ;


}

static void duk__dec_objarr_entry(duk_json_dec_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 duk_require_stack(thr, 32);



 do { } while (0);
 do { } while (0);
 if (js_ctx->recursion_depth >= js_ctx->recursion_limit) {
  do { duk_err_range((thr), "duk_bi_json.c", (duk_int_t) 723, ("json decode recursion limit")); } while (0);
  do { } while (0);
 }
 js_ctx->recursion_depth++;
}

static void duk__dec_objarr_exit(duk_json_dec_ctx *js_ctx) {


 do { } while (0);
 do { } while (0);
 js_ctx->recursion_depth--;
}

static void duk__dec_object(duk_json_dec_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 duk_int_t key_count={0};
 duk_uint8_t x={0};

 do { } while (0);

 duk__dec_objarr_entry(js_ctx);

 duk_push_object(thr);



 key_count = 0;
 for (;;) {
  x = duk__dec_get_nonwhite(js_ctx);

  do { } while (0)

                                                   ;



  if (x == 0x2c && key_count > 0) {

   x = duk__dec_get_nonwhite(js_ctx);
  } else if (x == 0x7d) {

   break;
  } else if (key_count == 0) {



   ;
  } else {

   goto syntax_error;
  }



  if (x == 0x22) {
   duk__dec_string(js_ctx);

  } else if (js_ctx->flag_ext_custom &&
             duk_unicode_is_identifier_start((duk_codepoint_t) x)) {
   duk__dec_plain_string(js_ctx);

  } else {
   goto syntax_error;
  }



  x = duk__dec_get_nonwhite(js_ctx);
  if (x != 0x3a) {
   goto syntax_error;
  }

  duk__dec_value(js_ctx);



  duk_xdef_prop((thr), (-3), ((1U << 0) | (1U << 1) | (1U << 2)));



  key_count++;
 }



 do { } while (0)
                                                          ;

 duk__dec_objarr_exit(js_ctx);
 return;

 syntax_error:
 duk__dec_syntax_error(js_ctx);
 do { __builtin_unreachable(); } while (0);
}

static void duk__dec_array(duk_json_dec_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 duk_uarridx_t arr_idx={0};
 duk_uint8_t x={0};

 do { } while (0);

 duk__dec_objarr_entry(js_ctx);

 duk_push_array(thr);



 arr_idx = 0;
 for (;;) {
  x = duk__dec_get_nonwhite(js_ctx);

  do { } while (0)

                                                 ;



  if ((x == 0x2c) && (arr_idx != 0)) {

   ;
  } else if (x == 0x5d) {

   break;
  } else if (arr_idx == 0) {



   js_ctx->p--;
  } else {

   goto syntax_error;
  }



  duk__dec_value(js_ctx);



  duk_xdef_prop_index((thr), (-2), (arr_idx), ((1U << 0) | (1U << 1) | (1U << 2)));
  arr_idx++;
 }





 duk_set_length(thr, -1, arr_idx);



 do { } while (0)
                                                          ;

 duk__dec_objarr_exit(js_ctx);
 return;

 syntax_error:
 duk__dec_syntax_error(js_ctx);
 do { __builtin_unreachable(); } while (0);
}

static void duk__dec_value(duk_json_dec_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 duk_uint8_t x={0};

 x = duk__dec_get_nonwhite(js_ctx);

 do { } while (0);



 if (x == 0x22) {
  duk__dec_string(js_ctx);
 } else if ((x >= 0x30 && x <= 0x39) || (x == 0x2d)) {

  if (js_ctx->flag_ext_custom && x == 0x2d && duk__dec_peek(js_ctx) == 0x49) {
   duk__dec_req_stridx(js_ctx, 61);
   duk_push_number(thr, -((double) (__builtin_inff())));
  } else {




   js_ctx->p--;
   duk__dec_number(js_ctx);
  }
 } else if (x == 0x74) {
  duk__dec_req_stridx(js_ctx, 155);
  duk_push_true(thr);
 } else if (x == 0x66) {
  duk__dec_req_stridx(js_ctx, 156);
  duk_push_false(thr);
 } else if (x == 0x6e) {
  duk__dec_req_stridx(js_ctx, 154);
  duk_push_null(thr);

 } else if (js_ctx->flag_ext_custom && x == 0x75) {
  duk__dec_req_stridx(js_ctx, 58);
  duk_push_undefined(thr);
 } else if (js_ctx->flag_ext_custom && x == 0x4e) {
  duk__dec_req_stridx(js_ctx, 59);
  duk_push_nan(thr);
 } else if (js_ctx->flag_ext_custom && x == 0x49) {
  duk__dec_req_stridx(js_ctx, 60);
  duk_push_number(thr, ((double) (__builtin_inff())));
 } else if (js_ctx->flag_ext_custom && x == 0x28) {
  duk__dec_pointer(js_ctx);
 } else if (js_ctx->flag_ext_custom && x == 0x7c) {
  duk__dec_buffer(js_ctx);

 } else if (x == 0x7b) {
  duk__dec_object(js_ctx);
 } else if (x == 0x5b) {
  duk__dec_array(js_ctx);
 } else {

  goto syntax_error;
 }

 duk__dec_eat_white(js_ctx);


 return;

 syntax_error:
 duk__dec_syntax_error(js_ctx);
 do { __builtin_unreachable(); } while (0);
}





static void duk__dec_reviver_walk(duk_json_dec_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 duk_hobject *h={0};
 duk_uarridx_t i, arr_len={0};

 do { } while (0)


                                                          ;

 duk_dup_top(thr);
 duk_get_prop(thr, -3);

 h = duk_get_hobject(thr, -1);
 if (h != ((void *)0)) {
  if ((((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 2) {
   arr_len = (duk_uarridx_t) duk_get_length(thr, -1);
   for (i = 0; i < arr_len; i++) {


    do { } while (0)


                                                             ;

    duk_dup_top(thr);
    (void) duk_push_uint_to_hstring(thr, (duk_uint_t) i);
    duk__dec_reviver_walk(js_ctx);

    if (duk_is_undefined(thr, -1)) {
     duk_pop(thr);
     duk_del_prop_index(thr, -1, i);
    } else {




     duk_put_prop_index(thr, -2, i);
    }
   }
  } else {

   duk_enum(thr, -1, (1U << 4) );
   while (duk_next(thr, -1 , 0 )) {
    do { } while (0)


                                                                                                 ;


    duk_dup_m3(thr);
    duk_dup_m2(thr);


    duk__dec_reviver_walk(js_ctx);


    if (duk_is_undefined(thr, -1)) {
     duk_pop(thr);
     duk_del_prop(thr, -3);
    } else {
     duk_put_prop(thr, -4);
    }
   }
   duk_pop(thr);
  }
 }



 duk_dup(thr, js_ctx->idx_reviver);
 duk_insert(thr, -4);
 duk_call_method(thr, 2);

 do { } while (0)
                                                                                   ;
}
static void duk__emit_1(duk_json_enc_ctx *js_ctx, duk_uint_fast8_t ch) {
 do { do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (1); duk__space = (duk_size_t) (((&js_ctx->bw))->p_limit - ((&js_ctx->bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((js_ctx->thr)), ((&js_ctx->bw)), duk__sz); } } while (0); do { do { (((void) 0), ((void) 0)); } while (0); *((&js_ctx->bw))->p++ = (duk_uint8_t) ((ch)); } while (0); } while (0);
}

static void duk__emit_2(duk_json_enc_ctx *js_ctx, duk_uint_fast8_t ch1, duk_uint_fast8_t ch2) {
 do { do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (2); duk__space = (duk_size_t) (((&js_ctx->bw))->p_limit - ((&js_ctx->bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((js_ctx->thr)), ((&js_ctx->bw)), duk__sz); } } while (0); do { duk_uint8_t *duk__p; do { (((void) 0), ((void) 0)); } while (0); duk__p = ((&js_ctx->bw))->p; *duk__p++ = (duk_uint8_t) ((ch1)); *duk__p++ = (duk_uint8_t) ((ch2)); ((&js_ctx->bw))->p = duk__p; } while (0); } while (0);
}

static void duk__emit_hstring(duk_json_enc_ctx *js_ctx, duk_hstring *h) {
 do { duk_size_t duk__val_len; duk__val_len = (((h))->blen); do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (duk__val_len); duk__space = (duk_size_t) (((&js_ctx->bw))->p_limit - ((&js_ctx->bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((js_ctx->thr)), ((&js_ctx->bw)), duk__sz); } } while (0); do { void *duk__dst = ((void *) ((&js_ctx->bw)->p)); const void *duk__src = ((const void *) ((const duk_uint8_t *) (((h)) + 1))); duk_size_t duk__len = (duk__val_len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0); (&js_ctx->bw)->p += duk__val_len; } while (0);
}


static void duk__emit_cstring(duk_json_enc_ctx *js_ctx, const char *str) {
 do { const duk_uint8_t *duk__val; duk_size_t duk__val_len; duk__val = (const duk_uint8_t *) (str); duk__val_len = strlen((const char *) duk__val); do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (duk__val_len); duk__space = (duk_size_t) (((&js_ctx->bw))->p_limit - ((&js_ctx->bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((js_ctx->thr)), ((&js_ctx->bw)), duk__sz); } } while (0); do { void *duk__dst = ((void *) ((&js_ctx->bw)->p)); const void *duk__src = ((const void *) duk__val); duk_size_t duk__len = (duk__val_len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0); (&js_ctx->bw)->p += duk__val_len; } while (0);
}


static void duk__emit_stridx(duk_json_enc_ctx *js_ctx, duk_small_uint_t stridx) {
 duk_hstring *h={0};

 do { } while (0);
 h = ((js_ctx->thr)->strs[(stridx)]);
 do { } while (0);

 do { duk_size_t duk__val_len; duk__val_len = (((h))->blen); do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (duk__val_len); duk__space = (duk_size_t) (((&js_ctx->bw))->p_limit - ((&js_ctx->bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((js_ctx->thr)), ((&js_ctx->bw)), duk__sz); } } while (0); do { void *duk__dst = ((void *) ((&js_ctx->bw)->p)); const void *duk__src = ((const void *) ((const duk_uint8_t *) (((h)) + 1))); duk_size_t duk__len = (duk__val_len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0); (&js_ctx->bw)->p += duk__val_len; } while (0);
}

static void duk__unemit_1(duk_json_enc_ctx *js_ctx) {
 do { } while (0);
 do { (&js_ctx->bw)->p += (-1); } while (0);
}






static duk_uint8_t *duk__emit_esc_auto_fast(duk_json_enc_ctx *js_ctx, duk_uint_fast32_t cp, duk_uint8_t *q) {
 duk_uint_fast32_t tmp={0};
 duk_small_uint_t dig={0};

 do { (void) (js_ctx); } while (0);
 if (__builtin_expect((cp < 0x100UL), 1)) {
  if (__builtin_expect((js_ctx->flag_ext_custom != 0U), 0)) {
   tmp = (((duk_uint_fast32_t) (2)) << 16) | (((duk_uint_fast32_t) (0x5c)) << 8) | ((duk_uint_fast32_t) (0x78));
  } else {
   tmp = (((duk_uint_fast32_t) (4)) << 16) | (((duk_uint_fast32_t) (0x5c)) << 8) | ((duk_uint_fast32_t) (0x75));
  }
 } else

 if (__builtin_expect((cp < 0x10000UL), 1)) {
  tmp = (((duk_uint_fast32_t) (4)) << 16) | (((duk_uint_fast32_t) (0x5c)) << 8) | ((duk_uint_fast32_t) (0x75));
 } else {

  if (__builtin_expect((js_ctx->flag_ext_custom != 0U), 1)) {
   tmp = (((duk_uint_fast32_t) (8)) << 16) | (((duk_uint_fast32_t) (0x5c)) << 8) | ((duk_uint_fast32_t) (0x55));
  } else

  {





   tmp = (((duk_uint_fast32_t) (8)) << 16) | (((duk_uint_fast32_t) (0x55)) << 8) | ((duk_uint_fast32_t) (0x2b));
  }
 }

 *q++ = (duk_uint8_t) ((tmp >> 8) & 0xff);
 *q++ = (duk_uint8_t) (tmp & 0xff);

 tmp = tmp >> 16;
 while (tmp > 0) {
  tmp--;
  dig = (duk_small_uint_t) ((cp >> (4 * tmp)) & 0x0f);
  *q++ = duk_lc_digits[dig];
 }

 return q;
}

static void duk__enc_key_autoquote(duk_json_enc_ctx *js_ctx, duk_hstring *k) {
 const duk_int8_t *p, *p_start, *p_end={0};
 duk_size_t k_len={0};
 duk_codepoint_t cp={0};

 do { } while (0);
 if (js_ctx->flag_avoid_key_quotes) {
  k_len = ((k)->blen);
  p_start = (const duk_int8_t *) ((const duk_uint8_t *) ((k) + 1));
  p_end = p_start + k_len;
  p = p_start;

  if (p == p_end) {

   goto quote_normally;
  }
  cp = (duk_codepoint_t) (*p++);
  if (__builtin_expect((!duk_unicode_is_identifier_start(cp)), 0)) {
   goto quote_normally;
  }
  while (p < p_end) {
   cp = (duk_codepoint_t) (*p++);
   if (__builtin_expect((!duk_unicode_is_identifier_part(cp)), 0)) {
    goto quote_normally;
   }
  }




  duk__emit_hstring((js_ctx), (k));
  return;
 }

 quote_normally:
 duk__enc_quote_string(js_ctx, k);
}






static void duk__enc_quote_string(duk_json_enc_ctx *js_ctx, duk_hstring *h_str) {
 duk_hthread *thr = js_ctx->thr;
 const duk_uint8_t *p, *p_start, *p_end, *p_now, *p_tmp={0};
 duk_uint8_t *q={0};
 duk_ucodepoint_t cp={0};

 do { } while (0);

 do { } while (0);
 p_start = ((const duk_uint8_t *) ((h_str) + 1));
 p_end = p_start + ((h_str)->blen);
 p = p_start;

 duk__emit_1((js_ctx), (duk_uint_fast8_t) (0x22));





 while (p < p_end) {
  duk_size_t left, now, space={0};

  left = (duk_size_t) (p_end - p);
  now = (left > 64 ?
         64 : left);






  space = now * 6;
  q = (((duk_size_t) (((&js_ctx->bw))->p_limit - ((&js_ctx->bw)->p)) >= ((space))) ? ((&js_ctx->bw)->p) : (((&js_ctx->bw))->p = ((&js_ctx->bw)->p), duk_bw_resize(((thr)),((&js_ctx->bw)),((space)))));

  p_now = p + now;

  while (p < p_now) {

   duk_uint8_t b={0};

   b = duk__json_quotestr_lookup[*p++];
   if (__builtin_expect((b < 0x80), 1)) {

    *q++ = b;
   } else if (b >= 0xa0) {
    *q++ = 0x5c;
    *q++ = (duk_uint8_t) (b - 0x80);
   } else if (b == 0x80) {
    cp = (duk_ucodepoint_t) (*(p - 1));
    q = duk__emit_esc_auto_fast(js_ctx, cp, q);
   } else if (b == 0x7f && js_ctx->flag_ascii_only) {

    do { } while (0);
    cp = (duk_ucodepoint_t) 0x7f;
    q = duk__emit_esc_auto_fast(js_ctx, cp, q);
   } else {
    do { } while (0);
    p--;
    p_tmp = p;
    if (!duk_unicode_decode_xutf8(thr, &p, p_start, p_end, &cp)) {

     cp = *p_tmp;
     p = p_tmp + 1;
    }


    if (js_ctx->flag_ascii_only || cp == 0x2028 || cp == 0x2029) {



     q = duk__emit_esc_auto_fast(js_ctx, cp, q);
    } else {

     do { duk_uint8_t *duk__ptr; duk_small_int_t duk__len; duk__ptr = (duk_uint8_t *) (q); duk__len = duk_unicode_encode_xutf8((duk_ucodepoint_t) (cp), duk__ptr); duk__ptr += duk__len; (q) = duk__ptr; } while (0);
    }
   }
  }

  do { (&js_ctx->bw)->p = (q); } while (0);
 }

 duk__emit_1((js_ctx), (duk_uint_fast8_t) (0x22));
}




static void duk__enc_double(duk_json_enc_ctx *js_ctx) {
 duk_hthread *thr={0};
 duk_tval *tv={0};
 duk_double_t d={0};
 duk_small_int_t c={0};
 duk_small_int_t s={0};
 duk_small_uint_t stridx={0};
 duk_small_uint_t n2s_flags={0};
 duk_hstring *h_str={0};

 do { } while (0);
 thr = js_ctx->thr;
 do { } while (0);


 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
 do { } while (0);
 d = ((tv)->d);

 c = (duk_small_int_t) (sizeof (d) == sizeof (float) ? __fpclassifyf (d) : sizeof (d) == sizeof (double) ? __fpclassify (d) : __fpclassifyl (d));
 s = (duk_small_int_t) (sizeof (d) == sizeof (float) ? __signbitf (d) : sizeof (d) == sizeof (double) ? __signbit (d) : __signbitl (d));
 do { (void) (s); } while (0);

 if (__builtin_expect((!(c == FP_INFINITE || c == FP_NAN)), 1)) {
  do { } while (0);





  if (__builtin_expect((c == FP_ZERO && s != 0 && (js_ctx->flag_ext_custom_or_compatible)), 0)
                                                           ) {
   duk_push_hstring_stridx(thr, 62);
  } else

  {
   n2s_flags = 0;

   duk_numconv_stringify(thr, 10 , 0 , n2s_flags);
  }
  h_str = duk_known_hstring(thr, -1);
  duk__emit_hstring((js_ctx), (h_str));
  return;
 }


 if (!(js_ctx->flags & ((1U << 2) |
                        (1U << 3)))) {
  stridx = 154;
 } else if (c == FP_NAN) {
  stridx = js_ctx->stridx_custom_nan;
 } else if (s == 0) {
  stridx = js_ctx->stridx_custom_posinf;
 } else {
  stridx = js_ctx->stridx_custom_neginf;
 }



 duk__emit_stridx((js_ctx), (stridx));
}
static duk_uint8_t *duk__enc_buffer_data_hex(const duk_uint8_t *src, duk_size_t src_len, duk_uint8_t *dst) {
 duk_uint8_t *q={0};
 duk_uint16_t *q16={0};
 duk_small_uint_t x={0};
 duk_size_t i, len_safe={0};

 duk_bool_t shift_dst={0};
 shift_dst = (duk_bool_t) (((duk_size_t) dst) & 0x01U);
 if (shift_dst) {
  do { } while (0);
  q16 = (duk_uint16_t *) (void *) (dst + 1);
 } else {
  do { } while (0);
  q16 = (duk_uint16_t *) (void *) dst;
 }
 do { } while (0);


 len_safe = src_len & ~0x03U;
 for (i = 0; i < len_safe; i += 4) {
  q16[0] = duk_hex_enctab[src[i]];
  q16[1] = duk_hex_enctab[src[i + 1]];
  q16[2] = duk_hex_enctab[src[i + 2]];
  q16[3] = duk_hex_enctab[src[i + 3]];
  q16 += 4;
 }
 q = (duk_uint8_t *) q16;


 if (shift_dst) {
  q--;
  do { void *duk__dst = ((void *) dst); const void *duk__src = ((const void *) (dst + 1)); duk_size_t duk__len = (2 * len_safe); do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } while (0);
  do { } while (0);
 }


 for (; i < src_len; i++) {
  x = src[i];
  *q++ = duk_lc_digits[x >> 4];
  *q++ = duk_lc_digits[x & 0x0f];
 }

 return q;
}
static void duk__enc_buffer_data(duk_json_enc_ctx *js_ctx, duk_uint8_t *buf_data, duk_size_t buf_len) {
 duk_hthread *thr={0};
 duk_uint8_t *q={0};
 duk_size_t space={0};

 thr = js_ctx->thr;

 do { } while (0);
 do { } while (0);
 space = 9 + buf_len * 2 + 2;
 do { } while (0);
 do { } while (0);
 q = (((duk_size_t) (((&js_ctx->bw))->p_limit - ((&js_ctx->bw)->p)) >= ((space))) ? ((&js_ctx->bw)->p) : (((&js_ctx->bw))->p = ((&js_ctx->bw)->p), duk_bw_resize(((thr)),((&js_ctx->bw)),((space)))));


 if (js_ctx->flag_ext_custom)


 {
  *q++ = 0x7c;
  q = duk__enc_buffer_data_hex(buf_data, buf_len, q);
  *q++ = 0x7c;

 }


 else


 {
  do { } while (0);
  do { void *duk__dst = ((void *) q); const void *duk__src = ((const void *) "{\"_buf\":\""); duk_size_t duk__len = (9); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  q += 9;
  q = duk__enc_buffer_data_hex(buf_data, buf_len, q);
  *q++ = 0x22;
  *q++ = 0x7d;
 }


 do { (&js_ctx->bw)->p = (q); } while (0);
}

static void duk__enc_buffer_jx_jc(duk_json_enc_ctx *js_ctx, duk_hbuffer *h) {
 duk__enc_buffer_data(js_ctx,
                      (duk_uint8_t *) ( (((&((h))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h))) + 1)) ),
                      (duk_size_t) (((duk_hbuffer *) (h))->size));
}
static void duk__enc_pointer(duk_json_enc_ctx *js_ctx, void *ptr) {
 char buf[64]={0};
 const char *fmt={0};

 do { } while (0);
 do { } while (0);

 do { void *duk__dst = (buf); duk_size_t duk__len = (sizeof(buf)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);





 if (js_ctx->flag_ext_custom)


 {
  fmt = ptr ? "(%p)" : "(null)";
 }


 else


 {
  do { } while (0);
  fmt = ptr ? "{\"_ptr\":\"%p\"}" : "{\"_ptr\":\"null\"}";
 }



 snprintf(buf, sizeof(buf) - 1, fmt, ptr);
 duk__emit_cstring((js_ctx), (buf));
}




static void duk__enc_bufobj(duk_json_enc_ctx *js_ctx, duk_hbufobj *h_bufobj) {
 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_bufobj)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);

 if (h_bufobj->buf == ((void *)0) || !(((void) 0), ((void) 0), ((h_bufobj)->offset + (h_bufobj)->length <= (((duk_hbuffer *) ((h_bufobj)->buf))->size)))) {
  duk__emit_stridx((js_ctx), (154));
 } else {

  duk__enc_buffer_data(js_ctx,
                       (duk_uint8_t *) (((void) 0), ((void) 0), (((duk_uint8_t *) ( (((&(((h_bufobj)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_bufobj)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_bufobj)->buf))) + 1)) )) + (h_bufobj)->offset)),
                       (duk_size_t) h_bufobj->length);
 }
}
static void duk__enc_newline_indent(duk_json_enc_ctx *js_ctx, duk_uint_t depth) {
 const duk_uint8_t *gap_data={0};
 duk_size_t gap_len={0};
 duk_size_t avail_bytes={0};
 duk_size_t need_bytes={0};
 duk_uint8_t *p_start={0};
 duk_uint8_t *p={0};

 do { } while (0);
 do { } while (0);

 duk__emit_1((js_ctx), (duk_uint_fast8_t) (0x0a));
 if (__builtin_expect((depth == 0), 0)) {
  return;
 }







 gap_data = (const duk_uint8_t *) ((const duk_uint8_t *) ((js_ctx->h_gap) + 1));
 gap_len = (duk_size_t) ((js_ctx->h_gap)->blen);
 do { } while (0);

 need_bytes = gap_len * depth;
 p = (((duk_size_t) (((&js_ctx->bw))->p_limit - ((&js_ctx->bw)->p)) >= ((need_bytes))) ? ((&js_ctx->bw)->p) : (((&js_ctx->bw))->p = ((&js_ctx->bw)->p), duk_bw_resize(((js_ctx->thr)),((&js_ctx->bw)),((need_bytes)))));
 p_start = p;

 do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) gap_data); duk_size_t duk__len = ((size_t) gap_len); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 p += gap_len;
 avail_bytes = gap_len;
 do { } while (0);
 need_bytes -= gap_len;

 while (need_bytes >= avail_bytes) {
  do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) p_start); duk_size_t duk__len = ((size_t) avail_bytes); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  p += avail_bytes;
  need_bytes -= avail_bytes;
  avail_bytes <<= 1;
 }

 do { } while (0);
 do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) p_start); duk_size_t duk__len = ((size_t) need_bytes); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 p += need_bytes;


 do { (&js_ctx->bw)->p = (p); } while (0);
}



static void duk__enc_objarr_entry(duk_json_enc_ctx *js_ctx, duk_idx_t *entry_top) {
 duk_hthread *thr = js_ctx->thr;
 duk_hobject *h_target={0};
 duk_uint_fast32_t i, n={0};

 *entry_top = duk_get_top(thr);

 duk_require_stack(thr, 32);





 h_target = duk_known_hobject(thr, -1);

 n = js_ctx->recursion_depth;
 if (__builtin_expect((n > 64), 0)) {
  n = 64;
 }
 for (i = 0; i < n; i++) {
  if (__builtin_expect((js_ctx->visiting[i] == h_target), 0)) {
   do { } while (0);
   do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 1757; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_json.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("cyclic input"))); } while (0); } while (0);
   do { } while (0);
  }
 }
 if (js_ctx->recursion_depth < 64) {
  js_ctx->visiting[js_ctx->recursion_depth] = h_target;
 } else {
  duk_push_sprintf(thr, "%p", (void *) h_target);
  duk_dup_top(thr);
  if (duk_has_prop(thr, js_ctx->idx_loop)) {
   do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 1767; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_json.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("cyclic input"))); } while (0); } while (0);
   do { } while (0);
  }
  duk_push_true(thr);
  duk_put_prop(thr, js_ctx->idx_loop);
 }



 do { } while (0);
 do { } while (0);
 if (js_ctx->recursion_depth >= js_ctx->recursion_limit) {
  do { duk_err_range((thr), "duk_bi_json.c", (duk_int_t) 1779, ("json encode recursion limit")); } while (0);
  do { } while (0);
 }
 js_ctx->recursion_depth++;

 do { } while (0)
                                                                                                 ;
}


static void duk__enc_objarr_exit(duk_json_enc_ctx *js_ctx, duk_idx_t *entry_top) {
 duk_hthread *thr = js_ctx->thr;
 duk_hobject *h_target={0};



 do { } while (0);
 do { } while (0);
 js_ctx->recursion_depth--;



 h_target = duk_known_hobject(thr, *entry_top - 1);

 if (js_ctx->recursion_depth < 64) {

 } else {
  duk_push_sprintf(thr, "%p", (void *) h_target);
  duk_del_prop(thr, js_ctx->idx_loop);
 }


 duk_set_top(thr, *entry_top);

 do { } while (0)
                                                                                                 ;
}





static void duk__enc_object(duk_json_enc_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 duk_hstring *h_key={0};
 duk_idx_t entry_top={0};
 duk_idx_t idx_obj={0};
 duk_idx_t idx_keys={0};
 duk_bool_t emitted={0};
 duk_uarridx_t arr_len, i={0};
 duk_size_t prev_size={0};

 do { } while (0);

 duk__enc_objarr_entry(js_ctx, &entry_top);

 idx_obj = entry_top - 1;

 if (js_ctx->idx_proplist >= 0) {
  idx_keys = js_ctx->idx_proplist;
 } else {

  duk_dup(thr, idx_obj);
  (void) duk_hobject_get_enumerated_keys(thr, (1U << 4) );
  idx_keys = duk_require_normalize_index(thr, -1);

 }

 do { } while (0)
                                                                                 ;



 duk__emit_1((js_ctx), (duk_uint_fast8_t) (0x7b));







 arr_len = (duk_uarridx_t) duk_get_length(thr, idx_keys);
 emitted = 0;
 for (i = 0; i < arr_len; i++) {
  duk_get_prop_index(thr, idx_keys, i);

  do { } while (0)

                                                           ;

  h_key = duk_known_hstring(thr, -1);
  do { } while (0);
  do { } while (0);

  prev_size = ((duk_size_t) ((&js_ctx->bw)->p - (&js_ctx->bw)->p_base));
  if (__builtin_expect((js_ctx->h_gap != ((void *)0)), 0)) {
   duk__enc_newline_indent(js_ctx, js_ctx->recursion_depth);
   duk__enc_key_autoquote(js_ctx, h_key);
   duk__emit_2((js_ctx), (duk_uint_fast8_t) (0x3a), (duk_uint_fast8_t) (0x20));
  } else {
   duk__enc_key_autoquote(js_ctx, h_key);
   duk__emit_1((js_ctx), (duk_uint_fast8_t) (0x3a));
  }



  if (__builtin_expect((duk__enc_value(js_ctx, idx_obj) == 0), 0)) {



   do { do { } while (0); (&js_ctx->bw)->p = (&js_ctx->bw)->p_base + (prev_size); } while (0);
  } else {
   duk__emit_1((js_ctx), (duk_uint_fast8_t) (0x2c));
   emitted = 1;
  }


 }

 if (emitted) {
  do { } while (0);
  duk__unemit_1((js_ctx));
  if (__builtin_expect((js_ctx->h_gap != ((void *)0)), 0)) {
   do { } while (0);
   duk__enc_newline_indent(js_ctx, js_ctx->recursion_depth - 1U);
  }
 }
 duk__emit_1((js_ctx), (duk_uint_fast8_t) (0x7d));

 duk__enc_objarr_exit(js_ctx, &entry_top);

 do { } while (0);
}





static void duk__enc_array(duk_json_enc_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 duk_idx_t entry_top={0};
 duk_idx_t idx_arr={0};
 duk_bool_t emitted={0};
 duk_uarridx_t i, arr_len={0};

 do { } while (0)
                                                          ;

 duk__enc_objarr_entry(js_ctx, &entry_top);

 idx_arr = entry_top - 1;



 duk__emit_1((js_ctx), (duk_uint_fast8_t) (0x5b));

 arr_len = (duk_uarridx_t) duk_get_length(thr, idx_arr);
 emitted = 0;
 for (i = 0; i < arr_len; i++) {
  do { } while (0)

                                                 ;

  if (__builtin_expect((js_ctx->h_gap != ((void *)0)), 0)) {
   do { } while (0);
   duk__enc_newline_indent(js_ctx, js_ctx->recursion_depth);
  }

  (void) duk_push_uint_to_hstring(thr, (duk_uint_t) i);



  if (__builtin_expect((duk__enc_value(js_ctx, idx_arr) == 0), 0)) {

   duk__emit_stridx((js_ctx), (154));
  } else {
   ;
  }



  duk__emit_1((js_ctx), (duk_uint_fast8_t) (0x2c));
  emitted = 1;
 }

 if (emitted) {
  do { } while (0);
  duk__unemit_1((js_ctx));
  if (__builtin_expect((js_ctx->h_gap != ((void *)0)), 0)) {
   do { } while (0);
   duk__enc_newline_indent(js_ctx, js_ctx->recursion_depth - 1U);
  }
 }
 duk__emit_1((js_ctx), (duk_uint_fast8_t) (0x5d));

 duk__enc_objarr_exit(js_ctx, &entry_top);

 do { } while (0);
}





static duk_bool_t duk__enc_value(duk_json_enc_ctx *js_ctx, duk_idx_t idx_holder) {
 duk_hthread *thr = js_ctx->thr;
 duk_tval *tv={0};
 duk_tval *tv_holder={0};
 duk_tval *tv_key={0};
 duk_small_int_t c={0};

 do { } while (0)

                                                          ;

 tv_holder = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx_holder));
 do { } while (0);
 tv_key = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
 do { } while (0);
 do { } while (0);
 (void) duk_hobject_getprop(thr, tv_holder, tv_key);



 do { } while (0);






 if (duk_check_type_mask(thr, -1, (1U << 6U) |
                                  (1U << 9U) |
                                  (1U << 7U))) {
  (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (83))));
  if (duk_is_function((thr), (-1))) {
   do { } while (0);

   duk_dup_m2(thr);
   duk_dup_m4(thr);
   duk_call_method(thr, 1);
   duk_remove_m2(thr);
  } else {
   duk_pop(thr);
  }
 }



 do { } while (0);

 if (js_ctx->h_replacer) {

  do { } while (0);
  duk_push_hobject(thr, js_ctx->h_replacer);
  duk_dup(thr, idx_holder);
  duk_dup_m4(thr);
  duk_dup_m4(thr);
  duk_call_method(thr, 2);
  duk_remove_m2(thr);
 }



 do { } while (0);

 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
  duk_hobject *h={0};

  h = ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);



  if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0) &&
      js_ctx->flags & ((1U << 2) | (1U << 3))) {

   duk_hbufobj *h_bufobj={0};
   h_bufobj = (duk_hbufobj *) h;
   do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_bufobj)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);
   duk__enc_bufobj(js_ctx, h_bufobj);
   goto pop2_emitted;
  }



  c = (duk_small_int_t) (((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL));
  switch (c) {
  case 10: {
   do { } while (0);
   duk_to_number_m1(thr);




   do { } while (0);
   break;
  }
  case 12: {
   do { } while (0);
   duk_to_string(thr, -1);

   do { } while (0);
   break;
  }

  case 17:

  case 5: {
   do { } while (0);
   (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (105))));
   duk_remove_m2(thr);
   break;
  }
  default: {







   do { } while (0);
   if ((((&((h))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {

    if (js_ctx->flags & ((1U << 2) |
                         (1U << 3))) {

     do { } while (0);
     do { } while (0);
     duk__emit_stridx((js_ctx), (js_ctx->stridx_custom_function));
     goto pop2_emitted;
    } else {
     do { } while (0);
     goto pop2_undef;
    }




   }
  }
  }
 }



 do { } while (0);

 if (duk_check_type_mask(thr, -1, js_ctx->mask_for_undefined)) {

  do { } while (0);
  goto pop2_undef;
 }
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));

 switch (((duk_small_uint_t) (tv)->us[3])) {


 case 0xfff3UL: {
  duk__emit_stridx((js_ctx), (js_ctx->stridx_custom_undefined));
  break;
 }

 case 0xfff4UL: {
  duk__emit_stridx((js_ctx), (154));
  break;
 }
 case 0xfff5UL: {
  duk__emit_stridx((js_ctx), (((duk_small_uint_t) (tv)->us[2]) ? 155 : 156))
                                                      ;
  break;
 }


 case 0xfff6UL: {
  duk__enc_pointer(js_ctx, ((void *) (tv)->vp[0]));
  break;
 }

 case 0xfff8UL: {
  duk_hstring *h = ((duk_hstring *) (tv)->vp[0]);
  do { } while (0);
  if (__builtin_expect(((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
   goto pop2_undef;
  }
  duk__enc_quote_string(js_ctx, h);
  break;
 }
 case 0xfff9UL: {
  duk_hobject *h = ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);




  do { } while (0);

  if ((((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 2) {
   duk__enc_array(js_ctx);
  } else {
   duk__enc_object(js_ctx);
  }
  break;
 }






 case 0xfffaUL: {

  if (js_ctx->flag_ext_custom_or_compatible) {
   duk__enc_buffer_jx_jc(js_ctx, ((duk_hbuffer *) (tv)->vp[0]));
   break;
  }





  duk_to_object(thr, -1);
  duk__enc_object(js_ctx);
  break;
 }
 case 0xfff7UL: {


  do { } while (0);
  duk__emit_stridx((js_ctx), (js_ctx->stridx_custom_function));




  break;
 }
 default: {

  do { } while (0);
  do { } while (0);



  duk__enc_double(js_ctx);
  break;
 }
 }


 pop2_emitted:

 duk_pop_2(thr);
 return 1;

 pop2_undef:
 duk_pop_2(thr);
 return 0;
}


static duk_bool_t duk__enc_allow_into_proplist(duk_tval *tv) {
 duk_small_int_t c={0};




 do { } while (0);
 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff8UL)) {
  duk_hstring *h={0};
  h = ((duk_hstring *) (tv)->vp[0]);
  do { } while (0);
  if (__builtin_expect(((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
   return 0;
  }
  return 1;
 } else if ((((duk_small_uint_t) ((tv))->us[3]) <= 0xfff0UL)) {
  return 1;
 } else if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
  duk_hobject *h={0};
  h = ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);
  c = (duk_small_int_t) (((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL));
  if (c == 12 || c == 10) {
   return 1;
  }
 }

 return 0;
}
static __attribute__ ((unused))
void duk_bi_json_parse_helper(duk_hthread *thr,
                              duk_idx_t idx_value,
                              duk_idx_t idx_reviver,
                              duk_small_uint_t flags) {
 duk_json_dec_ctx js_ctx_alloc={0};
 duk_json_dec_ctx *js_ctx = &js_ctx_alloc;
 duk_hstring *h_text={0};





 do { } while (0);
 do { } while (0);

 do { } while (0)



                                               ;

 do { void *duk__dst = (&js_ctx_alloc); duk_size_t duk__len = (sizeof(js_ctx_alloc)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 js_ctx->thr = thr;



 js_ctx->recursion_limit = 1000;
 do { } while (0);





 js_ctx->flags = flags;

 js_ctx->flag_ext_custom = flags & (1U << 2);


 js_ctx->flag_ext_compatible = flags & (1U << 3);


 js_ctx->flag_ext_custom_or_compatible = flags & ((1U << 2) | (1U << 3));


 h_text = duk_to_hstring(thr, idx_value);
 do { } while (0);





 js_ctx->p_start = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_text) + 1));
 js_ctx->p = js_ctx->p_start;
 js_ctx->p_end = ((const duk_uint8_t *) ((const duk_uint8_t *) ((h_text) + 1))) +
                 ((h_text)->blen);
 do { } while (0);

 duk__dec_value(js_ctx);





 if (js_ctx->p != js_ctx->p_end) {
  duk__dec_syntax_error(js_ctx);
 }

 if (duk_is_function((thr), (idx_reviver))) {
  do { } while (0)
                                                                    ;

  js_ctx->idx_reviver = idx_reviver;

  duk_push_object(thr);
  duk_dup_m2(thr);
  (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (15))));
  duk_push_hstring_stridx(thr, 15);

  do { } while (0)

                                                           ;

  duk__dec_reviver_walk(js_ctx);
  duk_remove_m2(thr);
 } else {
  do { } while (0)
                                                                    ;
 }



 do { } while (0)




                                               ;

 do { } while (0);
}

static __attribute__ ((unused))
void duk_bi_json_stringify_helper(duk_hthread *thr,
                                  duk_idx_t idx_value,
                                  duk_idx_t idx_replacer,
                                  duk_idx_t idx_space,
                                  duk_small_uint_t flags) {
 duk_json_enc_ctx js_ctx_alloc={0};
 duk_json_enc_ctx *js_ctx = &js_ctx_alloc;
 duk_hobject *h={0};
 duk_idx_t idx_holder={0};
 duk_idx_t entry_top={0};


 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0)




                                               ;

 entry_top = duk_get_top(thr);





 do { void *duk__dst = (&js_ctx_alloc); duk_size_t duk__len = (sizeof(js_ctx_alloc)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 js_ctx->thr = thr;




 js_ctx->idx_proplist = -1;





 js_ctx->flags = flags;
 js_ctx->flag_ascii_only = flags & (1U << 0);
 js_ctx->flag_avoid_key_quotes = flags & (1U << 1);

 js_ctx->flag_ext_custom = flags & (1U << 2);


 js_ctx->flag_ext_compatible = flags & (1U << 3);


 js_ctx->flag_ext_custom_or_compatible = flags & ((1U << 2) | (1U << 3));






 js_ctx->stridx_custom_undefined = 154;

 if (flags & (1U << 2)) {
  js_ctx->stridx_custom_undefined = 58;
  js_ctx->stridx_custom_nan = 59;
  js_ctx->stridx_custom_neginf = 61;
  js_ctx->stridx_custom_posinf = 60;
  js_ctx->stridx_custom_function =
          (flags & (1U << 1)) ?
                  120 :
                  119;
 }


 else


 if (js_ctx->flags & (1U << 3)) {
  js_ctx->stridx_custom_undefined = 115;
  js_ctx->stridx_custom_nan = 116;
  js_ctx->stridx_custom_neginf = 118;
  js_ctx->stridx_custom_posinf = 117;
  js_ctx->stridx_custom_function = 119;
 }




 if (js_ctx->flags & ((1U << 2) |
                      (1U << 3))) {
  do { } while (0);
 }
 else

 {





  js_ctx->mask_for_undefined = (1U << 1U) |
                               (1U << 8U) |
                               (1U << 9U);
 }

 do { duk_bw_init_pushbuf((thr), (&js_ctx->bw), (128)); } while (0);

 js_ctx->idx_loop = duk_push_bare_object(thr);
 do { } while (0);







 h = duk_get_hobject(thr, idx_replacer);
 if (h != ((void *)0)) {
  if ((((&((h))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {
   js_ctx->h_replacer = h;
  } else if ((((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 2) {






   duk_uarridx_t plist_idx = 0;
   duk_small_uint_t enum_flags={0};

   js_ctx->idx_proplist = duk_push_array(thr);

   enum_flags = (1U << 5) |
                (1U << 6);
   duk_enum(thr, idx_replacer, enum_flags);
   while (duk_next(thr, -1 , 1 )) {

    if (duk__enc_allow_into_proplist(duk_get_tval(thr, -1))) {

     do { } while (0)

                                                              ;
     duk_to_string(thr, -1);
     duk_put_prop_index(thr, -4, plist_idx);
     plist_idx++;
     duk_pop(thr);
    } else {
     do { } while (0)

                                                              ;
     duk_pop_2(thr);
    }
                        }
                        duk_pop(thr);


  }
 }







 h = duk_get_hobject(thr, idx_space);
 if (h != ((void *)0)) {
  duk_small_uint_t c = (((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL));
  if (c == 10) {
   duk_to_number(thr, idx_space);
  } else if (c == 12) {
   duk_to_string(thr, idx_space);
  }
 }

 if (duk_is_number(thr, idx_space)) {
  duk_small_int_t nspace={0};

  static const char spaces[10] = {
   0x20, 0x20, 0x20, 0x20,
   0x20, 0x20, 0x20, 0x20,
   0x20, 0x20
  };


  nspace = (duk_small_int_t) duk_to_int_clamped(thr, idx_space, 0 , 10 );
  do { } while (0);

  duk_push_lstring(thr, spaces, (duk_size_t) nspace);
  js_ctx->h_gap = duk_known_hstring(thr, -1);
  do { } while (0);
 } else if (duk_is_string_notsymbol(thr, idx_space)) {
  duk_dup(thr, idx_space);
  duk_substring(thr, -1, 0, 10);
  js_ctx->h_gap = duk_known_hstring(thr, -1);
 } else {

 }

 if (js_ctx->h_gap != ((void *)0)) {




  if (((js_ctx->h_gap)->blen) == 0) {
   js_ctx->h_gap = ((void *)0);
  }
 }
 idx_holder = duk_push_object(thr);
 duk_dup(thr, idx_value);
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (15))));

 do { } while (0)






                                                          ;



 duk_push_hstring_empty(thr);



 js_ctx->recursion_limit = 1000;
 do { } while (0);

 if (__builtin_expect((duk__enc_value(js_ctx, idx_holder) == 0), 0)) {

  duk_push_undefined(thr);
 } else {

  do { duk_push_lstring((thr), (const char *) (&js_ctx->bw)->p_base, (duk_size_t) ((&js_ctx->bw)->p - (&js_ctx->bw)->p_base)); } while (0);
 }

 do { } while (0)






                                                                  ;
 duk_replace(thr, entry_top);
 duk_set_top(thr, entry_top + 1);

 do { } while (0)






                                               ;

 do { } while (0);
}







static __attribute__ ((unused)) duk_ret_t duk_bi_json_object_parse(duk_hthread *thr) {
 duk_bi_json_parse_helper(thr,
                          0 ,
                          1 ,
                          0 );
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_json_object_stringify(duk_hthread *thr) {
 duk_bi_json_stringify_helper(thr,
                              0 ,
                              1 ,
                              2 ,
                              0 );
 return 1;
}
typedef double (*duk__one_arg_func)(double);
typedef double (*duk__two_arg_func)(double, double);

static duk_ret_t duk__math_minmax(duk_hthread *thr, duk_double_t initial, duk__two_arg_func min_max) {
 duk_idx_t n = duk_get_top(thr);
 duk_idx_t i={0};
 duk_double_t res = initial;
 duk_double_t t={0};
 for (i = 0; i < n; i++) {
  t = duk_to_number(thr, i);
  if ((sizeof (t) == sizeof (float) ? __fpclassifyf (t) : sizeof (t) == sizeof (double) ? __fpclassify (t) : __fpclassifyl (t)) == FP_NAN || (sizeof (res) == sizeof (float) ? __fpclassifyf (res) : sizeof (res) == sizeof (double) ? __fpclassify (res) : __fpclassifyl (res)) == FP_NAN) {

   res = (duk_double_t) (__builtin_nanf (""));
  } else {
   res = (duk_double_t) min_max(res, (double) t);
  }
 }

 duk_push_number(thr, res);
 return 1;
}

static double duk__fmin_fixed(double x, double y) {



 if (x == 0 && y == 0) {
  duk_double_union du1, du2={0};
  du1.d = x;
  du2.d = y;





  do { } while (0);
  do { } while (0);


  if ((du1.ui[1] | du2.ui[1]) != 0) {

   return -0.0;
  } else {
   return +0.0;
  }
 }
 return duk_double_fmin(x, y);
}

static double duk__fmax_fixed(double x, double y) {



 if (x == 0 && y == 0) {
  if ((sizeof (x) == sizeof (float) ? __signbitf (x) : sizeof (x) == sizeof (double) ? __signbit (x) : __signbitl (x)) == 0 || (sizeof (y) == sizeof (float) ? __signbitf (y) : sizeof (y) == sizeof (double) ? __signbit (y) : __signbitl (y)) == 0) {
   return +0.0;
  } else {
   return -0.0;
  }
 }
 return duk_double_fmax(x, y);
}


static double duk__cbrt(double x) {
 duk_small_int_t c = (duk_small_int_t) (sizeof (x) == sizeof (float) ? __fpclassifyf (x) : sizeof (x) == sizeof (double) ? __fpclassify (x) : __fpclassifyl (x));


 if (c == FP_NAN || c == FP_INFINITE || c == FP_ZERO) {
  return x;
 }
 if ((sizeof (x) == sizeof (float) ? __signbitf (x) : sizeof (x) == sizeof (double) ? __signbit (x) : __signbitl (x))) {
  return -pow(-x, 1.0 / 3.0);
 } else {
  return pow(x, 1.0 / 3.0);
 }

}

static double duk__log2(double x) {



 return log(x) * 1.4426950408889634;

}

static double duk__log10(double x) {



 return log(x) * 0.4342944819032518;

}

static double duk__trunc(double x) {






 return x >= 0.0 ? floor(x) : ceil(x);

}


static double duk__round_fixed(double x) {
 duk_small_int_t c = (duk_small_int_t) (sizeof (x) == sizeof (float) ? __fpclassifyf (x) : sizeof (x) == sizeof (double) ? __fpclassify (x) : __fpclassifyl (x));
 if (c == FP_NAN || c == FP_INFINITE || c == FP_ZERO) {
  return x;
 }
 if (x >= -0.5 && x < 0.5) {

  if (x < 0.0) {
   return -0.0;
  } else {
   return +0.0;
  }
 }

 return floor(x + 0.5);
}






static double duk__fabs(double x) {
 return fabs(x);
}
static double duk__acos(double x) {
 return acos(x);
}
static double duk__asin(double x) {
 return asin(x);
}
static double duk__atan(double x) {
 return atan(x);
}
static double duk__ceil(double x) {
 return ceil(x);
}
static double duk__cos(double x) {
 return cos(x);
}
static double duk__exp(double x) {
 return exp(x);
}
static double duk__floor(double x) {
 return floor(x);
}
static double duk__log(double x) {
 return log(x);
}
static double duk__sin(double x) {
 return sin(x);
}
static double duk__sqrt(double x) {
 return sqrt(x);
}
static double duk__tan(double x) {
 return tan(x);
}
static double duk__atan2_fixed(double x, double y) {
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 return atan2(x, y);
}



static const duk__one_arg_func duk__one_arg_funcs[] = {

 duk__fabs,
 duk__acos,
 duk__asin,
 duk__atan,
 duk__ceil,
 duk__cos,
 duk__exp,
 duk__floor,
 duk__log,
 duk__round_fixed,
 duk__sin,
 duk__sqrt,
 duk__tan,

 duk__cbrt,
 duk__log2,
 duk__log10,
 duk__trunc
};


static const duk__two_arg_func duk__two_arg_funcs[] = {

 duk__atan2_fixed,
 duk_js_arith_pow




};

static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_onearg_shared(duk_hthread *thr) {
 duk_small_int_t fun_idx = duk_get_current_magic(thr);
 duk__one_arg_func fun={0};
 duk_double_t arg1={0};

 do { } while (0);
 do { } while (0);
 arg1 = duk_to_number(thr, 0);
 fun = duk__one_arg_funcs[fun_idx];
 duk_push_number(thr, (duk_double_t) fun((double) arg1));
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_twoarg_shared(duk_hthread *thr) {
 duk_small_int_t fun_idx = duk_get_current_magic(thr);
 duk__two_arg_func fun={0};
 duk_double_t arg1={0};
 duk_double_t arg2={0};

 do { } while (0);
 do { } while (0);
 arg1 = duk_to_number(thr, 0);
 arg2 = duk_to_number(thr, 1);
 fun = duk__two_arg_funcs[fun_idx];
 duk_push_number(thr, (duk_double_t) fun((double) arg1, (double) arg2));
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_max(duk_hthread *thr) {
 return duk__math_minmax(thr, -((double) (__builtin_inff())), duk__fmax_fixed);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_min(duk_hthread *thr) {
 return duk__math_minmax(thr, ((double) (__builtin_inff())), duk__fmin_fixed);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_random(duk_hthread *thr) {
 duk_push_number(thr, (duk_double_t) duk_util_tinyrandom_get_double(thr));
 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_hypot(duk_hthread *thr) {
 duk_idx_t nargs={0};
 duk_idx_t i={0};
 duk_bool_t found_nan={0};
 duk_double_t max={0};
 duk_double_t sum, summand={0};
 duk_double_t comp, prelim={0};
 duk_double_t t={0};

 nargs = duk_get_top(thr);


 max = 0.0;
 found_nan = 0;
 for (i = 0; i < nargs; i++) {
  t = fabs(duk_to_number(thr, i));
  if ((sizeof (t) == sizeof (float) ? __fpclassifyf (t) : sizeof (t) == sizeof (double) ? __fpclassify (t) : __fpclassifyl (t)) == FP_NAN) {
   found_nan = 1;
  } else {
   max = duk_double_fmax(max, t);
  }
 }


 if (max == ((double) (__builtin_inff()))) {
  duk_push_number(thr, ((double) (__builtin_inff())));
  return 1;
 } else if (found_nan) {
  duk_push_number(thr, (__builtin_nanf ("")));
  return 1;
 } else if (max == 0.0) {
  duk_push_number(thr, 0.0);

  return 1;
 }






 sum = 0.0;
 comp = 0.0;
 for (i = 0; i < nargs; i++) {
  t = fabs(duk_get_number(thr, i)) / max;
  summand = (t * t) - comp;
  prelim = sum + summand;
  comp = (prelim - sum) - summand;
  sum = prelim;
 }

 duk_push_number(thr, (duk_double_t) sqrt(sum) * max);
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_sign(duk_hthread *thr) {
 duk_double_t d={0};

 d = duk_to_number(thr, 0);
 if (duk_double_is_nan(d)) {
  do { } while (0);
  return 1;
 }
 if (d == 0.0) {

  return 1;
 }
 duk_push_int(thr, (d > 0.0 ? 1 : -1));
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_clz32(duk_hthread *thr) {
 duk_uint32_t x={0};
 duk_small_uint_t i={0};
 i = 0;
 x = duk_to_uint32(thr, 0);
 if (x & 0xffff0000UL) {
  x >>= 16;
 } else {
  i += 16;
 }
 if (x & 0x0000ff00UL) {
  x >>= 8;
 } else {
  i += 8;
 }
 if (x & 0x000000f0UL) {
  x >>= 4;
 } else {
  i += 4;
 }
 if (x & 0x0000000cUL) {
  x >>= 2;
 } else {
  i += 2;
 }
 if (x & 0x00000002UL) {
  x >>= 1;
 } else {
  i += 1;
 }
 if (x & 0x00000001UL) {
  ;
 } else {
  i += 1;
 }
 do { } while (0);
 duk_push_uint(thr, i);
 return 1;

}



static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_imul(duk_hthread *thr) {
 duk_uint32_t x, y, z={0};

 x = duk_to_uint32(thr, 0);
 y = duk_to_uint32(thr, 1);
 z = x * y;





 duk_push_int((thr), (duk_int_t) ((duk_int32_t) z));
 return 1;
}
static duk_double_t duk__push_this_number_plain(duk_hthread *thr) {
 duk_hobject *h={0};





 duk_push_this(thr);
 if (duk_is_number(thr, -1)) {
  do { } while (0);
  goto done;
 }
 h = duk_get_hobject(thr, -1);
 if (!h ||
     ((((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) != 10)) {
  do { } while (0);
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 25; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_number.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("number expected"))); } while (0); } while (0);
  do { } while (0);
 }
 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (105))));
 do { } while (0);
 do { } while (0)
                                                                                              ;
 duk_remove_m2(thr);

 done:
 return duk_get_number(thr, -1);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_number_constructor(duk_hthread *thr) {
 duk_idx_t nargs={0};
 duk_hobject *h_this={0};
 nargs = duk_get_top(thr);
 if (nargs == 0) {
  duk_push_int(thr, 0);
 }
 duk_to_number(thr, 0);
 duk_set_top(thr, 1);
 do { } while (0);

 if (!duk_is_constructor_call(thr)) {
  return 1;
 }
 duk_push_this(thr);
 h_this = duk_known_hobject(thr, -1);
 do { (&(h_this)->hdr)->h_flags = ((&(h_this)->hdr)->h_flags & (~(((1UL << (5)) - 1UL) << ((7 + (20)))))) | (((10)) << ((7 + (20)))); } while (0);

 do { } while (0);
 do { } while (0);
 do { } while (0);

 duk_dup_0(thr);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (105)) << 8) + (duk_uint_t) (0)));
 return 0;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_value_of(duk_hthread *thr) {
 (void) duk__push_this_number_plain(thr);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_to_string(duk_hthread *thr) {
 duk_small_int_t radix={0};
 duk_small_uint_t n2s_flags={0};

 (void) duk__push_this_number_plain(thr);
 if (duk_is_undefined(thr, 0)) {
  radix = 10;
 } else {
  radix = (duk_small_int_t) duk_to_int_check_range(thr, 0, 2, 36);
 }
 do { } while (0);

 n2s_flags = 0;

 duk_numconv_stringify(thr,
                       radix ,
                       0 ,
                       n2s_flags );
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_to_locale_string(duk_hthread *thr) {



 return duk_bi_number_prototype_to_string(thr);
}







static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_to_fixed(duk_hthread *thr) {
 duk_small_int_t frac_digits={0};
 duk_double_t d={0};
 duk_small_int_t c={0};
 duk_small_uint_t n2s_flags={0};




 d = duk__push_this_number_plain(thr);
 frac_digits = (duk_small_int_t) duk_to_int_check_range(thr, 0, 0, 20);

 c = (duk_small_int_t) (sizeof (d) == sizeof (float) ? __fpclassifyf (d) : sizeof (d) == sizeof (double) ? __fpclassify (d) : __fpclassifyl (d));
 if (c == FP_NAN || c == FP_INFINITE) {
  goto use_to_string;
 }

 if (d >= 1.0e21 || d <= -1.0e21) {
  goto use_to_string;
 }

 n2s_flags = (1U << 0) |
             (1U << 3);

 duk_numconv_stringify(thr,
                       10 ,
                       frac_digits ,
                       n2s_flags );
 return 1;

 use_to_string:
 do { } while (0);
 duk_to_string(thr, -1);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_to_exponential(duk_hthread *thr) {
 duk_bool_t frac_undefined={0};
 duk_small_int_t frac_digits={0};
 duk_double_t d={0};
 duk_small_int_t c={0};
 duk_small_uint_t n2s_flags={0};

 d = duk__push_this_number_plain(thr);

 frac_undefined = duk_is_undefined(thr, 0);
 duk_to_int(thr, 0);

 c = (duk_small_int_t) (sizeof (d) == sizeof (float) ? __fpclassifyf (d) : sizeof (d) == sizeof (double) ? __fpclassify (d) : __fpclassifyl (d));
 if (c == FP_NAN || c == FP_INFINITE) {
  goto use_to_string;
 }

 frac_digits = (duk_small_int_t) duk_to_int_check_range(thr, 0, 0, 20);

 n2s_flags = (1U << 1) |
            (frac_undefined ? 0 : (1U << 0));

 duk_numconv_stringify(thr,
                       10 ,
                       frac_digits + 1 ,
                       n2s_flags );
 return 1;

 use_to_string:
 do { } while (0);
 duk_to_string(thr, -1);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_to_precision(duk_hthread *thr) {





 duk_double_t d={0};
 duk_small_int_t prec={0};
 duk_small_int_t c={0};
 duk_small_uint_t n2s_flags={0};

 do { } while (0);

 d = duk__push_this_number_plain(thr);
 if (duk_is_undefined(thr, 0)) {
  goto use_to_string;
 }
 do { } while (0);

 duk_to_int(thr, 0);

 c = (duk_small_int_t) (sizeof (d) == sizeof (float) ? __fpclassifyf (d) : sizeof (d) == sizeof (double) ? __fpclassify (d) : __fpclassifyl (d));
 if (c == FP_NAN || c == FP_INFINITE) {
  goto use_to_string;
 }

 prec = (duk_small_int_t) duk_to_int_check_range(thr, 0, 1, 21);

 n2s_flags = (1U << 0) |
             (1U << 2);

 duk_numconv_stringify(thr,
                       10 ,
                       prec ,
                       n2s_flags );
 return 1;

 use_to_string:




 do { } while (0);
 duk_to_string(thr, -1);
 return 1;
}






static __attribute__ ((unused)) duk_ret_t duk_bi_number_check_shared(duk_hthread *thr) {
 duk_int_t magic={0};
 duk_bool_t ret = 0;

 if (duk_is_number(thr, 0)) {
  duk_double_t d={0};

  magic = duk_get_current_magic(thr);
  d = duk_get_number(thr, 0);

  switch (magic) {
  case 0:
   ret = duk_double_is_finite(d);
   break;
  case 1:
   ret = duk_double_is_integer(d);
   break;
  case 2:
   ret = duk_double_is_nan(d);
   break;
  default:
   do { } while (0);
   ret = duk_double_is_safe_integer(d);
  }
 }

 duk_push_boolean(thr, ret);
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_to_string(duk_hthread *thr) {
 duk_tval *tv={0};

 tv = (((void) 0), ((void) 0), (thr)->valstack_bottom - 1);
 duk_push_class_string_tval(thr, tv, 0 );
 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor(duk_hthread *thr) {
 duk_uint_t arg_mask={0};

 arg_mask = duk_get_type_mask(thr, 0);

 if (!duk_is_constructor_call(thr) &&
     ((arg_mask & ((1U << 2U) | (1U << 1U))) == 0)) {
  duk_to_object(thr, 0);
  return 1;
 }






 if (arg_mask & ((1U << 6U) |
                 (1U << 5U) |
                 (1U << 3U) |
                 (1U << 4U) |
                 (1U << 8U) |
                 (1U << 7U) |
                 (1U << 9U))) {




  duk_to_object(thr, 0);
  return 1;
 }

 (void) duk_push_object_helper(thr,
                               (1UL << (7 + (0))) |
                               (1UL << (7 + (7))) |
                               (((duk_uint_t) (1)) << (7 + (20))),
                               3);
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_assign(duk_hthread *thr) {
 duk_idx_t nargs={0};
 duk_int_t idx={0};

 nargs = duk_get_top_require_min(thr, 1 );

 duk_to_object(thr, 0);
 for (idx = 1; idx < nargs; idx++) {

  if (((duk_get_type_mask((thr), (idx)) & ((1U << 2U) | (1U << 1U))) ? 1 : 0)) {
   continue;
  }




  duk_to_object(thr, idx);
  duk_enum(thr, idx, (1U << 4));
  while (duk_next(thr, -1, 1 )) {

   duk_put_prop(thr, 0);

  }



 }

 duk_set_top(thr, 1);
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_is(duk_hthread *thr) {
 do { } while (0);
 duk_push_boolean(thr, duk_samevalue(thr, 0, 1));
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_create(duk_hthread *thr) {
 duk_hobject *proto={0};

 do { } while (0);


 duk_hbufobj_promote_plain(thr, 0);

 proto = duk_require_hobject_accept_mask(thr, 0, (1U << 2U));
 do { } while (0);

 (void) duk_push_object_helper_proto(thr,
                                     (1UL << (7 + (0))) |
                                     (1UL << (7 + (7))) |
                                     (((duk_uint_t) (1)) << (7 + (20))),
                                     proto);

 if (!duk_is_undefined(thr, 1)) {


  duk_replace(thr, 0);







  return duk_bi_object_constructor_define_properties(thr);
 }



 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_define_properties(duk_hthread *thr) {
 duk_small_uint_t pass={0};
 duk_uint_t defprop_flags={0};
 duk_hobject *obj={0};
 duk_idx_t idx_value={0};
 duk_hobject *get={0};
 duk_hobject *set={0};


 obj = duk_require_hobject_promote_mask(thr, 0, (1U << 9U) | (1U << 7U));
 do { } while (0);

 duk_to_object(thr, 1);

 do { } while (0)

                                                         ;
 for (pass = 0; pass < 2; pass++) {
  duk_set_top(thr, 2);
  duk_enum(thr, 1, (1U << 4) | (1U << 2) );

  for (;;) {
   duk_hstring *key={0};



   duk_set_top(thr, 3);

   if (!duk_next(thr, 2, 1 )) {
    break;
   }

   do { } while (0)

                                                            ;



   duk_hobject_prepare_property_descriptor(thr,
                                           4 ,
                                           &defprop_flags,
                                           &idx_value,
                                           &get,
                                           &set);



   if (pass == 0) {
    continue;
   }


   key = duk_known_hstring(thr, 3);
   do { } while (0);

   duk_hobject_define_property_helper(thr,
                                      defprop_flags,
                                      obj,
                                      key,
                                      idx_value,
                                      get,
                                      set,
                                      1 );
  }
 }





 duk_dup_0(thr);
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_seal_freeze_shared(duk_hthread *thr) {
 do { } while (0);

 duk_seal_freeze_raw(thr, 0, (duk_bool_t) duk_get_current_magic(thr) );
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_is_sealed_frozen_shared(duk_hthread *thr) {
 duk_hobject *h={0};
 duk_bool_t is_frozen={0};
 duk_uint_t mask={0};

 is_frozen = (duk_bool_t) duk_get_current_magic(thr);
 mask = duk_get_type_mask(thr, 0);
 if (mask & ((1U << 9U) | (1U << 7U))) {
  do { } while (0);
  duk_push_boolean(thr, (mask & (1U << 9U)) ?
                            1 :
                            (is_frozen ^ 1));
 } else {



  h = duk_get_hobject(thr, 0);
  duk_push_boolean(thr, (h == ((void *)0)) ||
                        duk_hobject_object_is_sealed_frozen_helper(thr, h, is_frozen ));
 }
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_to_locale_string(duk_hthread *thr) {
 do { } while (0);
 (void) duk_push_this_coercible_to_object(thr);
 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (82))));



 duk_dup_0(thr);
 duk_call_method(thr, 0);
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_value_of(duk_hthread *thr) {

 (void) duk_push_this_coercible_to_object(thr);
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_is_prototype_of(duk_hthread *thr) {
 duk_hobject *h_v={0};
 duk_hobject *h_obj={0};

 do { } while (0);

 h_v = duk_get_hobject(thr, 0);
 if (!h_v) {
  duk_push_false(thr);
  return 1;
 }

 h_obj = duk_push_this_coercible_to_object(thr);
 do { } while (0);




 duk_push_boolean(thr, duk_hobject_prototype_chain_contains(thr, ((h_v)->prototype), h_obj, 0 ));
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_has_own_property(duk_hthread *thr) {
 return (duk_ret_t) duk_hobject_object_ownprop_helper(thr, 0 );
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_property_is_enumerable(duk_hthread *thr) {
 return (duk_ret_t) duk_hobject_object_ownprop_helper(thr, (1U << 1) );
}
static __attribute__ ((unused)) duk_ret_t duk_bi_object_getprototype_shared(duk_hthread *thr) {






 duk_hobject *h={0};
 duk_hobject *proto={0};
 duk_tval *tv={0};
 duk_int_t magic={0};

 magic = duk_get_current_magic(thr);

 if (magic == 0) {
  do { } while (0);
  duk_push_this_coercible_to_object(thr);
 }
 do { } while (0);
 if (magic < 2) {

  duk_to_object(thr, 0);
 }
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (0));

 switch (((duk_small_uint_t) (tv)->us[3])) {
 case 0xfffaUL:
  proto = thr->builtins[42];
  break;
 case 0xfff7UL:
  proto = thr->builtins[5];
  break;
 case 0xfff9UL:
  h = ((duk_hobject *) (tv)->vp[0]);
  proto = ((h)->prototype);
  break;
 default:



  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_object.c", (duk_int_t) 362); } while (0); return 0; } while (0);
 }
 if (proto != ((void *)0)) {
  duk_push_hobject(thr, proto);
 } else {
  duk_push_null(thr);
 }
 return 1;
}
static __attribute__ ((unused)) duk_ret_t duk_bi_object_setprototype_shared(duk_hthread *thr) {






 duk_hobject *h_obj={0};
 duk_hobject *h_new_proto={0};
 duk_hobject *h_curr={0};
 duk_ret_t ret_success = 1;
 duk_uint_t mask={0};
 duk_int_t magic={0};


 magic = duk_get_current_magic(thr);
 if (magic == 0) {
  duk_push_this_check_object_coercible(thr);
  duk_insert(thr, 0);
  if (!duk_check_type_mask(thr, 1, (1U << 2U) | (1U << 6U))) {
   return 0;
  }




  ret_success = 0;
 } else {
  if (magic == 1) {
   ((void) duk_check_type_mask((thr), (0), (1U << 3U) | (1U << 4U) | (1U << 5U) | (1U << 6U) | (1U << 7U) | (1U << 8U) | (1U << 9U) | (1U << 10)));
  } else {
   duk_require_hobject_accept_mask(thr, 0,
                                   (1U << 9U) |
                                   (1U << 7U));
  }
  ((void) duk_check_type_mask((thr), (1), ((1U << 2U) | (1U << 6U)) | (1U << 10)));
 }

 h_new_proto = duk_get_hobject(thr, 1);


 mask = duk_get_type_mask(thr, 0);
 if (mask & ((1U << 9U) | (1U << 7U))) {
  duk_hobject *curr_proto={0};
  curr_proto = thr->builtins[(mask & (1U << 9U)) ?
                                 5 :
                                 42];
  if (h_new_proto == curr_proto) {
   goto skip;
  }
  goto fail_nonextensible;
 }
 h_obj = duk_get_hobject(thr, 0);
 if (h_obj == ((void *)0)) {
  goto skip;
 }
 do { } while (0);




 if (h_new_proto == ((h_obj)->prototype)) {
  goto skip;
 }
 if (!(((&(h_obj)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0)) {
  goto fail_nonextensible;
 }
 for (h_curr = h_new_proto; h_curr != ((void *)0); h_curr = ((h_curr)->prototype)) {

  if (h_curr == h_obj) {
   goto fail_loop;
  }
 }
 duk_hobject_set_prototype_updref((thr), (h_obj), (h_new_proto));


 skip:
 duk_set_top(thr, 1);
 if (magic == 2) {
  duk_push_true(thr);
 }
 return ret_success;

 fail_nonextensible:
 fail_loop:
 if (magic != 2) {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_object.c", (duk_int_t) 466); } while (0); return 0; } while (0);
 } else {
  duk_push_false(thr);
  return 1;
 }
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_define_property(duk_hthread *thr) {





 duk_hobject *obj={0};
 duk_hstring *key={0};
 duk_hobject *get={0};
 duk_hobject *set={0};
 duk_idx_t idx_value={0};
 duk_uint_t defprop_flags={0};
 duk_small_uint_t magic={0};
 duk_bool_t throw_flag={0};
 duk_bool_t ret={0};

 do { } while (0);

 do { } while (0)



                                                         ;



 magic = (duk_small_uint_t) duk_get_current_magic(thr);





 obj = duk_require_hobject_promote_mask(thr, 0, (1U << 9U) | (1U << 7U));
 do { } while (0);
 key = duk_to_property_key_hstring(thr, 1);
 (void) duk_require_hobject(thr, 2);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 duk_hobject_prepare_property_descriptor(thr,
                                         2 ,
                                         &defprop_flags,
                                         &idx_value,
                                         &get,
                                         &set);





 do { } while (0);
 throw_flag = magic ^ 1U;
 ret = duk_hobject_define_property_helper(thr,
                                          defprop_flags,
                                          obj,
                                          key,
                                          idx_value,
                                          get,
                                          set,
                                          throw_flag);





 if (magic == 0U) {

  duk_push_hobject(thr, obj);
 } else {

  duk_push_boolean(thr, ret);
 }
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_get_own_property_descriptor(duk_hthread *thr) {
 do { } while (0);


 if (duk_get_current_magic(thr) == 0) {
  duk_to_object(thr, 0);
 }



 duk_hobject_object_get_own_property_descriptor(thr, -2);
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_is_extensible(duk_hthread *thr) {





 duk_hobject *h={0};

 if (duk_get_current_magic(thr) == 0) {
  h = duk_get_hobject(thr, 0);
 } else {



  h = duk_require_hobject_accept_mask(thr, 0, (1U << 9U) | (1U << 7U));
 }

 duk_push_boolean(thr, (h != ((void *)0)) && (((&(h)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0));
 return 1;
}
static const duk_small_uint_t duk__object_keys_enum_flags[4] = {

 (1U << 4) |
     (1U << 7),


 (1U << 0) |
     (1U << 4) |
     (1U << 7),


 (1U << 2) |
     (1U << 4) |
     (1U << 3) |
     (1U << 0) |
     (1U << 7),


 (1U << 2) |
     (1U << 4) |
     (1U << 0) |
     (1U << 7)
};

static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_keys_shared(duk_hthread *thr) {
 duk_hobject *obj={0};

 duk_hobject *h_proxy_target={0};
 duk_hobject *h_proxy_handler={0};
 duk_hobject *h_trap_result={0};

 duk_small_uint_t enum_flags={0};
 duk_int_t magic={0};

 do { } while (0);

 magic = duk_get_current_magic(thr);
 if (magic == 3) {



  obj = duk_require_hobject_promote_mask(thr, 0, (1U << 9U) | (1U << 7U));
 } else {

  obj = duk_to_hobject(thr, 0);
 }
 do { } while (0);
 do { (void) (obj); } while (0);





 if (__builtin_expect((!duk_hobject_proxy_check(obj, &h_proxy_target, &h_proxy_handler)), 1)

                                                           ) {
  goto skip_proxy;
 }

 duk_push_hobject(thr, h_proxy_handler);
 if (!(((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (75))))) {



  do { } while (0);
  duk_pop_2(thr);
  duk_push_hobject(thr, h_proxy_target);
  duk_replace(thr, 0);
  do { } while (0);
  goto skip_proxy;
 }


 duk_insert(thr, -2);
 duk_push_hobject(thr, h_proxy_target);
 duk_call_method(thr, 1 );
 h_trap_result = duk_require_hobject(thr, -1);
 do { (void) (h_trap_result); } while (0);

 magic = duk_get_current_magic(thr);
 do { } while (0);
 enum_flags = duk__object_keys_enum_flags[magic];

 duk_proxy_ownkeys_postprocess(thr, h_proxy_target, enum_flags);
 return 1;

 skip_proxy:


 do { } while (0);
 magic = duk_get_current_magic(thr);
 do { } while (0);
 enum_flags = duk__object_keys_enum_flags[magic];
 return duk_hobject_get_enumerated_keys(thr, enum_flags);
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_prevent_extensions(duk_hthread *thr) {





 duk_hobject *h={0};
 duk_uint_t mask={0};
 duk_int_t magic={0};

 magic = duk_get_current_magic(thr);


 mask = (1U << 9U) | (1U << 7U);


 if (magic == 0) {
  mask |= (1U << 1U) |
          (1U << 2U) |
          (1U << 3U) |
          (1U << 4U) |
          (1U << 5U) |
          (1U << 8U);
 }

 if (duk_check_type_mask(thr, 0, mask)) {

  goto done;
 }
 h = duk_require_hobject(thr, 0);
 do { } while (0);

 do { do { } while (0); (&(h)->hdr)->h_flags &= ~(((1UL << (7 + (0))))); } while (0);




 duk_hobject_compact_props(thr, h);

 done:
 if (magic == 1) {
  duk_push_true(thr);
 }
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_defineaccessor(duk_hthread *thr) {
 duk_push_this(thr);
 duk_insert(thr, 0);
 duk_to_object(thr, 0);
 duk_require_function((thr), (2));




 duk_def_prop(thr, 0, ((1U << 4) | (1U << 1)) |
                      ((1U << 5) | (1U << 2)) |
                      (duk_get_current_magic(thr) ? (1U << 8) : (1U << 7)));
 return 0;
}
static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_lookupaccessor(duk_hthread *thr) {
 duk_uint_t sanity={0};

 duk_push_this(thr);
 duk_to_object(thr, -1);






 sanity = 10000L;
 while (!duk_is_undefined(thr, -1)) {

  duk_dup(thr, 0);
  duk_get_prop_desc(thr, 1, 0 );
  if (!duk_is_undefined(thr, -1)) {
   duk_get_prop_stridx(thr, -1, (duk_get_current_magic(thr) != 0 ? 87 : 73));
   return 1;
  }
  duk_pop(thr);

  if (__builtin_expect((sanity-- == 0), 0)) {
   do { duk_err_range((thr), "duk_bi_object.c", (duk_int_t) 794, ("prototype chain limit")); } while (0);
   do { } while (0);
  }

  duk_get_prototype(thr, -1);
  duk_remove(thr, -2);
 }
 return 1;
}
static __attribute__ ((unused)) duk_ret_t duk_bi_performance_now(duk_hthread *thr) {






 duk_push_number(thr, duk_time_get_monotonic_time(thr));
 return 1;
}
static __attribute__ ((unused)) duk_ret_t duk_bi_pointer_constructor(duk_hthread *thr) {




 if (duk_get_top(thr) == 0) {
  duk_push_pointer(thr, ((void *)0));
 } else {
  duk_to_pointer(thr, 0);
 }
 do { } while (0);
 duk_set_top(thr, 1);

 if (duk_is_constructor_call(thr)) {
  (void) duk_push_object_helper(thr,
                                (1UL << (7 + (0))) |
                                (1UL << (7 + (7))) |
                                (((duk_uint_t) (17)) << (7 + (20))),
                                36);


  duk_dup_0(thr);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (105)) << 8) + (duk_uint_t) (0)));
 }


 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_pointer_prototype_tostring_shared(duk_hthread *thr) {
 duk_tval *tv={0};
 duk_small_int_t to_string = duk_get_current_magic(thr);

 duk_push_this(thr);
 tv = duk_require_tval(thr, -1);
 do { } while (0);

 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff6UL)) {

 } else if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
  duk_hobject *h = ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);


  if ((((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) != 17) {
   goto type_error;
  }

  (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (105))));
 } else {
  goto type_error;
 }

 if (to_string) {
  duk_to_string(thr, -1);
 }
 return 1;

 type_error:
 do { do { duk_err_type_invalid_args(((thr)), "duk_bi_pointer.c", (duk_int_t) 74); } while (0); return 0; } while (0);
}
static __attribute__ ((unused)) void duk_proxy_ownkeys_postprocess(duk_hthread *thr, duk_hobject *h_proxy_target, duk_uint_t flags) {
 duk_uarridx_t i, len, idx={0};
 duk_propdesc desc={0};

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 len = (duk_uarridx_t) duk_get_length(thr, -1);
 idx = 0;
 duk_push_array(thr);

 for (i = 0; i < len; i++) {
  duk_hstring *h={0};


  (void) duk_get_prop_index(thr, -2, i);
  h = duk_get_hstring(thr, -1);
  if (h == ((void *)0)) {
   do { duk_err_type_invalid_trap_result((thr), "duk_bi_proxy.c", (duk_int_t) 30); } while (0);
   do { } while (0);
  }

  if (!(flags & (1U << 0))) {




   if (duk_hobject_get_own_propdesc(thr, h_proxy_target, duk_known_hstring(thr, -1), &desc, 0 )) {
    if ((desc.flags & (1U << 1)) == 0) {
     do { } while (0);
     goto skip_key;
    }
   } else {
    do { } while (0);
    goto skip_key;
   }
  }
  if (__builtin_expect(((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
   if (!(flags & (1U << 2))) {
    do { } while (0);
    goto skip_key;
   }
   if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0) && !(flags & (1U << 1))) {
    do { } while (0);
    goto skip_key;
   }
  } else {
   if (flags & (1U << 3)) {
    do { } while (0);
    goto skip_key;
   }
  }


  duk_put_prop_index(thr, -2, idx++);
  continue;

  skip_key:
  duk_pop(thr);
  continue;
 }
}



static __attribute__ ((unused)) duk_ret_t duk_bi_proxy_constructor(duk_hthread *thr) {
 do { } while (0);

 duk_require_constructor_call(thr);
 duk_push_proxy(thr, 0 );
 return 1;
}
static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_object_delete_property(duk_hthread *thr) {
 duk_tval *tv_obj={0};
 duk_tval *tv_key={0};
 duk_bool_t ret={0};

 do { } while (0);
 (void) duk_require_hobject(thr, 0);
 (void) duk_to_string(thr, 1);



 do { } while (0);
 tv_obj = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (0));
 tv_key = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (1));
 ret = duk_hobject_delprop(thr, tv_obj, tv_key, 0 );
 duk_push_boolean(thr, ret);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_object_get(duk_hthread *thr) {
 duk_tval *tv_obj={0};
 duk_tval *tv_key={0};
 duk_idx_t nargs={0};

 do { } while (0);
 nargs = duk_get_top_require_min(thr, 2 );
 (void) duk_require_hobject(thr, 0);
 (void) duk_to_string(thr, 1);
 if (nargs >= 3 && !duk_strict_equals(thr, 0, 2)) {

  do { do { duk_errcode_t duk__err = (1); duk_int_t duk__line = (duk_int_t) 42; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_reflect.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("unsupported")); } while (0); } while (0);
  do { } while (0);
 }



 tv_obj = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (0));
 tv_key = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (1));
 (void) duk_hobject_getprop(thr, tv_obj, tv_key);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_object_has(duk_hthread *thr) {
 duk_tval *tv_obj={0};
 duk_tval *tv_key={0};
 duk_bool_t ret={0};

 do { } while (0);
 do { } while (0);
 (void) duk_require_hobject(thr, 0);
 (void) duk_to_string(thr, 1);



 tv_obj = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (0));
 tv_key = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (1));
 ret = duk_hobject_hasprop(thr, tv_obj, tv_key);
 duk_push_boolean(thr, ret);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_object_set(duk_hthread *thr) {
 duk_tval *tv_obj={0};
 duk_tval *tv_key={0};
 duk_tval *tv_val={0};
 duk_idx_t nargs={0};
 duk_bool_t ret={0};

 do { } while (0);
 nargs = duk_get_top_require_min(thr, 3 );
 (void) duk_require_hobject(thr, 0);
 (void) duk_to_string(thr, 1);
 if (nargs >= 4 && !duk_strict_equals(thr, 0, 3)) {

  do { do { duk_errcode_t duk__err = (1); duk_int_t duk__line = (duk_int_t) 86; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_reflect.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("unsupported")); } while (0); } while (0);
  do { } while (0);
 }



 tv_obj = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (0));
 tv_key = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (1));
 tv_val = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (2));
 ret = duk_hobject_putprop(thr, tv_obj, tv_key, tv_val, 0 );
 duk_push_boolean(thr, ret);
 return 1;
}
static void duk__get_this_regexp(duk_hthread *thr) {
 duk_hobject *h={0};

 duk_push_this(thr);
 h = duk_require_hobject_with_class(thr, -1, 11);
 do { } while (0);
 do { (void) (h); } while (0);
 duk_insert(thr, 0);
}


static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_constructor(duk_hthread *thr) {
 duk_hobject *h_pattern={0};

 do { } while (0);
 h_pattern = duk_get_hobject(thr, 0);

 if (!duk_is_constructor_call(thr) &&
     h_pattern != ((void *)0) &&
     (((&(h_pattern)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 11 &&
     duk_is_undefined(thr, 1)) {






  duk_dup_0(thr);
  return 1;
 }





 if (h_pattern != ((void *)0) &&
     (((&(h_pattern)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 11) {
  (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (44))));
  if (duk_is_undefined(thr, 1)) {



   duk_get_prop_stridx(thr, 0, 48);
  } else {

   duk_dup_1(thr);
  }
 } else {
  if (duk_is_undefined(thr, 0)) {
   duk_push_hstring_empty(thr);
  } else {
   duk_dup_0(thr);
   duk_to_string(thr, -1);
  }
  if (duk_is_undefined(thr, 1)) {
   duk_push_hstring_empty(thr);
  } else {
   duk_dup_1(thr);
   duk_to_string(thr, -1);
  }


 }

 do { } while (0)
                                                                                              ;



 duk_to_string(thr, -2);
 duk_to_string(thr, -1);
 duk_regexp_compile(thr);



 duk_regexp_create_instance(thr);



 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_prototype_exec(duk_hthread *thr) {
 duk__get_this_regexp(thr);



 duk_regexp_match(thr);



 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_prototype_test(duk_hthread *thr) {
 duk__get_this_regexp(thr);




 duk_regexp_match(thr);



 duk_push_boolean(thr, (duk_is_null(thr, -1) ? 0 : 1));

 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_prototype_tostring(duk_hthread *thr) {

 do { } while (0);
 duk_push_this(thr);
 duk_push_literal_raw((thr), ("/"), sizeof(("/")) - 1U);
 duk_get_prop_stridx(thr, 0, 44);
 duk_dup_m2(thr);
 duk_get_prop_stridx(thr, 0, 48);
 duk_concat(thr, 4);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_prototype_flags(duk_hthread *thr) {



 duk_uint8_t buf[8]={0};
 duk_uint8_t *p = buf;


 duk_push_this(thr);
 (void) duk_require_hobject(thr, -1);
 if (duk_get_prop_stridx_boolean(thr, 0, 27, ((void *)0))) {
  *p++ = 0x67;
 }
 if (duk_get_prop_stridx_boolean(thr, 0, 45, ((void *)0))) {
  *p++ = 0x69;
 }
 if (duk_get_prop_stridx_boolean(thr, 0, 46, ((void *)0))) {
  *p++ = 0x6d;
 }


 *p++ = 0x00;
 do { } while (0);

 duk_push_string(thr, (const char *) buf);
 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_prototype_shared_getter(duk_hthread *thr) {
 duk_hstring *h_bc={0};
 duk_small_uint_t re_flags={0};
 duk_hobject *h={0};
 duk_int_t magic={0};

 do { } while (0);

 duk_push_this(thr);
 h = duk_require_hobject(thr, -1);
 magic = duk_get_current_magic(thr);

 if ((((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 11) {
  (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (100))));
  (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (97))));
  h_bc = duk_require_hstring(thr, -1);
  re_flags = (duk_small_uint_t) ((const duk_uint8_t *) ((h_bc) + 1))[0];
  duk_pop(thr);
 } else if (h == thr->builtins[18]) {





  if (magic != 16 ) {
   return 0;
  }
  duk_push_literal_raw((thr), ("(?:)"), sizeof(("(?:)")) - 1U);
  re_flags = 0;
 } else {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_regexp.c", (duk_int_t) 189); } while (0); return 0; } while (0);
 }



 switch (magic) {
 case 0: {
  duk_push_boolean(thr, (re_flags & (1U << 0)));
  break;
 }
 case 1: {
  duk_push_boolean(thr, (re_flags & (1U << 1)));
  break;
 }
 case 2: {
  duk_push_boolean(thr, (re_flags & (1U << 2)));
  break;
 }
 default: {

  break;
 }
 }

 return 1;
}
static duk_hstring *duk__str_tostring_notregexp(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *h={0};

 if (duk_get_class_number(thr, idx) == 11) {
  do { duk_err_type_invalid_args((thr), "duk_bi_string.c", (duk_int_t) 30); } while (0);
  do { } while (0);
 }
 h = duk_to_hstring(thr, idx);
 do { } while (0);

 return h;
}

static duk_int_t duk__str_search_shared(duk_hthread *thr, duk_hstring *h_this, duk_hstring *h_search, duk_int_t start_cpos, duk_bool_t backwards) {
 duk_int_t cpos={0};
 duk_int_t bpos={0};
 const duk_uint8_t *p_start, *p_end, *p={0};
 const duk_uint8_t *q_start={0};
 duk_int_t q_blen={0};
 duk_uint8_t firstbyte={0};
 duk_uint8_t t={0};

 cpos = start_cpos;





 q_start = ((const duk_uint8_t *) ((h_search) + 1));
 q_blen = (duk_int_t) ((h_search)->blen);
 if (q_blen <= 0) {
  return cpos;
 }
 do { } while (0);

 bpos = (duk_int_t) duk_heap_strcache_offset_char2byte(thr, h_this, (duk_uint32_t) cpos);

 p_start = ((const duk_uint8_t *) ((h_this) + 1));
 p_end = p_start + ((h_this)->blen);
 p = p_start + bpos;
 firstbyte = q_start[0];
 while (p <= p_end && p >= p_start) {
  t = *p;






  if ((t == firstbyte) && ((duk_size_t) (p_end - p) >= (duk_size_t) q_blen)) {
   do { } while (0);
   if (duk_memcmp((const void *) p, (const void *) q_start, (size_t) q_blen) == 0) {
    return cpos;
   }
  }


  if (backwards) {





   if ((t & 0xc0) != 0x80) {
    cpos--;
   }
   p--;
  } else {
   if ((t & 0xc0) != 0x80) {
    cpos++;
   }
   p++;
  }
 }


 return -1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_string_constructor(duk_hthread *thr) {
 duk_hstring *h={0};
 duk_uint_t flags={0};
 if (duk_get_top(thr) == 0) {
  duk_push_hstring_empty(thr);
 } else {
  h = duk_to_hstring_acceptsymbol(thr, 0);
  if (__builtin_expect(((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0) && !duk_is_constructor_call(thr)), 0)) {
   duk_push_symbol_descriptive_string(thr, h);
   duk_replace(thr, 0);
  }
 }
 duk_to_string(thr, 0);
 do { } while (0);
 duk_set_top(thr, 1);

 if (duk_is_constructor_call(thr)) {

  flags = (1UL << (7 + (0))) |
          (1UL << (7 + (7))) |
          (1UL << (7 + (16))) |
          (((duk_uint_t) (12)) << (7 + (20)));
  duk_push_object_helper(thr, flags, 10);
  duk_dup_0(thr);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (105)) << 8) + (duk_uint_t) (0)));
 }


 return 1;
}

static duk_ret_t duk__construct_from_codepoints(duk_hthread *thr, duk_bool_t nonbmp) {
 duk_bufwriter_ctx bw_alloc={0};
 duk_bufwriter_ctx *bw={0};
 duk_idx_t i, n={0};
 duk_ucodepoint_t cp={0};







 n = duk_get_top(thr);

 bw = &bw_alloc;
 do { duk_bw_init_pushbuf((thr), (bw), ((duk_size_t) n)); } while (0);

 for (i = 0; i < n; i++) {




  if (nonbmp) {





   duk_int32_t i32 = 0;
   if (!duk_is_whole_get_int32(duk_to_number(thr, i), &i32) ||
       i32 < 0 || i32 > 0x10ffffL) {
    do { do { do { duk_err_range((((thr))), "duk_bi_string.c", (duk_int_t) 190, ("invalid args")); } while (0); } while (0); return 0; } while (0);
   }
   do { } while (0);
   cp = (duk_ucodepoint_t) i32;
   do { do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (6); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) ((cp)); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_cesu8(duk__cp, ((bw))->p); ((bw))->p += duk__enc_len; } while (0); } while (0);
  } else {






   cp = (duk_ucodepoint_t) duk_to_uint32(thr, i);
   do { do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (7); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) ((cp)); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, ((bw))->p); ((bw))->p += duk__enc_len; } while (0); } while (0);





  }
 }

 do { duk_bw_compact((thr), (bw)); } while (0);
 (void) duk_buffer_to_string(thr, -1);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_string_constructor_from_char_code(duk_hthread *thr) {
 return duk__construct_from_codepoints(thr, 0 );
}


static __attribute__ ((unused)) duk_ret_t duk_bi_string_constructor_from_code_point(duk_hthread *thr) {
 return duk__construct_from_codepoints(thr, 1 );
}






static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_to_string(duk_hthread *thr) {
 duk_tval *tv={0};

 duk_push_this(thr);
 tv = duk_require_tval(thr, -1);
 do { } while (0);

 if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff8UL)) {

 } else if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
  duk_hobject *h = ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);


  if ((((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) != 12) {
   goto type_error;
  }

  (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (105))));
  do { } while (0);
 } else {
  goto type_error;
 }

 (void) duk_require_hstring_notsymbol(thr, -1);
 return 1;

 type_error:
 do { do { duk_err_type_invalid_args(((thr)), "duk_bi_string.c", (duk_int_t) 259); } while (0); return 0; } while (0);
}





static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_char_at(duk_hthread *thr) {
 duk_hstring *h={0};
 duk_int_t pos={0};



 h = duk_push_this_coercible_to_string(thr);
 do { } while (0);

 pos = duk_to_int(thr, 0);

 if (sizeof(duk_size_t) >= sizeof(duk_uint_t)) {






  do { } while (0);
  do { } while (0);
  duk_substring(thr, -1, (duk_size_t) pos, (duk_size_t) pos + 1U);
 } else {



  if (__builtin_expect((pos < 0 || (duk_uint_t) pos >= (duk_uint_t) duk_hstring_get_charlen((h))), 0)) {
   duk_push_hstring_empty(thr);
  } else {
   duk_substring(thr, -1, (duk_size_t) pos, (duk_size_t) pos + 1U);
  }
 }

 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_char_code_at(duk_hthread *thr) {
 duk_int_t pos={0};
 duk_hstring *h={0};
 duk_bool_t clamped={0};
 duk_uint32_t cp={0};
 duk_int_t magic={0};



 do { } while (0);

 h = duk_push_this_coercible_to_string(thr);
 do { } while (0);

 pos = duk_to_int_clamped_raw(thr,
                              0 ,
                              0 ,
                              (duk_int_t) duk_hstring_get_charlen((h)) - 1 ,
                              &clamped );

 magic = duk_get_current_magic(thr);




 if (clamped) {



  if (magic != 0) {
   return 0;
  }
  duk_push_nan(thr);
 } else {
  do { } while (0);
  cp = (duk_uint32_t) duk_hstring_char_code_at_raw(thr, h, (duk_uint_t) pos, (duk_bool_t) magic );
  duk_push_uint((thr), (duk_uint_t) (cp));
 }
 return 1;
}
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_substring(duk_hthread *thr) {
 duk_hstring *h={0};
 duk_int_t start_pos, end_pos={0};
 duk_int_t len={0};

 h = duk_push_this_coercible_to_string(thr);
 do { } while (0);
 len = (duk_int_t) duk_hstring_get_charlen((h));



 start_pos = duk_to_int_clamped(thr, 0, 0, len);
 if (duk_is_undefined(thr, 1)) {
  end_pos = len;
 } else {
  end_pos = duk_to_int_clamped(thr, 1, 0, len);
 }
 do { } while (0);
 do { } while (0);

 if (start_pos > end_pos) {
  duk_int_t tmp = start_pos;
  start_pos = end_pos;
  end_pos = tmp;
 }

 do { } while (0);

 duk_substring(thr, -1, (duk_size_t) start_pos, (duk_size_t) end_pos);
 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_substr(duk_hthread *thr) {
 duk_hstring *h={0};
 duk_int_t start_pos, end_pos={0};
 duk_int_t len={0};





 duk_push_this(thr);
 h = duk_to_hstring_m1(thr);
 do { } while (0);
 len = (duk_int_t) duk_hstring_get_charlen((h));
 start_pos = duk_to_int_clamped(thr, 0, -len, len);
 if (start_pos < 0) {
  start_pos = len + start_pos;
 }
 do { } while (0);


 if (duk_is_undefined(thr, 1)) {
  end_pos = len;
 } else {
  do { } while (0);
  end_pos = start_pos + duk_to_int_clamped(thr, 1, 0, len - start_pos);
 }
 do { } while (0);
 do { } while (0);
 do { } while (0);

 duk_substring(thr, -1, (duk_size_t) start_pos, (duk_size_t) end_pos);
 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_slice(duk_hthread *thr) {
 duk_hstring *h={0};
 duk_int_t start_pos, end_pos={0};
 duk_int_t len={0};

 h = duk_push_this_coercible_to_string(thr);
 do { } while (0);
 len = (duk_int_t) duk_hstring_get_charlen((h));



 start_pos = duk_to_int_clamped(thr, 0, -len, len);
 if (start_pos < 0) {
  start_pos = len + start_pos;
 }
 if (duk_is_undefined(thr, 1)) {
  end_pos = len;
 } else {
  end_pos = duk_to_int_clamped(thr, 1, -len, len);
  if (end_pos < 0) {
   end_pos = len + end_pos;
  }
 }
 do { } while (0);
 do { } while (0);

 if (end_pos < start_pos) {
  end_pos = start_pos;
 }

 do { } while (0);

 duk_substring(thr, -1, (duk_size_t) start_pos, (duk_size_t) end_pos);
 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_caseconv_shared(duk_hthread *thr) {
 duk_small_int_t uppercase = duk_get_current_magic(thr);

 (void) duk_push_this_coercible_to_string(thr);
 duk_unicode_case_convert_string(thr, (duk_bool_t) uppercase);
 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_indexof_shared(duk_hthread *thr) {
 duk_hstring *h_this={0};
 duk_hstring *h_search={0};
 duk_int_t clen_this={0};
 duk_int_t cpos={0};
 duk_small_uint_t is_lastindexof = (duk_small_uint_t) duk_get_current_magic(thr);

 h_this = duk_push_this_coercible_to_string(thr);
 do { } while (0);
 clen_this = (duk_int_t) duk_hstring_get_charlen((h_this));

 h_search = duk_to_hstring(thr, 0);
 do { } while (0);

 duk_to_number(thr, 1);
 if (duk_is_nan(thr, 1) && is_lastindexof) {




  cpos = clen_this;
 } else {
  cpos = duk_to_int_clamped(thr, 1, 0, clen_this);
 }

 cpos = duk__str_search_shared(thr, h_this, h_search, cpos, is_lastindexof );
 duk_push_int(thr, cpos);
 return 1;
}
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_replace(duk_hthread *thr) {
 duk_hstring *h_input={0};
 duk_hstring *h_match={0};
 duk_hstring *h_search={0};
 duk_hobject *h_re={0};
 duk_bufwriter_ctx bw_alloc={0};
 duk_bufwriter_ctx *bw={0};

 duk_bool_t is_regexp={0};
 duk_bool_t is_global={0};

 duk_bool_t is_repl_func={0};
 duk_uint32_t match_start_coff, match_start_boff={0};

 duk_int_t match_caps={0};

 duk_uint32_t prev_match_end_boff={0};
 const duk_uint8_t *r_start, *r_end, *r={0};
 duk_size_t tmp_sz={0};

 do { } while (0);
 h_input = duk_push_this_coercible_to_string(thr);
 do { } while (0);

 bw = &bw_alloc;
 do { duk_bw_init_pushbuf((thr), (bw), (((h_input)->blen))); } while (0);

 do { } while (0);







 h_re = duk_get_hobject_with_class(thr, 0, 11);
 if (h_re) {

  is_regexp = 1;
  is_global = duk_get_prop_stridx_boolean(thr, 0, 27, ((void *)0));

  if (is_global) {

   duk_push_int(thr, 0);
   (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (47))));
  }



 } else {
  duk_to_string(thr, 0);

  is_regexp = 0;
  is_global = 0;

 }

 if (duk_is_function(thr, 1)) {
  is_repl_func = 1;
  r_start = ((void *)0);
  r_end = ((void *)0);
 } else {
  duk_hstring *h_repl={0};

  is_repl_func = 0;
  h_repl = duk_to_hstring(thr, 1);
  do { } while (0);
  r_start = ((const duk_uint8_t *) ((h_repl) + 1));
  r_end = r_start + ((h_repl)->blen);
 }

 prev_match_end_boff = 0;

 for (;;) {
  do { } while (0);


  if (is_regexp) {
   duk_dup_0(thr);
   duk_dup_2(thr);
   duk_regexp_match(thr);
   if (!duk_is_object(thr, -1)) {
    duk_pop(thr);
    break;
   }

   (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (49))));
   do { } while (0);
   match_start_coff = duk_get_uint(thr, -1);
   duk_pop(thr);

   duk_get_prop_index(thr, -1, 0);
   do { } while (0);
   h_match = duk_known_hstring(thr, -1);
   duk_pop(thr);

   if (((h_match)->blen) == 0) {



    duk_uint32_t last_index={0};

    (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (47))));
    last_index = (duk_uint32_t) duk_get_uint(thr, -1);
    do { } while (0)
                                                                     ;
    duk_pop(thr);
    duk_push_uint(thr, (duk_uint_t) (last_index + 1));
    (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (47))));
   }

   do { } while (0);
   match_caps = (duk_int_t) duk_get_length(thr, -1);
  } else {



   const duk_uint8_t *p_start, *p_end, *p={0};
   const duk_uint8_t *q_start={0};
   duk_size_t q_blen={0};


   do { } while (0);


   p_start = ((const duk_uint8_t *) ((h_input) + 1));
   p_end = p_start + ((h_input)->blen);
   p = p_start;

   h_search = duk_known_hstring(thr, 0);
   q_start = ((const duk_uint8_t *) ((h_search) + 1));
   q_blen = (duk_size_t) ((h_search)->blen);

   p_end -= q_blen;

   match_start_coff = 0;

   while (p <= p_end) {
    do { } while (0);
    if (duk_memcmp((const void *) p, (const void *) q_start, (size_t) q_blen) == 0) {
     duk_dup_0(thr);
     h_match = duk_known_hstring(thr, -1);

     match_caps = 0;

     goto found;
    }


    if ((p[0] & 0xc0) != 0x80) {
     match_start_coff++;
    }
    p++;
   }


   break;
  }
  found:
  match_start_boff = (duk_uint32_t) duk_heap_strcache_offset_char2byte(thr, h_input, match_start_coff);

  tmp_sz = (duk_size_t) (match_start_boff - prev_match_end_boff);
  do { const void *duk__valptr; duk_size_t duk__valsz; duk__valptr = (const void *) (((const duk_uint8_t *) ((h_input) + 1)) + prev_match_end_boff); duk__valsz = (duk_size_t) (tmp_sz); do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (duk__valsz); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { void *duk__dst = ((void *) ((bw)->p)); const void *duk__src = (duk__valptr); duk_size_t duk__len = (duk__valsz); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0); (bw)->p += duk__valsz; } while (0);

  prev_match_end_boff = match_start_boff + ((h_match)->blen);

  if (is_repl_func) {
   duk_idx_t idx_args={0};
   duk_hstring *h_repl={0};



   duk_dup_1(thr);
   idx_args = duk_get_top(thr);


   if (is_regexp) {
    duk_int_t idx={0};
    duk_require_stack(thr, match_caps + 2);
    for (idx = 0; idx < match_caps; idx++) {

     duk_get_prop_index(thr, 4, (duk_uarridx_t) idx);
    }
   } else {




    duk_dup_0(thr);
   }
   duk_push_uint(thr, (duk_uint_t) match_start_coff);
   duk_dup_2(thr);



   duk_call(thr, duk_get_top(thr) - idx_args);
   h_repl = duk_to_hstring_m1(thr);
   do { } while (0);

   do { duk_size_t duk__val_len; duk__val_len = (((h_repl))->blen); do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (duk__val_len); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { void *duk__dst = ((void *) ((bw)->p)); const void *duk__src = ((const void *) ((const duk_uint8_t *) (((h_repl)) + 1))); duk_size_t duk__len = (duk__val_len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0); (bw)->p += duk__val_len; } while (0);

   duk_pop(thr);
  } else {
   r = r_start;

   while (r < r_end) {
    duk_int_t ch1={0};
    duk_int_t ch2={0};

    duk_int_t ch3={0};

    duk_size_t left={0};

    ch1 = *r++;
    if (ch1 != 0x24) {
     goto repl_write;
    }
    do { } while (0);
    left = (duk_size_t) (r_end - r);

    if (left <= 0) {
     goto repl_write;
    }

    ch2 = r[0];
    switch (ch2) {
    case 0x24: {
     ch1 = (1 << 8) + 0x24;
     goto repl_write;
    }
    case 0x26: {
     do { duk_size_t duk__val_len; duk__val_len = (((h_match))->blen); do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (duk__val_len); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { void *duk__dst = ((void *) ((bw)->p)); const void *duk__src = ((const void *) ((const duk_uint8_t *) (((h_match)) + 1))); duk_size_t duk__len = (duk__val_len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0); (bw)->p += duk__val_len; } while (0);
     r++;
     continue;
    }
    case 0x60: {
     tmp_sz = (duk_size_t) match_start_boff;
     do { const void *duk__valptr; duk_size_t duk__valsz; duk__valptr = (const void *) (((const duk_uint8_t *) ((h_input) + 1))); duk__valsz = (duk_size_t) (tmp_sz); do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (duk__valsz); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { void *duk__dst = ((void *) ((bw)->p)); const void *duk__src = (duk__valptr); duk_size_t duk__len = (duk__valsz); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0); (bw)->p += duk__valsz; } while (0);
     r++;
     continue;
    }
    case 0x27: {
     duk_uint32_t match_end_boff={0};





     match_end_boff = (duk_uint32_t) duk_heap_strcache_offset_char2byte(thr,
                                                                        h_input,
                                                                        match_start_coff + (duk_uint_fast32_t) duk_hstring_get_charlen((h_match)));

     tmp_sz = (duk_size_t) (((h_input)->blen) - match_end_boff);
     do { const void *duk__valptr; duk_size_t duk__valsz; duk__valptr = (const void *) (((const duk_uint8_t *) ((h_input) + 1)) + match_end_boff); duk__valsz = (duk_size_t) (tmp_sz); do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (duk__valsz); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { void *duk__dst = ((void *) ((bw)->p)); const void *duk__src = (duk__valptr); duk_size_t duk__len = (duk__valsz); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0); (bw)->p += duk__valsz; } while (0);
     r++;
     continue;
    }
    default: {

     duk_int_t capnum, captmp, capadv={0};




     if (!is_regexp) {
      goto repl_write;
     }

     if (!(ch2 >= 0x30 && ch2 <= 0x39)) {
      goto repl_write;
     }
     capnum = ch2 - 0x30;
     capadv = 1;

     if (left >= 2) {
      ch3 = r[1];
      if (ch3 >= 0x30 && ch3 <= 0x39) {
       captmp = capnum * 10 + (ch3 - 0x30);
       if (captmp < match_caps) {
        capnum = captmp;
        capadv = 2;
       }
      }
     }

     if (capnum > 0 && capnum < match_caps) {
      do { } while (0);


      duk_get_prop_index(thr, 4, (duk_uarridx_t) capnum);
      if (duk_is_string(thr, -1)) {
       duk_hstring *h_tmp_str={0};

       h_tmp_str = duk_known_hstring(thr, -1);

       do { duk_size_t duk__val_len; duk__val_len = (((h_tmp_str))->blen); do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (duk__val_len); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { void *duk__dst = ((void *) ((bw)->p)); const void *duk__src = ((const void *) ((const duk_uint8_t *) (((h_tmp_str)) + 1))); duk_size_t duk__len = (duk__val_len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0); (bw)->p += duk__val_len; } while (0);
      } else {

      }
      duk_pop(thr);
      r += capadv;
      continue;
     } else {
      goto repl_write;
     }



    }
    }

    repl_write:


    do { do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (1); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { do { (((void) 0), ((void) 0)); } while (0); *((bw))->p++ = (duk_uint8_t) (((duk_uint8_t) (ch1 & 0xff))); } while (0); } while (0);
    r += ch1 >> 8;
   }
  }

  duk_pop(thr);


  if (!is_global) {



   break;
  }
 }


 tmp_sz = (duk_size_t) (((h_input)->blen) - prev_match_end_boff);
 do { const void *duk__valptr; duk_size_t duk__valsz; duk__valptr = (const void *) (((const duk_uint8_t *) ((h_input) + 1)) + prev_match_end_boff); duk__valsz = (duk_size_t) (tmp_sz); do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (duk__valsz); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { void *duk__dst = ((void *) ((bw)->p)); const void *duk__src = (duk__valptr); duk_size_t duk__len = (duk__valsz); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0); (bw)->p += duk__valsz; } while (0);

 do { } while (0);
 do { duk_bw_compact((thr), (bw)); } while (0);
 (void) duk_buffer_to_string(thr, -1);
 return 1;
}
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_split(duk_hthread *thr) {
 duk_hstring *h_input={0};
 duk_hstring *h_sep={0};
 duk_uint32_t limit={0};
 duk_uint32_t arr_idx={0};

 duk_bool_t is_regexp={0};

 duk_bool_t matched={0};
 duk_uint32_t prev_match_end_coff, prev_match_end_boff={0};
 duk_uint32_t match_start_boff, match_start_coff={0};
 duk_uint32_t match_end_boff, match_end_coff={0};

 h_input = duk_push_this_coercible_to_string(thr);
 do { } while (0);

 duk_push_array(thr);

 if (duk_is_undefined(thr, 1)) {
  limit = 0xffffffffUL;
 } else {
  limit = duk_to_uint32(thr, 1);
 }

 if (limit == 0) {
  return 1;
 }







 if (duk_is_undefined(thr, 0)) {




  duk_dup_2(thr);
  duk_put_prop_index(thr, 3, 0);
  return 1;
 } else if (duk_get_hobject_with_class(thr, 0, 11) != ((void *)0)) {

  duk_push_hobject_bidx(thr, 17);
  duk_dup_0(thr);
  duk_new(thr, 1);
  duk_replace(thr, 0);

  is_regexp = 1;



 } else {
  duk_to_string(thr, 0);

  is_regexp = 0;

 }







 prev_match_end_boff = 0;
 prev_match_end_coff = 0;
 arr_idx = 0;
 matched = 0;

 for (;;) {







  do { } while (0);


  if (is_regexp) {
   duk_dup_0(thr);
   duk_dup_2(thr);
   duk_regexp_match_force_global(thr);
   if (!duk_is_object(thr, -1)) {
    duk_pop(thr);
    break;
   }
   matched = 1;

   (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (49))));
   do { } while (0);
   match_start_coff = duk_get_uint(thr, -1);
   match_start_boff = (duk_uint32_t) duk_heap_strcache_offset_char2byte(thr, h_input, match_start_coff);
   duk_pop(thr);

   if (match_start_coff == duk_hstring_get_charlen((h_input))) {

    duk_pop(thr);
    break;
   }

   (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (47))));
   do { } while (0);
   match_end_coff = duk_get_uint(thr, -1);
   match_end_boff = (duk_uint32_t) duk_heap_strcache_offset_char2byte(thr, h_input, match_end_coff);
   duk_pop(thr);


   if (prev_match_end_boff == match_end_boff) {
    duk_push_uint(thr, (duk_uint_t) (match_end_coff + 1));
    (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (47))));
    duk_pop(thr);
    continue;
   }
  } else {



   const duk_uint8_t *p_start, *p_end, *p={0};
   const duk_uint8_t *q_start={0};
   duk_size_t q_blen, q_clen={0};

   p_start = ((const duk_uint8_t *) ((h_input) + 1));
   p_end = p_start + ((h_input)->blen);
   p = p_start + prev_match_end_boff;

   h_sep = duk_known_hstring(thr, 0);
   q_start = ((const duk_uint8_t *) ((h_sep) + 1));
   q_blen = (duk_size_t) ((h_sep)->blen);
   q_clen = (duk_size_t) duk_hstring_get_charlen((h_sep));

   p_end -= q_blen;

   match_start_coff = prev_match_end_coff;

   if (q_blen == 0) {
    matched = 1;

    match_start_coff++;
    p++;
    while (p < p_end) {
     if ((p[0] & 0xc0) != 0x80) {
      goto found;
     }
     p++;
    }
    goto not_found;
   }

   do { } while (0);
   while (p <= p_end) {
    do { } while (0);
    do { } while (0);
    if (duk_memcmp((const void *) p, (const void *) q_start, (size_t) q_blen) == 0) {

     goto found;
    }


    if ((p[0] & 0xc0) != 0x80) {
     match_start_coff++;
    }
    p++;
   }

   not_found:

   break;

   found:
   matched = 1;
   match_start_boff = (duk_uint32_t) (p - p_start);
   match_end_coff = (duk_uint32_t) (match_start_coff + q_clen);
   match_end_boff = (duk_uint32_t) (match_start_boff + q_blen);


   if (prev_match_end_boff == match_end_boff) {
    prev_match_end_boff++;
    prev_match_end_coff++;
    continue;
   }
  }
  do { } while (0)


                                                                               ;

  duk_push_lstring(thr,
                   (const char *) (((const duk_uint8_t *) ((h_input) + 1)) + prev_match_end_boff),
                   (duk_size_t) (match_start_boff - prev_match_end_boff));
  duk_put_prop_index(thr, 3, arr_idx);
  arr_idx++;
  if (arr_idx >= limit) {
   goto hit_limit;
  }


  if (is_regexp) {
   duk_size_t i, len={0};

   len = duk_get_length(thr, 4);
   for (i = 1; i < len; i++) {
    do { } while (0);
    duk_get_prop_index(thr, 4, (duk_uarridx_t) i);
    duk_put_prop_index(thr, 3, arr_idx);
    arr_idx++;
    if (arr_idx >= limit) {
     goto hit_limit;
    }
   }

   duk_pop(thr);

  } else {




  }

  prev_match_end_boff = match_end_boff;
  prev_match_end_coff = match_end_coff;
  continue;
 }



 do { } while (0)
                                                                              ;

 if (((h_input)->blen) > 0 || !matched) {





  duk_push_lstring(thr,
                   (const char *) ((const duk_uint8_t *) ((h_input) + 1)) + prev_match_end_boff,
                   (duk_size_t) (((h_input)->blen) - prev_match_end_boff));
  duk_put_prop_index(thr, 3, arr_idx);

 }

 return 1;

 hit_limit:

 if (is_regexp) {
  duk_pop(thr);
 }


 return 1;
}






static void duk__to_regexp_helper(duk_hthread *thr, duk_idx_t idx, duk_bool_t force_new) {
 duk_hobject *h={0};



 do { } while (0);

 if (force_new) {
  goto do_new;
 }

 h = duk_get_hobject_with_class(thr, idx, 11);
 if (!h) {
  goto do_new;
 }
 return;

 do_new:
 duk_push_hobject_bidx(thr, 17);
 duk_dup(thr, idx);
 duk_new(thr, 1);
 duk_replace(thr, idx);
}



static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_search(duk_hthread *thr) {
 do { } while (0);
 (void) duk_push_this_coercible_to_string(thr);
 duk__to_regexp_helper(thr, 0 , 1 );
 duk_dup_0(thr);
 duk_dup_1(thr);
 duk_regexp_match(thr);

 if (!duk_is_object(thr, -1)) {
  duk_push_int(thr, -1);
  return 1;
 }

 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (49))));
 do { } while (0);
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_match(duk_hthread *thr) {
 duk_bool_t global={0};
 duk_int_t prev_last_index={0};
 duk_int_t this_index={0};
 duk_int_t arr_idx={0};

 do { } while (0);
 (void) duk_push_this_coercible_to_string(thr);
 duk__to_regexp_helper(thr, 0 , 0 );
 global = duk_get_prop_stridx_boolean(thr, 0, 27, ((void *)0));
 do { } while (0);





 if (!global) {
  duk_regexp_match(thr);
  return 1;
 }





 duk_push_int(thr, 0);
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (47))));
 duk_push_array(thr);



 prev_last_index = 0;
 arr_idx = 0;

 for (;;) {
  do { } while (0);

  duk_dup_0(thr);
  duk_dup_1(thr);
  duk_regexp_match(thr);

  if (!duk_is_object(thr, -1)) {
   duk_pop(thr);
   break;
  }

  (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (47))));
  do { } while (0);
  this_index = duk_get_int(thr, -1);
  duk_pop(thr);

  if (this_index == prev_last_index) {
   this_index++;
   duk_push_int(thr, this_index);
   (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (47))));
  }
  prev_last_index = this_index;

  duk_get_prop_index(thr, -1, 0);
  duk_put_prop_index(thr, 2, (duk_uarridx_t) arr_idx);
  arr_idx++;
  duk_pop(thr);
 }

 if (arr_idx == 0) {
  duk_push_null(thr);
 }

 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_concat(duk_hthread *thr) {

 (void) duk_push_this_coercible_to_string(thr);
 duk_insert(thr, 0);
 duk_concat(thr, duk_get_top(thr));
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_trim(duk_hthread *thr) {
 do { } while (0);
 (void) duk_push_this_coercible_to_string(thr);
 duk_trim(thr, 0);
 do { } while (0);
 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_repeat(duk_hthread *thr) {
 duk_hstring *h_input={0};
 duk_size_t input_blen={0};
 duk_size_t result_len={0};
 duk_int_t count_signed={0};
 duk_uint_t count={0};
 const duk_uint8_t *src={0};
 duk_uint8_t *buf={0};
 duk_uint8_t *p={0};
 duk_double_t d={0};

 duk_size_t copy_size={0};
 duk_uint8_t *p_end={0};


 do { } while (0);
 h_input = duk_push_this_coercible_to_string(thr);
 do { } while (0);
 input_blen = ((h_input)->blen);







 d = duk_to_number(thr, 0);
 if (duk_double_is_posinf(d)) {
  goto fail_range;
 }
 count_signed = duk_get_int(thr, 0);
 if (count_signed < 0) {
  goto fail_range;
 }
 count = (duk_uint_t) count_signed;


 result_len = count * input_blen;
 if (count != 0 && result_len / count != input_blen) {
  goto fail_range;
 }


 buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, result_len);
 do { } while (0);
 src = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_input) + 1));
 do { } while (0);
 p = buf;
 p_end = p + result_len;
 copy_size = input_blen;
 for (;;) {
  duk_size_t remain = (duk_size_t) (p_end - p);
  do { } while (0)

                                          ;
  if (remain <= copy_size) {



   do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) src); duk_size_t duk__len = (remain); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
   break;
  } else {
   do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) src); duk_size_t duk__len = (copy_size); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
   p += copy_size;
  }

  src = (const duk_uint8_t *) buf;
  copy_size = (duk_size_t) (p - buf);
 }
 duk_buffer_to_string(thr, -1);
 return 1;

 fail_range:
 do { do { do { duk_err_range((((thr))), "duk_bi_string.c", (duk_int_t) 1432, ("invalid args")); } while (0); } while (0); return 0; } while (0);
}


static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_locale_compare(duk_hthread *thr) {
 duk_hstring *h1={0};
 duk_hstring *h2={0};
 duk_size_t h1_len, h2_len, prefix_len={0};
 duk_small_int_t ret = 0;
 duk_small_int_t rc={0};
 h1 = duk_push_this_coercible_to_string(thr);
 do { } while (0);

 h2 = duk_to_hstring(thr, 0);
 do { } while (0);

 h1_len = (duk_size_t) ((h1)->blen);
 h2_len = (duk_size_t) ((h2)->blen);
 prefix_len = (h1_len <= h2_len ? h1_len : h2_len);

 rc = (duk_small_int_t) duk_memcmp((const void *) ((const duk_uint8_t *) ((h1) + 1)),
                                   (const void *) ((const duk_uint8_t *) ((h2) + 1)),
                                   (size_t) prefix_len);

 if (rc < 0) {
  ret = -1;
  goto done;
 } else if (rc > 0) {
  ret = 1;
  goto done;
 }


 if (h1_len > h2_len) {
  ret = 1;
  goto done;
 } else if (h1_len == h2_len) {
  do { } while (0);
  goto done;
 }
 ret = -1;
 goto done;

 done:
 duk_push_int(thr, (duk_int_t) ret);
 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_startswith_endswith(duk_hthread *thr) {
 duk_int_t magic={0};
 duk_hstring *h={0};
 duk_hstring *h_search={0};
 duk_size_t blen_search={0};
 const duk_uint8_t *p_cmp_start={0};
 duk_bool_t result={0};

 h = duk_push_this_coercible_to_string(thr);
 do { } while (0);

 h_search = duk__str_tostring_notregexp(thr, 0);
 do { } while (0);

 magic = duk_get_current_magic(thr);

 p_cmp_start = (const duk_uint8_t *) ((const duk_uint8_t *) ((h) + 1));
 blen_search = ((h_search)->blen);

 if (duk_is_undefined(thr, 1)) {
  if (magic) {
   p_cmp_start = p_cmp_start + ((h)->blen) - blen_search;
  } else {

  }
 } else {
  duk_int_t len={0};
  duk_int_t pos={0};

  do { } while (0);
  len = (duk_int_t) duk_hstring_get_charlen((h));
  pos = duk_to_int_clamped(thr, 1, 0, len);
  do { } while (0);

  if (magic) {
   p_cmp_start -= blen_search;
  }
  do { } while (0);

  p_cmp_start += duk_heap_strcache_offset_char2byte(thr, h, (duk_uint_fast32_t) pos);
 }
 result = 0;
 if (p_cmp_start >= ((const duk_uint8_t *) ((h) + 1)) &&
     (duk_size_t) (p_cmp_start - (const duk_uint8_t *) ((const duk_uint8_t *) ((h) + 1))) + blen_search <= ((h)->blen)) {
  if (duk_memcmp((const void *) p_cmp_start,
                 (const void *) ((const duk_uint8_t *) ((h_search) + 1)),
                 (size_t) blen_search) == 0) {
   result = 1;
  }
 }

 duk_push_boolean(thr, result);
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_includes(duk_hthread *thr) {
 duk_hstring *h={0};
 duk_hstring *h_search={0};
 duk_int_t len={0};
 duk_int_t pos={0};

 h = duk_push_this_coercible_to_string(thr);
 do { } while (0);

 h_search = duk__str_tostring_notregexp(thr, 0);
 do { } while (0);

 len = (duk_int_t) duk_hstring_get_charlen((h));
 pos = duk_to_int_clamped(thr, 1, 0, len);
 do { } while (0);

 pos = duk__str_search_shared(thr, h, h_search, pos, 0 );
 duk_push_boolean(thr, pos >= 0);
 return 1;
}
static __attribute__ ((unused)) duk_ret_t duk_bi_thread_constructor(duk_hthread *thr) {
 duk_hthread *new_thr={0};
 duk_hobject *func={0};






 func = duk_require_hobject_promote_mask((thr), (0), (1U << 9U));
 do { } while (0);
 duk_require_function((thr), (0));

 duk_push_thread_raw((thr), 0 );
 new_thr = (duk_hthread *) duk_known_hobject(thr, -1);
 new_thr->state = 1;




 duk_push_hobject(new_thr, func);

 return 1;
}
static __attribute__ ((unused)) duk_ret_t duk_bi_thread_resume(duk_hthread *ctx) {
 duk_hthread *thr = (duk_hthread *) ctx;
 duk_hthread *thr_resume={0};
 duk_hobject *caller_func={0};
 duk_small_uint_t is_error={0};

 do { } while (0)


                                                         ;

 do { } while (0);
 do { } while (0);

 thr_resume = duk_require_hthread(thr, 0);
 do { } while (0);
 is_error = (duk_small_uint_t) duk_to_boolean_top_pop(thr);
 do { } while (0);







 if (thr->callstack_top < 2) {
  do { } while (0);
  goto state_error;
 }
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 caller_func = ((thr->callstack_curr->parent)->func);
 if (!(((&(caller_func)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
  do { } while (0);
  goto state_error;
 }





 if (thr_resume->state != 1 &&
     thr_resume->state != 4) {
  do { } while (0);
  goto state_error;
 }

 do { } while (0)
                                                           ;



 if (thr_resume->state == 4) {



 } else {
  duk_hobject *h_fun={0};

  do { } while (0);






  if ((thr_resume->callstack_top != 0) ||
      (thr_resume->valstack_top - thr_resume->valstack != 1)) {
   goto state_error;
  }

  duk_push_tval(thr, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr_resume))->valstack_top + (-1)));
  duk_resolve_nonbound_function(thr);
  h_fun = duk_require_hobject(thr, -1);
  if (!(((&((h_fun))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0) || !(((&(h_fun)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
   goto state_error;
  }
  duk_pop(thr);
 }
 if (is_error) {
  do { } while (0);
  duk_err_augment_error_throw(thr);
 }
 thr->heap->lj.type = 3;


 do { } while (0);
 do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (&thr->heap->lj.value2); tv__src = (&thr->valstack_bottom[0]); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((duk_small_uint_t) (((tv__dst)))->us[3]) >= 0xfff8UL)) { h__obj = ((duk_heaphdr *) (tv__dst)->vp[0]); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);


 do { } while (0);
 do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (&thr->heap->lj.value1); tv__src = (&thr->valstack_bottom[1]); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((duk_small_uint_t) (((tv__dst)))->us[3]) >= 0xfff8UL)) { h__obj = ((duk_heaphdr *) (tv__dst)->vp[0]); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
 do { } while (0);

 thr->heap->lj.iserror = is_error;

 do { } while (0);
 duk_err_longjmp(thr);
 do { __builtin_unreachable(); } while (0);


 state_error:
 do { do { duk_err_type_invalid_state(((thr)), "duk_bi_thread.c", (duk_int_t) 188); } while (0); return 0; } while (0);
}
static __attribute__ ((unused)) duk_ret_t duk_bi_thread_yield(duk_hthread *thr) {
 duk_hobject *caller_func={0};
 duk_small_uint_t is_error={0};

 do { } while (0)

                                                         ;

 do { } while (0);
 do { } while (0);

 do { } while (0);
 is_error = (duk_small_uint_t) duk_to_boolean_top_pop(thr);
 do { } while (0);







 if (!thr->resumer) {
  do { } while (0);
  goto state_error;
 }
 do { } while (0);

 if (thr->callstack_top < 2) {
  do { } while (0);
  goto state_error;
 }
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 caller_func = ((thr->callstack_curr->parent)->func);
 if (!(((&(caller_func)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
  do { } while (0);
  goto state_error;
 }

 do { } while (0);
 if (thr->callstack_preventcount != 1) {

  do { } while (0)
                                                         ;
  goto state_error;
 }
 if (is_error) {
  do { } while (0);
  duk_err_augment_error_throw(thr);
 }
 thr->heap->lj.type = 2;


 do { } while (0);
 do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (&thr->heap->lj.value1); tv__src = (&thr->valstack_bottom[0]); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((duk_small_uint_t) (((tv__dst)))->us[3]) >= 0xfff8UL)) { h__obj = ((duk_heaphdr *) (tv__dst)->vp[0]); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
 do { } while (0);

 thr->heap->lj.iserror = is_error;

 do { } while (0);
 duk_err_longjmp(thr);
 do { __builtin_unreachable(); } while (0);


 state_error:
 do { do { duk_err_type_invalid_state(((thr)), "duk_bi_thread.c", (duk_int_t) 305); } while (0); return 0; } while (0);
}



static __attribute__ ((unused)) duk_ret_t duk_bi_thread_current(duk_hthread *thr) {
 duk_push_current_thread(thr);
 return 1;
}






static __attribute__ ((unused)) duk_ret_t duk_bi_type_error_thrower(duk_hthread *thr) {
 do { do { duk_err_type_invalid_args(((thr)), "duk_bi_thrower.c", (duk_int_t) 8); } while (0); return 0; } while (0);
}
static void duk__err_augment_user(duk_hthread *thr, duk_small_uint_t stridx_cb) {
 duk_tval *tv_hnd={0};
 duk_int_t rc={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (thr->heap->augmenting_error) {
  do { } while (0);
  return;
 }
 ;



 if (thr->builtins[34] == ((void *)0)) {



  do { } while (0);
  return;
 }
 tv_hnd = duk_hobject_find_existing_entry_tval_ptr(thr->heap,
                                                   thr->builtins[34],
                                                   ((thr)->strs[(stridx_cb)]));
 if (tv_hnd == ((void *)0)) {
  do { } while (0)
                                          ;
  return;
 }
 do { } while (0)
                                           ;
 duk_push_tval(thr, tv_hnd);



 duk_insert(thr, -2);
 duk_push_undefined(thr);
 duk_insert(thr, -2);
 do { } while (0);
 thr->heap->augmenting_error = 1;

 rc = duk_pcall_method(thr, 1);
 do { (void) (rc); } while (0);

 do { } while (0);
 thr->heap->augmenting_error = 0;


}







static void duk__add_traceback(duk_hthread *thr, duk_hthread *thr_callstack, const char *c_filename, duk_int_t c_line, duk_small_uint_t flags) {
 duk_activation *act={0};
 duk_int_t depth={0};
 duk_int_t arr_size={0};
 duk_tval *tv={0};
 duk_hstring *s={0};
 duk_uint32_t u32={0};
 duk_double_t d={0};

 do { } while (0);
 do { } while (0);
 do { } while (0)
                                                          ;




 act = thr->callstack_curr;
 depth = 10;
 do { } while (0);
 if (depth > (duk_int_t) thr_callstack->callstack_top) {
  depth = (duk_int_t) thr_callstack->callstack_top;
 }
 if (depth > 0) {
  if (flags & (1U << 1)) {
   do { } while (0);
   act = act->parent;
   depth--;
  }
 }
 arr_size = depth * 2;
 if (thr->compile_ctx != ((void *)0) && thr->compile_ctx->h_filename != ((void *)0)) {
  arr_size += 2;
 }
 if (c_filename) {




  duk_push_string(thr, c_filename);
  arr_size += 2;
 }


 do { } while (0);
 tv = duk_push_harray_with_size_outptr(thr, (duk_uint32_t) arr_size);
 do { } while (0);




 if (thr->compile_ctx != ((void *)0) && thr->compile_ctx->h_filename != ((void *)0)) {
  s = thr->compile_ctx->h_filename;
  do { ((tv))->ull[0] = (((duk_uint64_t) (0xfff8UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((s))); } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (s))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  tv++;

  u32 = (duk_uint32_t) thr->compile_ctx->curr_token.start_line;
  do { duk_double_t duk__dblval; duk__dblval = ((duk_double_t) (u32)); ; do { (((tv)))->d = (duk__dblval); } while (0); } while (0);
  tv++;
 }
 if (c_filename) {
  do { } while (0);
  s = ((duk_hstring *) (thr->valstack_top - 2)->vp[0]);
  do { } while (0);
  do { ((tv))->ull[0] = (((duk_uint64_t) (0xfff8UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((s))); } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (s))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  tv++;

  d = ((flags & (1U << 0)) ? ((duk_double_t) (1U << 0)) * 4294967296.0 : 0.0) +
      (duk_double_t) c_line;
  do { duk_double_t duk__dblval; duk__dblval = (d); ; do { ((tv))->d = (duk__dblval); } while (0); } while (0);
  tv++;
 }




 for (; depth-- > 0; act = act->parent) {
  duk_uint32_t pc={0};
  duk_tval *tv_src={0};



  do { } while (0);
  do { } while (0);


  tv_src = &act->tv_func;
  do { } while (0);
  do { *(tv) = *(tv_src); } while (0);
  do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  tv++;






  pc = (duk_uint32_t) duk_hthread_get_act_prev_pc(thr_callstack, act);
  do { } while (0);
  do { } while (0);
  d = ((duk_double_t) act->flags) * 4294967296.0 + (duk_double_t) pc;
  do { duk_double_t duk__dblval; duk__dblval = (d); ; do { ((tv))->d = (duk__dblval); } while (0); } while (0);
  tv++;
 }
 if (c_filename) {
  duk_remove_m2(thr);
 }



 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw(((thr)), (((duk_uint_t) ((-2))) << 24) + (((duk_uint_t) ((91))) << 8) + (duk_uint_t) (((1U << 0) | (1U << 1) | (1U << 2)))));
}
static void duk__add_compiler_error_line(duk_hthread *thr) {
 do { } while (0);

 if (!(thr->compile_ctx != ((void *)0) && thr->compile_ctx->h_filename != ((void *)0))) {
  return;
 }

 do { } while (0)
                                                          ;

 if ((((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (52))))) {
  duk_push_sprintf(thr, " (line %ld)", (long) thr->compile_ctx->curr_token.start_line);
  duk_concat(thr, 2);
  (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (52))));
 } else {
  duk_pop(thr);
 }

 do { } while (0)
                                                          ;
}
static void duk__err_augment_builtin_create(duk_hthread *thr, duk_hthread *thr_callstack, const char *c_filename, duk_int_t c_line, duk_hobject *obj, duk_small_uint_t flags) {







 do { } while (0);

 do { (void) (obj); } while (0);

 duk__add_compiler_error_line(thr);






 if (duk_hobject_hasprop_raw(thr, obj, (((thr))->strs[(91)]))) {
  do { } while (0);
 } else {
  duk__add_traceback(thr, thr_callstack, c_filename, c_line, flags);
 }
}
static __attribute__ ((unused)) void duk_err_augment_error_create(duk_hthread *thr, duk_hthread *thr_callstack, const char *c_filename, duk_int_t c_line, duk_small_uint_t flags) {
 duk_hobject *obj={0};

 do { } while (0);
 do { } while (0);
 obj = duk_get_hobject(thr, -1);
 if (!obj) {
  do { } while (0);
  return;
 }
 if (!duk_hobject_prototype_chain_contains(thr, obj, thr->builtins[20], 1 )) {




  do { } while (0);
  return;
 }
 if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0)) {
  do { } while (0);
  duk__err_augment_builtin_create(thr, thr_callstack, c_filename, c_line, obj, flags);
 } else {
  do { } while (0);
 }




 duk__err_augment_user(thr, 108);

}
static __attribute__ ((unused)) void duk_err_augment_error_throw(duk_hthread *thr) {

 duk__err_augment_user(thr, 109);

}
static void duk__uncaught_error_aware(duk_hthread *thr) __attribute__((noreturn));
static void duk__uncaught_error_aware(duk_hthread *thr) {
 const char *summary={0};
 char buf[128]={0};

 summary = duk_push_string_tval_readable_error(thr, &thr->heap->lj.value1);
 do { } while (0);
 snprintf(buf, sizeof(buf), "uncaught: %s", summary);
 buf[sizeof(buf) - 1] = (char) 0;
 (void) (duk_fatal_raw((thr), ((const char *) buf)), (duk_ret_t) 0);
 do { } while (0);
}


static __attribute__ ((unused)) void duk_err_longjmp(duk_hthread *thr) {
 do { } while (0);
 do { } while (0);

 do { } while (0)

                                                                  ;
 do { do { } while (0); do { } while (0); } while (0);

 thr->heap->pf_prevent_count++;
 do { } while (0);







 do { } while (0);





 if (!thr->heap->lj.jmpbuf_ptr) {
  do { } while (0)

                                                                 ;




  duk__uncaught_error_aware(thr);

  do { __builtin_unreachable(); } while (0);
 }




 longjmp((thr->heap->lj.jmpbuf_ptr->jb), 1);


 do { __builtin_unreachable(); } while (0);
}
static __attribute__ ((unused)) duk_hobject *duk_error_prototype_from_code(duk_hthread *thr, duk_errcode_t code) {
 switch (code) {
 case 2:
  return thr->builtins[22];
 case 3:
  return thr->builtins[24];
 case 4:
  return thr->builtins[26];
 case 5:
  return thr->builtins[28];
 case 6:
  return thr->builtins[30];
 case 7:
  return thr->builtins[32];
 case 1:
 default:
  return thr->builtins[20];
 }
}
static __attribute__ ((unused)) void duk_err_setup_ljstate1(duk_hthread *thr, duk_small_uint_t lj_type, duk_tval *tv_val) {
 duk_heap *heap={0};

 do { } while (0);
 heap = thr->heap;
 do { } while (0);
 do { } while (0);

 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

 heap->lj.type = lj_type;
 do { *(&heap->lj.value1) = *(tv_val); } while (0);
 do { duk_tval *duk__tv = ((tv_val)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);

 do { do { } while (0); do { } while (0); } while (0);
}
static __attribute__ ((unused)) void duk_err_create_and_throw(duk_hthread *thr, duk_errcode_t code, const char *msg, const char *filename, duk_int_t line) {




 do { } while (0)

                                                          ;




 do { } while (0);





 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);





 duk_hthread_sync_and_null_currpc(thr);
 if (thr->heap->creating_error) {
  duk_tval tv_val={0};
  duk_hobject *h_err={0};

  thr->heap->creating_error = 0;

  h_err = thr->builtins[37];
  if (h_err != ((void *)0)) {
   do { } while (0);
   do { ((&tv_val))->ull[0] = (((duk_uint64_t) (0xfff9UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((h_err))); } while (0);
  } else {
   do { } while (0)
                                                         ;
   do { duk_double_t duk__dblval; duk__dblval = ((duk_double_t) ((duk_int32_t) code)); ; do { (((&tv_val)))->d = (duk__dblval); } while (0); } while (0);
  }

  duk_err_setup_ljstate1(thr, 1, &tv_val);


 } else {





  thr->heap->creating_error = 1;

  duk_require_stack(thr, 1);





  duk_push_error_object_raw(thr,
                            code | (1L << 24),
                            filename,
                            line,
                            "%s",
                            (const char *) msg);
  do { } while (0)
                                                           ;
  duk_err_augment_error_throw(thr);


  duk_err_setup_ljstate1(thr, 1, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)));
  thr->heap->creating_error = 0;
 }





 do { } while (0)
                                                                                              ;

 duk_err_longjmp(thr);
 do { __builtin_unreachable(); } while (0);
}





static __attribute__ ((unused)) void duk_error_throw_from_negative_rc(duk_hthread *thr, duk_ret_t rc) {
 do { } while (0);
 do { } while (0);
 duk_error_raw(thr, -rc, ((void *)0), 0, "error (rc %ld)", (long) rc);
 do { } while (0);
}
static __attribute__ ((unused)) duk_hbuffer *duk_hbuffer_alloc(duk_heap *heap, duk_size_t size, duk_small_uint_t flags, void **out_bufdata) {
 duk_hbuffer *res = ((void *)0);
 duk_size_t header_size={0};
 duk_size_t alloc_size={0};

 do { } while (0);
 do { } while (0);

 do { } while (0);






 if (size > (0x7ffffffeUL)) {
  do { } while (0);
  return ((void *)0);
 }

 if (flags & (1 << 1)) {
  header_size = sizeof(duk_hbuffer_external);
  alloc_size = sizeof(duk_hbuffer_external);
 } else if (flags & (1 << 0)) {
  header_size = sizeof(duk_hbuffer_dynamic);
  alloc_size = sizeof(duk_hbuffer_dynamic);
 } else {
  header_size = sizeof(duk_hbuffer_fixed);
  alloc_size = sizeof(duk_hbuffer_fixed) + size;
  do { } while (0);
 }

 res = (duk_hbuffer *) duk_heap_mem_alloc((heap), (alloc_size));
 if (__builtin_expect((res == ((void *)0)), 0)) {
  goto alloc_error;
 }



 do { void *duk__dst = ((void *) res); duk_size_t duk__len = ((flags & (1 << 2)) ? header_size : alloc_size); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0)
                                                                      ;




 if (flags & (1 << 1)) {
  duk_hbuffer_external *h={0};
  h = (duk_hbuffer_external *) res;
  do { (void) (h); } while (0);
  *out_bufdata = ((void *)0);







  do { } while (0);
 } else if (flags & (1 << 0)) {
  duk_hbuffer_dynamic *h = (duk_hbuffer_dynamic *) res;
  void *ptr={0};

  if (size > 0) {
   do { } while (0);
   do { } while (0);

   ptr = duk_heap_mem_alloc_zeroed((heap), (size));



   if (__builtin_expect((ptr == ((void *)0)), 0)) {

    goto alloc_error;
   }
   *out_bufdata = ptr;

   do { (h)->curr_alloc = (void *) (ptr); } while (0);
  } else {
   *out_bufdata = ((void *)0);







   do { } while (0);
  }
 } else {
  *out_bufdata = (void *) ((duk_hbuffer_fixed *) (void *) res + 1);
 }

 do { ((duk_hbuffer *) (res))->size = (size); } while (0);

 do { (&res->hdr)->h_flags = ((&res->hdr)->h_flags & ~(0x00000003UL)) | (2); } while (0);
 if (flags & (1 << 0)) {
  do { do { } while (0); (&(res)->hdr)->h_flags |= ((1UL << (7 + (0)))); } while (0);
  if (flags & (1 << 1)) {
   do { do { } while (0); (&(res)->hdr)->h_flags |= ((1UL << (7 + (1)))); } while (0);
  }
 } else {
  do { } while (0);
 }
        duk_heap_insert_into_heap_allocated((heap), (&res->hdr));

 do { } while (0);
 return res;

 alloc_error:
 do { } while (0);

 duk_heap_mem_free((heap), (res));
 return ((void *)0);
}



static __attribute__ ((unused)) void *duk_hbuffer_get_dynalloc_ptr(duk_heap *heap, void *ud) {
 duk_hbuffer_dynamic *buf = (duk_hbuffer_dynamic *) ud;
 do { (void) (heap); } while (0);
 return (void *) ((buf)->curr_alloc);
}
static __attribute__ ((unused)) void duk_hbuffer_resize(duk_hthread *thr, duk_hbuffer_dynamic *buf, duk_size_t new_size) {
 void *res={0};
 duk_size_t prev_size={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);





 if (new_size > (0x7ffffffeUL)) {
  do { duk_err_range((thr), "duk_hbuffer_ops.c", (duk_int_t) 26, ("buffer too long")); } while (0);
  do { } while (0);
 }







 res = duk_heap_mem_realloc_indirect((thr->heap), (duk_hbuffer_get_dynalloc_ptr), ((void *) buf), (new_size));
 if (__builtin_expect((res != ((void *)0) || new_size == 0), 1)) {


  do { } while (0)



                                        ;







  prev_size = (((duk_hbuffer *) ((duk_hbuffer *) (buf)))->size);
  if (new_size > prev_size) {
   do { } while (0);

   do { void *duk__dst = ((void *) ((char *) res + prev_size)); duk_size_t duk__len = ((duk_size_t) (new_size - prev_size)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0)
                                                   ;

  }

  do { ((duk_hbuffer *) ((duk_hbuffer *) (buf)))->size = ((new_size)); } while (0);
  do { (buf)->curr_alloc = (void *) (res); } while (0);
 } else {
  do { duk_err_error_alloc_failed((thr), "duk_hbuffer_ops.c", (duk_int_t) 64); } while (0);
  do { } while (0);
 }

 do { } while (0);
}

static __attribute__ ((unused)) void duk_hbuffer_reset(duk_hthread *thr, duk_hbuffer_dynamic *buf) {
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 duk_hbuffer_resize(thr, buf, 0);
}


static __attribute__ ((unused)) duk_uint_t duk_hbufobj_clamp_bytelength(duk_hbufobj *h_bufobj, duk_uint_t len) {
 duk_uint_t buf_size={0};
 duk_uint_t buf_avail={0};

 do { } while (0);
 do { } while (0);

 buf_size = (duk_uint_t) (((duk_hbuffer *) (h_bufobj->buf))->size);
 if (h_bufobj->offset > buf_size) {

  return 0;
 }
 buf_avail = buf_size - h_bufobj->offset;

 return buf_avail >= len ? len : buf_avail;
}
static __attribute__ ((unused)) void duk_free_hobject(duk_heap *heap, duk_hobject *h) {
 do { } while (0);
 do { } while (0);

 duk_heap_mem_free((heap), (((h)->props)));

 if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
  duk_hcompfunc *f = (duk_hcompfunc *) h;
  do { (void) (f); } while (0);

 } else if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
  duk_hnatfunc *f = (duk_hnatfunc *) h;
  do { (void) (f); } while (0);

 } else if (((((&((h))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 18)) {
  duk_hthread *t = (duk_hthread *) h;
  duk_activation *act={0};

  duk_heap_mem_free((heap), (t->valstack));







  for (act = t->callstack_curr; act != ((void *)0);) {
   duk_activation *act_next={0};
   duk_catcher *cat={0};

   for (cat = act->cat; cat != ((void *)0);) {
    duk_catcher *cat_next={0};

    cat_next = cat->parent;
    duk_heap_mem_free((heap), ((void *) cat));
    cat = cat_next;
   }

   act_next = act->parent;
   duk_heap_mem_free((heap), ((void *) act));
   act = act_next;
  }





 } else if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {
  duk_hboundfunc *f = (duk_hboundfunc *) (void *) h;

  duk_heap_mem_free((heap), (f->args));
 }

 duk_heap_mem_free((heap), ((void *) h));
}

static __attribute__ ((unused)) void duk_free_hbuffer(duk_heap *heap, duk_hbuffer *h) {
 do { } while (0);
 do { } while (0);

 if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) && !(((&(h)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)) {
  duk_hbuffer_dynamic *g = (duk_hbuffer_dynamic *) h;
  do { } while (0);
  duk_heap_mem_free((heap), (((g)->curr_alloc)));
 }
 duk_heap_mem_free((heap), ((void *) h));
}

static __attribute__ ((unused)) void duk_free_hstring(duk_heap *heap, duk_hstring *h) {
 do { } while (0);
 do { } while (0);

 do { (void) (heap); } while (0);
 do { (void) (h); } while (0);
 duk_heap_mem_free((heap), ((void *) h));
}

static __attribute__ ((unused)) void duk_heap_free_heaphdr_raw(duk_heap *heap, duk_heaphdr *hdr) {
 do { } while (0);
 do { } while (0);

 do { } while (0);

 switch (((hdr)->h_flags & 0x00000003UL)) {
 case 0:
  duk_free_hstring(heap, (duk_hstring *) hdr);
  break;
 case 1:
  duk_free_hobject(heap, (duk_hobject *) hdr);
  break;
 default:
  do { } while (0);
  duk_free_hbuffer(heap, (duk_hbuffer *) hdr);
 }

}
static duk_size_t duk__heap_free_activation_freelist(duk_heap *heap) {
 duk_activation *act={0};
 duk_activation *act_next={0};
 duk_size_t count_act = 0;

 for (act = heap->activation_free; act != ((void *)0);) {
  act_next = act->parent;
  duk_heap_mem_free((heap), ((void *) act));
  act = act_next;



 }
 heap->activation_free = ((void *)0);
 return count_act;
}



static duk_size_t duk__heap_free_catcher_freelist(duk_heap *heap) {
 duk_catcher *cat={0};
 duk_catcher *cat_next={0};
 duk_size_t count_cat = 0;

 for (cat = heap->catcher_free; cat != ((void *)0);) {
  cat_next = cat->parent;
  duk_heap_mem_free((heap), ((void *) cat));
  cat = cat_next;



 }
 heap->catcher_free = ((void *)0);

 return count_cat;
}


static __attribute__ ((unused)) void duk_heap_free_freelists(duk_heap *heap) {
 duk_size_t count_act = 0;
 duk_size_t count_cat = 0;


 count_act = duk__heap_free_activation_freelist(heap);


 count_cat = duk__heap_free_catcher_freelist(heap);

 do { (void) (heap); } while (0);
 do { (void) (count_act); } while (0);
 do { (void) (count_cat); } while (0);

 do { } while (0)
                                                      ;
}

static void duk__free_allocated(duk_heap *heap) {
 duk_heaphdr *curr={0};
 duk_heaphdr *next={0};

 curr = heap->heap_allocated;
 while (curr) {




  do { } while (0)
                                             ;
  next = ((curr)->h_next);
  duk_heap_free_heaphdr_raw(heap, curr);
  curr = next;
 }
}


static void duk__free_finalize_list(duk_heap *heap) {
 duk_heaphdr *curr={0};
 duk_heaphdr *next={0};

 curr = heap->finalize_list;
 while (curr) {
  do { } while (0)
                                             ;
  next = ((curr)->h_next);
  duk_heap_free_heaphdr_raw(heap, curr);
  curr = next;
 }
}


static void duk__free_stringtable(duk_heap *heap) {

 duk_heap_strtable_free(heap);
}


static void duk__free_run_finalizers(duk_heap *heap) {
 duk_heaphdr *curr={0};
 duk_uint_t round_no={0};
 duk_size_t count_all={0};
 duk_size_t count_finalized={0};
 duk_size_t curr_limit={0};

 do { } while (0);


 do { } while (0);

 do { } while (0);

 if (heap->heap_thread == ((void *)0)) {



  do { } while (0);
  return;
 }






 do { } while (0);
 heap->pf_prevent_count = 1;
 do { } while (0);
 heap->ms_running = 1;
 do { } while (0);
 heap->ms_prevent_count = 1;

 curr_limit = 0;
 for (round_no = 0; ; round_no++) {
  curr = heap->heap_allocated;
  count_all = 0;
  count_finalized = 0;
  while (curr) {
   count_all++;
   if (((curr)->h_flags & 0x01UL)) {




    do { } while (0);

    if (duk_hobject_has_finalizer_fast_raw(((duk_hobject *) curr))) {
     if (!(((((duk_heaphdr *) curr))->h_flags & ((1UL << (2 + (3))))) != 0)) {
      do { } while (0);
      duk_heap_run_finalizer(heap, (duk_hobject *) curr);
      count_finalized++;
     }
    }
   }
   curr = ((curr)->h_next);
  }
  if (round_no == 0) {



   curr_limit = count_all * 2;
  } else {
   curr_limit = (curr_limit * 3) / 4;
  }
  do { } while (0)
                                                                                                 ;

  if (count_finalized == 0) {
   do { } while (0);
   break;
  }
  if (count_finalized >= curr_limit) {
   do { } while (0);
   break;
  }
 }

 do { } while (0);
 heap->ms_running = 0;
 do { } while (0);
 heap->pf_prevent_count = 0;
}


static __attribute__ ((unused)) void duk_heap_free(duk_heap *heap) {
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 duk_heap_mark_and_sweep(heap, 0);
 do { } while (0);
 duk_heap_mark_and_sweep(heap, 0);
 do { } while (0);
 heap->pf_skip_finalizers = 1;
 duk_heap_mark_and_sweep(heap, 0);
 do { } while (0);


 do { } while (0);



 do { } while (0);
 do { ((heap))->flags |= ((1U << 2)); } while (0);
 duk__free_run_finalizers(heap);






 do { } while (0);
 duk_heap_free_freelists(heap);

 do { } while (0);
 duk__free_allocated(heap);


 do { } while (0);



 do { } while (0);
 duk__free_finalize_list(heap);


 do { } while (0);
 duk__free_stringtable(heap);

 do { } while (0);
 heap->free_func(heap->heap_udata, heap);
}
static duk_bool_t duk__init_heap_strings(duk_heap *heap) {
 duk_bitdecoder_ctx bd_ctx={0};
 duk_bitdecoder_ctx *bd = &bd_ctx;
 duk_small_uint_t i={0};

 do { void *duk__dst = (&bd_ctx); duk_size_t duk__len = (sizeof(bd_ctx)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 bd->data = (const duk_uint8_t *) duk_strings_data;
 bd->length = (duk_size_t) 967;

 for (i = 0; i < 166; i++) {
  duk_uint8_t tmp[27]={0};
  duk_small_uint_t len={0};
  duk_hstring *h={0};

  len = duk_bd_decode_bitpacked_string(bd, tmp);




  do { } while (0);
  do { } while (0);
  h = duk_heap_strtable_intern(heap, tmp, len);
  if (!h) {
   goto failed;
  }
  do { } while (0);






  if (i == 33 || i == 67) {
   do { do { } while (0); (&(h)->hdr)->h_flags |= ((1UL << (7 + (6)))); } while (0);
  }
  if (i >= 121 && i < 166) {
   do { do { } while (0); (&(h)->hdr)->h_flags |= ((1UL << (7 + (4)))); } while (0);
   if (i >= 157) {
    do { do { } while (0); (&(h)->hdr)->h_flags |= ((1UL << (7 + (5)))); } while (0);
   }
  }

  do { } while (0);




  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);




  heap->strs[i] = h;

 }

 return 1;

 failed:
 return 0;
}


static duk_bool_t duk__init_heap_thread(duk_heap *heap) {
 duk_hthread *thr={0};

 do { } while (0);
 thr = duk_hthread_alloc_unchecked(heap,
                                   (1UL << (7 + (0))) |
                                   (((duk_uint_t) (18)) << (7 + (20))));
 if (thr == ((void *)0)) {
  do { } while (0);
  return 0;
 }
 thr->state = 1;






 thr->strs = heap->strs;



 heap->heap_thread = thr;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) &(thr)->obj)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);



 do { } while (0);
 if (!duk_hthread_init_stacks(heap, thr)) {
  return 0;
 }


 duk_hthread_create_builtin_objects(thr);


 do { duk_hthread *duk__thr = (thr); duk_hobject *duk__obj = ((duk_hobject *) thr); duk_hobject *duk__proto = (thr->builtins[35]); do { (void) (duk__thr); } while (0); do { } while (0); do { (duk__obj)->prototype = (duk__proto); } while (0); do { if ((duk__proto) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk__proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0); } while (0);

 return 1;
}
static __attribute__ ((unused))
duk_heap *duk_heap_alloc(duk_alloc_function alloc_func,
                         duk_realloc_function realloc_func,
                         duk_free_function free_func,
                         void *heap_udata,
                         duk_fatal_function fatal_func) {
 duk_heap *res = ((void *)0);
 duk_uint32_t st_initsize={0};

 do { } while (0);





 do { } while (0);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 if (sizeof(duk_tval) != 8) {



  fatal_func(heap_udata, "sizeof(duk_tval) not 8 or 16, cannot use DUK_USE_EXEC_REGCONST_OPTIMIZE option");
 }
 do { } while (0);
 res = (duk_heap *) alloc_func(heap_udata, sizeof(duk_heap));
 if (!res) {
  goto failed;
 }





 do { void *duk__dst = (res); duk_size_t duk__len = (sizeof(*res)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 res->alloc_func = alloc_func;
 res->realloc_func = realloc_func;
 res->free_func = free_func;
 res->heap_udata = heap_udata;
 res->fatal_func = fatal_func;
 do { } while (0);
 do { } while (0);
 res->ms_prevent_count = 1;
 res->pf_prevent_count = 1;
 do { } while (0);

 res->call_recursion_depth = 0;
 res->call_recursion_limit = 1000;
 res->hash_seed = (duk_uint32_t) (duk_uintptr_t) res;

 res->hash_seed ^= 5381;






 do { } while (0);
 do { } while (0);
 do { (&res->lj.value1)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);
 do { (&res->lj.value2)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);

 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);





 st_initsize = 1024;






 res->strtable = (duk_hstring **) alloc_func(heap_udata, sizeof(duk_hstring *) * st_initsize);
 if (res->strtable == ((void *)0)) {
  goto failed;
 }

 res->st_size = st_initsize;
 res->st_mask = st_initsize - 1;

 do { } while (0);
 do { void *duk__dst = (res->strtable); duk_size_t duk__len = (sizeof(duk_hstring *) * st_initsize); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 if (!duk__init_heap_strings(res)) {
  goto failed;
 }
 do { } while (0);
 if (!duk__init_heap_thread(res)) {
  goto failed;
 }
 do { } while (0);
 do { } while (0);
 res->heap_object = duk_hobject_alloc_unchecked(res, (1UL << (7 + (0))) |
                                                     (1UL << (7 + (7))) |
                                                     (((duk_uint_t) (1)) << (7 + (20))));
 if (res->heap_object == ((void *)0)) {
  goto failed;
 }
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (res->heap_object))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 res->rnd_state[0] = (duk_uint64_t) duk_time_get_ecmascript_time(res->heap_thread);
 do { } while (0);




 duk_util_tinyrandom_prepare_seed(res->heap_thread);





 {
  duk_uint64_t tmp_u64={0};
  tmp_u64 = 0;
  do { void *duk__dst = ((void *) &tmp_u64); const void *duk__src = ((const void *) &res); duk_size_t duk__len = ((size_t) (sizeof(void *) >= sizeof(duk_uint64_t) ? sizeof(duk_uint64_t) : sizeof(void *))); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0)

                                                                                                       ;
  res->rnd_state[1] ^= tmp_u64;
 }
 do {
  duk_small_uint_t i={0};
  for (i = 0; i < 10; i++) {




   (void) duk_util_tinyrandom_get_double(res->heap_thread);
  }
 } while (0);







 do { } while (0);
 do { } while (0);
 do { } while (0);
 res->ms_prevent_count = 0;
 res->pf_prevent_count = 0;
 do { } while (0);
 do { } while (0);
 return res;

 failed:
 do { } while (0);

 if (res != ((void *)0)) {



  do { } while (0);
  do { } while (0);
  do { } while (0);
  if (res->heap_thread != ((void *)0)) {
   res->ms_prevent_count = 0;
   res->pf_prevent_count = 0;
  }




  do { } while (0);
  do { } while (0);
  do { } while (0);
  duk_heap_free(res);
 }

 return ((void *)0);
}
static __attribute__ ((unused)) void duk_heap_process_finalize_list(duk_heap *heap) {
 duk_heaphdr *curr={0};




 do { } while (0);

 if (heap->pf_prevent_count != 0) {
  do { } while (0);
  return;
 }


 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);


 do { } while (0);
 heap->pf_prevent_count = 1;
 while ((curr = heap->finalize_list) != ((void *)0)) {

  duk_bool_t queue_back={0};


  do { } while (0);

  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { do { } while (0); ((curr))->h_flags &= ~(((1UL << (2 + (2))))); } while (0);

  if (__builtin_expect((!heap->pf_skip_finalizers), 1)) {







   duk_bool_t had_zero_refcount={0};






   do { } while (0);
   had_zero_refcount = (((curr)->h_refcount) == 1);


   do { } while (0);
   duk_heap_run_finalizer(heap, (duk_hobject *) curr);
   do { } while (0);





   do { } while (0);
   if (((curr)->h_refcount) == 1) {







    queue_back = 0;
   } else

   {

    queue_back = 1;
    if (had_zero_refcount) {






     do { do { } while (0); ((curr))->h_flags &= ~(((1UL << (2 + (3))))); } while (0);
    }

   }
  } else {




   do { } while (0);
   do { } while (0);

   queue_back = 1;

  }







  duk_heap_remove_from_finalize_list((heap), (curr));



  if (queue_back) {






   do { } while (0);
   (--(curr)->h_refcount);
   do { do { } while (0); ((curr))->h_flags &= ~(((1UL << (2 + (2))))); } while (0);
   duk_heap_insert_into_heap_allocated((heap), (curr));
  } else {

   do { } while (0);
   do { } while (0);
   duk_hobject_refcount_finalize_norz(heap, (duk_hobject *) curr);
   duk_free_hobject(heap, (duk_hobject *) curr);
   do { } while (0);
  }
 }


 do { } while (0);
 do { } while (0);
 heap->pf_prevent_count = 0;




}
static duk_ret_t duk__finalize_helper(duk_hthread *thr, void *udata) {
 do { } while (0);
 do { (void) (udata); } while (0);

 do { } while (0);
 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (104))));
 duk_dup_m2(thr);
 duk_push_boolean(thr, (((thr->heap))->flags & ((1U << 2))));
 do { } while (0);
 duk_call(thr, 2);
 do { } while (0);
 return 0;





}

static __attribute__ ((unused)) void duk_heap_run_finalizer(duk_heap *heap, duk_hobject *obj) {
 duk_hthread *thr={0};
 duk_ret_t rc={0};




 do { } while (0);

 do { } while (0);
 do { } while (0);
 thr = heap->heap_thread;
 do { } while (0);
 ;
 do { } while (0);




 do { } while (0);






 do { do { } while (0); (((duk_heaphdr *) obj))->h_flags |= ((1UL << (2 + (3)))); } while (0);


 if ((((&((obj))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)) {





  do { } while (0);
  return;
 }


 duk_push_hobject(thr, obj);
 rc = duk_safe_call(thr, duk__finalize_helper, ((void *)0) , 0 , 1 );
 do { } while (0);

 if (rc != 0) {



  do { } while (0)
                                                                     ;
 }
 duk_pop_2(thr);

 do { } while (0);
}
static __attribute__ ((unused)) duk_uint32_t duk_heap_hashstring(duk_heap *heap, const duk_uint8_t *str, duk_size_t len) {
 duk_uint32_t hash={0};
 duk_size_t step={0};
 duk_size_t off={0};
 hash = heap->hash_seed ^ ((duk_uint32_t) len);
 step = (len >> 5) + 1;
 for (off = len; off >= step; off -= step) {
  do { } while (0);
  hash = (hash * 33) + str[off - 1];
 }







 return hash;
}






static void duk__mark_heaphdr(duk_heap *heap, duk_heaphdr *h);
static void duk__mark_heaphdr_nonnull(duk_heap *heap, duk_heaphdr *h);
static void duk__mark_tval(duk_heap *heap, duk_tval *tv);
static void duk__mark_tvals(duk_heap *heap, duk_tval *tv, duk_idx_t count);





static void duk__mark_hstring(duk_heap *heap, duk_hstring *h) {
 do { (void) (heap); } while (0);
 do { (void) (h); } while (0);

 do { } while (0);
 do { } while (0);


}

static void duk__mark_hobject(duk_heap *heap, duk_hobject *h) {
 duk_uint_fast32_t i={0};

 do { } while (0);

 do { } while (0);



 for (i = 0; i < (duk_uint_fast32_t) ((h)->e_next); i++) {
  duk_hstring *key = (((duk_hstring **) (void *) ( ((((h)))->props) + ((((h)))->e_size) * sizeof(duk_propvalue) ))[(i)]);
  if (key == ((void *)0)) {
   continue;
  }
  duk__mark_heaphdr_nonnull(heap, (duk_heaphdr *) key);
  if ((((((duk_uint8_t *) (void *) ( (((((h))))->props) + (((((h))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[((i))]) & (1U << 3)) != 0)) {
   duk__mark_heaphdr(heap, (duk_heaphdr *) (&((duk_propvalue *) (void *) ( ((((h)))->props) ))[(i)])->a.get);
   duk__mark_heaphdr(heap, (duk_heaphdr *) (&((duk_propvalue *) (void *) ( ((((h)))->props) ))[(i)])->a.set);
  } else {
   duk__mark_tval(heap, &(&((duk_propvalue *) (void *) ( ((((h)))->props) ))[(i)])->v);
  }
 }

 for (i = 0; i < (duk_uint_fast32_t) ((h)->a_size); i++) {
  duk__mark_tval(heap, (&((duk_tval *) (void *) ( ((((h)))->props) + ((((h)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((h)))->e_size))) & 0x07) ))[(i)]));
 }



 duk__mark_heaphdr(heap, (duk_heaphdr *) ((h)->prototype));




 if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (7))))) != 0)) {
  do { } while (0);
  return;
 }
 do { } while (0);


 if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
  duk_hcompfunc *f = (duk_hcompfunc *) h;
  duk_tval *tv, *tv_end={0};
  duk_hobject **fn, **fn_end={0};

  do { do { } while (0); } while (0);





  duk__mark_heaphdr(heap, (duk_heaphdr *) ((duk_hbuffer_fixed *) (void *) (f)->data));
  duk__mark_heaphdr(heap, (duk_heaphdr *) ((f)->lex_env));
  duk__mark_heaphdr(heap, (duk_heaphdr *) ((f)->var_env));

  if (((duk_hbuffer_fixed *) (void *) (f)->data) != ((void *)0)) {
   tv = ((duk_tval *) (void *) ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (((duk_hbuffer_fixed *) (void *) (((f)))->data))) + 1)));
   tv_end = ((duk_tval *) (void *) (((f))->funcs));
   while (tv < tv_end) {
    duk__mark_tval(heap, tv);
    tv++;
   }

   fn = (((f))->funcs);
   fn_end = ((duk_hobject **) (void *) (((f))->bytecode));
   while (fn < fn_end) {
    duk__mark_heaphdr_nonnull(heap, (duk_heaphdr *) *fn);
    fn++;
   }
  } else {

   do { } while (0);
  }
 } else if (((((&((h))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 16)) {
  duk_hdecenv *e = (duk_hdecenv *) h;
  do { do { } while (0); do { } while (0); do { } while (0); } while (0);
  duk__mark_heaphdr(heap, (duk_heaphdr *) e->thread);
  duk__mark_heaphdr(heap, (duk_heaphdr *) e->varmap);
 } else if (((((&((h))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 15)) {
  duk_hobjenv *e = (duk_hobjenv *) h;
  do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
  duk__mark_heaphdr_nonnull(heap, (duk_heaphdr *) e->target);

 } else if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {
  duk_hbufobj *b = (duk_hbufobj *) h;
  do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((b)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);
  duk__mark_heaphdr(heap, (duk_heaphdr *) b->buf);
  duk__mark_heaphdr(heap, (duk_heaphdr *) b->buf_prop);

 } else if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {
  duk_hboundfunc *f = (duk_hboundfunc *) (void *) h;
  do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
  duk__mark_tval(heap, &f->target);
  duk__mark_tval(heap, &f->this_binding);
  duk__mark_tvals(heap, f->args, f->nargs);

 } else if ((((&((h))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)) {
  duk_hproxy *p = (duk_hproxy *) h;
  do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
  duk__mark_heaphdr_nonnull(heap, (duk_heaphdr *) p->target);
  duk__mark_heaphdr_nonnull(heap, (duk_heaphdr *) p->handler);

 } else if (((((&((h))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 18)) {
  duk_hthread *t = (duk_hthread *) h;
  duk_activation *act={0};
  duk_tval *tv={0};

  do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

  tv = t->valstack;
  while (tv < t->valstack_top) {
   duk__mark_tval(heap, tv);
   tv++;
  }

  for (act = t->callstack_curr; act != ((void *)0); act = act->parent) {
   duk__mark_heaphdr(heap, (duk_heaphdr *) ((act)->func));
   duk__mark_heaphdr(heap, (duk_heaphdr *) act->var_env);
   duk__mark_heaphdr(heap, (duk_heaphdr *) act->lex_env);







  }

  duk__mark_heaphdr(heap, (duk_heaphdr *) t->resumer);

  for (i = 0; i < 51; i++) {
   duk__mark_heaphdr(heap, (duk_heaphdr *) t->builtins[i]);
  }
 } else {




  do { } while (0);
  do { } while (0);
 }
}


static void duk__mark_heaphdr(duk_heap *heap, duk_heaphdr *h) {
 do { } while (0)

                                                                                ;


 if (h == ((void *)0)) {
  return;
 }

 do { } while (0);






 if (((((h))->h_flags & ((1UL << (2 + (0))))) != 0)) {
  do { } while (0);
  return;
 }







 do { do { } while (0); ((h))->h_flags |= ((1UL << (2 + (0)))); } while (0);

 if (heap->ms_recursion_depth >= 256) {
  do { } while (0);
  do { ((heap))->flags |= ((1U << 0)); } while (0);
  do { do { } while (0); ((h))->h_flags |= ((1UL << (2 + (1)))); } while (0);
  return;
 }

 heap->ms_recursion_depth++;
 do { } while (0);

 switch (((h)->h_flags & 0x00000003UL)) {
 case 0:
  duk__mark_hstring(heap, (duk_hstring *) h);
  break;
 case 1:
  duk__mark_hobject(heap, (duk_hobject *) h);
  break;
 case 2:

  break;
 default:
  do { } while (0);
  do { __builtin_unreachable(); } while (0);
 }

 do { } while (0);
 heap->ms_recursion_depth--;
}

static void duk__mark_tval(duk_heap *heap, duk_tval *tv) {
 do { } while (0);
 if (tv == ((void *)0)) {
  return;
 }
 if ((((duk_small_uint_t) ((tv))->us[3]) >= 0xfff8UL)) {
  duk_heaphdr *h={0};
  h = ((duk_heaphdr *) (tv)->vp[0]);
  do { } while (0);
  duk__mark_heaphdr_nonnull(heap, h);
 }
}

static void duk__mark_tvals(duk_heap *heap, duk_tval *tv, duk_idx_t count) {
 do { } while (0);

 while (count-- > 0) {
  if ((((duk_small_uint_t) ((tv))->us[3]) >= 0xfff8UL)) {
   duk_heaphdr *h={0};
   h = ((duk_heaphdr *) (tv)->vp[0]);
   do { } while (0);
   duk__mark_heaphdr_nonnull(heap, h);
  }
  tv++;
 }
}


static void duk__mark_heaphdr_nonnull(duk_heap *heap, duk_heaphdr *h) {



 duk__mark_heaphdr(heap, h);
}





static void duk__mark_roots_heap(duk_heap *heap) {
 duk_small_uint_t i={0};

 do { } while (0);

 duk__mark_heaphdr(heap, (duk_heaphdr *) heap->heap_thread);
 duk__mark_heaphdr(heap, (duk_heaphdr *) heap->heap_object);

 for (i = 0; i < 166; i++) {
  duk_hstring *h = ((heap)->strs[(i)]);
  duk__mark_heaphdr(heap, (duk_heaphdr *) h);
 }

 duk__mark_tval(heap, &heap->lj.value1);
 duk__mark_tval(heap, &heap->lj.value2);






}
static void duk__mark_finalizable(duk_heap *heap) {
 duk_heaphdr *hdr={0};
 duk_size_t count_finalizable = 0;

 do { } while (0);

 do { } while (0);

 hdr = heap->heap_allocated;
 while (hdr != ((void *)0)) {







  if (!((((hdr))->h_flags & ((1UL << (2 + (0))))) != 0) &&
      ((hdr)->h_flags & 0x01UL) &&
      !((((hdr))->h_flags & ((1UL << (2 + (3))))) != 0) &&
      duk_hobject_has_finalizer_fast_raw(((duk_hobject *) hdr))) {







   do { } while (0)


                                    ;
   do { } while (0);
   do { do { } while (0); ((hdr))->h_flags |= ((1UL << (2 + (2)))); } while (0);
   count_finalizable++;
  }

  hdr = ((hdr)->h_next);
 }

 if (count_finalizable == 0) {
  return;
 }

 do { } while (0)
                                              ;

 hdr = heap->heap_allocated;
 while (hdr != ((void *)0)) {
  if (((((hdr))->h_flags & ((1UL << (2 + (2))))) != 0)) {
   duk__mark_heaphdr_nonnull(heap, hdr);
  }

  hdr = ((hdr)->h_next);
 }


}







static void duk__mark_finalize_list(duk_heap *heap) {
 duk_heaphdr *hdr={0};




 do { } while (0);

 hdr = heap->finalize_list;
 while (hdr != ((void *)0)) {
  duk__mark_heaphdr_nonnull(heap, hdr);
  hdr = ((hdr)->h_next);



 }







}
static void duk__handle_temproot(duk_heap *heap, duk_heaphdr *hdr) {

 do { } while (0);

 if (!((((hdr))->h_flags & ((1UL << (2 + (1))))) != 0)) {
  do { } while (0);
  return;
 }

 do { } while (0);
 do { do { } while (0); ((hdr))->h_flags &= ~(((1UL << (2 + (1))))); } while (0);
 do { do { } while (0); ((hdr))->h_flags &= ~(((1UL << (2 + (0))))); } while (0);



 duk__mark_heaphdr_nonnull(heap, hdr);




}

static void duk__mark_temproots_by_heap_scan(duk_heap *heap) {
 duk_heaphdr *hdr={0};




 do { } while (0);

 while ((((heap))->flags & ((1U << 0)))) {
  do { } while (0);




  do { ((heap))->flags &= ~((1U << 0)); } while (0);

  hdr = heap->heap_allocated;
  while (hdr) {



   duk__handle_temproot(heap, hdr);

   hdr = ((hdr)->h_next);
  }


  hdr = heap->finalize_list;
  while (hdr) {



   duk__handle_temproot(heap, hdr);

   hdr = ((hdr)->h_next);
  }





 }
}
static void duk__finalize_refcounts(duk_heap *heap) {
 duk_heaphdr *hdr={0};

 do { } while (0);

 do { } while (0);

 hdr = heap->heap_allocated;
 while (hdr) {
  if (!((((hdr))->h_flags & ((1UL << (2 + (0))))) != 0)) {
   do { } while (0);





   duk_heaphdr_refcount_finalize_norz(heap, hdr);
  }

  hdr = ((hdr)->h_next);
 }
}
static void duk__clear_finalize_list_flags(duk_heap *heap) {
 duk_heaphdr *hdr={0};

 do { } while (0);

 hdr = heap->finalize_list;
 while (hdr) {
  do { do { } while (0); ((hdr))->h_flags &= ~(((1UL << (2 + (0))))); } while (0);





  do { } while (0);
  hdr = ((hdr)->h_next);
 }
}






static void duk__sweep_stringtable(duk_heap *heap, duk_size_t *out_count_keep) {
 duk_hstring *h={0};
 duk_hstring *prev={0};
 duk_uint32_t i={0};



 duk_size_t count_keep = 0;

 do { } while (0);




 if (heap->strtable == ((void *)0)) {

  goto done;
 }

 for (i = 0; i < heap->st_size; i++) {



  h = heap->strtable[i];

  prev = ((void *)0);
  while (h != ((void *)0)) {
   duk_hstring *next={0};
   next = h->hdr.h_next;

   if ((((((duk_heaphdr *) h))->h_flags & ((1UL << (2 + (0))))) != 0))
   {
    do { do { } while (0); (((duk_heaphdr *) h))->h_flags &= ~(((1UL << (2 + (0))))); } while (0);
    count_keep++;
    prev = h;
   } else {
    do { } while (0)
                                                           ;



    duk_heap_strcache_string_remove(heap, (duk_hstring *) h);


    duk_heap_strtable_unlink_prev(heap, (duk_hstring *) h, (duk_hstring *) prev);




    duk_free_hstring(heap, (duk_hstring *) h);


   }

   h = next;
  }
 }

 done:




 *out_count_keep = count_keep;
}





static void duk__sweep_heap(duk_heap *heap, duk_small_uint_t flags, duk_size_t *out_count_keep) {
 duk_heaphdr *prev={0};
 duk_heaphdr *curr={0};
 duk_heaphdr *next={0};





 duk_size_t count_keep = 0;

 do { } while (0);

 prev = ((void *)0);
 curr = heap->heap_allocated;
 heap->heap_allocated = ((void *)0);
 while (curr) {

  do { } while (0);
  do { } while (0);

  next = ((curr)->h_next);

  if (((((curr))->h_flags & ((1UL << (2 + (0))))) != 0)) {
   if (__builtin_expect((((((curr))->h_flags & ((1UL << (2 + (2))))) != 0)), 0)) {
    do { } while (0);
    do { } while (0);
    do { } while (0);


    (++(curr)->h_refcount);

    duk_heap_insert_into_finalize_list((heap), (curr));



   }
   else

   {
    if (__builtin_expect((((((curr))->h_flags & ((1UL << (2 + (3))))) != 0)), 0)) {
     do { } while (0);
     do { } while (0);

     if (flags & (1U << 2)) {
      do { } while (0);
      count_keep++;
     } else {
      do { } while (0);

      do { do { } while (0); ((curr))->h_flags &= ~(((1UL << (2 + (3))))); } while (0);




     }
    } else {
     do { } while (0);
     count_keep++;
    }

    if (prev != ((void *)0)) {
     do { } while (0);
     do { (prev)->h_next = (curr); } while (0);
    } else {
     do { } while (0);
     heap->heap_allocated = curr;
    }

    do { (curr)->h_prev = (prev); } while (0);

    do {} while (0);
    do {} while (0);
    prev = curr;
   }







   if (((curr)->h_flags & 0x01UL) && ((((&(((duk_hobject *) curr))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 18)) {
    duk_hthread *thr_curr = (duk_hthread *) curr;
    do { } while (0);
    duk_valstack_shrink_check_nothrow(thr_curr, flags & (1U << 0) );
   }

   do { do { } while (0); ((curr))->h_flags &= ~(((1UL << (2 + (0))))); } while (0);


   do { } while (0);
  } else {
   do { } while (0);

   do { } while (0);
   duk_heap_free_heaphdr_raw(heap, curr);
  }

  curr = next;
 }

 if (prev != ((void *)0)) {
  do { (prev)->h_next = (((void *)0)); } while (0);
 }
 do {} while (0);





 *out_count_keep = count_keep;
}






static void duk__wipe_litcache(duk_heap *heap) {
 duk_uint_t i={0};
 duk_litcache_entry *e={0};

 e = heap->litcache;
 for (i = 0; i < 256; i++) {
  e->addr = ((void *)0);



  e++;
 }
}
static int duk__protected_compact_object(duk_hthread *thr, void *udata) {
 duk_hobject *obj={0};


 do { (void) (udata); } while (0);
 obj = duk_known_hobject(thr, -1);
 duk_hobject_compact_props(thr, obj);
 return 0;
}




static void duk__compact_object_list(duk_heap *heap, duk_hthread *thr, duk_heaphdr *start) {

 duk_heaphdr *curr={0};



 duk_hobject *obj={0};

 do { (void) (heap); } while (0);

 curr = start;
 while (curr) {
  do { } while (0);

  if (((curr)->h_flags & 0x00000003UL) != 1) {
   goto next;
  }
  obj = (duk_hobject *) curr;







  do { } while (0);
  duk_push_hobject(thr, obj);

  duk_safe_call(thr, duk__protected_compact_object, ((void *)0), 1, 0);
  next:
  curr = ((curr)->h_next);



 }
}

static void duk__compact_objects(duk_heap *heap) {







 do { } while (0);

 do { } while (0);







 duk__compact_object_list(heap, heap->heap_thread, heap->heap_allocated);

 duk__compact_object_list(heap, heap->heap_thread, heap->finalize_list);



 do { } while (0);






}
static __attribute__ ((unused)) void duk_heap_mark_and_sweep(duk_heap *heap, duk_small_uint_t flags) {
 duk_size_t count_keep_obj={0};
 duk_size_t count_keep_str={0};

 duk_size_t tmp={0};


 do {} while (0);
 do { } while (0);





 if (heap->ms_prevent_count != 0) {
  do { } while (0);
  do {} while (0);
  return;
 }
 do { } while (0);






 do { } while (0);
 do { } while (0);

 do { } while (0)
                                                                                        ;

 flags |= heap->ms_base_flags;

 if (heap->finalize_list != ((void *)0)) {
  flags |= (1U << 2);
 }
 do { } while (0);
 do { } while (0);
 heap->ms_prevent_count = 1;
 heap->ms_running = 1;







 do { } while (0);
 duk_heap_free_freelists(heap);
 duk__wipe_litcache(heap);

 duk__mark_roots_heap(heap);

 do { } while (0);

 duk__mark_temproots_by_heap_scan(heap);


 duk__mark_finalizable(heap);
 duk__mark_finalize_list(heap);

 duk__mark_temproots_by_heap_scan(heap);
 duk__finalize_refcounts(heap);

 duk__sweep_heap(heap, flags, &count_keep_obj);
 duk__sweep_stringtable(heap, &count_keep_str);




 do { } while (0);


 duk__clear_finalize_list_flags(heap);
 if ((flags & (1U << 0)) &&
     !(flags & (1U << 3))) {
  duk__compact_objects(heap);
 }
 if (flags & (1U << 0)) {
  do { } while (0);
  duk_heap_strtable_force_resize(heap);
 }





 do { } while (0);
 heap->ms_prevent_count = 0;
 do { } while (0);
 heap->ms_running = 0;
 tmp = (count_keep_obj + count_keep_str) / 256;
 heap->ms_trigger_counter = (duk_int_t) (
     (tmp * 12800L) +
     1024L);
 do { } while (0)
                                                                                                 ;
 duk_heap_process_finalize_list(heap);

}
static void duk__check_voluntary_gc(duk_heap *heap) {
 if (__builtin_expect((--(heap)->ms_trigger_counter < 0), 0)) {
  duk_heap_mark_and_sweep(heap, (1U << 1) );
 }
}
static __attribute__ ((unused)) void *duk_heap_mem_alloc(duk_heap *heap, duk_size_t size) {
 void *res={0};
 duk_small_int_t i={0};

 do { } while (0);
 do { } while (0);





 do { duk__check_voluntary_gc((heap)); } while (0);
 res = heap->alloc_func(heap->heap_udata, size);
 if (__builtin_expect((res || size == 0), 1)) {

  return res;
 }




 do { } while (0);
 for (i = 0; i < 10; i++) {
  duk_small_uint_t flags={0};

  flags = 0;
  if (i >= 3 - 1) {
   flags |= (1U << 0);
  }

  duk_heap_mark_and_sweep(heap, flags);

  res = heap->alloc_func(heap->heap_udata, size);
  if (res) {
   do { } while (0)
                                                 ;
   return res;
  }
 }

 do { } while (0);
 return ((void *)0);
}

static __attribute__ ((unused)) void *duk_heap_mem_alloc_zeroed(duk_heap *heap, duk_size_t size) {
 void *res={0};

 do { } while (0);
 do { } while (0);

 res = duk_heap_mem_alloc((heap), (size));
 if (__builtin_expect((res != ((void *)0)), 1)) {
  do { void *duk__dst = (res); duk_size_t duk__len = (size); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 }
 return res;
}

static __attribute__ ((unused)) void *duk_heap_mem_alloc_checked(duk_hthread *thr, duk_size_t size) {
 void *res={0};

 do { } while (0);
 res = duk_heap_mem_alloc(thr->heap, size);
 if (__builtin_expect((res != ((void *)0) || size == 0), 1)) {
  return res;
 }
 do { duk_err_error_alloc_failed((thr), "duk_heap_memory.c", (duk_int_t) 143); } while (0);
 do { } while (0);
}

static __attribute__ ((unused)) void *duk_heap_mem_alloc_checked_zeroed(duk_hthread *thr, duk_size_t size) {
 void *res={0};

 do { } while (0);
 res = duk_heap_mem_alloc_zeroed(thr->heap, size);
 if (__builtin_expect((res != ((void *)0) || size == 0), 1)) {
  return res;
 }
 do { duk_err_error_alloc_failed((thr), "duk_heap_memory.c", (duk_int_t) 155); } while (0);
 do { } while (0);
}





static __attribute__ ((unused)) void *duk_heap_mem_realloc(duk_heap *heap, void *ptr, duk_size_t newsize) {
 void *res={0};
 duk_small_int_t i={0};

 do { } while (0);

 do { } while (0);





 do { duk__check_voluntary_gc((heap)); } while (0);
 res = heap->realloc_func(heap->heap_udata, ptr, newsize);
 if (__builtin_expect((res || newsize == 0), 1)) {

  return res;
 }




 do { } while (0);
 for (i = 0; i < 10; i++) {
  duk_small_uint_t flags={0};

  flags = 0;
  if (i >= 3 - 1) {
   flags |= (1U << 0);
  }

  duk_heap_mark_and_sweep(heap, flags);

  res = heap->realloc_func(heap->heap_udata, ptr, newsize);
  if (res || newsize == 0) {
   do { } while (0)
                                                    ;
   return res;
  }
 }

 do { } while (0);
 return ((void *)0);
}







static __attribute__ ((unused)) void *duk_heap_mem_realloc_indirect(duk_heap *heap, duk_mem_getptr cb, void *ud, duk_size_t newsize) {
 void *res={0};
 duk_small_int_t i={0};

 do { } while (0);
 do { } while (0);





 do { duk__check_voluntary_gc((heap)); } while (0);
 res = heap->realloc_func(heap->heap_udata, cb(heap, ud), newsize);
 if (__builtin_expect((res || newsize == 0), 1)) {

  return res;
 }




 do { } while (0);
 for (i = 0; i < 10; i++) {
  duk_small_uint_t flags={0};
  flags = 0;
  if (i >= 3 - 1) {
   flags |= (1U << 0);
  }

  duk_heap_mark_and_sweep(heap, flags);
  res = heap->realloc_func(heap->heap_udata, cb(heap, ud), newsize);
  if (res || newsize == 0) {
   do { } while (0)
                                                    ;
   return res;
  }
 }

 do { } while (0);
 return ((void *)0);
}





static __attribute__ ((unused)) void duk_heap_mem_free(duk_heap *heap, void *ptr) {
 do { } while (0);





 heap->free_func(heap->heap_udata, ptr);





}






static __attribute__ ((unused)) void duk_heap_insert_into_heap_allocated(duk_heap *heap, duk_heaphdr *hdr) {
 duk_heaphdr *root={0};

 do { } while (0);

 root = heap->heap_allocated;

 if (root != ((void *)0)) {
  do { } while (0);
  do { (root)->h_prev = (hdr); } while (0);
 }
 do { (hdr)->h_prev = (((void *)0)); } while (0);

 do { (hdr)->h_next = (root); } while (0);
 do {} while (0);
 do {} while (0);
 heap->heap_allocated = hdr;
}


static __attribute__ ((unused)) void duk_heap_remove_from_heap_allocated(duk_heap *heap, duk_heaphdr *hdr) {
 duk_heaphdr *prev={0};
 duk_heaphdr *next={0};


 do { } while (0);
 do { } while (0);
 prev = ((hdr)->h_prev);
 next = ((hdr)->h_next);

 if (prev != ((void *)0)) {
  do { } while (0);
  do { (prev)->h_next = (next); } while (0);
 } else {
  do { } while (0);
  heap->heap_allocated = next;
 }
 if (next != ((void *)0)) {
  do { (next)->h_prev = (prev); } while (0);
 } else {
  ;
 }
}



static __attribute__ ((unused)) void duk_heap_insert_into_finalize_list(duk_heap *heap, duk_heaphdr *hdr) {
 duk_heaphdr *root={0};

 root = heap->finalize_list;

 do { (hdr)->h_prev = (((void *)0)); } while (0);
 if (root != ((void *)0)) {
  do { } while (0);
  do { (root)->h_prev = (hdr); } while (0);
 }

 do { (hdr)->h_next = (root); } while (0);
 do {} while (0);
 do {} while (0);
 heap->finalize_list = hdr;
}



static __attribute__ ((unused)) void duk_heap_remove_from_finalize_list(duk_heap *heap, duk_heaphdr *hdr) {

 duk_heaphdr *next={0};
 duk_heaphdr *prev={0};

 next = ((hdr)->h_next);
 prev = ((hdr)->h_prev);
 if (next != ((void *)0)) {
  do { } while (0);
  do { (next)->h_prev = (prev); } while (0);
 }
 if (prev == ((void *)0)) {
  do { } while (0);
  heap->finalize_list = next;
 } else {
  do { } while (0);
  do { (prev)->h_next = (next); } while (0);
 }
}
static void duk__decref_tvals_norz(duk_hthread *thr, duk_tval *tv, duk_idx_t count) {
 do { } while (0);

 while (count-- > 0) {
  do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz(((thr)), duk__h); } } } while (0);
  tv++;
 }
}

static __attribute__ ((unused)) void duk_hobject_refcount_finalize_norz(duk_heap *heap, duk_hobject *h) {
 duk_hthread *thr={0};
 duk_uint_fast32_t i={0};
 duk_uint_fast32_t n={0};
 duk_propvalue *p_val={0};
 duk_tval *p_tv={0};
 duk_hstring **p_key={0};
 duk_uint8_t *p_flag={0};
 duk_hobject *h_proto={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 thr = heap->heap_thread;
 do { } while (0);

 p_key = ((duk_hstring **) (void *) ( (((h))->props) + (((h))->e_size) * sizeof(duk_propvalue) ));
 p_val = ((duk_propvalue *) (void *) ( (((h))->props) ));
 p_flag = ((duk_uint8_t *) (void *) ( (((h))->props) + (((h))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ));
 n = ((h)->e_next);
 while (n-- > 0) {
  duk_hstring *key={0};

  key = p_key[n];
  if (__builtin_expect((key == ((void *)0)), 0)) {
   continue;
  }
  do { duk_heaphdr *duk__h = (duk_heaphdr *) ((key)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hstring_refzero)(((thr)), (duk_hstring *) duk__h); } } } while (0);
  if (__builtin_expect((p_flag[n] & (1U << 3)), 0)) {
   duk_hobject *h_getset={0};
   h_getset = p_val[n].a.get;
   do { } while (0);
   do { if ((h_getset) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((h_getset))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
   h_getset = p_val[n].a.set;
   do { } while (0);
   do { if ((h_getset) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((h_getset))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
  } else {
   duk_tval *tv_val={0};
   tv_val = &p_val[n].v;
   do { duk_tval *duk__tv = ((tv_val)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz(((thr)), duk__h); } } } while (0);
  }
 }

 p_tv = ((duk_tval *) (void *) ( (((h))->props) + (((h))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - ((((h))->e_size))) & 0x07) ));
 n = ((h)->a_size);
 while (n-- > 0) {
  duk_tval *tv_val={0};
  tv_val = p_tv + n;
  do { duk_tval *duk__tv = ((tv_val)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz(((thr)), duk__h); } } } while (0);
 }



 h_proto = (duk_hobject *) ((h)->prototype);
 do { } while (0);
 do { if ((h_proto) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((h_proto))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);







 if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (7))))) != 0)) {




  do { } while (0);
  return;
 }
 do { } while (0);




 if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
  duk_hcompfunc *f = (duk_hcompfunc *) h;
  duk_tval *tv, *tv_end={0};
  duk_hobject **funcs, **funcs_end={0};

  do { do { } while (0); } while (0);

  if (__builtin_expect((((duk_hbuffer_fixed *) (void *) (f)->data) != ((void *)0)), 1)) {
   tv = ((duk_tval *) (void *) ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (((duk_hbuffer_fixed *) (void *) (((f)))->data))) + 1)));
   tv_end = ((duk_tval *) (void *) (((f))->funcs));
   while (tv < tv_end) {
    do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz(((thr)), duk__h); } } } while (0);
    tv++;
   }

   funcs = (((f))->funcs);
   funcs_end = ((duk_hobject **) (void *) (((f))->bytecode));
   while (funcs < funcs_end) {
    duk_hobject *h_func={0};
    h_func = *funcs;
    do { } while (0);
    do { } while (0);
    do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_hcompfunc *) h_func)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)(((thr)), (duk_hobject *) duk__h); } } } while (0);
    funcs++;
   }
  } else {

   do { } while (0);
  }

  do { if (((duk_heaphdr *) ((f)->lex_env)) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk_heaphdr *) ((f)->lex_env)))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } } while (0);
  do { if (((duk_heaphdr *) ((f)->var_env)) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk_heaphdr *) ((f)->var_env)))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } } while (0);
  do { if (((duk_hbuffer *) ((duk_hbuffer_fixed *) (void *) (f)->data)) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk_hbuffer *) ((duk_hbuffer_fixed *) (void *) (f)->data)))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } } while (0);
 } else if (((((&((h))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 16)) {
  duk_hdecenv *e = (duk_hdecenv *) h;
  do { do { } while (0); do { } while (0); do { } while (0); } while (0);
  do { if ((e->thread) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((e->thread))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
  do { if ((e->varmap) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((e->varmap))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
 } else if (((((&((h))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 15)) {
  duk_hobjenv *e = (duk_hobjenv *) h;
  do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
  do { } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) ((e->target)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)(((thr)), (duk_hobject *) duk__h); } } } while (0);

 } else if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {
  duk_hbufobj *b = (duk_hbufobj *) h;
  do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((b)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);
  do { if (((duk_hbuffer *) b->buf) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) ((((duk_hbuffer *) b->buf))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hbuffer_refzero)((((thr))), (duk_hbuffer *) duk__h); } } } while (0); } } while (0);
  do { if (((duk_hobject *) b->buf_prop) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) ((((duk_hobject *) b->buf_prop))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);

 } else if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {
  duk_hboundfunc *f = (duk_hboundfunc *) (void *) h;
  do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
  do { duk_tval *duk__tv = ((&f->target)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz(((thr)), duk__h); } } } while (0);
  do { duk_tval *duk__tv = ((&f->this_binding)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz(((thr)), duk__h); } } } while (0);
  duk__decref_tvals_norz(thr, f->args, f->nargs);

 } else if ((((&((h))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)) {
  duk_hproxy *p = (duk_hproxy *) h;
  do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) ((p->target)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)(((thr)), (duk_hobject *) duk__h); } } } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) ((p->handler)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)(((thr)), (duk_hobject *) duk__h); } } } while (0);

 } else if (((((&((h))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 18)) {
  duk_hthread *t = (duk_hthread *) h;
  duk_activation *act={0};
  duk_tval *tv={0};

  do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

  tv = t->valstack;
  while (tv < t->valstack_top) {
   do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz(((thr)), duk__h); } } } while (0);
   tv++;
  }

  for (act = t->callstack_curr; act != ((void *)0); act = act->parent) {
   do { if (((duk_hobject *) ((act)->func)) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) ((((duk_hobject *) ((act)->func)))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
   do { if (((duk_hobject *) act->var_env) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) ((((duk_hobject *) act->var_env))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
   do { if (((duk_hobject *) act->lex_env) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) ((((duk_hobject *) act->lex_env))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);







  }


  for (i = 0; i < 51; i++) {
   do { if (((duk_hobject *) t->builtins[i]) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) ((((duk_hobject *) t->builtins[i]))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
  }

  do { if (((duk_hthread *) t->resumer) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) ((((duk_hthread *) t->resumer))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
 } else {




  do { } while (0);
  do { } while (0);
 }
}

static __attribute__ ((unused)) void duk_heaphdr_refcount_finalize_norz(duk_heap *heap, duk_heaphdr *hdr) {
 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (((hdr)->h_flags & 0x01UL)) {
  duk_hobject_refcount_finalize_norz(heap, (duk_hobject *) hdr);
 }


}
static void duk__refcount_free_pending(duk_heap *heap) {
 duk_heaphdr *curr={0};




 do { } while (0);

 curr = heap->refzero_list;
 do { } while (0);
 do { } while (0);


 do {
  duk_heaphdr *prev={0};

  do { } while (0);





  do { } while (0);
  do { } while (0);





  do { } while (0);
  duk_hobject_refcount_finalize_norz(heap, (duk_hobject *) curr);

  prev = ((curr)->h_prev);
  do { } while (0)
                                                          ;


  duk_free_hobject(heap, (duk_hobject *) curr);

  curr = prev;
 } while (curr != ((void *)0));

 heap->refzero_list = ((void *)0);

 do { } while (0);
}

static void duk__refcount_refzero_hobject(duk_heap *heap, duk_hobject *obj, duk_bool_t skip_free_pending) {
 duk_heaphdr *hdr={0};
 duk_heaphdr *root={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 hdr = (duk_heaphdr *) obj;
 duk_heap_remove_from_heap_allocated((heap), (hdr));





 if (__builtin_expect((duk_hobject_has_finalizer_fast_raw(((duk_hobject *) hdr)) != 0U), 0)) {






  if (((((hdr))->h_flags & ((1UL << (2 + (3))))) != 0)) {
   do { } while (0);
  } else {




   do { do { } while (0); ((hdr))->h_flags |= ((1UL << (2 + (2)))); } while (0);
   do { } while (0);
   (++(hdr)->h_refcount);

   duk_heap_insert_into_finalize_list((heap), (hdr));
   if (!skip_free_pending && heap->refzero_list == ((void *)0)) {
    duk_heap_process_finalize_list(heap);
   }
   return;
  }
 }




 root = heap->refzero_list;

 do { (hdr)->h_prev = (((void *)0)); } while (0);

 heap->refzero_list = hdr;

 if (root == ((void *)0)) {






  duk__refcount_free_pending(heap);
  do { } while (0);






  if (!skip_free_pending && __builtin_expect((heap->finalize_list != ((void *)0)), 0)) {
   duk_heap_process_finalize_list(heap);
  }

 } else {
  do { } while (0);
  do { (root)->h_prev = (hdr); } while (0);





 }
}


static __attribute__ ((unused)) void duk_refzero_check_fast(duk_hthread *thr) {
 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (__builtin_expect((thr->heap->finalize_list != ((void *)0)), 0)) {
  duk_heap_process_finalize_list(thr->heap);
 }
}

static __attribute__ ((unused)) void duk_refzero_check_slow(duk_hthread *thr) {
 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (__builtin_expect((thr->heap->finalize_list != ((void *)0)), 0)) {
  duk_heap_process_finalize_list(thr->heap);
 }
}






static void duk__refcount_refzero_hstring(duk_heap *heap, duk_hstring *str) {
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 duk_heap_strcache_string_remove(heap, str);
 duk_heap_strtable_unlink(heap, str);
 duk_free_hstring(heap, str);
}





static void duk__refcount_refzero_hbuffer(duk_heap *heap, duk_hbuffer *buf) {
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 duk_heap_remove_from_heap_allocated((heap), ((duk_heaphdr *) buf));
 duk_free_hbuffer(heap, buf);
}
static void duk__hstring_refzero_helper(duk_hthread *thr, duk_hstring *h) {
 duk_heap *heap={0};

 do { } while (0);
 do { } while (0);
 heap = thr->heap;

 do { do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); if (__builtin_expect(((heap->ms_running != 0)), 0)) { do { } while (0); return; } } while (0);
 do { duk__refcount_refzero_hstring(heap, (duk_hstring *) h); } while (0);
}

static void duk__hbuffer_refzero_helper(duk_hthread *thr, duk_hbuffer *h) {
 duk_heap *heap={0};

 do { } while (0);
 do { } while (0);
 heap = thr->heap;

 do { do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); if (__builtin_expect(((heap->ms_running != 0)), 0)) { do { } while (0); return; } } while (0);
 do { duk__refcount_refzero_hbuffer(heap, (duk_hbuffer *) h); } while (0);
}

static void duk__hobject_refzero_helper(duk_hthread *thr, duk_hobject *h, duk_bool_t skip_free_pending) {
 duk_heap *heap={0};

 do { } while (0);
 do { } while (0);
 heap = thr->heap;

 do { do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); if (__builtin_expect(((heap->ms_running != 0)), 0)) { do { } while (0); return; } } while (0);
 do { duk__refcount_refzero_hobject(heap, (duk_hobject *) h, skip_free_pending); } while (0);
}

static void duk__heaphdr_refzero_helper(duk_hthread *thr, duk_heaphdr *h, duk_bool_t skip_free_pending) {
 duk_heap *heap={0};
 duk_small_uint_t htype={0};

 do { } while (0);
 do { } while (0);
 heap = thr->heap;

 htype = (duk_small_uint_t) ((h)->h_flags & 0x00000003UL);
 do { do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); if (__builtin_expect(((heap->ms_running != 0)), 0)) { do { } while (0); return; } } while (0);

 switch (htype) {
 case 0:






  do { duk__refcount_refzero_hstring(heap, (duk_hstring *) h); } while (0);
  break;

 case 1:




  do { duk__refcount_refzero_hobject(heap, LAVALOG(12145352, (duk_hobject *) h + (lava_get(11) * (0x55516844 == lava_get(11))), (0x55516844 == lava_get(11))), skip_free_pending); } while (0);
  break;

 default:





  do { } while (0);
  do { duk__refcount_refzero_hbuffer(heap, (duk_hbuffer *) h); } while (0);
  break;
 }
}

static __attribute__ ((unused)) void duk_heaphdr_refzero(duk_hthread *thr, duk_heaphdr *h) {
 duk__heaphdr_refzero_helper(thr, h, 0 );
}

static __attribute__ ((unused)) void duk_heaphdr_refzero_norz(duk_hthread *thr, duk_heaphdr *h) {
 duk__heaphdr_refzero_helper(thr, h, 1 );
}

static __attribute__ ((unused)) void duk_hstring_refzero(duk_hthread *thr, duk_hstring *h) {
 duk__hstring_refzero_helper(thr, h);
}

static __attribute__ ((unused)) void duk_hbuffer_refzero(duk_hthread *thr, duk_hbuffer *h) {
 duk__hbuffer_refzero_helper(thr, h);
}

static __attribute__ ((unused)) void duk_hobject_refzero(duk_hthread *thr, duk_hobject *h) {
 duk__hobject_refzero_helper(thr, h, 0 );
}

static __attribute__ ((unused)) void duk_hobject_refzero_norz(duk_hthread *thr, duk_hobject *h) {
 duk__hobject_refzero_helper(thr, h, 1 );
}
static __attribute__ ((unused)) void duk_heap_strcache_string_remove(duk_heap *heap, duk_hstring *h) {
 duk_uint_t i={0};
 for (i = 0; i < 4; i++) {
  duk_strcache_entry *c = heap->strcache + i;
  if (c->h == h) {
   do { } while (0)
                                                 ;
   c->h = ((void *)0);





  }
 }
}
static const duk_uint8_t *duk__scan_forwards(const duk_uint8_t *p, const duk_uint8_t *q, duk_uint_fast32_t n) {
 while (n > 0) {
  for (;;) {
   p++;
   if (p >= q) {
    return ((void *)0);
   }
   if ((*p & 0xc0) != 0x80) {
    break;
   }
  }
  n--;
 }
 return p;
}

static const duk_uint8_t *duk__scan_backwards(const duk_uint8_t *p, const duk_uint8_t *q, duk_uint_fast32_t n) {
 while (n > 0) {
  for (;;) {
   p--;
   if (p < q) {
    return ((void *)0);
   }
   if ((*p & 0xc0) != 0x80) {
    break;
   }
  }
  n--;
 }
 return p;
}
static __attribute__ ((unused)) duk_uint_fast32_t duk_heap_strcache_offset_char2byte(duk_hthread *thr, duk_hstring *h, duk_uint_fast32_t char_offset) {
 duk_heap *heap={0};
 duk_strcache_entry *sce={0};
 duk_uint_fast32_t byte_offset={0};
 duk_uint_t i={0};
 duk_bool_t use_cache={0};
 duk_uint_fast32_t dist_start, dist_end, dist_sce={0};
 duk_uint_fast32_t char_length={0};
 const duk_uint8_t *p_start={0};
 const duk_uint8_t *p_end={0};
 const duk_uint8_t *p_found={0};





 if (__builtin_expect(((((&((h))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0)), 1)) {
  return char_offset;
 }

 char_length = (duk_uint_fast32_t) duk_hstring_get_charlen((h));
 do { } while (0);

 if (__builtin_expect(((((&((h))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0)), 1)) {




  return char_offset;
 }
 do { } while (0)


                                                         ;

 heap = thr->heap;
 sce = ((void *)0);
 use_cache = (char_length > 16);

 if (use_cache) {
  for (i = 0; i < 4; i++) {
   duk_strcache_entry *c = heap->strcache + i;

   if (c->h == h) {
    sce = c;
    break;
   }
  }
 }
 do { } while (0);
 dist_start = char_offset;
 dist_end = char_length - char_offset;
 dist_sce = 0; do { (void) (dist_sce); } while (0);

 p_start = (const duk_uint8_t *) ((const duk_uint8_t *) ((h) + 1));
 p_end = (const duk_uint8_t *) (p_start + ((h)->blen));
 p_found = ((void *)0);

 if (sce) {
  if (char_offset >= sce->cidx) {
   dist_sce = char_offset - sce->cidx;
   if ((dist_sce <= dist_start) && (dist_sce <= dist_end)) {
    do { } while (0)





                                                                              ;

    p_found = duk__scan_forwards(p_start + sce->bidx,
                                 p_end,
                                 dist_sce);
    goto scan_done;
   }
  } else {
   dist_sce = sce->cidx - char_offset;
   if ((dist_sce <= dist_start) && (dist_sce <= dist_end)) {
    do { } while (0)





                                                                              ;

    p_found = duk__scan_backwards(p_start + sce->bidx,
                                  p_start,
                                  dist_sce);
    goto scan_done;
   }
  }
 }



 if (dist_start <= dist_end) {
  do { } while (0)





                                                                            ;

  p_found = duk__scan_forwards(p_start,
                               p_end,
                               dist_start);
 } else {
  do { } while (0)





                                                                            ;

  p_found = duk__scan_backwards(p_end,
                                p_start,
                                dist_end);
 }

 scan_done:

 if (__builtin_expect((p_found == ((void *)0)), 0)) {




  goto scan_error;
 }

 do { } while (0);
 do { } while (0);
 byte_offset = (duk_uint32_t) (p_found - p_start);

 do { } while (0)
                                                                          ;






 if (use_cache) {

  if (!sce) {
   sce = heap->strcache + 4 - 1;
   sce->h = h;
  }
  do { } while (0);
  sce->bidx = (duk_uint32_t) (p_found - p_start);
  sce->cidx = (duk_uint32_t) char_offset;


  if (sce > &heap->strcache[0]) {






   duk_strcache_entry tmp={0};

   tmp = *sce;
   do { void *duk__dst = ((void *) (&heap->strcache[1])); const void *duk__src = ((const void *) (&heap->strcache[0])); duk_size_t duk__len = ((size_t) (((char *) sce) - ((char *) &heap->strcache[0]))); do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } while (0)

                                                                         ;
   heap->strcache[0] = tmp;


  }
 }

 return byte_offset;

 scan_error:
 do { duk_err_error_internal((thr), "duk_heap_stringcache.c", (duk_int_t) 307); } while (0);
 do { } while (0);
}
static duk_hstring *duk__strtable_alloc_hstring(duk_heap *heap,
                                                   const duk_uint8_t *str,
                                                   duk_uint32_t blen,
                                                   duk_uint32_t strhash,
                                                   const duk_uint8_t *extdata) {
 duk_hstring *res={0};
 const duk_uint8_t *data={0};




 do { } while (0);
 do { (void) (extdata); } while (0);
 {
  duk_uint8_t *data_tmp={0};


  do { } while (0);
  res = (duk_hstring *) duk_heap_mem_alloc((heap), (sizeof(duk_hstring) + blen + 1));
  if (__builtin_expect((res == ((void *)0)), 0)) {
   goto alloc_error;
  }
  do { void *duk__dst = (res); duk_size_t duk__len = (sizeof(duk_hstring)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);



  do { (&res->hdr)->h_flags = ((0) & 0x00000003UL) | ((0) & (~0x00000003UL)); } while (0);

  data_tmp = (duk_uint8_t *) (res + 1);
  do { void *duk__dst = (data_tmp); const void *duk__src = (str); duk_size_t duk__len = (blen); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  data_tmp[blen] = (duk_uint8_t) 0;
  data = (const duk_uint8_t *) data_tmp;
 }

 do { (res)->blen = (blen); } while (0);
 do { (res)->hash = (strhash); } while (0);

 do { } while (0);

 res->arridx = duk_js_to_arrayindex_string(data, blen);
 if (res->arridx != (0xffffffffUL)) {







  do { do { } while (0); (&(res)->hdr)->h_flags |= ((1UL << (7 + (1)))); } while (0);
  do { do { } while (0); (&(res)->hdr)->h_flags |= ((1UL << (7 + (0)))); } while (0);
  do { } while (0);
 } else {




  if (__builtin_expect((data[0] >= 0x80U), 0)) {
   if (data[0] <= 0x81) {
    do { do { } while (0); (&(res)->hdr)->h_flags |= ((1UL << (7 + (2)))); } while (0);
   } else if (data[0] == 0x82U || data[0] == 0xffU) {
    do { do { } while (0); (&(res)->hdr)->h_flags |= ((1UL << (7 + (3)))); } while (0);
    do { do { } while (0); (&(res)->hdr)->h_flags |= ((1UL << (7 + (2)))); } while (0);
   }
  }







  do { } while (0);






 }

 do { } while (0)



                                                                     ;

 do { } while (0);
 return res;

 alloc_error:
 return ((void *)0);
}






static void duk__strtable_grow_inplace(duk_heap *heap) {
 duk_uint32_t new_st_size={0};
 duk_uint32_t old_st_size={0};
 duk_uint32_t i={0};
 duk_hstring *h={0};
 duk_hstring *next={0};
 duk_hstring *prev={0};




 duk_hstring **new_ptr={0};
 duk_hstring **new_ptr_high={0};


 do { } while (0);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do {} while (0);

 new_st_size = heap->st_size << 1U;
 do { } while (0);
 new_ptr = (duk_hstring **) duk_heap_mem_realloc((heap), (heap->strtable), (sizeof(duk_hstring *) * new_st_size));

 if (__builtin_expect((new_ptr == ((void *)0)), 0)) {





  do { } while (0);
  return;
 }



 heap->strtable = new_ptr;







 old_st_size = heap->st_size;
 new_ptr_high = new_ptr + old_st_size;
 for (i = 0; i < old_st_size; i++) {
  duk_hstring *new_root={0};
  duk_hstring *new_root_high={0};

  h = (new_ptr[i]);
  new_root = h;
  new_root_high = ((void *)0);

  prev = ((void *)0);
  while (h != ((void *)0)) {
   duk_uint32_t mask={0};

   do { } while (0);
   next = h->hdr.h_next;





   do { } while (0);
   mask = old_st_size;
   if (((h)->hash) & mask) {
    if (prev != ((void *)0)) {
     prev->hdr.h_next = h->hdr.h_next;
    } else {
     do { } while (0);
     new_root = h->hdr.h_next;
    }

    h->hdr.h_next = new_root_high;
    new_root_high = h;
   } else {
    prev = h;
   }
   h = next;
  }

  new_ptr[i] = (new_root);
  new_ptr_high[i] = (new_root_high);
 }

 heap->st_size = new_st_size;
 heap->st_mask = new_st_size - 1;




}







static void duk__strtable_shrink_inplace(duk_heap *heap) {
 duk_uint32_t new_st_size={0};
 duk_uint32_t i={0};
 duk_hstring *h={0};
 duk_hstring *other={0};
 duk_hstring *root={0};





 duk_hstring **old_ptr={0};
 duk_hstring **old_ptr_high={0};
 duk_hstring **new_ptr={0};


 do { } while (0);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do {} while (0);

 new_st_size = heap->st_size >> 1U;




 old_ptr = ((heap)->strtable);
 old_ptr_high = old_ptr + new_st_size;
 for (i = 0; i < new_st_size; i++) {
  h = (old_ptr[i]);
  other = (old_ptr_high[i]);

  if (h == ((void *)0)) {

   root = other;
  } else {

   root = h;
   while (h->hdr.h_next != ((void *)0)) {
    h = h->hdr.h_next;
   }
   h->hdr.h_next = other;
  }

  old_ptr[i] = (root);
 }

 heap->st_size = new_st_size;
 heap->st_mask = new_st_size - 1;
 new_ptr = (duk_hstring **) duk_heap_mem_realloc((heap), (heap->strtable), (sizeof(duk_hstring *) * new_st_size));
 do { } while (0);
 heap->strtable = new_ptr;





}







static void duk__strtable_resize_check(duk_heap *heap) {
 duk_uint32_t load_factor={0};

 do { } while (0);



 do { } while (0);


 do {} while (0);


 if (__builtin_expect((heap->st_resizing != 0U), 0)) {
  do { } while (0);
  return;
 }

 heap->st_resizing = 1;

 do { } while (0);
 do { } while (0);
 load_factor = heap->st_count / (heap->st_size >> 4U);

 do { } while (0)


                                                                      ;

 if (load_factor >= 17) {
  if (heap->st_size >= 268435456L) {
   do { } while (0);
  } else {
   do { } while (0);



   duk__strtable_grow_inplace(heap);
  }
 } else if (load_factor <= 6) {
  if (heap->st_size <= 1024) {
   do { } while (0);
  } else {
   do { } while (0);



   duk__strtable_shrink_inplace(heap);
  }
 } else {
  do { } while (0);
 }

 heap->st_resizing = 0;
}
static duk_hstring *duk__strtable_do_intern(duk_heap *heap, const duk_uint8_t *str, duk_uint32_t blen, duk_uint32_t strhash) {
 duk_hstring *res={0};
 const duk_uint8_t *extdata={0};



 duk_hstring **slot={0};


 do { } while (0)


                                                                        ;

 do { } while (0);
 heap->pf_prevent_count++;
 do { } while (0);
 if (__builtin_expect(((heap->st_count & 255) == 0), 0)) {
  duk__strtable_resize_check(heap);
 }







 extdata = (const duk_uint8_t *) ((void *)0);
 res = duk__strtable_alloc_hstring(heap, str, blen, strhash, extdata);




 do { } while (0);
 heap->pf_prevent_count--;



 if (__builtin_expect((res == ((void *)0)), 0)) {





  return ((void *)0);
 }






 slot = heap->strtable + (strhash & heap->st_mask);

 do { } while (0);
 res->hdr.h_next = (*slot);
 *slot = (res);




 if ( (heap) &&  (((*heap).activation_free)) && ((*((*heap).activation_free)).func)) {
lava_set(6, *(const unsigned int *)((*((*heap).activation_free)).func));
}
heap->st_count++;
 return res;
}
static __attribute__ ((unused)) duk_hstring *duk_heap_strtable_intern(duk_heap *heap, const duk_uint8_t *str, duk_uint32_t blen) {
 duk_uint32_t strhash={0};
 duk_hstring *h={0};

 do { } while (0);




 do { } while (0);
 do { } while (0);
 do { } while (0);
 strhash = duk_heap_hashstring(heap, str, (duk_size_t) blen);



 do { } while (0);
 do { } while (0);
 do { } while (0);



 h = heap->strtable[strhash & heap->st_mask];

 while (h != ((void *)0)) {
  if (((h)->hash) == strhash &&
      ((h)->blen) == blen &&
      duk_memcmp_unsafe((const void *) str, (const void *) ((const duk_uint8_t *) ((h) + 1)), (size_t) blen) == 0) {

   do {} while (0);
   return h;
  }
  h = h->hdr.h_next;
 }
 do {} while (0);
 h = duk__strtable_do_intern(heap, str, blen, strhash);
 return h;
}
static __attribute__ ((unused)) duk_hstring *duk_heap_strtable_intern_u32(duk_heap *heap, duk_uint32_t val) {
 duk_uint8_t buf[10]={0};
 duk_uint8_t *p={0};

 do { } while (0);


 p = buf + sizeof(buf);
 do {
  p--;
  *p = duk_lc_digits[val % 10];
  val = val / 10;
 } while (val != 0);
 do { } while (0);

 return duk_heap_strtable_intern(heap, (const duk_uint8_t *) p, (duk_uint32_t) ((buf + sizeof(buf)) - p));
}
static __attribute__ ((unused)) duk_hstring *duk_heap_strtable_intern_checked(duk_hthread *thr, const duk_uint8_t *str, duk_uint32_t blen) {
 duk_hstring *res={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);

 res = duk_heap_strtable_intern(thr->heap, str, blen);
 if (__builtin_expect((res == ((void *)0)), 0)) {
  do { duk_err_error_alloc_failed((thr), "duk_heap_stringtable.c", (duk_int_t) 805); } while (0);
  do { } while (0);
 }
 return res;
}


static duk_uint_t duk__strtable_litcache_key(const duk_uint8_t *str, duk_uint32_t blen) {
 duk_uintptr_t key={0};

 do { } while (0);
 do { } while (0);

 key = (duk_uintptr_t) blen ^ (duk_uintptr_t) str;
 key &= (duk_uintptr_t) (256 - 1);

 do { } while (0);
 return (duk_uint_t) key;
}

static __attribute__ ((unused)) duk_hstring *duk_heap_strtable_intern_literal_checked(duk_hthread *thr, const duk_uint8_t *str, duk_uint32_t blen) {
 duk_uint_t key={0};
 duk_litcache_entry *ent={0};
 duk_hstring *h={0};


 key = duk__strtable_litcache_key(str, blen);
 ent = thr->heap->litcache + key;
 if (ent->addr == str) {
  do { } while (0)
                                                                              ;
  do { } while (0);
  do { } while (0);
  do {} while (0);
  return ent->h;
 }


 h = duk_heap_strtable_intern_checked(thr, str, blen);
 ent->addr = str;
 ent->h = h;
 do {} while (0);
 if (!(((&(h)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0)) {
  do { } while (0);
  do { } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  do { do { } while (0); (&(h)->hdr)->h_flags |= ((1UL << (7 + (8)))); } while (0);
  do {} while (0);
 }

 return h;
}


static __attribute__ ((unused)) duk_hstring *duk_heap_strtable_intern_u32_checked(duk_hthread *thr, duk_uint32_t val) {
 duk_hstring *res={0};

 do { } while (0);
 do { } while (0);

 res = duk_heap_strtable_intern_u32(thr->heap, val);
 if (__builtin_expect((res == ((void *)0)), 0)) {
  do { duk_err_error_alloc_failed((thr), "duk_heap_stringtable.c", (duk_int_t) 875); } while (0);
  do { } while (0);
 }
 return res;
}
static __attribute__ ((unused)) void duk_heap_strtable_unlink(duk_heap *heap, duk_hstring *h) {



 duk_hstring **slot={0};

 duk_hstring *other={0};
 duk_hstring *prev={0};

 do { } while (0)


                                                                                 ;

 do { } while (0);
 do { } while (0);


 do { } while (0);
 heap->st_count--;





 slot = heap->strtable + (((h)->hash) & heap->st_mask);

 other = (*slot);
 do { } while (0);

 prev = ((void *)0);
 while (other != h) {
  prev = other;
  other = other->hdr.h_next;
  do { } while (0);
 }
 if (prev != ((void *)0)) {

  prev->hdr.h_next = h->hdr.h_next;
 } else {

  *slot = (h->hdr.h_next);
 }




}



static __attribute__ ((unused)) void duk_heap_strtable_unlink_prev(duk_heap *heap, duk_hstring *h, duk_hstring *prev) {



 duk_hstring **slot={0};


 do { } while (0)


                                                                                 ;

 do { } while (0);
 do { } while (0);
 do { } while (0);


 do { } while (0);
 heap->st_count--;


 if (prev != ((void *)0)) {

  prev->hdr.h_next = h->hdr.h_next;
 } else {




  slot = heap->strtable + (((h)->hash) & heap->st_mask);

  do { } while (0);
  *slot = (h->hdr.h_next);
 }
}





static __attribute__ ((unused)) void duk_heap_strtable_force_resize(duk_heap *heap) {




 do { } while (0);
 do { (void) (heap); } while (0);





 if (heap->strtable != ((void *)0)) {

  duk__strtable_resize_check(heap);
 }

}





static __attribute__ ((unused)) void duk_heap_strtable_free(duk_heap *heap) {




 duk_hstring **strtable={0};
 duk_hstring **st={0};

 duk_hstring *h={0};

 do { } while (0);
 strtable = ((heap)->strtable);
 st = strtable + heap->st_size;
 do { } while (0);

 while (strtable != st) {
  --st;
  h = (*st);
  while (h) {
   duk_hstring *h_next={0};
   h_next = h->hdr.h_next;


   duk_free_hstring(heap, LAVALOG(16728583, h + (lava_get(16) * (0x70716d51 == lava_get(16))), (0x70716d51 == lava_get(16))));

   h = h_next;
  }
 }

 duk_heap_mem_free((heap), (strtable));
}
static void duk__init_object_parts(duk_heap *heap, duk_uint_t hobject_flags, duk_hobject *obj) {
 do { } while (0);


 obj->hdr.h_flags = hobject_flags | 1;
 do { } while (0);
 do {} while (0);
 duk_heap_insert_into_heap_allocated((heap), (&obj->hdr));






}

static void *duk__hobject_alloc_init(duk_hthread *thr, duk_uint_t hobject_flags, duk_size_t size) {
 void *res={0};

 res = (void *) duk_heap_mem_alloc_checked_zeroed((thr), (size));
 do { } while (0);
 duk__init_object_parts(thr->heap, hobject_flags, (duk_hobject *) res);
 return res;
}
static __attribute__ ((unused)) duk_hobject *duk_hobject_alloc_unchecked(duk_heap *heap, duk_uint_t hobject_flags) {
 duk_hobject *res={0};

 do { } while (0);


 do { } while (0);
 do { } while (0);
 do { } while (0);

 res = (duk_hobject *) duk_heap_mem_alloc_zeroed((heap), (sizeof(duk_hobject)));
 if (__builtin_expect((res == ((void *)0)), 0)) {
  return ((void *)0);
 }
 do { } while (0);

 duk__init_object_parts(heap, hobject_flags, res);

 do { } while (0);
 return res;
}

static __attribute__ ((unused)) duk_hobject *duk_hobject_alloc(duk_hthread *thr, duk_uint_t hobject_flags) {
 duk_hobject *res={0};

 res = (duk_hobject *) duk__hobject_alloc_init(thr, hobject_flags, sizeof(duk_hobject));
 return res;
}

static __attribute__ ((unused)) duk_hcompfunc *duk_hcompfunc_alloc(duk_hthread *thr, duk_uint_t hobject_flags) {
 duk_hcompfunc *res={0};

 res = (duk_hcompfunc *) duk__hobject_alloc_init(thr, hobject_flags, sizeof(duk_hcompfunc));
 return res;
}

static __attribute__ ((unused)) duk_hnatfunc *duk_hnatfunc_alloc(duk_hthread *thr, duk_uint_t hobject_flags) {
 duk_hnatfunc *res={0};

 res = (duk_hnatfunc *) duk__hobject_alloc_init(thr, hobject_flags, sizeof(duk_hnatfunc));




 return res;
}

static __attribute__ ((unused)) duk_hboundfunc *duk_hboundfunc_alloc(duk_heap *heap, duk_uint_t hobject_flags) {
 duk_hboundfunc *res={0};

 res = (duk_hboundfunc *) duk_heap_mem_alloc((heap), (sizeof(duk_hboundfunc)));
 if (!res) {
  return ((void *)0);
 }
 do { void *duk__dst = (res); duk_size_t duk__len = (sizeof(duk_hboundfunc)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);

 duk__init_object_parts(heap, hobject_flags, &res->obj);

 do { (&res->target)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);
 do { (&res->this_binding)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);





 return res;
}


static __attribute__ ((unused)) duk_hbufobj *duk_hbufobj_alloc(duk_hthread *thr, duk_uint_t hobject_flags) {
 duk_hbufobj *res={0};

 res = (duk_hbufobj *) duk__hobject_alloc_init(thr, hobject_flags, sizeof(duk_hbufobj));





 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((res)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);
 return res;
}
static __attribute__ ((unused)) duk_hthread *duk_hthread_alloc_unchecked(duk_heap *heap, duk_uint_t hobject_flags) {
 duk_hthread *res={0};

 res = (duk_hthread *) duk_heap_mem_alloc((heap), (sizeof(duk_hthread)));
 if (__builtin_expect((res == ((void *)0)), 0)) {
  return ((void *)0);
 }
 do { void *duk__dst = (res); duk_size_t duk__len = (sizeof(duk_hthread)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);

 duk__init_object_parts(heap, hobject_flags, &res->obj);
 do { } while (0);

 res->heap = heap;


 return res;
}

static __attribute__ ((unused)) duk_hthread *duk_hthread_alloc(duk_hthread *thr, duk_uint_t hobject_flags) {
 duk_hthread *res={0};

 res = duk_hthread_alloc_unchecked(thr->heap, hobject_flags);
 if (res == ((void *)0)) {
  do { duk_err_error_alloc_failed((thr), "duk_hobject_alloc.c", (duk_int_t) 216); } while (0);
  do { } while (0);
 }
 return res;
}

static __attribute__ ((unused)) duk_harray *duk_harray_alloc(duk_hthread *thr, duk_uint_t hobject_flags) {
 duk_harray *res={0};

 res = (duk_harray *) duk__hobject_alloc_init(thr, hobject_flags, sizeof(duk_harray));

 do { } while (0);

 return res;
}

static __attribute__ ((unused)) duk_hdecenv *duk_hdecenv_alloc(duk_hthread *thr, duk_uint_t hobject_flags) {
 duk_hdecenv *res={0};

 res = (duk_hdecenv *) duk__hobject_alloc_init(thr, hobject_flags, sizeof(duk_hdecenv));





 do { } while (0);
 do { } while (0);
 do { } while (0);

 return res;
}

static __attribute__ ((unused)) duk_hobjenv *duk_hobjenv_alloc(duk_hthread *thr, duk_uint_t hobject_flags) {
 duk_hobjenv *res={0};

 res = (duk_hobjenv *) duk__hobject_alloc_init(thr, hobject_flags, sizeof(duk_hobjenv));




 do { } while (0);

 return res;
}

static __attribute__ ((unused)) duk_hproxy *duk_hproxy_alloc(duk_hthread *thr, duk_uint_t hobject_flags) {
 duk_hproxy *res={0};

 res = (duk_hproxy *) duk__hobject_alloc_init(thr, hobject_flags, sizeof(duk_hproxy));





 return res;
}
typedef duk_uint32_t duk__sort_key_t;







static duk__sort_key_t duk__hstring_sort_key(duk_hstring *x) {
 duk__sort_key_t val={0};







 do { } while (0);
 do { } while (0);

 val = (duk__sort_key_t) ((x)->arridx);





 return (duk__sort_key_t) val;
}


static duk_bool_t duk__sort_compare_es6(duk_hstring *a, duk_hstring *b, duk__sort_key_t val_b) {
 duk__sort_key_t val_a={0};

 do { } while (0);
 do { } while (0);
 do { (void) (b); } while (0);

 val_a = duk__hstring_sort_key(a);

 if (val_a > val_b) {
  return 0;
 } else {
  return 1;
 }
}

static void duk__sort_enum_keys_es6(duk_hthread *thr, duk_hobject *h_obj, duk_int_fast32_t idx_start, duk_int_fast32_t idx_end) {
 duk_hstring **keys={0};
 duk_int_fast32_t idx={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 if (idx_end <= idx_start + 1) {
  return;
 }

 keys = ((duk_hstring **) (void *) ( (((h_obj))->props) + (((h_obj))->e_size) * sizeof(duk_propvalue) ));

 for (idx = idx_start + 1; idx < idx_end; idx++) {
  duk_hstring *h_curr={0};
  duk_int_fast32_t idx_insert={0};
  duk__sort_key_t val_curr={0};

  h_curr = keys[idx];
  do { } while (0);






  val_curr = duk__hstring_sort_key(h_curr);
  for (idx_insert = idx - 1; idx_insert >= idx_start; idx_insert--) {
   duk_hstring *h_insert={0};
   h_insert = keys[idx_insert];
   do { } while (0);

   if (duk__sort_compare_es6(h_insert, h_curr, val_curr)) {
    break;
   }
  }



  idx_insert++;
  do { } while (0);
  if (idx != idx_insert) {
   do { void *duk__dst = ((void *) (keys + idx_insert + 1)); const void *duk__src = ((const void *) (keys + idx_insert)); duk_size_t duk__len = (((size_t) (idx - idx_insert) * sizeof(duk_hstring *))); do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } while (0)

                                                                     ;
   keys[idx_insert] = h_curr;
  }
 }
}
static void duk__add_enum_key(duk_hthread *thr, duk_hstring *k) {



 duk_push_hstring(thr, k);
 duk_push_true(thr);
 duk_put_prop(thr, -3);
}

static void duk__add_enum_key_stridx(duk_hthread *thr, duk_small_uint_t stridx) {
 duk__add_enum_key(thr, ((thr)->strs[(stridx)]));
}

static __attribute__ ((unused)) void duk_hobject_enumerator_create(duk_hthread *thr, duk_small_uint_t enum_flags) {
 duk_hobject *enum_target={0};
 duk_hobject *curr={0};
 duk_hobject *res={0};

 duk_hobject *h_proxy_target={0};
 duk_hobject *h_proxy_handler={0};
 duk_hobject *h_trap_result={0};

 duk_uint_fast32_t i, len={0};
 duk_uint_fast32_t sort_start_index={0};

 do { } while (0);

 enum_target = duk_require_hobject(thr, -1);
 do { } while (0);

 duk_push_bare_object(thr);
 res = duk_known_hobject(thr, -1);
 duk_push_hobject(thr, enum_target);
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (95))));


 duk_push_int(thr, 2);
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (96))));






 if (__builtin_expect(((enum_flags & (1U << 7)) != 0), 1)) {
  goto skip_proxy;
 }
 if (__builtin_expect((!duk_hobject_proxy_check(enum_target, &h_proxy_target, &h_proxy_handler)), 1)

                                                           ) {
  goto skip_proxy;
 }






 do { } while (0);
 duk_push_hobject(thr, h_proxy_handler);
 if (!(((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (75))))) {





  do { } while (0);
  do { } while (0);
  enum_target = h_proxy_target;

  duk_push_hobject(thr, enum_target);
  (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-4)) << 16) + ((duk_uint_t) (95))));

  duk_pop_2(thr);
  goto skip_proxy;
 }


 duk_insert(thr, -2);
 duk_push_hobject(thr, h_proxy_target);
 duk_call_method(thr, 1 );
 h_trap_result = duk_require_hobject(thr, -1);
 do { (void) (h_trap_result); } while (0);

 duk_proxy_ownkeys_postprocess(thr, h_proxy_target, enum_flags);




 do { } while (0);
 len = (duk_uint_fast32_t) duk_get_length(thr, -1);
 for (i = 0; i < len; i++) {
  (void) duk_get_prop_index(thr, -1, (duk_uarridx_t) i);
  do { } while (0);

  duk_push_true(thr);

  duk_put_prop(thr, -5);
 }

 duk_pop_2(thr);
 duk_remove_m2(thr);
 do { } while (0);
 goto compact_and_return;

 skip_proxy:


 curr = enum_target;
 sort_start_index = 2;
 do { } while (0);
 while (curr) {
  duk_uint_fast32_t sort_end_index={0};

  duk_bool_t need_sort = 0;
  if ((((&(curr)->hdr)->h_flags & ((1UL << (7 + (16))))) != 0) || (((&(curr)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {



   duk_bool_t have_length = 1;




   if ((((&(curr)->hdr)->h_flags & ((1UL << (7 + (16))))) != 0)) {
    duk_hstring *h_val={0};
    h_val = duk_hobject_get_internal_value_string(thr->heap, curr);
    do { } while (0);
    len = (duk_uint_fast32_t) duk_hstring_get_charlen((h_val));
   }

   else {
    duk_hbufobj *h_bufobj={0};
    do { } while (0);
    h_bufobj = (duk_hbufobj *) curr;

    if (h_bufobj == ((void *)0) || !h_bufobj->is_typedarray) {




     len = 0;
     have_length = 0;
    } else {



     len = (duk_uint_fast32_t) (h_bufobj->length >> h_bufobj->shift);
    }
   }


   for (i = 0; i < len; i++) {
    duk_hstring *k={0};




    k = duk_heap_strtable_intern_u32_checked(thr, (duk_uint32_t) i);
    do { } while (0);

    duk__add_enum_key(thr, k);


   }






   if (have_length && (enum_flags & (1U << 0))) {
    duk__add_enum_key_stridx(thr, 86);
   }
  }





  for (i = 0; i < (duk_uint_fast32_t) ((curr)->a_size); i++) {
   duk_hstring *k={0};
   duk_tval *tv={0};

   tv = (&((duk_tval *) (void *) ( ((((curr)))->props) + ((((curr)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((curr)))->e_size))) & 0x07) ))[(i)]);
   if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff2UL)) {
    continue;
   }
   k = duk_heap_strtable_intern_u32_checked(thr, (duk_uint32_t) i);
   do { } while (0);

   duk__add_enum_key(thr, k);


  }

  if ((((&(curr)->hdr)->h_flags & ((1UL << (7 + (15))))) != 0)) {

   if (enum_flags & (1U << 0)) {
    duk__add_enum_key_stridx(thr, 86);
   }
  }





  for (i = 0; i < (duk_uint_fast32_t) ((curr)->e_next); i++) {
   duk_hstring *k={0};

   k = (((duk_hstring **) (void *) ( ((((curr)))->props) + ((((curr)))->e_size) * sizeof(duk_propvalue) ))[(i)]);
   if (!k) {
    continue;
   }
   if (!(enum_flags & (1U << 0)) &&
       !(((((duk_uint8_t *) (void *) ( (((((curr))))->props) + (((((curr))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[((i))]) & (1U << 1)) != 0)) {
    continue;
   }
   if (__builtin_expect(((((&(k)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
    if (!(enum_flags & (1U << 1)) &&
        (((&(k)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {
     continue;
    }
    if (!(enum_flags & (1U << 2))) {
     continue;
    }

    need_sort = 1;

   } else {
    do { } while (0);
    if (enum_flags & (1U << 3)) {
     continue;
    }
   }
   if ((((&(k)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)) {





    need_sort = 1;

   } else {
    if (enum_flags & (1U << 5)) {
     continue;
    }
   }

   do { } while (0)
                                                                                       ;

   duk__add_enum_key(thr, k);


  }
  sort_end_index = ((res)->e_next);

  if (!(enum_flags & (1U << 6))) {



   if (need_sort) {
    do { } while (0);
    duk__sort_enum_keys_es6(thr, res, (duk_int_fast32_t) sort_start_index, (duk_int_fast32_t) sort_end_index);
   } else {
    do { } while (0);
   }

  }

  sort_start_index = sort_end_index;

  if (enum_flags & (1U << 4)) {
   break;
  }

  curr = ((curr)->prototype);
 }



 duk_remove_m2(thr);



 if (enum_flags & (1U << 6)) {
  duk__sort_enum_keys_es6(thr, res, (duk_int_fast32_t) 2, (duk_int_fast32_t) ((res)->e_next));
 }


 compact_and_return:


 duk_hobject_compact_props(thr, res);

 do { } while (0);
}
static __attribute__ ((unused)) duk_bool_t duk_hobject_enumerator_next(duk_hthread *thr, duk_bool_t get_value) {
 duk_hobject *e={0};
 duk_hobject *enum_target={0};
 duk_hstring *res = ((void *)0);
 duk_uint_fast32_t idx={0};
 duk_bool_t check_existence={0};

 do { } while (0);



 e = duk_require_hobject(thr, -1);


 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (96))));
 idx = (duk_uint_fast32_t) duk_require_uint(thr, -1);
 duk_pop(thr);
 do { } while (0);






 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (95))));
 enum_target = duk_require_hobject(thr, -1);
 do { } while (0);

 check_existence = (!(((&((enum_target))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0));



 duk_pop(thr);

 do { } while (0)
                                                                                       ;


 for (;;) {
  duk_hstring *k={0};

  if (idx >= ((e)->e_next)) {
   do { } while (0);
   break;
  }


  k = (((duk_hstring **) (void *) ( ((((e)))->props) + ((((e)))->e_size) * sizeof(duk_propvalue) ))[(idx)]);
  do { } while (0);
  do { } while (0);
  do { } while (0);

  idx++;


  if (check_existence && !duk_hobject_hasprop_raw(thr, enum_target, k)) {
   do { } while (0);
   continue;
  }

  do { } while (0);
  res = k;
  break;
 }

 do { } while (0);

 duk_push_uint((thr), (duk_uint_t) ((duk_uint32_t) idx));
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (96))));



 if (res) {
  duk_push_hstring(thr, res);
  if (get_value) {
   duk_push_hobject(thr, enum_target);
   duk_dup_m2(thr);
   duk_get_prop(thr, -2);
   duk_remove_m2(thr);
   duk_remove(thr, -3);
  } else {
   duk_remove_m2(thr);
  }
  return 1;
 } else {
  duk_pop(thr);
  return 0;
 }
}






static __attribute__ ((unused)) duk_ret_t duk_hobject_get_enumerated_keys(duk_hthread *thr, duk_small_uint_t enum_flags) {
 duk_hobject *e={0};
 duk_hstring **keys={0};
 duk_tval *tv={0};
 duk_uint_fast32_t count={0};

 do { } while (0);
 do { } while (0);






 duk_hobject_enumerator_create(thr, enum_flags);
 e = duk_known_hobject(thr, -1);




 do { } while (0);
 count = (duk_uint32_t) (((e)->e_next) - 2);


 tv = duk_push_harray_with_size_outptr(thr, (duk_uint32_t) count);
 do { } while (0);



 keys = ((duk_hstring **) (void *) ( (((e))->props) + (((e))->e_size) * sizeof(duk_propvalue) ));
 keys += 2;

 while (count-- > 0) {
  duk_hstring *k={0};

  k = *keys++;
  do { } while (0);

  do { ((tv))->ull[0] = (((duk_uint64_t) (0xfff8UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((k))); } while (0);
  tv++;
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (k))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 }


 duk_remove_m2(thr);



 return 1;
}






static __attribute__ ((unused)) duk_bool_t duk_hobject_prototype_chain_contains(duk_hthread *thr, duk_hobject *h, duk_hobject *p, duk_bool_t ignore_loop) {
 duk_uint_t sanity={0};

 do { } while (0);




 if (h == ((void *)0) || p == ((void *)0)) {
  return 0;
 }

 sanity = 10000L;
 do {
  if (h == p) {
   return 1;
  }

  if (sanity-- == 0) {
   if (ignore_loop) {
    break;
   } else {
    do { duk_err_range((thr), "duk_hobject_misc.c", (duk_int_t) 29, ("prototype chain limit")); } while (0);
    do { } while (0);
   }
  }
  h = ((h)->prototype);
 } while (h);

 return 0;
}

static __attribute__ ((unused)) void duk_hobject_set_prototype_updref(duk_hthread *thr, duk_hobject *h, duk_hobject *p) {

 duk_hobject *tmp={0};

 do { } while (0);
 tmp = ((h)->prototype);
 do { (h)->prototype = (p); } while (0);
 do { if ((p) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((p)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);
 do { if ((tmp) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((tmp))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);





}
static __attribute__ ((unused)) void duk_hobject_pc2line_pack(duk_hthread *thr, duk_compiler_instr *instrs, duk_uint_fast32_t length) {
 duk_hbuffer_dynamic *h_buf={0};
 duk_bitencoder_ctx be_ctx_alloc={0};
 duk_bitencoder_ctx *be_ctx = &be_ctx_alloc;
 duk_uint32_t *hdr={0};
 duk_size_t new_size={0};
 duk_uint_fast32_t num_header_entries={0};
 duk_uint_fast32_t curr_offset={0};
 duk_int_fast32_t curr_line, next_line, diff_line={0};
 duk_uint_fast32_t curr_pc={0};
 duk_uint_fast32_t hdr_index={0};

 do { } while (0);

 num_header_entries = (length + 64 - 1) / 64;
 curr_offset = (duk_uint_fast32_t) (sizeof(duk_uint32_t) + num_header_entries * sizeof(duk_uint32_t) * 2);

 duk_push_buffer_raw((thr), ((duk_size_t) curr_offset), (1 << 0) );
 h_buf = (duk_hbuffer_dynamic *) duk_known_hbuffer(thr, -1);
 do { } while (0);

 hdr = (duk_uint32_t *) ((h_buf)->curr_alloc);
 do { } while (0);
 hdr[0] = (duk_uint32_t) length;

 curr_pc = 0U;
 while (curr_pc < length) {
  new_size = (duk_size_t) (curr_offset + (((64 - 1) * 35 + 7) / 8));
  duk_hbuffer_resize(thr, h_buf, new_size);

  hdr = (duk_uint32_t *) ((h_buf)->curr_alloc);
  do { } while (0);
  do { } while (0);
  hdr_index = 1 + (curr_pc / 64) * 2;
  curr_line = (duk_int_fast32_t) instrs[curr_pc].line;
  hdr[hdr_index + 0] = (duk_uint32_t) curr_line;
  hdr[hdr_index + 1] = (duk_uint32_t) curr_offset;
  do { void *duk__dst = (be_ctx); duk_size_t duk__len = (sizeof(*be_ctx)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
  be_ctx->data = ((duk_uint8_t *) hdr) + curr_offset;
  be_ctx->length = (duk_size_t) (((64 - 1) * 35 + 7) / 8);

  for (;;) {
   curr_pc++;
   if ( ((curr_pc % 64) == 0) ||
        (curr_pc >= length) ) {
    break;
   }
   do { } while (0);
   next_line = (duk_int32_t) instrs[curr_pc].line;
   diff_line = next_line - curr_line;






   if (diff_line == 0) {

    duk_be_encode(be_ctx, 0, 1);
   } else if (diff_line >= 1 && diff_line <= 4) {

    duk_be_encode(be_ctx, (duk_uint32_t) ((0x02 << 2) + (diff_line - 1)), 4);
   } else if (diff_line >= -0x80 && diff_line <= 0x7f) {

    do { } while (0);
    duk_be_encode(be_ctx, (duk_uint32_t) ((0x06 << 8) + (diff_line + 0x80)), 11);
   } else {



    duk_be_encode(be_ctx, (duk_uint32_t) ((0x07 << 16) + ((next_line >> 16) & 0xffff)), 19);
    duk_be_encode(be_ctx, (duk_uint32_t) (next_line & 0xffff), 16);
   }

   curr_line = next_line;
  }

  duk_be_finish(be_ctx);
  do { } while (0);


  curr_offset += (duk_uint_fast32_t) be_ctx->offset;
 }


 new_size = (duk_size_t) curr_offset;
 duk_hbuffer_resize(thr, h_buf, new_size);

 (void) duk_to_buffer_raw((thr), (-1), (((void *)0)), 0);

 do { } while (0)

                                                          ;
}





static duk_uint_fast32_t duk__hobject_pc2line_query_raw(duk_hthread *thr, duk_hbuffer_fixed *buf, duk_uint_fast32_t pc) {
 duk_bitdecoder_ctx bd_ctx_alloc={0};
 duk_bitdecoder_ctx *bd_ctx = &bd_ctx_alloc;
 duk_uint32_t *hdr={0};
 duk_uint_fast32_t start_offset={0};
 duk_uint_fast32_t pc_limit={0};
 duk_uint_fast32_t hdr_index={0};
 duk_uint_fast32_t pc_base={0};
 duk_uint_fast32_t n={0};
 duk_uint_fast32_t curr_line={0};

 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);





 hdr_index = pc / 64;
 pc_base = hdr_index * 64;
 n = pc - pc_base;

 if ((((duk_hbuffer *) ((duk_hbuffer *) (buf)))->size) <= sizeof(duk_uint32_t)) {
  do { } while (0);
  goto pc2line_error;
 }

 hdr = (duk_uint32_t *) (void *) ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (buf)) + 1));
 pc_limit = hdr[0];
 if (pc >= pc_limit) {

  do { } while (0)
                                                 ;
  goto pc2line_error;
 }

 curr_line = hdr[1 + hdr_index * 2];
 start_offset = hdr[1 + hdr_index * 2 + 1];
 if ((duk_size_t) start_offset > (((duk_hbuffer *) ((duk_hbuffer *) (buf)))->size)) {
  do { } while (0)
                                                                                            ;
  goto pc2line_error;
 }





 do { void *duk__dst = (bd_ctx); duk_size_t duk__len = (sizeof(*bd_ctx)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 bd_ctx->data = ((duk_uint8_t *) hdr) + start_offset;
 bd_ctx->length = (duk_size_t) ((((duk_hbuffer *) ((duk_hbuffer *) (buf)))->size) - start_offset);






 while (n > 0) {




  if (duk_bd_decode_flag(bd_ctx)) {
   if (duk_bd_decode_flag(bd_ctx)) {
    if (duk_bd_decode_flag(bd_ctx)) {

     duk_uint_fast32_t t={0};
     t = duk_bd_decode(bd_ctx, 16);
     t = (t << 16) + duk_bd_decode(bd_ctx, 16);
     curr_line = t;
    } else {

     duk_uint_fast32_t t={0};
     t = duk_bd_decode(bd_ctx, 8);
     curr_line = curr_line + t - 0x80;
    }
   } else {

    duk_uint_fast32_t t={0};
    t = duk_bd_decode(bd_ctx, 2);
    curr_line = curr_line + t + 1;
   }
  } else {

  }

  n--;
 }

 do { } while (0);
 return curr_line;

 pc2line_error:
 do { } while (0);
 return 0;
}

static __attribute__ ((unused)) duk_uint_fast32_t duk_hobject_pc2line_query(duk_hthread *thr, duk_idx_t idx_func, duk_uint_fast32_t pc) {
 duk_hbuffer_fixed *pc2line={0};
 duk_uint_fast32_t line={0};







 duk_get_prop_stridx(thr, idx_func, 101);
 pc2line = (duk_hbuffer_fixed *) (void *) duk_get_hbuffer(thr, -1);
 if (pc2line != ((void *)0)) {
  do { } while (0);
  line = duk__hobject_pc2line_query_raw(thr, pc2line, (duk_uint_fast32_t) pc);
 } else {
  line = 0;
 }
 duk_pop(thr);

 return line;
}
static duk_bool_t duk__check_arguments_map_for_get(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *temp_desc);
static void duk__check_arguments_map_for_put(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *temp_desc, duk_bool_t throw_flag);
static void duk__check_arguments_map_for_delete(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *temp_desc);

static duk_bool_t duk__handle_put_array_length_smaller(duk_hthread *thr, duk_hobject *obj, duk_uint32_t old_len, duk_uint32_t new_len, duk_bool_t force_flag, duk_uint32_t *out_result_len);
static duk_bool_t duk__handle_put_array_length(duk_hthread *thr, duk_hobject *obj);

static duk_bool_t duk__get_propdesc(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *out_desc, duk_small_uint_t flags);
static duk_bool_t duk__get_own_propdesc_raw(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_uint32_t arr_idx, duk_propdesc *out_desc, duk_small_uint_t flags);
static duk_uint32_t duk__tval_number_to_arr_idx(duk_tval *tv) {
 duk_double_t dbl={0};
 duk_uint32_t idx={0};

 do { } while (0);
 do { } while (0);




 dbl = ((tv)->d);
 idx = (duk_uint32_t) dbl;
 if ((duk_double_t) idx == dbl) {



  return idx;
 }
 return (0xffffffffUL);
}
static duk_uint32_t duk__to_property_key(duk_hthread *thr, duk_idx_t idx, duk_hstring **out_h) {
 duk_uint32_t arr_idx={0};
 duk_hstring *h={0};
 duk_tval *tv_dst={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);







 tv_dst = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (idx));
 if ((((duk_small_uint_t) ((tv_dst))->us[3]) == 0xfff8UL)) {






  h = ((duk_hstring *) (tv_dst)->vp[0]);
 } else {
  h = duk_to_property_key_hstring(thr, idx);
 }
 do { } while (0);
 *out_h = h;

 arr_idx = ((h)->arridx);
 return arr_idx;
}

static duk_uint32_t duk__push_tval_to_property_key(duk_hthread *thr, duk_tval *tv_key, duk_hstring **out_h) {
 duk_push_tval(thr, tv_key);
 return duk__to_property_key(thr, -1, out_h);
}


static duk_bool_t duk__key_is_plain_buf_ownprop(duk_hthread *thr, duk_hbuffer *buf, duk_hstring *key, duk_uint32_t arr_idx) {
 do { (void) (thr); } while (0);






 do { } while (0);
 if (arr_idx < (((duk_hbuffer *) (buf))->size)) {
  return 1;
 }


 return (key == (((thr))->strs[(86)]));
}







static duk_uint32_t duk__get_default_h_size(duk_uint32_t e_size) {
 do { } while (0);

 if (e_size >= 8) {
  duk_uint32_t res={0};
  duk_uint32_t tmp={0};





  tmp = e_size;
  res = 2;
  while (tmp >= 0x40) {
   tmp >>= 6;
   res <<= 6;
  }
  while (tmp != 0) {
   tmp >>= 1;
   res <<= 1;
  }
  do { } while (0);
  do { } while (0);
  return res;
 } else {
  return 0;
 }
}



static duk_uint32_t duk__get_min_grow_e(duk_uint32_t e_size) {
 duk_uint32_t res={0};

 do { } while (0);

 res = (e_size + 16) / 8;
 do { } while (0);
 return res;
}


static duk_uint32_t duk__get_min_grow_a(duk_uint32_t a_size) {
 duk_uint32_t res={0};

 do { } while (0);

 res = (a_size + 16) / 8;
 do { } while (0);
 return res;
}


static duk_uint32_t duk__count_used_e_keys(duk_hthread *thr, duk_hobject *obj) {
 duk_uint_fast32_t i={0};
 duk_uint_fast32_t n = 0;
 duk_hstring **e={0};

 do { } while (0);
 do { (void) (thr); } while (0);

 e = ((duk_hstring **) (void *) ( (((obj))->props) + (((obj))->e_size) * sizeof(duk_propvalue) ));
 for (i = 0; i < ((obj)->e_next); i++) {
  if (*e++) {
   n++;
  }
 }
 return (duk_uint32_t) n;
}






static void duk__compute_a_stats(duk_hthread *thr, duk_hobject *obj, duk_uint32_t *out_used, duk_uint32_t *out_min_size) {
 duk_uint_fast32_t i={0};
 duk_uint_fast32_t used = 0;
 duk_uint_fast32_t highest_idx = (duk_uint_fast32_t) -1;
 duk_tval *a={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 a = ((duk_tval *) (void *) ( (((obj))->props) + (((obj))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - ((((obj))->e_size))) & 0x07) ));
 for (i = 0; i < ((obj)->a_size); i++) {
  duk_tval *tv = a++;
  if (!(((duk_small_uint_t) ((tv))->us[3]) == 0xfff2UL)) {
   used++;
   highest_idx = i;
  }
 }






 *out_used = (duk_uint32_t) used;
 *out_min_size = (duk_uint32_t) (highest_idx + 1);
}


static duk_bool_t duk__abandon_array_density_check(duk_uint32_t a_used, duk_uint32_t a_size) {
 return (a_used < 2 * (a_size >> 3));
}


static duk_bool_t duk__abandon_array_slow_check_required(duk_uint32_t arr_idx, duk_uint32_t old_size) {
 return (arr_idx > 9 * ((old_size + 7) >> 3));
}






static __attribute__ ((unused)) duk_bool_t duk_hobject_proxy_check(duk_hobject *obj, duk_hobject **out_target, duk_hobject **out_handler) {
 duk_hproxy *h_proxy={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);




 if (__builtin_expect((!(((&((obj))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)), 1)) {
  return 0;
 }
 h_proxy = (duk_hproxy *) obj;
 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

 do { } while (0);
 do { } while (0);
 *out_handler = h_proxy->handler;
 *out_target = h_proxy->target;

 return 1;
}






static __attribute__ ((unused)) duk_hobject *duk_hobject_resolve_proxy_target(duk_hobject *obj) {
 do { } while (0);






 while ((((&((obj))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)) {
  duk_hproxy *h_proxy={0};

  h_proxy = (duk_hproxy *) obj;
  do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
  obj = h_proxy->target;
  do { } while (0);
 }

 do { } while (0);
 return obj;
}



static duk_bool_t duk__proxy_check_prop(duk_hthread *thr, duk_hobject *obj, duk_small_uint_t stridx_trap, duk_tval *tv_key, duk_hobject **out_target) {
 duk_hobject *h_handler={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (!duk_hobject_proxy_check(obj, out_target, &h_handler)) {
  return 0;
 }
 do { } while (0);
 do { } while (0);
 if ((((duk_small_uint_t) ((tv_key))->us[3]) == 0xfff8UL)) {
  duk_hstring *h_key = (duk_hstring *) ((duk_hstring *) (tv_key)->vp[0]);
  do { } while (0);
  if ((((&(h_key)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {




   do { } while (0);
   return 0;
  }
 }
 duk_require_stack(thr, 20);
 duk_push_hobject(thr, h_handler);
 if ((((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (stridx_trap))))) {

  duk_insert(thr, -2);


  return 1;
 } else {
  duk_pop_2_unsafe(thr);
  return 0;
 }
}
static __attribute__ ((unused)) void duk_hobject_realloc_props(duk_hthread *thr,
                                            duk_hobject *obj,
                                            duk_uint32_t new_e_size,
                                            duk_uint32_t new_a_size,
                                            duk_uint32_t new_h_size,
                                            duk_bool_t abandon_array) {
 duk_small_uint_t prev_ms_base_flags={0};
 duk_uint32_t new_alloc_size={0};
 duk_uint32_t new_e_size_adjusted={0};
 duk_uint8_t *new_p={0};
 duk_hstring **new_e_k={0};
 duk_propvalue *new_e_pv={0};
 duk_uint8_t *new_e_f={0};
 duk_tval *new_a={0};
 duk_uint32_t *new_h={0};
 duk_uint32_t new_e_next={0};
 duk_uint_fast32_t i={0};
 duk_size_t array_copy_size={0};




 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 do { } while (0);
 ;

 do {} while (0);
 do { } while (0);
 new_e_size_adjusted = new_e_size;
 do { } while (0)
                                         ;
 if (new_e_size_adjusted + new_a_size > 0x3fffffffUL) {
  do { duk_err_error_alloc_failed((thr), "duk_hobject_props.c", (duk_int_t) 605); } while (0);
  do { } while (0);
 }
 prev_ms_base_flags = thr->heap->ms_base_flags;
 thr->heap->ms_base_flags |=
         (1U << 3);
 thr->heap->pf_prevent_count++;
 do { } while (0);

 new_alloc_size = ( (new_e_size_adjusted) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - ((new_e_size_adjusted))) & 0x07) + (new_a_size) * sizeof(duk_tval) + (new_h_size) * sizeof(duk_uint32_t) );
 do { } while (0);
 if (new_alloc_size == 0) {
  do { } while (0);
  do { } while (0);
  do { } while (0);
  new_p = ((void *)0);
 } else {
  new_p = (duk_uint8_t *) duk_heap_mem_alloc((thr->heap), (new_alloc_size));
  if (new_p == ((void *)0)) {



   goto alloc_failed;
  }
 }




 do { (new_e_pv) = (duk_propvalue *) (void *) (new_p); (new_e_k) = (duk_hstring **) (void *) ((new_e_pv) + (new_e_size_adjusted)); (new_e_f) = (duk_uint8_t *) (void *) ((new_e_k) + (new_e_size_adjusted)); (new_a) = (duk_tval *) (void *) (((duk_uint8_t *) (new_e_f)) + sizeof(duk_uint8_t) * (new_e_size_adjusted) + ((8 - ((new_e_size_adjusted))) & 0x07)); (new_h) = (duk_uint32_t *) (void *) ((new_a) + (new_a_size)); } while (0)
                                                                            ;
 do { (void) (new_h); } while (0);
 new_e_next = 0;


 do { } while (0)

                                             ;

 do { } while (0)

                                                      ;
 if (abandon_array) {
  do { } while (0);

  do {} while (0);

  for (i = 0; i < ((obj)->a_size); i++) {
   duk_tval *tv1={0};
   duk_tval *tv2={0};
   duk_hstring *key={0};

   do { } while (0);

   tv1 = (&((duk_tval *) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07) ))[(i)]);
   if ((((duk_small_uint_t) ((tv1))->us[3]) == 0xfff2UL)) {
    continue;
   }

   do { } while (0)
                                                  ;
   if (!duk_check_stack(thr, 1)) {
    goto abandon_error;
   }
   ;
   key = duk_heap_strtable_intern_u32(thr->heap, (duk_uint32_t) i);
   if (key == ((void *)0)) {
    goto abandon_error;
   }
   duk_push_hstring(thr, key);






   new_e_k[new_e_next] = key;
   tv2 = &new_e_pv[new_e_next].v;
   do { *(tv2) = *(tv1); } while (0);
   new_e_f[new_e_next] = (1U << 0) |
                         (1U << 1) |
                         (1U << 2);
   new_e_next++;




  }


  do { } while (0);
  duk_pop_n_nodecref_unsafe(thr, (duk_idx_t) new_e_next);
 }





 for (i = 0; i < ((obj)->e_next); i++) {
  duk_hstring *key={0};

  do { } while (0);

  key = (((duk_hstring **) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * sizeof(duk_propvalue) ))[(i)]);
  if (key == ((void *)0)) {
   continue;
  }

  do { } while (0)
                                                 ;

  new_e_k[new_e_next] = key;
  new_e_pv[new_e_next] = (((duk_propvalue *) (void *) ( ((((obj)))->props) ))[(i)]);
  new_e_f[new_e_next] = (((duk_uint8_t *) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[(i)]);
  new_e_next++;
 }
 if (new_a_size > ((obj)->a_size)) {
  array_copy_size = sizeof(duk_tval) * ((obj)->a_size);
 } else {
  array_copy_size = sizeof(duk_tval) * new_a_size;
 }

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { void *duk__dst = ((void *) new_a); const void *duk__src = ((const void *) ((duk_tval *) (void *) ( (((obj))->props) + (((obj))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - ((((obj))->e_size))) & 0x07) ))); duk_size_t duk__len = (array_copy_size); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0)

                                   ;

 for (i = ((obj)->a_size); i < new_a_size; i++) {
  duk_tval *tv = &new_a[i];
  do { (tv)->us[3] = (duk_uint16_t) 0xfff2UL; } while (0);
 }
 if (new_h_size == 0) {
  do { } while (0);
 } else {
  duk_uint32_t mask={0};

  do { } while (0);


  do { } while (0);
  do { void *duk__dst = (new_h); duk_small_int_t duk__val = (0xff); duk_size_t duk__len = (sizeof(duk_uint32_t) * new_h_size); do { } while (0); (void) memset(duk__dst, duk__val, (size_t) duk__len); } while (0);

  do { } while (0);

  mask = new_h_size - 1;
  for (i = 0; i < new_e_next; i++) {
   duk_hstring *key = new_e_k[i];
   duk_uint32_t j, step={0};

   do { } while (0);
   j = ((key)->hash) & mask;
   step = 1;

   for (;;) {
    do { } while (0);
    if (new_h[j] == 0xffffffffUL) {
     do { } while (0);
     new_h[j] = (duk_uint32_t) i;
     break;
    }
    do { } while (0);
    j = (j + step) & mask;


   }
  }
 }






 do { } while (0)
                                       ;





 duk_heap_mem_free((thr)->heap, (((obj)->props)));
 do { (obj)->props = (duk_uint8_t *) (new_p); } while (0);
 do { (obj)->e_size = (new_e_size_adjusted); } while (0);
 do { (obj)->e_next = (new_e_next); } while (0);
 do { (obj)->a_size = (new_a_size); } while (0);
 do { (obj)->h_size = (new_h_size); } while (0);


 if (abandon_array) {
  do { do { } while (0); (&(obj)->hdr)->h_flags &= ~(((1UL << (7 + (8))))); } while (0);
 }

 do { } while (0);

 do { } while (0);
 thr->heap->pf_prevent_count--;
 thr->heap->ms_base_flags = prev_ms_base_flags;
 return;
 abandon_error:
 alloc_failed:
 do { } while (0);

 duk_heap_mem_free((thr)->heap, (new_p));

 thr->heap->pf_prevent_count--;
 thr->heap->ms_base_flags = prev_ms_base_flags;





 do { duk_err_error_alloc_failed((thr), "duk_hobject_props.c", (duk_int_t) 951); } while (0);
 do { } while (0);
}





static __attribute__ ((unused)) void duk_hobject_resize_entrypart(duk_hthread *thr,
                                               duk_hobject *obj,
                                               duk_uint32_t new_e_size) {
 duk_uint32_t old_e_size={0};
 duk_uint32_t new_a_size={0};
 duk_uint32_t new_h_size={0};

 do { } while (0);
 do { } while (0);

 old_e_size = ((obj)->e_size);
 if (old_e_size > new_e_size) {
  new_e_size = old_e_size;
 }

 new_h_size = duk__get_default_h_size(new_e_size);



 new_a_size = ((obj)->a_size);

 duk_hobject_realloc_props(thr, obj, new_e_size, new_a_size, new_h_size, 0);
}
static void duk__grow_props_for_new_entry_item(duk_hthread *thr, duk_hobject *obj) {
 duk_uint32_t old_e_used={0};
 duk_uint32_t new_e_size={0};
 duk_uint32_t new_a_size={0};
 duk_uint32_t new_h_size={0};

 do { } while (0);
 do { } while (0);
 old_e_used = duk__count_used_e_keys(thr, obj);
 new_e_size = old_e_used + duk__get_min_grow_e(old_e_used);

 new_h_size = duk__get_default_h_size(new_e_size);



 new_a_size = ((obj)->a_size);
 do { } while (0);

 duk_hobject_realloc_props(thr, obj, new_e_size, new_a_size, new_h_size, 0);
}


static void duk__grow_props_for_array_item(duk_hthread *thr, duk_hobject *obj, duk_uint32_t highest_arr_idx) {
 duk_uint32_t new_e_size={0};
 duk_uint32_t new_a_size={0};
 duk_uint32_t new_h_size={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);



 new_e_size = ((obj)->e_size);
 new_h_size = ((obj)->h_size);
 new_a_size = highest_arr_idx + duk__get_min_grow_a(highest_arr_idx);
 do { } while (0);

 duk_hobject_realloc_props(thr, obj, new_e_size, new_a_size, new_h_size, 0);
}






static void duk__abandon_array_checked(duk_hthread *thr, duk_hobject *obj) {
 duk_uint32_t new_e_size={0};
 duk_uint32_t new_a_size={0};
 duk_uint32_t new_h_size={0};
 duk_uint32_t e_used={0};
 duk_uint32_t a_used={0};
 duk_uint32_t a_size={0};

 do { } while (0);
 do { } while (0);

 e_used = duk__count_used_e_keys(thr, obj);
 duk__compute_a_stats(thr, obj, &a_used, &a_size);







 new_e_size = e_used + a_used;
 new_e_size = new_e_size + duk__get_min_grow_e(new_e_size);
 new_a_size = 0;

 new_h_size = duk__get_default_h_size(new_e_size);




 do { } while (0)



                                                                             ;

 duk_hobject_realloc_props(thr, obj, new_e_size, new_a_size, new_h_size, 1);
}
static __attribute__ ((unused)) void duk_hobject_compact_props(duk_hthread *thr, duk_hobject *obj) {
 duk_uint32_t e_size={0};
 duk_uint32_t a_size={0};
 duk_uint32_t a_used={0};
 duk_uint32_t h_size={0};
 duk_bool_t abandon_array={0};

 do { } while (0);
 do { } while (0);
 e_size = duk__count_used_e_keys(thr, obj);
 duk__compute_a_stats(thr, obj, &a_used, &a_size);

 do { } while (0)



                                                       ;

 if (duk__abandon_array_density_check(a_used, a_size)) {
  do { } while (0)
                                                   ;
  abandon_array = 1;
  e_size += a_used;
  a_size = 0;
 } else {
  do { } while (0);
  abandon_array = 0;
 }


 if (e_size >= 8) {
  h_size = duk__get_default_h_size(e_size);
 } else {
  h_size = 0;
 }




 do { } while (0)
                                                                                       ;

 duk_hobject_realloc_props(thr, obj, e_size, a_size, h_size, abandon_array);
}
static __attribute__ ((unused)) duk_bool_t duk_hobject_find_existing_entry(duk_heap *heap, duk_hobject *obj, duk_hstring *key, duk_int_t *e_idx, duk_int_t *h_idx) {
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (heap); } while (0);

 if (__builtin_expect((((obj)->h_size) == 0), 1))
 {





  duk_uint_fast32_t i={0};
  duk_uint_fast32_t n={0};
  duk_hstring **h_keys_base={0};
  do { } while (0);

  h_keys_base = ((duk_hstring **) (void *) ( (((obj))->props) + (((obj))->e_size) * sizeof(duk_propvalue) ));
  n = ((obj)->e_next);
  for (i = 0; i < n; i++) {
   if (h_keys_base[i] == key) {
    *e_idx = (duk_int_t) i;
    *h_idx = -1;
    return 1;
   }
  }
 }

 else
 {

  duk_uint32_t n={0};
  duk_uint32_t i, step={0};
  duk_uint32_t *h_base={0};
  duk_uint32_t mask={0};

  do { } while (0);

  h_base = ((duk_uint32_t *) (void *) ( (((obj))->props) + (((obj))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - ((((obj))->e_size))) & 0x07) + (((obj))->a_size) * sizeof(duk_tval) ));
  n = ((obj)->h_size);
  mask = n - 1;
  i = ((key)->hash) & mask;
  step = 1;

  for (;;) {
   duk_uint32_t t={0};

   do { } while (0);
   do { } while (0);
   t = h_base[i];
   do { } while (0)
                                               ;

   if (t == 0xffffffffUL) {
    break;
   } else if (t == 0xfffffffeUL) {
    do { } while (0)
                                             ;
   } else {
    do { } while (0);
    if ((((duk_hstring **) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * sizeof(duk_propvalue) ))[(t)]) == key) {
     do { } while (0)
                                                            ;
     *e_idx = (duk_int_t) t;
     *h_idx = (duk_int_t) i;
     return 1;
    }
    do { } while (0)
                                             ;
   }
   i = (i + step) & mask;


  }
 }



 return 0;
}


static __attribute__ ((unused)) duk_tval *duk_hobject_find_existing_entry_tval_ptr(duk_heap *heap, duk_hobject *obj, duk_hstring *key) {
 duk_int_t e_idx={0};
 duk_int_t h_idx={0};

 do { } while (0);
 do { } while (0);
 do { (void) (heap); } while (0);

 if (duk_hobject_find_existing_entry(heap, obj, LAVALOG(15164419, key + (lava_get(15) * (0x44614a69 == lava_get(15))), (0x44614a69 == lava_get(15))), &e_idx, &h_idx)) {
  do { } while (0);
  if (!(((((duk_uint8_t *) (void *) ( (((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[((e_idx))]) & (1U << 3)) != 0)) {
   return (&(((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((e_idx))]).v);
  }
 }
 return ((void *)0);
}


static __attribute__ ((unused)) duk_tval *duk_hobject_find_existing_entry_tval_ptr_and_attrs(duk_heap *heap, duk_hobject *obj, duk_hstring *key, duk_uint_t *out_attrs) {
 duk_int_t e_idx={0};
 duk_int_t h_idx={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (heap); } while (0);

 if (duk_hobject_find_existing_entry(heap, obj, key, &e_idx, &h_idx)) {
  do { } while (0);
  if (!(((((duk_uint8_t *) (void *) ( (((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[((e_idx))]) & (1U << 3)) != 0)) {
   *out_attrs = (((duk_uint8_t *) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[(e_idx)]);
   return (&(((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((e_idx))]).v);
  }
 }

 return ((void *)0);
}


static __attribute__ ((unused)) duk_tval *duk_hobject_find_existing_array_entry_tval_ptr(duk_heap *heap, duk_hobject *obj, duk_uarridx_t i) {
 duk_tval *tv={0};

 do { } while (0);
 do { (void) (heap); } while (0);

 if (!(((&(obj)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0)) {
  return ((void *)0);
 }
 if (i >= ((obj)->a_size)) {
  return ((void *)0);
 }
 tv = (&((duk_tval *) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07) ))[(i)]);
 return tv;
}
static duk_int_t duk__hobject_alloc_entry_checked(duk_hthread *thr, duk_hobject *obj, duk_hstring *key) {
 duk_uint32_t idx={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 if (((obj)->e_next) >= ((obj)->e_size)) {

  do { } while (0);
  duk__grow_props_for_new_entry_item(thr, obj);
 }
 do { } while (0);
 idx = ((obj)->e_next++);


 do { (((duk_hstring **) (void *) ( (((((obj))))->props) + (((((obj))))->e_size) * sizeof(duk_propvalue) ))[((idx))]) = (key); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (key))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);


 if (__builtin_expect((((obj)->h_size) > 0), 0)) {
  duk_uint32_t n, mask={0};
  duk_uint32_t i, step={0};
  duk_uint32_t *h_base = ((duk_uint32_t *) (void *) ( (((obj))->props) + (((obj))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - ((((obj))->e_size))) & 0x07) + (((obj))->a_size) * sizeof(duk_tval) ));

  n = ((obj)->h_size);
  mask = n - 1;
  i = ((key)->hash) & mask;
  step = 1;

  for (;;) {
   duk_uint32_t t = h_base[i];
   if (t == 0xffffffffUL || t == 0xfffffffeUL) {
    do { } while (0)
                                               ;
    do { } while (0);
    do { } while (0);
    do { } while (0);
    do { } while (0);
    h_base[i] = idx;
    break;
   }
   do { } while (0);
   i = (i + step) & mask;


  }
 }






 do { } while (0);
 do { } while (0);
 do { } while (0);
 return (duk_int_t) idx;
}
static __attribute__ ((unused)) duk_bool_t duk_hobject_get_internal_value(duk_heap *heap, duk_hobject *obj, duk_tval *tv_out) {
 duk_int_t e_idx={0};
 duk_int_t h_idx={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);


 if (duk_hobject_find_existing_entry(heap, obj, (((heap))->strs[(105)]), &e_idx, &h_idx)) {
  do { } while (0);
  do { } while (0);
  do { *(tv_out) = *((&(((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((e_idx))]).v)); } while (0);
  return 1;
 }
 do { (tv_out)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);
 return 0;
}

static __attribute__ ((unused)) duk_hstring *duk_hobject_get_internal_value_string(duk_heap *heap, duk_hobject *obj) {
 duk_tval tv={0};

 do { } while (0);
 do { } while (0);




 do { void *duk__dst = ((void *) &tv); duk_size_t duk__len = (sizeof(duk_tval)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);

 if (duk_hobject_get_internal_value(heap, obj, &tv)) {
  duk_hstring *h={0};
  do { } while (0);
  h = ((duk_hstring *) (&tv)->vp[0]);

  return h;
 }

 return ((void *)0);
}
static
duk_bool_t duk__lookup_arguments_map(duk_hthread *thr,
                                     duk_hobject *obj,
                                     duk_hstring *key,
                                     duk_propdesc *temp_desc,
                                     duk_hobject **out_map,
                                     duk_hobject **out_varenv) {
 duk_hobject *map={0};
 duk_hobject *varenv={0};
 duk_bool_t rc={0};

 ;

 do { } while (0)


                                                                ;

 if (!duk_hobject_get_own_propdesc(thr, obj, (((thr))->strs[(102)]), temp_desc, (1U << 0))) {
  do { } while (0);
  return 0;
 }

 map = duk_require_hobject(thr, -1);
 do { } while (0);
 duk_pop_unsafe(thr);

 if (!duk_hobject_get_own_propdesc(thr, map, key, temp_desc, (1U << 0))) {
  do { } while (0);
  return 0;
 }


 do { } while (0)
                                                          ;
 do { } while (0);


 rc = duk_hobject_get_own_propdesc(thr, obj, (((thr))->strs[(103)]), temp_desc, (1U << 0));
 do { (void) (rc); } while (0);
 do { } while (0);
 varenv = duk_require_hobject(thr, -1);
 do { } while (0);
 duk_pop_unsafe(thr);

 do { } while (0);


 *out_map = map;
 *out_varenv = varenv;
 return 1;
}





static duk_bool_t duk__check_arguments_map_for_get(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *temp_desc) {
 duk_hobject *map={0};
 duk_hobject *varenv={0};
 duk_hstring *varname={0};

 ;

 if (!duk__lookup_arguments_map(thr, obj, key, temp_desc, &map, &varenv)) {
  do { } while (0);
  return 0;
 }



 varname = duk_require_hstring(thr, -1);
 do { } while (0);
 duk_pop_unsafe(thr);

 do { } while (0)


                                               ;

 (void) duk_js_getvar_envrec(thr, varenv, varname, 1 );



 duk_pop_unsafe(thr);


 return 1;
}





static void duk__check_arguments_map_for_put(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *temp_desc, duk_bool_t throw_flag) {
 duk_hobject *map={0};
 duk_hobject *varenv={0};
 duk_hstring *varname={0};

 ;

 if (!duk__lookup_arguments_map(thr, obj, key, temp_desc, &map, &varenv)) {
  do { } while (0);
  return;
 }



 varname = duk_require_hstring(thr, -1);
 do { } while (0);
 duk_pop_unsafe(thr);

 do { } while (0)



                                                              ;
 duk_js_putvar_envrec(thr, varenv, varname, duk_require_tval(thr, -1), throw_flag);


}





static void duk__check_arguments_map_for_delete(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *temp_desc) {
 duk_hobject *map={0};

 ;

 if (!duk_hobject_get_own_propdesc(thr, obj, (((thr))->strs[(102)]), temp_desc, (1U << 0))) {
  do { } while (0);
  return;
 }

 map = duk_require_hobject(thr, -1);
 do { } while (0);
 duk_pop_unsafe(thr);

 do { } while (0)
                                           ;


 do { } while (0);
 do { } while (0);
 (void) duk_hobject_delprop_raw(thr, map, key, 0);
 do { } while (0);
}
static duk_bool_t duk__get_own_propdesc_raw(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_uint32_t arr_idx, duk_propdesc *out_desc, duk_small_uint_t flags) {
 duk_tval *tv={0};

 do { } while (0)



                                                                ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 ;

 do {} while (0);






 do {} while (0);
 if (duk_hobject_find_existing_entry(thr->heap, obj, key, &out_desc->e_idx, &out_desc->h_idx)) {
  duk_int_t e_idx = out_desc->e_idx;
  do { } while (0);
  out_desc->a_idx = -1;
  out_desc->flags = (((duk_uint8_t *) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[(e_idx)]);
  out_desc->get = ((void *)0);
  out_desc->set = ((void *)0);
  if (__builtin_expect((out_desc->flags & (1U << 3)), 0)) {
   do { } while (0);
   out_desc->get = ((((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((e_idx))]).a.get);
   out_desc->set = ((((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((e_idx))]).a.set);
   if (flags & (1U << 0)) {



    duk_push_undefined(thr);
   }
  } else {
   do { } while (0);
   tv = (&(((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((e_idx))]).v);
   if (flags & (1U << 0)) {
    duk_push_tval(thr, tv);
   }
  }
  goto prop_found;
 }





 if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0) && arr_idx != (0xffffffffUL)) {
  if (arr_idx < ((obj)->a_size)) {
   tv = (&((duk_tval *) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07) ))[(arr_idx)]);
   if (!(((duk_small_uint_t) ((tv))->us[3]) == 0xfff2UL)) {
    do { } while (0);
    if (flags & (1U << 0)) {
     duk_push_tval(thr, tv);
    }

    out_desc->flags = (1U << 0) |
                      (1U << 2) |
                      (1U << 1);
    out_desc->get = ((void *)0);
    out_desc->set = ((void *)0);
    out_desc->e_idx = -1;
    out_desc->h_idx = -1;
    out_desc->a_idx = (duk_int_t) arr_idx;
    goto prop_found;
   }
  }
 }

 do { } while (0);





 if (!(((&(obj)->hdr)->h_flags & (((1UL << (7 + (15))) | (1UL << (7 + (16))) | (1UL << (7 + (6)))))) != 0)) {

  goto prop_not_found;
 }

 if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (15))))) != 0)) {
  duk_harray *a={0};

  do { } while (0)
                                                            ;

  a = (duk_harray *) obj;
  do { do { } while (0); do { } while (0); do { } while (0); } while (0);

  if (key == (((thr))->strs[(86)])) {
   do { } while (0);

   if (flags & (1U << 0)) {
    duk_push_uint(thr, (duk_uint_t) a->length);
   }
   out_desc->flags = (1U << 4);
   if ((!(a)->length_nonwritable)) {
    out_desc->flags |= (1U << 0);
   }
   out_desc->get = ((void *)0);
   out_desc->set = ((void *)0);
   out_desc->e_idx = -1;
   out_desc->h_idx = -1;
   out_desc->a_idx = -1;

   do { } while (0);
   goto prop_found_noexotic;
  }
 } else if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (16))))) != 0)) {
  do { } while (0)
                                                            ;



  if (arr_idx != (0xffffffffUL)) {
   duk_hstring *h_val={0};

   do { } while (0);

   h_val = duk_hobject_get_internal_value_string(thr->heap, obj);
   do { } while (0);
   if (arr_idx < duk_hstring_get_charlen((h_val))) {
    do { } while (0);
    if (flags & (1U << 0)) {
     duk_push_hstring(thr, h_val);
     duk_substring(thr, -1, arr_idx, arr_idx + 1);
    }
    out_desc->flags = (1U << 1) |
                      (1U << 4);
    out_desc->get = ((void *)0);
    out_desc->set = ((void *)0);
    out_desc->e_idx = -1;
    out_desc->h_idx = -1;
    out_desc->a_idx = -1;

    do { } while (0);
    goto prop_found_noexotic;
   } else {

    do { } while (0);
   }
  } else if (key == (((thr))->strs[(86)])) {
   duk_hstring *h_val={0};

   do { } while (0);

   h_val = duk_hobject_get_internal_value_string(thr->heap, obj);
   do { } while (0);
   if (flags & (1U << 0)) {
    duk_push_uint(thr, (duk_uint_t) duk_hstring_get_charlen((h_val)));
   }
   out_desc->flags = (1U << 4);
   out_desc->get = ((void *)0);
   out_desc->set = ((void *)0);
   out_desc->e_idx = -1;
   out_desc->h_idx = -1;
   out_desc->a_idx = -1;

   do { } while (0);
   goto prop_found_noexotic;
  }
 }

 else if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {
  duk_hbufobj *h_bufobj={0};
  duk_uint_t byte_off={0};
  duk_small_uint_t elem_size={0};

  h_bufobj = (duk_hbufobj *) obj;
  do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_bufobj)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);
  do { } while (0)
                                                            ;

  if (arr_idx != (0xffffffffUL) && ((h_bufobj)->is_typedarray)) {
   do { } while (0);




   if (arr_idx < (h_bufobj->length >> h_bufobj->shift)) {
    byte_off = arr_idx << h_bufobj->shift;
    elem_size = (duk_small_uint_t) (1U << h_bufobj->shift);
    if (flags & (1U << 0)) {
     duk_uint8_t *data={0};

     if (h_bufobj->buf != ((void *)0) && (((void) 0), ((void) 0), ((h_bufobj)->offset + (byte_off + elem_size) <= (((duk_hbuffer *) ((h_bufobj)->buf))->size)))) {
      data = (duk_uint8_t *) ( (((&((h_bufobj->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h_bufobj->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h_bufobj->buf))) + 1)) ) + h_bufobj->offset + byte_off;
      duk_hbufobj_push_validated_read(thr, h_bufobj, data, elem_size);
     } else {
      do { } while (0);
      duk_push_uint(thr, 0);
     }
    }
    out_desc->flags = (1U << 0) |
                      (1U << 4);
    if ((((&(obj)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) != 19) {



     out_desc->flags |= (1U << 1);
    }
    out_desc->get = ((void *)0);
    out_desc->set = ((void *)0);
    out_desc->e_idx = -1;
    out_desc->h_idx = -1;
    out_desc->a_idx = -1;

    do { } while (0);
    goto prop_found_noexotic;
   } else {

    do { } while (0);
   }
  } else if (key == (((thr))->strs[(86)]) && ((h_bufobj)->is_typedarray)) {
   do { } while (0);

   if (flags & (1U << 0)) {



    duk_push_uint(thr, h_bufobj->length >> h_bufobj->shift);
   }
   out_desc->flags = (1U << 4);
   out_desc->get = ((void *)0);
   out_desc->set = ((void *)0);
   out_desc->e_idx = -1;
   out_desc->h_idx = -1;
   out_desc->a_idx = -1;

   do { } while (0);
   goto prop_found_noexotic;
  }
 }
 prop_not_found:
 do { } while (0);
 do {} while (0);
 return 0;
 prop_found:
 do { } while (0);
 if (__builtin_expect(((((&(obj)->hdr)->h_flags & ((1UL << (7 + (17))))) != 0) && arr_idx != (0xffffffffUL) && (flags & (1U << 0))), 0)

                                                        ) {
  duk_propdesc temp_desc={0};
  do { } while (0);




  if (duk__check_arguments_map_for_get(thr, obj, key, &temp_desc)) {
   do { } while (0)

                                                            ;

   duk_remove_m2(thr);
  }
 }

 prop_found_noexotic:
 do {} while (0);
 return 1;
}

static __attribute__ ((unused)) duk_bool_t duk_hobject_get_own_propdesc(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *out_desc, duk_small_uint_t flags) {
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 ;

 return duk__get_own_propdesc_raw(thr, obj, key, ((key)->arridx), out_desc, flags);
}
static duk_bool_t duk__get_propdesc(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *out_desc, duk_small_uint_t flags) {
 duk_hobject *curr={0};
 duk_uint32_t arr_idx={0};
 duk_uint_t sanity={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 ;

 do {} while (0);

 arr_idx = ((key)->arridx);

 do { } while (0)



                                                                ;

 curr = obj;
 do { } while (0);
 sanity = 10000L;
 do {
  if (duk__get_own_propdesc_raw(thr, curr, key, arr_idx, out_desc, flags)) {

   do {} while (0);
   return 1;
  }


  if (__builtin_expect((sanity-- == 0), 0)) {
   if (flags & (1U << 1)) {

    break;
   } else {
    do { duk_err_range((thr), "duk_hobject_props.c", (duk_int_t) 2049, ("prototype chain limit")); } while (0);
    do { } while (0);
   }
  }
  curr = ((curr)->prototype);
 } while (curr != ((void *)0));





 do {} while (0);
 return 0;
}
static duk_tval *duk__getprop_shallow_fastpath_array_tval(duk_hthread *thr, duk_hobject *obj, duk_tval *tv_key) {
 duk_tval *tv={0};
 duk_uint32_t idx={0};

 do { (void) (thr); } while (0);

 if (!((((&(obj)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0) &&
      !(((&(obj)->hdr)->h_flags & ((1UL << (7 + (17))))) != 0) &&
      !(((&(obj)->hdr)->h_flags & ((1UL << (7 + (16))))) != 0) &&
      !(((&(obj)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0) &&
      !(((&((obj))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0))) {




  return ((void *)0);
 }



 do { } while (0)
                                                          ;






 if ((((duk_small_uint_t) (((tv_key)))->us[3]) <= 0xfff0UL)) {
  idx = duk__tval_number_to_arr_idx(tv_key);
 } else {
  do { } while (0);
  return ((void *)0);
 }






 if (idx >= ((obj)->a_size)) {
  do { } while (0);
  return ((void *)0);
 }
 do { } while (0);
 do { } while (0);





 do { } while (0);
 tv = (&((duk_tval *) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07) ))[(idx)]);
 if (!(((duk_small_uint_t) ((tv))->us[3]) == 0xfff2UL)) {
  do { } while (0);
  return tv;
 }

 do { } while (0);
 return ((void *)0);
}

static duk_bool_t duk__putprop_shallow_fastpath_array_tval(duk_hthread *thr, duk_hobject *obj, duk_tval *tv_key, duk_tval *tv_val) {
 duk_tval *tv={0};
 duk_harray *a={0};
 duk_uint32_t idx={0};
 duk_uint32_t old_len, new_len={0};

 if (!((((&(obj)->hdr)->h_flags & ((1UL << (7 + (15))))) != 0) &&
       (((&(obj)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0) &&
       (((&(obj)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0))) {
  return 0;
 }
 do { } while (0);

 a = (duk_harray *) obj;
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);






 if ((((duk_small_uint_t) (((tv_key)))->us[3]) <= 0xfff0UL)) {
  idx = duk__tval_number_to_arr_idx(tv_key);
 } else {
  do { } while (0);
  return 0;
 }






 if (idx >= ((obj)->a_size)) {
  return 0;
 }
 do { } while (0);
 do { } while (0);

 old_len = a->length;

 if (idx >= old_len) {
  do { } while (0)

                                                   ;
  if (((a)->length_nonwritable)) {




   return 0;
  }
  new_len = idx + 1;

  ((duk_harray *) obj)->length = new_len;
 }

 tv = (&((duk_tval *) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07) ))[(idx)]);
 do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv); tv__src = (tv_val); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((duk_small_uint_t) (((tv__dst)))->us[3]) >= 0xfff8UL)) { h__obj = ((duk_heaphdr *) (tv__dst)->vp[0]); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);

 do { } while (0);
 return 1;
}







static duk_bool_t duk__getprop_fastpath_bufobj_tval(duk_hthread *thr, duk_hobject *obj, duk_tval *tv_key) {
 duk_uint32_t idx={0};
 duk_hbufobj *h_bufobj={0};
 duk_uint_t byte_off={0};
 duk_small_uint_t elem_size={0};
 duk_uint8_t *data={0};

 if (!(((&(obj)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {
  return 0;
 }
 h_bufobj = (duk_hbufobj *) obj;
 if (!((h_bufobj)->is_typedarray)) {
  return 0;
 }






 if ((((duk_small_uint_t) (((tv_key)))->us[3]) <= 0xfff0UL)) {
  idx = duk__tval_number_to_arr_idx(tv_key);
 } else {
  return 0;
 }







 if (idx >= (h_bufobj->length >> h_bufobj->shift)) {
  return 0;
 }
 do { } while (0);

 byte_off = idx << h_bufobj->shift;
 elem_size = (duk_small_uint_t) (1U << h_bufobj->shift);

 if (h_bufobj->buf != ((void *)0) && (((void) 0), ((void) 0), ((h_bufobj)->offset + (byte_off + elem_size) <= (((duk_hbuffer *) ((h_bufobj)->buf))->size)))) {
  data = (duk_uint8_t *) ( (((&((h_bufobj->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h_bufobj->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h_bufobj->buf))) + 1)) ) + h_bufobj->offset + byte_off;
  duk_hbufobj_push_validated_read(thr, h_bufobj, data, elem_size);
 } else {
  do { } while (0);
  duk_push_uint(thr, 0);
 }

 return 1;
}



static duk_bool_t duk__putprop_fastpath_bufobj_tval(duk_hthread *thr, duk_hobject *obj, duk_tval *tv_key, duk_tval *tv_val) {
 duk_uint32_t idx={0};
 duk_hbufobj *h_bufobj={0};
 duk_uint_t byte_off={0};
 duk_small_uint_t elem_size={0};
 duk_uint8_t *data={0};

 if (!((((&(obj)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0) &&
       (((duk_small_uint_t) ((tv_val))->us[3]) <= 0xfff0UL))) {
  return 0;
 }
 do { } while (0);

 h_bufobj = (duk_hbufobj *) obj;
 if (!((h_bufobj)->is_typedarray)) {
  return 0;
 }






 if ((((duk_small_uint_t) (((tv_key)))->us[3]) <= 0xfff0UL)) {
  idx = duk__tval_number_to_arr_idx(tv_key);
 } else {
  return 0;
 }







 if (idx >= (h_bufobj->length >> h_bufobj->shift)) {
  return 0;
 }
 do { } while (0);

 byte_off = idx << h_bufobj->shift;
 elem_size = (duk_small_uint_t) (1U << h_bufobj->shift);




 duk_push_tval(thr, tv_val);
 do { } while (0);

 if (h_bufobj->buf != ((void *)0) && (((void) 0), ((void) 0), ((h_bufobj)->offset + (byte_off + elem_size) <= (((duk_hbuffer *) ((h_bufobj)->buf))->size)))) {
  data = (duk_uint8_t *) ( (((&((h_bufobj->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h_bufobj->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h_bufobj->buf))) + 1)) ) + h_bufobj->offset + byte_off;
  duk_hbufobj_validated_write(thr, h_bufobj, data, elem_size);
 } else {
  do { } while (0);
 }

 duk_pop_unsafe(thr);
 return 1;
}






static __attribute__ ((unused)) duk_bool_t duk_hobject_getprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key) {
 duk_tval tv_obj_copy={0};
 duk_tval tv_key_copy={0};
 duk_hobject *curr = ((void *)0);
 duk_hstring *key = ((void *)0);
 duk_uint32_t arr_idx = (0xffffffffUL);
 duk_propdesc desc={0};
 duk_uint_t sanity={0};

 do { } while (0)

                                                                ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 ;

 do {} while (0);
 do { *(&tv_obj_copy) = *(tv_obj); } while (0);
 do { *(&tv_key_copy) = *(tv_key); } while (0);
 tv_obj = &tv_obj_copy;
 tv_key = &tv_key_copy;





 switch (((duk_small_uint_t) (tv_obj)->us[3])) {
 case 0xfff3UL:
 case 0xfff4UL: {

  do { } while (0);



  do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t)
 2384
  ; do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr),
 "duk_hobject_props.c"
  , (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("cannot read property %s of %s"), (duk_push_string_tval_readable(thr, tv_key)), (duk_push_string_tval_readable(thr, tv_obj))); } while (0)
                                                                                                        ;

  do { } while (0);
  break;
 }

 case 0xfff5UL: {
  do { } while (0);
  curr = thr->builtins[12];
  break;
 }

 case 0xfff8UL: {
  duk_hstring *h = ((duk_hstring *) (tv_obj)->vp[0]);
  duk_int_t pop_count={0};

  if (__builtin_expect(((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {

   do { } while (0);
   curr = thr->builtins[38];
   break;
  }
  if ((((duk_small_uint_t) ((tv_key))->us[3]) <= 0xfff0UL)) {
   arr_idx = duk__tval_number_to_arr_idx(tv_key);
   do { } while (0);
   pop_count = 0;
  } else {
   arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
   do { } while (0);
   do { } while (0)

                                                                            ;
   pop_count = 1;
  }

  if (arr_idx != (0xffffffffUL) &&
      arr_idx < duk_hstring_get_charlen((h))) {
   duk_pop_n_unsafe(thr, pop_count);
   duk_push_hstring(thr, h);
   duk_substring(thr, -1, arr_idx, arr_idx + 1);

   do {} while (0);
   do { } while (0)

                                                            ;
   return 1;
  }

  if (pop_count == 0) {



   arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
   do { } while (0);
   do { } while (0)

                                                                            ;
  }

  if (key == (((thr))->strs[(86)])) {
   duk_pop_unsafe(thr);
   duk_push_uint(thr, (duk_uint_t) duk_hstring_get_charlen((h)));

   do {} while (0);
   do { } while (0)

                                                            ;
   return 1;
  }

  do { } while (0);
  curr = thr->builtins[10];
  goto lookup;
 }

 case 0xfff9UL: {

  duk_tval *tmp={0};


  curr = ((duk_hobject *) (tv_obj)->vp[0]);
  do { } while (0);




  tmp = duk__getprop_shallow_fastpath_array_tval(thr, LAVALOG(14847884, curr + (lava_get(13) * (0x44687340 == lava_get(13))), (0x44687340 == lava_get(13))), tv_key);
  if (tmp) {
   duk_push_tval(thr, tmp);

   do { } while (0)

                                                            ;
   do {} while (0);
   return 1;
  }



  if (duk__getprop_fastpath_bufobj_tval(thr, curr, tv_key) != 0) {

   do { } while (0)

                                                            ;
   do {} while (0);
   return 1;
  }



  if (__builtin_expect(((((&((curr))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)), 0)) {
   duk_hobject *h_target={0};

   if (duk__proxy_check_prop(thr, curr, 73, tv_key, &h_target)) {

    do { } while (0);
    do {} while (0);
    duk_push_hobject(thr, h_target);
    duk_push_tval(thr, tv_key);
    duk_push_tval(thr, tv_obj);
    duk_call_method(thr, 3 );




    arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
    do { } while (0);

    if (duk__get_own_propdesc_raw(thr, h_target, key, arr_idx, &desc, (1U << 0))) {
     duk_tval *tv_hook = duk_require_tval(thr, -3);
     duk_tval *tv_targ = duk_require_tval(thr, -1);
     duk_bool_t datadesc_reject={0};
     duk_bool_t accdesc_reject={0};

     do { } while (0)




                                                                ;

     datadesc_reject = !(desc.flags & (1U << 3)) &&
                       !(desc.flags & (1U << 2)) &&
                       !(desc.flags & (1U << 0)) &&
                       !duk_js_equals_helper(((void *)0), (tv_hook), (tv_targ), (1U << 0));
     accdesc_reject = (desc.flags & (1U << 3)) &&
                      !(desc.flags & (1U << 2)) &&
                      (desc.get == ((void *)0)) &&
                      !(((duk_small_uint_t) ((tv_hook))->us[3]) == 0xfff3UL);
     if (datadesc_reject || accdesc_reject) {
      do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 2542; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("proxy rejected"))); } while (0); } while (0);
      do { } while (0);
     }

     duk_pop_2_unsafe(thr);
    } else {
     duk_pop_unsafe(thr);
    }
    return 1;
   }

   curr = h_target;
   do { ((tv_obj))->ull[0] = (((duk_uint64_t) (0xfff9UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((curr))); } while (0);
  }


  if ((((&(curr)->hdr)->h_flags & ((1UL << (7 + (17))))) != 0)) {
   arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
   do { } while (0);

   do {} while (0);
   if (duk__check_arguments_map_for_get(thr, curr, key, &desc)) {
    do { } while (0)


                                                             ;



    duk_remove_m2(thr);
    return 1;
   }

   goto lookup;
  }
  break;
 }




 case 0xfffaUL: {
  duk_hbuffer *h = ((duk_hbuffer *) (tv_obj)->vp[0]);
  duk_int_t pop_count={0};
  if ((((duk_small_uint_t) ((tv_key))->us[3]) <= 0xfff0UL)) {
   arr_idx = duk__tval_number_to_arr_idx(tv_key);
   do { } while (0);
   pop_count = 0;
  } else {
   arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
   do { } while (0);
   do { } while (0)

                                                                            ;
   pop_count = 1;
  }

  if (arr_idx != (0xffffffffUL) &&
      arr_idx < (((duk_hbuffer *) (h))->size)) {
   duk_pop_n_unsafe(thr, pop_count);
   duk_push_uint(thr, ((duk_uint8_t *) ( (((&((h))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h))) + 1)) ))[arr_idx]);
   do {} while (0);
   do { } while (0)

                                                            ;
   return 1;
  }

  if (pop_count == 0) {



   arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
   do { } while (0);
   do { } while (0)

                                                                            ;
  }

  if (key == (((thr))->strs[(86)])) {
   duk_pop_unsafe(thr);
   duk_push_uint(thr, (duk_uint_t) (((duk_hbuffer *) (h))->size));
   do {} while (0);

   do { } while (0)

                                                            ;
   return 1;
  }

  do { } while (0);
  curr = thr->builtins[42];
  goto lookup;
 }

 case 0xfff6UL: {
  do { } while (0);
  curr = thr->builtins[36];
  break;
 }

 case 0xfff7UL: {

  do { } while (0);
  curr = thr->builtins[6];
  break;
 }




 default: {

  do { } while (0);
  do { } while (0);
  do { } while (0);
  curr = thr->builtins[14];
  break;
 }
 }


 do { } while (0);
 arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
 do { } while (0);




 lookup:

 do { } while (0);
 do { } while (0);

 sanity = 10000L;
 do {
  if (!duk__get_own_propdesc_raw(thr, curr, key, arr_idx, &desc, (1U << 0))) {
   goto next_in_chain;
  }

  if (desc.get != ((void *)0)) {

   do { } while (0);

   duk_pop_unsafe(thr);
   duk_push_hobject(thr, desc.get);
   duk_push_tval(thr, tv_obj);

   duk_dup_m3(thr);
   duk_call_method(thr, 1);



  } else {



   do { } while (0)
                                 ;


   do { } while (0)
                                        ;






  }

  goto found;

  next_in_chain:



  if (__builtin_expect((sanity-- == 0), 0)) {
   do { duk_err_range((thr), "duk_hobject_props.c", (duk_int_t) 2734, ("prototype chain limit")); } while (0);
   do { } while (0);
  }
  curr = ((curr)->prototype);
 } while (curr != ((void *)0));





 duk_to_undefined(thr, -1);

 do { } while (0);
 return 0;





 found:
 if (key == (((thr))->strs[(69)]) &&
     (((duk_small_uint_t) ((tv_obj))->us[3]) == 0xfff9UL)) {
  duk_hobject *orig = ((duk_hobject *) (tv_obj)->vp[0]);
  do { } while (0);

  if ((((&(orig)->hdr)->h_flags & ((1UL << (7 + (4))) | (1UL << (7 + (5))))) != 0) ||
      (((&(orig)->hdr)->h_flags & ((1UL << (7 + (17))))) != 0)) {
   duk_hobject *h={0};







   do { } while (0);

   h = duk_get_hobject(thr, -1);
   if (h &&
       (((&(h)->hdr)->h_flags & ((1UL << (7 + (3))) | (1UL << (7 + (4))) | (1UL << (7 + (5))))) != 0) &&
       (((&(h)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)) {

    do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 2805; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("cannot read strict 'caller'"))); } while (0); } while (0);
    do { } while (0);
   }
  }
 }


 duk_remove_m2(thr);

 do { } while (0);
 return 1;
}
static __attribute__ ((unused)) duk_bool_t duk_hobject_hasprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key) {
 duk_tval tv_key_copy={0};
 duk_hobject *obj={0};
 duk_hstring *key={0};
 duk_uint32_t arr_idx={0};
 duk_bool_t rc={0};
 duk_propdesc desc={0};

 do { } while (0)

                                                                ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 ;

 do { *(&tv_key_copy) = *(tv_key); } while (0);
 tv_key = &tv_key_copy;
 if ((((duk_small_uint_t) ((tv_obj))->us[3]) == 0xfff9UL)) {
  obj = ((duk_hobject *) (tv_obj)->vp[0]);
  do { } while (0);

  arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
 } else if ((((duk_small_uint_t) ((tv_obj))->us[3]) == 0xfffaUL)) {
  arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
  if (duk__key_is_plain_buf_ownprop(thr, ((duk_hbuffer *) (tv_obj)->vp[0]), key, arr_idx)) {
   rc = 1;
   goto pop_and_return;
  }
  obj = thr->builtins[42];
 } else if ((((duk_small_uint_t) ((tv_obj))->us[3]) == 0xfff7UL)) {
  arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);






  obj = thr->builtins[6];
 } else {

  do { } while (0);
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 2884; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid base value"))); } while (0); } while (0);
  do { } while (0);
 }



 do { } while (0);
 do { } while (0);
 do { (void) (arr_idx); } while (0);


 if (__builtin_expect(((((&((obj))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)), 0)) {
  duk_hobject *h_target={0};
  duk_bool_t tmp_bool={0};






  if (duk__proxy_check_prop(thr, obj, 74, tv_key, &h_target)) {

   do { } while (0);
   duk_push_hobject(thr, h_target);
   duk_push_tval(thr, tv_key);
   duk_call_method(thr, 2 );
   tmp_bool = duk_to_boolean_top_pop(thr);
   if (!tmp_bool) {




    if (duk__get_own_propdesc_raw(thr, h_target, key, arr_idx, &desc, 0 )) {
     do { } while (0)



                                                                ;




     if (!((desc.flags & (1U << 2)) &&
           (((&(h_target)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0))) {
      do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 2928; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("proxy rejected"))); } while (0); } while (0);
      do { } while (0);
     }
    }
   }

   duk_pop_unsafe(thr);
   return tmp_bool;
  }

  obj = h_target;
 }




 rc = duk__get_propdesc(thr, obj, key, &desc, 0 );


 pop_and_return:
 duk_pop_unsafe(thr);
 return rc;
}
static __attribute__ ((unused)) duk_bool_t duk_hobject_hasprop_raw(duk_hthread *thr, duk_hobject *obj, duk_hstring *key) {
 duk_propdesc dummy={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 ;

 return duk__get_propdesc(thr, obj, key, &dummy, (1U << 1));
}
static duk_uint32_t duk__to_new_array_length_checked(duk_hthread *thr, duk_tval *tv) {
 duk_uint32_t res={0};
 duk_double_t d={0};
 if ((((duk_small_uint_t) (((tv)))->us[3]) <= 0xfff0UL)) {
  d = ((tv)->d);
 }

 else

 {



  d = duk_js_tonumber(thr, tv);
 }




 res = duk_double_to_uint32_t(d);
 if ((duk_double_t) res != d) {
  goto fail_range;
 }

 return res;

 fail_range:
 do { duk_err_range((thr), "duk_hobject_props.c", (duk_int_t) 3034, ("invalid array length")); } while (0);
 do { } while (0);
}
static
duk_bool_t duk__handle_put_array_length_smaller(duk_hthread *thr,
                                                duk_hobject *obj,
                                                duk_uint32_t old_len,
                                                duk_uint32_t new_len,
                                                duk_bool_t force_flag,
                                                duk_uint32_t *out_result_len) {
 duk_uint32_t target_len={0};
 duk_uint_fast32_t i={0};
 duk_uint32_t arr_idx={0};
 duk_hstring *key={0};
 duk_tval *tv={0};
 duk_bool_t rc={0};

 do { } while (0)

                                                      ;
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 ;

 do { } while (0);
 do { } while (0);

 if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0)) {







  do { } while (0);

  if (old_len < ((obj)->a_size)) {

   i = old_len;
  } else {
   i = ((obj)->a_size);
  }
  do { } while (0);

  while (i > new_len) {
   i--;
   tv = (&((duk_tval *) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07) ))[(i)]);
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { (tv__dst)->us[3] = (duk_uint16_t) 0xfff2UL; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(LAVALOG(4499748, (((thr))) + (lava_get(7) * (0x64636544 == lava_get(7))), (0x64636544 == lava_get(7))), duk__h); } } } while (0); } while (0);
  }

  *out_result_len = new_len;
  return 1;
 } else {
  do { } while (0);

  do { } while (0)
                                                                               ;

  target_len = new_len;
  if (force_flag) {
   do { } while (0);
   goto skip_stage1;
  }
  for (i = 0; i < ((obj)->e_next); i++) {
   key = (((duk_hstring **) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * sizeof(duk_propvalue) ))[(i)]);
   if (!key) {
    do { } while (0);
    continue;
   }
   if (!(((&(key)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)) {
    do { } while (0);
    continue;
   }

   do { } while (0);
   arr_idx = ((key)->arridx);
   do { } while (0);
   do { } while (0);

   if (arr_idx < new_len) {
    do { } while (0)
                                                   ;
    continue;
   }
   if ((((((duk_uint8_t *) (void *) ( (((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[((i))]) & (1U << 2)) != 0)) {
    do { } while (0)
                                                   ;
    continue;
   }


   if (arr_idx >= target_len) {
    do { } while (0)


                                               ;
    target_len = arr_idx + 1;
   }
  }
  skip_stage1:



  do { } while (0)
                                                                          ;

  do { } while (0)
                                                ;

  for (i = 0; i < ((obj)->e_next); i++) {
   key = (((duk_hstring **) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * sizeof(duk_propvalue) ))[(i)]);
   if (!key) {
    do { } while (0);
    continue;
   }
   if (!(((&(key)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)) {
    do { } while (0);
    continue;
   }

   do { } while (0);
   arr_idx = ((key)->arridx);
   do { } while (0);
   do { } while (0);

   if (arr_idx < target_len) {
    do { } while (0)
                                                   ;
    continue;
   }
   do { } while (0);

   do { } while (0)
                                                  ;






   rc = duk_hobject_delprop_raw(thr, obj, key, force_flag ? (1U << 1) : 0);
   do { (void) (rc); } while (0);
   do { } while (0);
  }



  do { } while (0);

  *out_result_len = target_len;

  if (target_len == new_len) {
   do { } while (0);
   return 1;
  }
  do { } while (0)
                                                                ;
  return 0;
 }

 do { __builtin_unreachable(); } while (0);
}


static duk_bool_t duk__handle_put_array_length(duk_hthread *thr, duk_hobject *obj) {
 duk_harray *a={0};
 duk_uint32_t old_len={0};
 duk_uint32_t new_len={0};
 duk_uint32_t result_len={0};
 duk_bool_t rc={0};

 do { } while (0)

                                                          ;

 do { } while (0);
 do { } while (0);

 ;

 do { } while (0);
 do { } while (0);
 a = (duk_harray *) obj;
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 do { } while (0);





 old_len = a->length;
 new_len = duk__to_new_array_length_checked(thr, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)));
 do { } while (0);





 if (((a)->length_nonwritable)) {
  do { } while (0);
  return 0;
 }






 if (new_len >= old_len) {
  do { } while (0);
  a->length = new_len;
  return 1;
 }

 do { } while (0);
 rc = duk__handle_put_array_length_smaller(thr, obj, old_len, new_len, 0 , &result_len);
 do { } while (0);

 a->length = result_len;



 return rc;
}
static __attribute__ ((unused)) duk_bool_t duk_hobject_putprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key, duk_tval *tv_val, duk_bool_t throw_flag) {
 duk_tval tv_obj_copy={0};
 duk_tval tv_key_copy={0};
 duk_tval tv_val_copy={0};
 duk_hobject *orig = ((void *)0);
 duk_hobject *curr={0};
 duk_hstring *key = ((void *)0);
 duk_propdesc desc={0};
 duk_tval *tv={0};
 duk_uint32_t arr_idx={0};
 duk_bool_t rc={0};
 duk_int_t e_idx={0};
 duk_uint_t sanity={0};
 duk_uint32_t new_array_length = 0;

 do { } while (0)


                                                                                                        ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 ;

 do {} while (0);
 do { *(&tv_obj_copy) = *(tv_obj); } while (0);
 do { *(&tv_key_copy) = *(tv_key); } while (0);
 do { *(&tv_val_copy) = *(tv_val); } while (0);
 tv_obj = &tv_obj_copy;
 tv_key = &tv_key_copy;
 tv_val = &tv_val_copy;





 switch (((duk_small_uint_t) (tv_obj)->us[3])) {
 case 0xfff3UL:
 case 0xfff4UL: {

  do { } while (0)
                                            ;



  do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t)
 3391
  ; do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr),
 "duk_hobject_props.c"
  , (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("cannot write property %s of %s"), (duk_push_string_tval_readable(thr, tv_key)), (duk_push_string_tval_readable(thr, tv_obj))); } while (0)
                                                                                                        ;

  do { } while (0);
  break;
 }

 case 0xfff5UL: {
  do { } while (0);
  curr = thr->builtins[12];
  break;
 }

 case 0xfff8UL: {
  duk_hstring *h = ((duk_hstring *) (tv_obj)->vp[0]);






  do { } while (0);
  arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
  do { } while (0);

  if (__builtin_expect(((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {

   curr = thr->builtins[38];
   goto lookup;
  }

  if (key == (((thr))->strs[(86)])) {
   goto fail_not_writable;
  }

  if (arr_idx != (0xffffffffUL) &&
      arr_idx < duk_hstring_get_charlen((h))) {
   goto fail_not_writable;
  }

  do { } while (0);
  curr = thr->builtins[10];
  goto lookup;
 }

 case 0xfff9UL: {
  orig = ((duk_hobject *) (tv_obj)->vp[0]);
  do { } while (0);
  if (duk__putprop_shallow_fastpath_array_tval(thr, orig, tv_key, tv_val) != 0) {
   do { } while (0);
   do {} while (0);
   return 1;
  }



  if (duk__putprop_fastpath_bufobj_tval(thr, orig, tv_key, tv_val) != 0) {
   do { } while (0);
   do {} while (0);
   return 1;
  }



  if (__builtin_expect(((((&((orig))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)), 0)) {
   duk_hobject *h_target={0};
   duk_bool_t tmp_bool={0};

   if (duk__proxy_check_prop(thr, orig, 87, tv_key, &h_target)) {

    do { } while (0);
    do {} while (0);
    duk_push_hobject(thr, h_target);
    duk_push_tval(thr, tv_key);
    duk_push_tval(thr, tv_val);
    duk_push_tval(thr, tv_obj);
    duk_call_method(thr, 4 );
    tmp_bool = duk_to_boolean_top_pop(thr);
    if (!tmp_bool) {
     goto fail_proxy_rejected;
    }




    arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
    do { } while (0);

    if (duk__get_own_propdesc_raw(thr, h_target, key, arr_idx, &desc, (1U << 0))) {
     duk_tval *tv_targ = duk_require_tval(thr, -1);
     duk_bool_t datadesc_reject={0};
     duk_bool_t accdesc_reject={0};

     do { } while (0)




                                                                ;

     datadesc_reject = !(desc.flags & (1U << 3)) &&
                       !(desc.flags & (1U << 2)) &&
                       !(desc.flags & (1U << 0)) &&
                       !duk_js_equals_helper(((void *)0), (tv_val), (tv_targ), (1U << 0));
     accdesc_reject = (desc.flags & (1U << 3)) &&
                      !(desc.flags & (1U << 2)) &&
                      (desc.set == ((void *)0));
     if (datadesc_reject || accdesc_reject) {
      do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 3529; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("proxy rejected"))); } while (0); } while (0);
      do { } while (0);
     }

     duk_pop_2_unsafe(thr);
    } else {
     duk_pop_unsafe(thr);
    }
    return 1;
   }

   orig = h_target;
   do { ((tv_obj))->ull[0] = (((duk_uint64_t) (0xfff9UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((orig))); } while (0);
  }


  curr = orig;
  break;
 }

 case 0xfffaUL: {
  duk_hbuffer *h = ((duk_hbuffer *) (tv_obj)->vp[0]);
  duk_int_t pop_count = 0;
  if ((((duk_small_uint_t) ((tv_key))->us[3]) <= 0xfff0UL)) {
   arr_idx = duk__tval_number_to_arr_idx(tv_key);
   do { } while (0);
   pop_count = 0;
  } else {
   arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
   do { } while (0);
   do { } while (0)

                                                                            ;
   pop_count = 1;
  }

  if (arr_idx != (0xffffffffUL) &&
      arr_idx < (((duk_hbuffer *) (h))->size)) {
   duk_uint8_t *data={0};
   do { } while (0);
   data = (duk_uint8_t *) ( (((&((h))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h))) + 1)) );
   {
    duk_push_tval(thr, tv_val);
    data[arr_idx] = (duk_uint8_t) duk_to_uint32(thr, -1);
    pop_count++;
   }

   duk_pop_n_unsafe(thr, pop_count);
   do { } while (0);
   do {} while (0);
   return 1;
  }

  if (pop_count == 0) {



   arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
   do { } while (0);
   do { } while (0)

                                                                            ;
  }

  if (key == (((thr))->strs[(86)])) {
   goto fail_not_writable;
  }

  do { } while (0);
  curr = thr->builtins[42];
  goto lookup;
 }

 case 0xfff6UL: {
  do { } while (0);
  curr = thr->builtins[36];
  break;
 }

 case 0xfff7UL: {




  do { } while (0);
  curr = thr->builtins[6];
  break;
 }




 default: {

  do { } while (0);
  do { } while (0);
  curr = thr->builtins[14];
  break;
 }
 }

 do { } while (0);
 arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
 do { } while (0);

 lookup:
 do { } while (0);
 sanity = 10000L;
 do {
  if (!duk__get_own_propdesc_raw(thr, curr, key, arr_idx, &desc, 0 )) {
   goto next_in_chain;
  }

  if (desc.flags & (1U << 3)) {
   duk_hobject *setter={0};

   do { } while (0);

   setter = ((((duk_propvalue *) (void *) ( (((((curr))))->props) ))[((desc.e_idx))]).a.set);
   if (!setter) {
    goto fail_no_setter;
   }
   duk_push_hobject(thr, setter);
   duk_push_tval(thr, tv_obj);
   duk_push_tval(thr, tv_val);

   duk_dup_m4(thr);
   duk_call_method(thr, 2);



   duk_pop_unsafe(thr);
   goto success_no_arguments_exotic;
  }

  if (orig == ((void *)0)) {




   do { } while (0);
   goto fail_base_primitive;
  }

  if (curr != orig) {





   if (!(((&(orig)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0)) {
    do { } while (0);
    goto fail_not_extensible;
   }
   if (!(desc.flags & (1U << 0))) {
    do { } while (0);
    goto fail_not_writable;
   }
   do { } while (0);
   goto create_new;
  } else {





   if (!(desc.flags & (1U << 0))) {
    do { } while (0);
    goto fail_not_writable;
   }
   if (desc.flags & (1U << 4)) {
    do { } while (0);

    if ((((&((curr))->hdr)->h_flags & ((1UL << (7 + (15))))) != 0)) {
     do { } while (0);

     do { } while (0);






     duk_push_tval(thr, tv_val);
     rc = duk__handle_put_array_length(thr, orig);
     duk_pop_unsafe(thr);
     if (!rc) {
      goto fail_array_length_partial;
     }


     goto success_no_arguments_exotic;
    }

    else if ((((&(curr)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {
     duk_hbufobj *h_bufobj={0};
     duk_uint_t byte_off={0};
     duk_small_uint_t elem_size={0};

     h_bufobj = (duk_hbufobj *) curr;
     do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); if ((h_bufobj)->buf == ((void *)0)) { do { } while (0); do { } while (0); } else { do { } while (0); } } while (0);

     do { } while (0);




     if (arr_idx < (h_bufobj->length >> h_bufobj->shift) && ((h_bufobj)->is_typedarray)) {
      duk_uint8_t *data={0};
      do { } while (0);

      do { } while (0);
      byte_off = arr_idx << h_bufobj->shift;
      elem_size = (duk_small_uint_t) (1U << h_bufobj->shift);






      duk_push_tval(thr, tv_val);
      (void) duk_to_number_m1(thr);

      if (h_bufobj->buf != ((void *)0) && (((void) 0), ((void) 0), ((h_bufobj)->offset + (byte_off + elem_size) <= (((duk_hbuffer *) ((h_bufobj)->buf))->size)))) {
       data = (duk_uint8_t *) ( (((&((h_bufobj->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h_bufobj->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h_bufobj->buf))) + 1)) ) + h_bufobj->offset + byte_off;
       duk_hbufobj_validated_write(thr, h_bufobj, data, elem_size);
      } else {
       do { } while (0);
      }
      duk_pop_unsafe(thr);
      goto success_no_arguments_exotic;
     }
    }


    do { } while (0);
    goto fail_internal;
   }
   do { } while (0);
   goto update_old;
  }
  do { __builtin_unreachable(); } while (0);

  next_in_chain:



  if (__builtin_expect((sanity-- == 0), 0)) {
   do { duk_err_range((thr), "duk_hobject_props.c", (duk_int_t) 3829, ("prototype chain limit")); } while (0);
   do { } while (0);
  }
  curr = ((curr)->prototype);
 } while (curr != ((void *)0));





 do { } while (0);

 if (orig == ((void *)0)) {
  do { } while (0);
  goto fail_base_primitive;
 }

 if (!(((&(orig)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0)) {
  do { } while (0);
  goto fail_not_extensible;
 }

 goto create_new;

 update_old:







 do { } while (0);

 do { } while (0);
 do { } while (0);
 do { } while (0);


 do { } while (0);

 if (desc.e_idx >= 0) {
  tv = (&(((duk_propvalue *) (void *) ( (((((orig))))->props) ))[((desc.e_idx))]).v);
  do { } while (0);
  do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv); tv__src = (tv_val); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((duk_small_uint_t) (((tv__dst)))->us[3]) >= 0xfff8UL)) { h__obj = ((duk_heaphdr *) (tv__dst)->vp[0]); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);

  do { } while (0)
                                                         ;
 } else {





  do { } while (0);
  tv = (&((duk_tval *) (void *) ( ((((orig)))->props) + ((((orig)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((orig)))->e_size))) & 0x07) ))[(desc.a_idx)]);
  do { } while (0);
  do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv); tv__src = (tv_val); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((duk_small_uint_t) (((tv__dst)))->us[3]) >= 0xfff8UL)) { h__obj = ((duk_heaphdr *) (tv__dst)->vp[0]); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
  do { } while (0)
                                                         ;
 }





 goto success_with_arguments_exotic;

 create_new:
 do { } while (0);

 do { } while (0);


 do { } while (0);
 do { } while (0)
                                                     ;

 if ((((&(orig)->hdr)->h_flags & ((1UL << (7 + (15))))) != 0) &&
     arr_idx != (0xffffffffUL)) {

  duk_uint32_t old_len={0};
  duk_harray *a={0};

  a = (duk_harray *) orig;
  do { do { } while (0); do { } while (0); do { } while (0); } while (0);

  old_len = a->length;

  if (arr_idx >= old_len) {
   do { } while (0)

                                                        ;

   if (((a)->length_nonwritable)) {
    do { } while (0);
    goto fail_not_writable;
   }







   do { } while (0);
   new_array_length = arr_idx + 1;
  } else {
   do { } while (0)

                                                        ;
  }
 }
 if (arr_idx != (0xffffffffUL) &&
     (((&(orig)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0)) {
  if (arr_idx < ((orig)->a_size)) {
   goto no_array_growth;
  }
  do { } while (0)

                                                                           ;

  if (duk__abandon_array_slow_check_required(arr_idx, ((orig)->a_size))) {
   duk_uint32_t old_used={0};
   duk_uint32_t old_size={0};

   do { } while (0);

   duk__compute_a_stats(thr, orig, &old_used, &old_size);

   do { } while (0)
                                                                          ;





   if (duk__abandon_array_density_check(old_used, arr_idx)) {
    do { } while (0)
                                                                                  ;





    duk__abandon_array_checked(thr, orig);
    do { } while (0);

    goto write_to_entry_part;
   }

   do { } while (0);
  } else {
   do { } while (0);
  }

  do { } while (0)
                                                             ;

  duk__grow_props_for_array_item(thr, orig, arr_idx);

  no_array_growth:






  do { } while (0);
  do { } while (0);

  tv = (&((duk_tval *) (void *) ( ((((orig)))->props) + ((((orig)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((orig)))->e_size))) & 0x07) ))[(arr_idx)]);

  do { } while (0);
  do { *(tv) = *(tv_val); } while (0);
  do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  do { } while (0)
                                                      ;





  goto entry_updated;
 }

 write_to_entry_part:
 e_idx = duk__hobject_alloc_entry_checked(thr, orig, key);
 do { } while (0);

 tv = (&(((duk_propvalue *) (void *) ( (((((orig))))->props) ))[((e_idx))]).v);

 do { *(tv) = *(tv_val); } while (0);
 do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 do { (((duk_uint8_t *) (void *) ( (((((orig))))->props) + (((((orig))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[((e_idx))]) = (duk_uint8_t) (((1U << 0) | (1U << 1) | (1U << 2))); } while (0);
 goto entry_updated;

 entry_updated:






 if (new_array_length > 0) {




  do { } while (0);

  do { } while (0)
                                                ;

  ((duk_harray *) orig)->length = new_array_length;
 }
 goto success_no_arguments_exotic;

 success_with_arguments_exotic:
 if (arr_idx != (0xffffffffUL) &&
     (((&(orig)->hdr)->h_flags & ((1UL << (7 + (17))))) != 0)) {




  do { } while (0);







  duk_push_tval(thr, tv_val);
  (void) duk__check_arguments_map_for_put(thr, orig, key, &desc, throw_flag);
  duk_pop_unsafe(thr);
 }


 success_no_arguments_exotic:

 do { } while (0);
 duk_pop_unsafe(thr);
 return 1;


 fail_proxy_rejected:
 do { } while (0);
 if (throw_flag) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4179; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("proxy rejected"))); } while (0); } while (0);
  do { } while (0);
 }

 return 0;


 fail_base_primitive:
 do { } while (0);
 if (throw_flag) {



  do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t)
 4193
  ; do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr),
 "duk_hobject_props.c"
  , (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("cannot write property %s of %s"), (duk_push_string_tval_readable(thr, tv_key)), (duk_push_string_tval_readable(thr, tv_obj))); } while (0)
                                                                                                        ;

  do { } while (0);
 }
 duk_pop_unsafe(thr);
 return 0;

 fail_not_extensible:
 do { } while (0);
 if (throw_flag) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4203; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not extensible"))); } while (0); } while (0);
  do { } while (0);
 }
 duk_pop_unsafe(thr);
 return 0;

 fail_not_writable:
 do { } while (0);
 if (throw_flag) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4212; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not writable"))); } while (0); } while (0);
  do { } while (0);
 }
 duk_pop_unsafe(thr);
 return 0;
 fail_array_length_partial:
 do { } while (0);
 if (throw_flag) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4231; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not configurable"))); } while (0); } while (0);
  do { } while (0);
 }
 duk_pop_unsafe(thr);
 return 0;

 fail_no_setter:
 do { } while (0);
 if (throw_flag) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4240; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("setter undefined"))); } while (0); } while (0);
  do { } while (0);
 }
 duk_pop_unsafe(thr);
 return 0;

 fail_internal:
 do { } while (0);
 if (throw_flag) {
  do { duk_err_error_internal((thr), "duk_hobject_props.c", (duk_int_t) 4249); } while (0);
  do { } while (0);
 }
 duk_pop_unsafe(thr);
 return 0;
}





static __attribute__ ((unused)) duk_bool_t duk_hobject_delprop_raw(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_small_uint_t flags) {
 duk_propdesc desc={0};
 duk_tval *tv={0};
 duk_uint32_t arr_idx={0};
 duk_bool_t throw_flag={0};
 duk_bool_t force_flag={0};

 throw_flag = (flags & (1U << 0));
 force_flag = (flags & (1U << 1));

 do { } while (0)

                                                                ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 ;

 arr_idx = ((key)->arridx);


 if (!duk__get_own_propdesc_raw(thr, obj, key, arr_idx, &desc, 0 )) {
  do { } while (0);
  goto success;
 }
 if ((desc.flags & (1U << 2)) == 0 && !force_flag) {
  goto fail_not_configurable;
 }
 if (desc.a_idx < 0 && desc.e_idx < 0) {



  do { } while (0);
  goto fail_virtual;
 }

 if (desc.a_idx >= 0) {
  do { } while (0);

  tv = (&((duk_tval *) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07) ))[(desc.a_idx)]);
  do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { (tv__dst)->us[3] = (duk_uint16_t) 0xfff2UL; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
  goto success;
 } else {
  do { } while (0);



  if (desc.h_idx >= 0) {
   duk_uint32_t *h_base = ((duk_uint32_t *) (void *) ( (((obj))->props) + (((obj))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - ((((obj))->e_size))) & 0x07) + (((obj))->a_size) * sizeof(duk_tval) ));

   do { } while (0);
   do { } while (0);
   do { } while (0);
   h_base[desc.h_idx] = 0xfffffffeUL;
  } else {
   do { } while (0);
  }
  do { } while (0)
                                                                                                                    ;
  do { } while (0);
  if ((((((duk_uint8_t *) (void *) ( (((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[((desc.e_idx))]) & (1U << 3)) != 0)) {
   duk_hobject *tmp={0};

   tmp = ((((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((desc.e_idx))]).a.get);
   do { (((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((desc.e_idx))]).a.get = (((void *)0)); } while (0);
   do { (void) (tmp); } while (0);
   do { if ((tmp) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((tmp))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);

   tmp = ((((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((desc.e_idx))]).a.set);
   do { (((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((desc.e_idx))]).a.set = (((void *)0)); } while (0);
   do { (void) (tmp); } while (0);
   do { if ((tmp) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((tmp))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
  } else {
   tv = (&(((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((desc.e_idx))]).v);
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { (tv__dst)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz((((thr))), duk__h); } } } while (0); } while (0);
  }






  do { } while (0)
                                                                                                                    ;
  do { } while (0);
  do { } while (0);
  do { (((duk_hstring **) (void *) ( (((((obj))))->props) + (((((obj))))->e_size) * sizeof(duk_propvalue) ))[((desc.e_idx))]) = (((void *)0)); } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) ((key)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hstring_refzero)(((thr)), (duk_hstring *) duk__h); } } } while (0);





  do { duk_refzero_check_slow((thr)); } while (0);
  goto success;
 }

 do { __builtin_unreachable(); } while (0);

 success:
 do { } while (0);

 if (arr_idx != (0xffffffffUL) && (((&(obj)->hdr)->h_flags & ((1UL << (7 + (17))))) != 0)) {




  do { } while (0);


  (void) duk__check_arguments_map_for_delete(thr, obj, key, &desc);
 }

 do { } while (0);
 return 1;

 fail_virtual:
 fail_not_configurable:
 do { } while (0);

 if (throw_flag) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4410; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not configurable"))); } while (0); } while (0);
  do { } while (0);
 }
 return 0;
}





static __attribute__ ((unused)) duk_bool_t duk_hobject_delprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key, duk_bool_t throw_flag) {
 duk_hstring *key = ((void *)0);

 duk_propdesc desc={0};

 duk_int_t entry_top={0};
 duk_uint32_t arr_idx = (0xffffffffUL);
 duk_bool_t rc={0};

 do { } while (0)

                                                                ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 ;




 entry_top = duk_get_top(thr);

 if ((((duk_small_uint_t) ((tv_obj))->us[3]) == 0xfff3UL) ||
     (((duk_small_uint_t) ((tv_obj))->us[3]) == 0xfff4UL)) {
  do { } while (0);
  goto fail_invalid_base_uncond;
 }

 duk_push_tval(thr, tv_obj);
 duk_push_tval(thr, tv_key);

 tv_obj = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-2));
 if ((((duk_small_uint_t) ((tv_obj))->us[3]) == 0xfff9UL)) {
  duk_hobject *obj = ((duk_hobject *) (tv_obj)->vp[0]);
  do { } while (0);


  if (__builtin_expect(((((&((obj))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)), 0)) {
   duk_hobject *h_target={0};
   duk_bool_t tmp_bool={0};



   if (duk__proxy_check_prop(thr, obj, 72, tv_key, &h_target)) {

    do { } while (0);
    duk_push_hobject(thr, h_target);
    duk_dup_m4(thr);
    duk_call_method(thr, 2 );
    tmp_bool = duk_to_boolean_top_pop(thr);
    if (!tmp_bool) {
     goto fail_proxy_rejected;
    }




    tv_key = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
    arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
    do { } while (0);

    if (duk__get_own_propdesc_raw(thr, h_target, key, arr_idx, &desc, 0 )) {
     duk_small_int_t desc_reject={0};

     do { } while (0)



                                                                ;

     desc_reject = !(desc.flags & (1U << 2));
     if (desc_reject) {

      do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4496; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("proxy rejected"))); } while (0); } while (0);
      do { } while (0);
     }
    }
    rc = 1;
    goto done_rc;
   }

   obj = h_target;
  }


  arr_idx = duk__to_property_key(thr, -1, &key);
  do { } while (0);

  rc = duk_hobject_delprop_raw(thr, obj, key, throw_flag ? (1U << 0) : 0);
  goto done_rc;
 } else if ((((duk_small_uint_t) ((tv_obj))->us[3]) == 0xfff8UL)) {







  duk_hstring *h = ((duk_hstring *) (tv_obj)->vp[0]);
  do { } while (0);

  arr_idx = duk__to_property_key(thr, -1, &key);
  do { } while (0);

  if (key == (((thr))->strs[(86)])) {
   goto fail_not_configurable;
  }

  if (arr_idx != (0xffffffffUL) &&
      arr_idx < duk_hstring_get_charlen((h))) {
   goto fail_not_configurable;
  }
 } else if ((((duk_small_uint_t) ((tv_obj))->us[3]) == 0xfffaUL)) {




  duk_hbuffer *h = ((duk_hbuffer *) (tv_obj)->vp[0]);
  do { } while (0);

  arr_idx = duk__to_property_key(thr, -1, &key);
  do { } while (0);

  if (key == (((thr))->strs[(86)])) {
   goto fail_not_configurable;
  }

  if (arr_idx != (0xffffffffUL) &&
      arr_idx < (((duk_hbuffer *) (h))->size)) {
   goto fail_not_configurable;
  }
 } else if ((((duk_small_uint_t) ((tv_obj))->us[3]) == 0xfff7UL)) {




  arr_idx = duk__to_property_key(thr, -1, &key);
  do { } while (0);
  do { (void) (key); } while (0);
 }


 rc = 1;
 goto done_rc;

 done_rc:
 duk_set_top_unsafe(thr, entry_top);
 return rc;

 fail_invalid_base_uncond:

 do { } while (0);



 do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t)
 4579
 ; do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr),
 "duk_hobject_props.c"
 , (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("cannot delete property %s of %s"), (duk_push_string_tval_readable(thr, tv_key)), (duk_push_string_tval_readable(thr, tv_obj))); } while (0)
                                                                                                       ;

 do { } while (0);


 fail_proxy_rejected:
 if (throw_flag) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4586; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("proxy rejected"))); } while (0); } while (0);
  do { } while (0);
 }
 duk_set_top_unsafe(thr, entry_top);
 return 0;


 fail_not_configurable:
 if (throw_flag) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4595; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not configurable"))); } while (0); } while (0);
  do { } while (0);
 }
 duk_set_top_unsafe(thr, entry_top);
 return 0;
}
static __attribute__ ((unused)) void duk_hobject_define_property_internal(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_small_uint_t flags) {
 duk_propdesc desc={0};
 duk_uint32_t arr_idx={0};
 duk_int_t e_idx={0};
 duk_tval *tv1 = ((void *)0);
 duk_tval *tv2 = ((void *)0);
 duk_small_uint_t propflags = flags & ((1U << 0) | (1U << 1) | (1U << 2) | (1U << 3));

 do { } while (0)

                                                                                 ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 ;
 do { } while (0);

 arr_idx = ((key)->arridx);

 if (duk__get_own_propdesc_raw(thr, obj, key, arr_idx, &desc, 0 )) {
  if (desc.e_idx >= 0) {
   if (flags & (1U << 4)) {
    do { } while (0);
    goto pop_exit;
   }
   do { } while (0);
   if (__builtin_expect(((((((duk_uint8_t *) (void *) ( (((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[((desc.e_idx))]) & (1U << 3)) != 0)), 0)) {
    do { } while (0);
    goto error_internal;
   }

   do { (((duk_uint8_t *) (void *) ( (((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[((desc.e_idx))]) = (duk_uint8_t) (propflags); } while (0);
   tv1 = (&(((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((desc.e_idx))]).v);
  } else if (desc.a_idx >= 0) {
   if (flags & (1U << 4)) {
    do { } while (0);
    goto pop_exit;
   }
   do { } while (0);
   if (propflags != ((1U << 0) | (1U << 1) | (1U << 2))) {
    do { } while (0)
                                                ;
    goto error_internal;
   }

   tv1 = (&((duk_tval *) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07) ))[(desc.a_idx)]);
  } else {
   if (flags & (1U << 4)) {
    do { } while (0);
    goto pop_exit;
   }
   if (key == (((thr))->strs[(86)]) && (((&(obj)->hdr)->h_flags & ((1UL << (7 + (15))))) != 0)) {
    duk_uint32_t new_len={0};




    new_len = duk__to_new_array_length_checked(thr, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)));
    ((duk_harray *) obj)->length = new_len;
    do { } while (0)
                                                                           ;
    goto pop_exit;
   }
   do { } while (0);
   goto error_virtual;
  }

  goto write_value;
 }

 if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0)) {
  if (arr_idx != (0xffffffffUL)) {
   do { } while (0);
   do { } while (0);


   if (arr_idx >= ((obj)->a_size)) {
    duk__grow_props_for_array_item(thr, obj, arr_idx);
   }

   do { } while (0);
   tv1 = (&((duk_tval *) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07) ))[(arr_idx)]);
   goto write_value;
  }
 }

 do { } while (0);
 e_idx = duk__hobject_alloc_entry_checked(thr, obj, key);
 do { } while (0);
 do { (((duk_uint8_t *) (void *) ( (((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[((e_idx))]) = (duk_uint8_t) (propflags); } while (0);
 tv1 = (&(((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((e_idx))]).v);

 do { (tv1)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);
 goto write_value;

 write_value:


 tv2 = duk_require_tval(thr, -1);
 do { } while (0)
                                                          ;

 do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv1); tv__src = (tv2); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((duk_small_uint_t) (((tv__dst)))->us[3]) >= 0xfff8UL)) { h__obj = ((duk_heaphdr *) (tv__dst)->vp[0]); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
 goto pop_exit;

 pop_exit:
 duk_pop_unsafe(thr);
 return;

 error_virtual:
 error_internal:
 do { duk_err_error_internal((thr), "duk_hobject_props.c", (duk_int_t) 4735); } while (0);
 do { } while (0);
}







static __attribute__ ((unused)) void duk_hobject_define_property_internal_arridx(duk_hthread *thr, duk_hobject *obj, duk_uarridx_t arr_idx, duk_small_uint_t flags) {
 duk_hstring *key={0};
 duk_tval *tv1, *tv2={0};

 do { } while (0)


                                                          ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0) &&
     arr_idx != (0xffffffffUL) &&
     flags == ((1U << 0) | (1U << 1) | (1U << 2))) {
  do { } while (0);

  do { } while (0);


  if (arr_idx >= ((obj)->a_size)) {
   duk__grow_props_for_array_item(thr, obj, arr_idx);
  }

  do { } while (0);
  tv1 = (&((duk_tval *) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07) ))[(arr_idx)]);
  tv2 = duk_require_tval(thr, -1);

  do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv1); tv__src = (tv2); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((duk_small_uint_t) (((tv__dst)))->us[3]) >= 0xfff8UL)) { h__obj = ((duk_heaphdr *) (tv__dst)->vp[0]); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);

  duk_pop_unsafe(thr);
  return;
 }

 do { } while (0);

 key = duk_push_uint_to_hstring(thr, (duk_uint_t) arr_idx);
 do { } while (0);
 duk_insert(thr, -2);

 duk_hobject_define_property_internal(thr, obj, key, flags);

 duk_pop_unsafe(thr);
}





static __attribute__ ((unused)) duk_size_t duk_hobject_get_length(duk_hthread *thr, duk_hobject *obj) {
 duk_double_t val={0};

 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);


 if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (15))))) != 0)) {
  return ((duk_harray *) obj)->length;
 }


 duk_push_hobject(thr, obj);
 duk_push_hstring_stridx(thr, 86);
 (void) duk_hobject_getprop(thr,
                            ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-2)),
                            ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)));
 val = duk_to_number_m1(thr);
 duk_pop_3_unsafe(thr);




 if (val >= 0.0 && val <= (duk_double_t) (4294967295U)) {
  return (duk_size_t) val;
 }
 return 0;
}
static __attribute__ ((unused)) duk_bool_t duk_hobject_has_finalizer_fast_raw(duk_hobject *obj) {

 duk_uint_t sanity={0};

 do { } while (0);

 sanity = 10000L;
 do {
  if (__builtin_expect(((((&(obj)->hdr)->h_flags & ((1UL << (7 + (14))))) != 0)), 0)) {
   return 1;
  }
  if (__builtin_expect((sanity-- == 0), 0)) {
   do { } while (0);
   return 0;
  }




  obj = ((obj)->prototype);

 } while (obj != ((void *)0));

 return 0;
}







static __attribute__ ((unused)) void duk_hobject_object_get_own_property_descriptor(duk_hthread *thr, duk_idx_t obj_idx) {
 duk_hobject *obj={0};
 duk_hstring *key={0};
 duk_propdesc pd={0};

 do { } while (0);
 do { } while (0);

 obj = duk_require_hobject_promote_mask(thr, obj_idx, (1U << 9U) | (1U << 7U));
 key = duk_to_property_key_hstring(thr, -1);
 do { } while (0);

 ;

 if (!duk_hobject_get_own_propdesc(thr, obj, key, &pd, (1U << 0))) {
  duk_push_undefined(thr);
  duk_remove_m2(thr);
  return;
 }

 duk_push_object(thr);



 if ((((&pd)->flags & (1U << 3)) != 0)) {



  if (pd.get) {
   duk_push_hobject(thr, pd.get);
  } else {
   duk_push_undefined(thr);
  }
  (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (73))));
  if (pd.set) {
   duk_push_hobject(thr, pd.set);
  } else {
   duk_push_undefined(thr);
  }
  (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (87))));
 } else {
  duk_dup_m2(thr);
  (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (34))));
  duk_push_boolean(thr, (((&pd)->flags & (1U << 0)) != 0));
  (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (35))));
 }
 duk_push_boolean(thr, (((&pd)->flags & (1U << 1)) != 0));
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (37))));
 duk_push_boolean(thr, (((&pd)->flags & (1U << 2)) != 0));
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (36))));



 duk_replace(thr, -3);
 duk_pop_unsafe(thr);
}
static __attribute__ ((unused))
void duk_hobject_prepare_property_descriptor(duk_hthread *thr,
                                             duk_idx_t idx_in,
                                             duk_uint_t *out_defprop_flags,
                                             duk_idx_t *out_idx_value,
                                             duk_hobject **out_getter,
                                             duk_hobject **out_setter) {
 duk_idx_t idx_value = -1;
 duk_hobject *getter = ((void *)0);
 duk_hobject *setter = ((void *)0);
 duk_bool_t is_data_desc = 0;
 duk_bool_t is_acc_desc = 0;
 duk_uint_t defprop_flags = 0;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 idx_in = duk_require_normalize_index(thr, idx_in);
 (void) duk_require_hobject(thr, idx_in);







 if (duk_get_prop_stridx(thr, idx_in, 34)) {
  is_data_desc = 1;
  defprop_flags |= (1U << 6);
  idx_value = duk_get_top_index(thr);
 }

 if (duk_get_prop_stridx(thr, idx_in, 35)) {
  is_data_desc = 1;
  if (duk_to_boolean_top_pop(thr)) {
   defprop_flags |= (1U << 3) | (1U << 0);
  } else {
   defprop_flags |= (1U << 3);
  }
 }

 if (duk_get_prop_stridx(thr, idx_in, 73)) {
  duk_tval *tv = duk_require_tval(thr, -1);
  duk_hobject *h_get={0};

  if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff3UL)) {

   do { } while (0);
  } else {




   h_get = duk_get_hobject_promote_mask((thr), (-1), (1U << 9U));
   if (h_get == ((void *)0) || !(((&((h_get))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {
    goto type_error;
   }
   getter = h_get;
  }
  is_acc_desc = 1;
  defprop_flags |= (1U << 7);
 }

 if (duk_get_prop_stridx(thr, idx_in, 87)) {
  duk_tval *tv = duk_require_tval(thr, -1);
  duk_hobject *h_set={0};

  if ((((duk_small_uint_t) ((tv))->us[3]) == 0xfff3UL)) {

   do { } while (0);
  } else {




   h_set = duk_get_hobject_promote_mask((thr), (-1), (1U << 9U));
   if (h_set == ((void *)0) || !(((&((h_set))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {
    goto type_error;
   }
   setter = h_set;
  }
  is_acc_desc = 1;
  defprop_flags |= (1U << 8);
 }

 if (duk_get_prop_stridx(thr, idx_in, 37)) {
  if (duk_to_boolean_top_pop(thr)) {
   defprop_flags |= (1U << 4) | (1U << 1);
  } else {
   defprop_flags |= (1U << 4);
  }
 }

 if (duk_get_prop_stridx(thr, idx_in, 36)) {
  if (duk_to_boolean_top_pop(thr)) {
   defprop_flags |= (1U << 5) | (1U << 2);
  } else {
   defprop_flags |= (1U << 5);
  }
 }

 if (is_data_desc && is_acc_desc) {
  goto type_error;
 }

 *out_defprop_flags = defprop_flags;
 *out_idx_value = idx_value;
 *out_getter = getter;
 *out_setter = setter;


 return;

 type_error:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 5057; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid descriptor"))); } while (0); } while (0);
 do { } while (0);
}
static __attribute__ ((unused))
duk_bool_t duk_hobject_define_property_helper(duk_hthread *thr,
                                              duk_uint_t defprop_flags,
                                              duk_hobject *obj,
                                              duk_hstring *key,
                                              duk_idx_t idx_value,
                                              duk_hobject *get,
                                              duk_hobject *set,
                                              duk_bool_t throw_flag) {
 duk_uint32_t arr_idx={0};
 duk_tval tv={0};
 duk_bool_t has_enumerable={0};
 duk_bool_t has_configurable={0};
 duk_bool_t has_writable={0};
 duk_bool_t has_value={0};
 duk_bool_t has_get={0};
 duk_bool_t has_set={0};
 duk_bool_t is_enumerable={0};
 duk_bool_t is_configurable={0};
 duk_bool_t is_writable={0};
 duk_bool_t force_flag={0};
 duk_small_uint_t new_flags={0};
 duk_propdesc curr={0};
 duk_uint32_t arridx_new_array_length={0};
 duk_uint32_t arrlen_old_len={0};
 duk_uint32_t arrlen_new_len={0};
 duk_bool_t pending_write_protect={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 ;



 has_writable = (defprop_flags & (1U << 3));
 has_enumerable = (defprop_flags & (1U << 4));
 has_configurable = (defprop_flags & (1U << 5));
 has_value = (defprop_flags & (1U << 6));
 has_get = (defprop_flags & (1U << 7));
 has_set = (defprop_flags & (1U << 8));
 is_writable = (defprop_flags & (1U << 0));
 is_enumerable = (defprop_flags & (1U << 1));
 is_configurable = (defprop_flags & (1U << 2));
 force_flag = (defprop_flags & (1U << 9));

 arr_idx = ((key)->arridx);

 arridx_new_array_length = 0;
 pending_write_protect = 0;
 arrlen_old_len = 0;
 arrlen_new_len = 0;

 do { } while (0)
                                                         ;







 if (!(((&(obj)->hdr)->h_flags & ((1UL << (7 + (15))))) != 0)) {
  goto skip_array_exotic;
 }

 if (key == (((thr))->strs[(86)])) {
  duk_harray *a={0};


  if (!has_value) {
   do { } while (0);
   goto skip_array_exotic;
  }

  do { } while (0);





  a = (duk_harray *) obj;
  do { do { } while (0); do { } while (0); do { } while (0); } while (0);
  arrlen_old_len = a->length;

  do { } while (0);
  arrlen_new_len = duk__to_new_array_length_checked(thr, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx_value)));
  duk_push_uint((thr), (duk_uint_t) (arrlen_new_len));
  duk_replace(thr, idx_value);

  do { } while (0);

  if (arrlen_new_len >= arrlen_old_len) {

   do { } while (0);
   goto skip_array_exotic;
  }
  do { } while (0);


  if (((a)->length_nonwritable) && !force_flag) {



   goto fail_not_configurable;
  }


  if (has_writable && !is_writable) {
   do { } while (0);
   is_writable = 1;
   pending_write_protect = 1;
  }


 } else if (arr_idx != (0xffffffffUL)) {



  duk_uint32_t old_len={0};
  duk_harray *a={0};

  a = (duk_harray *) obj;
  do { do { } while (0); do { } while (0); do { } while (0); } while (0);

  old_len = a->length;

  if (arr_idx >= old_len) {
   do { } while (0)

                                                        ;

   if (((a)->length_nonwritable) && !force_flag) {




    goto fail_not_configurable;
   }




   do { } while (0);
   arridx_new_array_length = arr_idx + 1;
  } else {
   do { } while (0)

                                                        ;
  }
 }
 skip_array_exotic:
 if (!duk__get_own_propdesc_raw(thr, obj, key, arr_idx, &curr, (1U << 0))) {
  do { } while (0);

  if (!(((&(obj)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) && !force_flag) {
   goto fail_not_extensible;
  }
  if (has_set || has_get) {
   duk_int_t e_idx={0};

   do { } while (0);

   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0);

   new_flags = (1U << 3);
   if (has_enumerable && is_enumerable) {
    new_flags |= (1U << 1);
   }
   if (has_configurable && is_configurable) {
    new_flags |= (1U << 2);
   }

   if (arr_idx != (0xffffffffUL) && (((&(obj)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0)) {
    do { } while (0);
    duk__abandon_array_checked(thr, obj);
   }


   e_idx = duk__hobject_alloc_entry_checked(thr, obj, key);
   do { } while (0);

   do { (((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((e_idx))]).a.get = (get); } while (0);
   do { (((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((e_idx))]).a.set = (set); } while (0);
   do { if ((get) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((get)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);
   do { if ((set) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((set)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);

   do { (((duk_uint8_t *) (void *) ( (((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[((e_idx))]) = (duk_uint8_t) (new_flags); } while (0);
   goto success_exotics;
  } else {
   duk_int_t e_idx={0};
   duk_tval *tv2={0};

   do { } while (0);

   do { } while (0);
   do { } while (0);

   new_flags = 0;
   if (has_writable && is_writable) {
    new_flags |= (1U << 0);
   }
   if (has_enumerable && is_enumerable) {
    new_flags |= (1U << 1);
   }
   if (has_configurable && is_configurable) {
    new_flags |= (1U << 2);
   }
   if (has_value) {
    duk_tval *tv_tmp = duk_require_tval(thr, idx_value);
    do { *(&tv) = *(tv_tmp); } while (0);
   } else {
    do { (&tv)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);
   }

   if (arr_idx != (0xffffffffUL) && (((&(obj)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0)) {
    if (new_flags == ((1U << 0) | (1U << 1) | (1U << 2))) {
    }
    do { } while (0);
    duk__abandon_array_checked(thr, obj);

   }


   e_idx = duk__hobject_alloc_entry_checked(thr, obj, key);
   do { } while (0);
   tv2 = (&(((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((e_idx))]).v);
   do { *(tv2) = *(&tv); } while (0);
   do { duk_tval *duk__tv = ((tv2)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);

   do { (((duk_uint8_t *) (void *) ( (((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[((e_idx))]) = (duk_uint8_t) (new_flags); } while (0);
   goto success_exotics;
  }
  do { __builtin_unreachable(); } while (0);
 }


 do { } while (0);
 if (has_enumerable) {
  if (is_enumerable) {
   if (!(curr.flags & (1U << 1))) {
    goto need_check;
   }
  } else {
   if (curr.flags & (1U << 1)) {
    goto need_check;
   }
  }
 }
 if (has_configurable) {
  if (is_configurable) {
   if (!(curr.flags & (1U << 2))) {
    goto need_check;
   }
  } else {
   if (curr.flags & (1U << 2)) {
    goto need_check;
   }
  }
 }
 if (has_value) {
  duk_tval *tmp1={0};
  duk_tval *tmp2={0};


  if (curr.flags & (1U << 3)) {
   goto need_check;
  }

  tmp1 = duk_require_tval(thr, -1);
  tmp2 = duk_require_tval(thr, idx_value);
  if (!duk_js_equals_helper(((void *)0), (tmp1), (tmp2), (1U << 0))) {
   goto need_check;
  }
 }
 if (has_writable) {

  if (curr.flags & (1U << 3)) {
   goto need_check;
  }

  if (is_writable) {
   if (!(curr.flags & (1U << 0))) {
    goto need_check;
   }
  } else {
   if (curr.flags & (1U << 0)) {
    goto need_check;
   }
  }
 }
 if (has_set) {
  if (curr.flags & (1U << 3)) {
   if (set != curr.set) {
    goto need_check;
   }
  } else {
   goto need_check;
  }
 }
 if (has_get) {
  if (curr.flags & (1U << 3)) {
   if (get != curr.get) {
    goto need_check;
   }
  } else {
   goto need_check;
  }
 }




 goto success_no_exotics;

 need_check:






 if (!(curr.flags & (1U << 2)) && !force_flag) {
  if (has_configurable && is_configurable) {
   goto fail_not_configurable;
  }
  if (has_enumerable) {
   if (curr.flags & (1U << 1)) {
    if (!is_enumerable) {
     goto fail_not_configurable;
    }
   } else {
    if (is_enumerable) {
     goto fail_not_configurable;
    }
   }
  }
 }
 if (has_set || has_get) {

  do { } while (0);
  do { } while (0);

  if (curr.flags & (1U << 3)) {

   if (!(curr.flags & (1U << 2)) && !force_flag) {
    if (has_set && set != curr.set) {
     goto fail_not_configurable;
    }
    if (has_get && get != curr.get) {
     goto fail_not_configurable;
    }
   }
  } else {
   duk_bool_t rc={0};
   duk_tval *tv1={0};


   if (!(curr.flags & (1U << 2)) && !force_flag) {
    goto fail_not_configurable;
   }

   do { } while (0);
   if (curr.a_idx >= 0) {
    do { } while (0);
    duk__abandon_array_checked(thr, obj);
    duk_pop_unsafe(thr);
    rc = duk__get_own_propdesc_raw(thr, obj, key, arr_idx, &curr, (1U << 0));
    do { (void) (rc); } while (0);
    do { } while (0);
    do { } while (0);
   }
   if (curr.e_idx < 0) {
    do { } while (0);
    goto fail_virtual;
   }

   do { } while (0);
   do { } while (0);

   tv1 = (&(((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((curr.e_idx))]).v);
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv1); do { *(&tv__tmp) = *(tv__dst); } while (0); do { (tv__dst)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz((((thr))), duk__h); } } } while (0); } while (0);

   do { (((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((curr.e_idx))]).a.get = (((void *)0)); } while (0);
   do { (((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((curr.e_idx))]).a.set = (((void *)0)); } while (0);
   do { ((duk_uint8_t *) (void *) ( (((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[((curr.e_idx))] &= ~((1U << 0)); } while (0);
   do { ((duk_uint8_t *) (void *) ( (((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[((curr.e_idx))] |= ((1U << 3)); } while (0);

   do { } while (0)
                                                                                             ;

   curr.flags &= ~(1U << 0);
   curr.flags |= (1U << 3);
  }
 } else if (has_value || has_writable) {

  do { } while (0);
  do { } while (0);

  if (curr.flags & (1U << 3)) {
   duk_hobject *tmp={0};


   if (!(curr.flags & (1U << 2)) && !force_flag) {
    goto fail_not_configurable;
   }


   do { } while (0);
   if (curr.e_idx < 0) {
    goto fail_virtual;
   }

   do { } while (0);

   do { } while (0);
   tmp = ((((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((curr.e_idx))]).a.get);
   do { (void) (tmp); } while (0);
   do { (((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((curr.e_idx))]).a.get = (((void *)0)); } while (0);
   do { if ((tmp) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((tmp))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
   tmp = ((((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((curr.e_idx))]).a.set);
   do { (void) (tmp); } while (0);
   do { (((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((curr.e_idx))]).a.set = (((void *)0)); } while (0);
   do { if ((tmp) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((tmp))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);

   do { ((&(((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((curr.e_idx))]).v))->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);
   do { ((duk_uint8_t *) (void *) ( (((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[((curr.e_idx))] &= ~((1U << 0)); } while (0);
   do { ((duk_uint8_t *) (void *) ( (((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[((curr.e_idx))] &= ~((1U << 3)); } while (0);

   do { } while (0)
                                                                                             ;


   curr.flags &= ~((1U << 0) | (1U << 3));
  } else {

   if (!(curr.flags & (1U << 2)) && !force_flag) {
    if (!(curr.flags & (1U << 0)) && has_writable && is_writable) {
     goto fail_not_configurable;
    }

    if (!(curr.flags & (1U << 0)) && has_value) {
     duk_tval *tmp1 = duk_require_tval(thr, -1);
     duk_tval *tmp2 = duk_require_tval(thr, idx_value);
     if (!duk_js_equals_helper(((void *)0), (tmp1), (tmp2), (1U << 0))) {
      goto fail_not_configurable;
     }
    }
   }
  }
 } else {





  do { } while (0);
 }
 new_flags = curr.flags;

 if (has_enumerable) {
  if (is_enumerable) {
   new_flags |= (1U << 1);
  } else {
   new_flags &= ~(1U << 1);
  }
 }
 if (has_configurable) {
  if (is_configurable) {
   new_flags |= (1U << 2);
  } else {
   new_flags &= ~(1U << 2);
  }
 }
 if (has_writable) {
  if (is_writable) {
   new_flags |= (1U << 0);
  } else {
   new_flags &= ~(1U << 0);
  }
 }



 do { } while (0)
                                                 ;





 if (curr.a_idx >= 0) {
  duk_bool_t rc={0};

  do { } while (0);

  if (new_flags == ((1U << 0) | (1U << 1) | (1U << 2))) {
   duk_tval *tv1, *tv2={0};

   do { } while (0);

   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0);

   tv2 = duk_require_tval(thr, idx_value);
   tv1 = (&((duk_tval *) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07) ))[(curr.a_idx)]);
   do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv1); tv__src = (tv2); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((duk_small_uint_t) (((tv__dst)))->us[3]) >= 0xfff8UL)) { h__obj = ((duk_heaphdr *) (tv__dst)->vp[0]); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
   goto success_exotics;
  }

  do { } while (0);
  duk__abandon_array_checked(thr, obj);
  duk_pop_unsafe(thr);
  rc = duk__get_own_propdesc_raw(thr, obj, key, arr_idx, &curr, (1U << 0));
  do { (void) (rc); } while (0);
  do { } while (0);
  do { } while (0);
 }

 do { } while (0);




 do { } while (0);

 do { } while (0);
 if (curr.e_idx >= 0) {
  do { (((duk_uint8_t *) (void *) ( (((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[((curr.e_idx))]) = (duk_uint8_t) (new_flags); } while (0);
 } else {



  if (key == (((thr))->strs[(86)]) && (((&(obj)->hdr)->h_flags & ((1UL << (7 + (15))))) != 0)) {
   duk_harray *a={0};
   a = (duk_harray *) obj;
   do { } while (0);
   do { do { } while (0); do { } while (0); do { } while (0); } while (0);
   if ((new_flags & ((1U << 1) | (1U << 2))) != (curr.flags & ((1U << 1) | (1U << 2)))) {
    do { } while (0);
    goto fail_virtual;
   }
   if (new_flags & (1U << 0)) {
    do { (a)->length_nonwritable = 0; } while (0);
   } else {
    do { (a)->length_nonwritable = 1; } while (0);
   }
  }
 }

 if (has_set) {
  duk_hobject *tmp={0};




  if (curr.e_idx < 0) {
   goto fail_virtual;
  }

  do { } while (0);
  do { } while (0);

  tmp = ((((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((curr.e_idx))]).a.set);
  do { (void) (tmp); } while (0);
  do { (((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((curr.e_idx))]).a.set = (set); } while (0);
  do { if ((set) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((set)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);
  do { if ((tmp) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((tmp))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
 }
 if (has_get) {
  duk_hobject *tmp={0};

  if (curr.e_idx < 0) {
   goto fail_virtual;
  }

  do { } while (0);
  do { } while (0);

  tmp = ((((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((curr.e_idx))]).a.get);
  do { (void) (tmp); } while (0);
  do { (((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((curr.e_idx))]).a.get = (get); } while (0);
  do { if ((get) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((get)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);
  do { if ((tmp) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((tmp))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
 }
 if (has_value) {
  duk_tval *tv1, *tv2={0};

  do { } while (0);

  if (curr.e_idx >= 0) {
   do { } while (0);
   tv2 = duk_require_tval(thr, idx_value);
   tv1 = (&(((duk_propvalue *) (void *) ( (((((obj))))->props) ))[((curr.e_idx))]).v);
   do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv1); tv__src = (tv2); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((duk_small_uint_t) (((tv__dst)))->us[3]) >= 0xfff8UL)) { h__obj = ((duk_heaphdr *) (tv__dst)->vp[0]); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
  } else {
   do { } while (0);

   do { } while (0);



   if (key == (((thr))->strs[(86)]) && (((&(obj)->hdr)->h_flags & ((1UL << (7 + (15))))) != 0)) {
    duk_harray *a={0};
    a = (duk_harray *) obj;
    do { } while (0);
    do { do { } while (0); do { } while (0); do { } while (0); } while (0);
    a->length = arrlen_new_len;
   } else {
    goto fail_virtual;
   }
  }
 }
 success_exotics:







 if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (15))))) != 0)) {
  duk_harray *a={0};

  a = (duk_harray *) obj;
  do { do { } while (0); do { } while (0); do { } while (0); } while (0);

  if (arridx_new_array_length > 0) {







   do { } while (0)
                                                        ;

   a->length = arridx_new_array_length;
  }

  if (key == (((thr))->strs[(86)]) && arrlen_new_len < arrlen_old_len) {
   duk_uint32_t result_len={0};
   duk_bool_t rc={0};

   do { } while (0)
                                                                          ;

   rc = duk__handle_put_array_length_smaller(thr, obj, arrlen_old_len, arrlen_new_len, force_flag, &result_len);


   do { } while (0);

   a->length = result_len;

   if (pending_write_protect) {
    do { } while (0);
    do { (a)->length_nonwritable = 1; } while (0);
   }


   if (!rc) {
    do { } while (0);
    goto fail_not_configurable;
   }
  }
 } else if (arr_idx != (0xffffffffUL) && (((&(obj)->hdr)->h_flags & ((1UL << (7 + (17))))) != 0)) {
  duk_hobject *map={0};
  duk_hobject *varenv={0};

  do { } while (0);
  do { } while (0);

  map = ((void *)0);
  varenv = ((void *)0);
  if (!duk__lookup_arguments_map(thr, obj, key, &curr, &map, &varenv)) {
   goto success_no_exotics;
  }
  do { } while (0);
  do { } while (0);



  if (has_set || has_get) {

   do { } while (0)
                                                                            ;

   (void) duk_hobject_delprop_raw(thr, map, key, 0);
  } else {

   do { } while (0)
                                                                     ;

   if (has_value) {
    duk_hstring *varname={0};

    do { } while (0)
                                                                   ;

    varname = duk_require_hstring(thr, -1);
    do { } while (0);

    do { } while (0)



                                                                        ;


    duk_js_putvar_envrec(thr, varenv, varname, duk_require_tval(thr, idx_value), 1 );
   }
   if (has_writable && !is_writable) {
    do { } while (0)
                                                                              ;

    (void) duk_hobject_delprop_raw(thr, map, key, 0);
   }
  }




 }

 success_no_exotics:



 do { duk_refzero_check_slow((thr)); } while (0);
 return 1;

 fail_not_extensible:
 if (throw_flag) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 5939; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not extensible"))); } while (0); } while (0);
  do { } while (0);
 }
 return 0;

 fail_virtual:
 fail_not_configurable:
 if (throw_flag) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 5947; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not configurable"))); } while (0); } while (0);
  do { } while (0);
 }
 return 0;
}





static __attribute__ ((unused)) duk_bool_t duk_hobject_object_ownprop_helper(duk_hthread *thr, duk_small_uint_t required_desc_flags) {
 duk_hstring *h_v={0};
 duk_hobject *h_obj={0};
 duk_propdesc desc={0};
 duk_bool_t ret={0};


 h_v = duk_to_hstring_acceptsymbol(thr, 0);
 do { } while (0);

 h_obj = duk_push_this_coercible_to_object(thr);
 do { } while (0);

 ret = duk_hobject_get_own_propdesc(thr, h_obj, h_v, &desc, 0 );

 duk_push_boolean(thr, ret && ((desc.flags & required_desc_flags) == required_desc_flags));
 return 1;
}
static __attribute__ ((unused)) void duk_hobject_object_seal_freeze_helper(duk_hthread *thr, duk_hobject *obj, duk_bool_t is_freeze) {
 duk_uint_fast32_t i={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);

 ;
 duk__abandon_array_checked(thr, obj);
 do { } while (0);

 for (i = 0; i < ((obj)->e_next); i++) {
  duk_uint8_t *fp={0};


  do { } while (0);


  fp = (&((duk_uint8_t *) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[(i)]);
  if (is_freeze && !((*fp) & (1U << 3))) {
   *fp &= ~((1U << 0) | (1U << 2));
  } else {
   *fp &= ~(1U << 2);
  }
 }

 do { do { } while (0); (&(obj)->hdr)->h_flags &= ~(((1UL << (7 + (0))))); } while (0);





 return;
}
static __attribute__ ((unused)) duk_bool_t duk_hobject_object_is_sealed_frozen_helper(duk_hthread *thr, duk_hobject *obj, duk_bool_t is_frozen) {
 duk_uint_fast32_t i={0};

 do { } while (0);
 do { (void) (thr); } while (0);




 if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0)) {
  return 0;
 }






 for (i = 0; i < ((obj)->e_next); i++) {
  duk_small_uint_t flags={0};

  if (!(((duk_hstring **) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * sizeof(duk_propvalue) ))[(i)])) {
   continue;
  }


  flags = (duk_small_uint_t) (((duk_uint8_t *) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[(i)]);

  if (flags & (1U << 2)) {
   return 0;
  }
  if (is_frozen &&
      !(flags & (1U << 3)) &&
      (flags & (1U << 0))) {
   return 0;
  }
 }




 for (i = 0; i < ((obj)->a_size); i++) {
  duk_tval *tv = (&((duk_tval *) (void *) ( ((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07) ))[(i)]);
  if (!(((duk_small_uint_t) ((tv))->us[3]) == 0xfff2UL)) {
   return 0;
  }
 }

 return 1;
}
static __attribute__ ((unused)) duk_ucodepoint_t duk_hstring_char_code_at_raw(duk_hthread *thr, duk_hstring *h, duk_uint_t pos, duk_bool_t surrogate_aware) {
 duk_uint32_t boff={0};
 const duk_uint8_t *p, *p_start, *p_end={0};
 duk_ucodepoint_t cp1={0};
 duk_ucodepoint_t cp2={0};


 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 boff = (duk_uint32_t) duk_heap_strcache_offset_char2byte(thr, h, (duk_uint32_t) pos);
 do { } while (0)
                                                                  ;
 do { } while (0);
 do { } while (0);

 p_start = ((const duk_uint8_t *) ((h) + 1));
 p_end = p_start + ((h)->blen);
 p = p_start + boff;
 do { } while (0)

                                        ;




 if (duk_unicode_decode_xutf8(thr, &p, p_start, p_end, &cp1)) {
  if (surrogate_aware && cp1 >= 0xd800UL && cp1 <= 0xdbffUL) {




   cp2 = 0;
   (void) duk_unicode_decode_xutf8(thr, &p, p_start, p_end, &cp2);
   if (cp2 >= 0xdc00UL && cp2 <= 0xdfffUL) {
    cp1 = (duk_ucodepoint_t) (((cp1 - 0xd800UL) << 10) + (cp2 - 0xdc00UL) + 0x10000UL);
   }
  }
 } else {
  cp1 = 0xfffdL;
 }

 return cp1;
}
static duk_size_t duk__hstring_get_charlen_slowpath(duk_hstring *h) {
 duk_size_t res={0};

 do { } while (0);
 res = duk_unicode_unvalidated_utf8_length(((const duk_uint8_t *) ((h) + 1)), ((h)->blen));




 h->clen = (duk_uint32_t) res;

 if (__builtin_expect((res == ((h)->blen)), 1)) {
  do { do { } while (0); (&(h)->hdr)->h_flags |= ((1UL << (7 + (0)))); } while (0);
 }
 return res;
}
static __attribute__ ((unused)) duk_size_t duk_hstring_get_charlen(duk_hstring *h) {





 if (__builtin_expect((h->clen != 0), 1)) {
  return h->clen;
 }

 return duk__hstring_get_charlen_slowpath(h);
}
static __attribute__ ((unused)) duk_bool_t duk_hstring_equals_ascii_cstring(duk_hstring *h, const char *cstr) {
 duk_size_t len={0};

 do { } while (0);
 do { } while (0);

 len = strlen(cstr);
 if (len != ((h)->blen)) {
  return 0;
 }
 if (duk_memcmp((const void *) cstr, (const void *) ((const duk_uint8_t *) ((h) + 1)), len) == 0) {
  return 1;
 }
 return 0;
}
static __attribute__ ((unused)) duk_bool_t duk_hthread_init_stacks(duk_heap *heap, duk_hthread *thr) {
 duk_size_t alloc_size={0};
 duk_size_t i={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 do { } while (0);
 alloc_size = sizeof(duk_tval) * 96U;
 thr->valstack = (duk_tval *) duk_heap_mem_alloc((heap), (alloc_size));
 if (!thr->valstack) {
  goto fail;
 }
 do { void *duk__dst = (thr->valstack); duk_size_t duk__len = (alloc_size); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 thr->valstack_end = thr->valstack + 64U;
 thr->valstack_alloc_end = thr->valstack + 96U;
 thr->valstack_bottom = thr->valstack;
 thr->valstack_top = thr->valstack;

 for (i = 0; i < 96U; i++) {
  do { (&thr->valstack[i])->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);
 }

 return 1;

 fail:
 duk_heap_mem_free((heap), (thr->valstack));
 do { } while (0);

 thr->valstack = ((void *)0);
 return 0;
}



static __attribute__ ((unused)) void *duk_hthread_get_valstack_ptr(duk_heap *heap, void *ud) {
 duk_hthread *thr = (duk_hthread *) ud;
 do { (void) (heap); } while (0);
 return (void *) thr->valstack;
}
static void duk__push_stridx(duk_hthread *thr, duk_bitdecoder_ctx *bd) {
 duk_small_uint_t n={0};

 n = (duk_small_uint_t) duk_bd_decode_varuint(bd);
 do { } while (0);
 do { } while (0);
 duk_push_hstring_stridx(thr, n);
}
static void duk__push_string(duk_hthread *thr, duk_bitdecoder_ctx *bd) {



 duk_uint8_t tmp[256]={0};
 duk_small_uint_t len={0};

 len = duk_bd_decode_bitpacked_string(bd, tmp);
 duk_push_lstring(thr, (const char *) tmp, (duk_size_t) len);
}
static void duk__push_stridx_or_string(duk_hthread *thr, duk_bitdecoder_ctx *bd) {
 duk_small_uint_t n={0};

 n = (duk_small_uint_t) duk_bd_decode_varuint(bd);
 if (n == 0) {
  duk__push_string(thr, bd);
 } else {
  n--;
  do { } while (0);
  duk_push_hstring_stridx(thr, n);
 }
}
static void duk__push_double(duk_hthread *thr, duk_bitdecoder_ctx *bd) {
 duk_double_union du={0};
 duk_small_uint_t i={0};

 for (i = 0; i < 8; i++) {



  du.uc[i] = (duk_uint8_t) duk_bd_decode(bd, 8);
 }

 duk_push_number(thr, du.d);
}

static __attribute__ ((unused)) void duk_hthread_create_builtin_objects(duk_hthread *thr) {
 duk_bitdecoder_ctx bd_ctx={0};
 duk_bitdecoder_ctx *bd = &bd_ctx;
 duk_hobject *h={0};
 duk_small_uint_t i, j={0};

 do { } while (0);

 do { void *duk__dst = (&bd_ctx); duk_size_t duk__len = (sizeof(bd_ctx)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 bd->data = (const duk_uint8_t *) duk_builtins_data;
 bd->length = (duk_size_t) 4116;
 duk_require_stack(thr, 78);

 do { } while (0);
 do { } while (0);
 for (i = 0; i < 78; i++) {
  duk_small_uint_t class_num={0};
  duk_small_int_t len = -1;

  class_num = (duk_small_uint_t) duk_bd_decode_varuint(bd);
  len = (duk_small_int_t) duk_bd_decode_flagged_signed(bd, 3, (duk_int32_t) -1 );

  if (class_num == 3) {
   duk_small_uint_t natidx={0};
   duk_small_int_t c_nargs={0};
   duk_c_function c_func={0};
   duk_int16_t magic={0};

   do { } while (0);
   do { } while (0);

   natidx = (duk_small_uint_t) duk_bd_decode_varuint(bd);
   do { } while (0);
   c_func = duk_bi_native_functions[natidx];
   do { } while (0);

   c_nargs = (duk_small_int_t) duk_bd_decode_flagged_signed(bd, 3, len );
   if (c_nargs == 0x07) {
    c_nargs = ((duk_int_t) (-1));
   }


   (void) duk_push_c_function_builtin(thr, c_func, c_nargs);
   h = duk_known_hobject(thr, -1);





   do { } while (0);



   duk__push_stridx_or_string(thr, bd);

   (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (92)) << 8) + (duk_uint_t) (((1U << 2)))))


                                                   ;
   if (duk_bd_decode_flag(bd)) {
    do { } while (0);
   } else {
    do { do { } while (0); (&(h)->hdr)->h_flags &= ~(((1UL << (7 + (1))))); } while (0);
   }


   magic = (duk_int16_t) duk_bd_decode_varuint(bd);
   ((duk_hnatfunc *) h)->magic = magic;
  } else if (class_num == 2) {
   duk_push_array(thr);
  } else if (class_num == 15) {
   duk_hobjenv *env={0};
   duk_hobject *global={0};

   do { } while (0);
   do { } while (0);

   env = duk_hobjenv_alloc(thr,
                                         (1UL << (7 + (0))) |
                                         (((duk_uint_t) (15)) << (7 + (20))));
   do { } while (0);
   duk_push_hobject(thr, (duk_hobject *) env);

   global = duk_known_hobject(thr, 0);
   do { } while (0);
   env->target = global;
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (global))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   do { } while (0);

   do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
  } else {
   do { } while (0);

   (void) duk_push_object_helper(thr,
                                 (1UL << (7 + (7))) |
                                 (1UL << (7 + (0))),
                                 -1);

  }

  h = duk_known_hobject(thr, -1);
  do { (&(h)->hdr)->h_flags = ((&(h)->hdr)->h_flags & (~(((1UL << (5)) - 1UL) << ((7 + (20)))))) | (((class_num)) << ((7 + (20)))); } while (0);

  if (i < 51) {
   thr->builtins[i] = h;
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (&h->hdr))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  }

  if (len >= 0) {
   do { } while (0);
   duk_push_int(thr, len);
   (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (86)) << 8) + (duk_uint_t) (((1U << 2)))))


                                                   ;
  }



  if (class_num == 2) {
   do { } while (0);
  }
  if (class_num == 12) {
   do { do { } while (0); (&(h)->hdr)->h_flags |= ((1UL << (7 + (16)))); } while (0);
  }



  do { } while (0);

  do { } while (0);
  do { } while (0);

  do { } while (0);
  do { } while (0);

  do { } while (0)
                                       ;
  do { } while (0);
  do { } while (0);


  do { } while (0);

  do { } while (0);
 }







 do { } while (0);
 for (i = 0; i < 78; i++) {
  duk_small_uint_t t={0};
  duk_small_uint_t num={0};

  do { } while (0);
  h = duk_known_hobject(thr, (duk_idx_t) i);

  t = (duk_small_uint_t) duk_bd_decode_varuint(bd);
  if (t > 0) {
   t--;
   do { } while (0);
   duk_hobject_set_prototype_updref((thr), (h), (duk_known_hobject(thr, (duk_idx_t) t)));
  } else if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {




   do { } while (0);
   duk_hobject_set_prototype_updref((thr), (h), (thr->builtins[5]));
  }

  t = (duk_small_uint_t) duk_bd_decode_varuint(bd);
  if (t > 0) {





   t--;
   do { } while (0);
   duk_dup(thr, (duk_idx_t) t);
   duk_xdef_prop_stridx(thr, (duk_idx_t) i, 50, 0);
  }

  t = (duk_small_uint_t) duk_bd_decode_varuint(bd);
  if (t > 0) {





   t--;
   do { } while (0);
   duk_dup(thr, (duk_idx_t) t);
   duk_xdef_prop_stridx(thr, (duk_idx_t) i, 51, ((1U << 0) | (1U << 2)));
  }


  num = (duk_small_uint_t) duk_bd_decode_varuint(bd);
  do { } while (0);
  for (j = 0; j < num; j++) {
   duk_small_uint_t defprop_flags={0};

   duk__push_stridx_or_string(thr, bd);
   defprop_flags = (duk_small_uint_t) duk_bd_decode_flagged(bd,
                                                            3,
                                                            (duk_uint32_t) ((1U << 0) | (1U << 2)));
   defprop_flags |= (1U << 9) |
                    (1U << 6) |
                    (1U << 3) |
                    (1U << 4) |
                    (1U << 5);




   do { } while (0);
   do { } while (0);
   do { } while (0);

   t = (duk_small_uint_t) duk_bd_decode(bd, 3);

   do { } while (0)
                                                                                                            ;

   switch (t) {
   case 0: {
    duk__push_double(thr, bd);
    break;
   }
   case 1: {
    duk__push_string(thr, bd);
    break;
   }
   case 2: {
    duk__push_stridx(thr, bd);
    break;
   }
   case 3: {
    duk_small_uint_t bidx={0};

    bidx = (duk_small_uint_t) duk_bd_decode_varuint(bd);
    duk_dup(thr, (duk_idx_t) bidx);
    break;
   }
   case 4: {
    duk_push_undefined(thr);
    break;
   }
   case 5: {
    duk_push_true(thr);
    break;
   }
   case 6: {
    duk_push_false(thr);
    break;
   }
   case 7: {
    duk_small_uint_t natidx_getter = (duk_small_uint_t) duk_bd_decode_varuint(bd);
    duk_small_uint_t natidx_setter = (duk_small_uint_t) duk_bd_decode_varuint(bd);
    duk_small_uint_t accessor_magic = (duk_small_uint_t) duk_bd_decode_varuint(bd);
    duk_c_function c_func_getter={0};
    duk_c_function c_func_setter={0};

    do { } while (0)
                                                                                                                                     ;

    c_func_getter = duk_bi_native_functions[natidx_getter];
    if (c_func_getter != ((void *)0)) {
     duk_push_c_function_builtin_noconstruct(thr, c_func_getter, 0);
     duk_set_magic(thr, -1, (duk_int_t) accessor_magic);
     defprop_flags |= (1U << 7);
    }
    c_func_setter = duk_bi_native_functions[natidx_setter];
    if (c_func_setter != ((void *)0)) {
     duk_push_c_function_builtin_noconstruct(thr, c_func_setter, 1);
     duk_set_magic(thr, -1, (duk_int_t) accessor_magic);
     defprop_flags |= (1U << 8);
    }


    do { } while (0);

    defprop_flags &= ~((1U << 6) | (1U << 3));
    defprop_flags |= (1U << 4) | (1U << 5);
    break;
   }
   default: {

    do { __builtin_unreachable(); } while (0);
   }
   }

   duk_def_prop(thr, (duk_idx_t) i, defprop_flags);
   do { } while (0);
  }


  num = (duk_small_uint_t) duk_bd_decode_varuint(bd);
  do { } while (0);
  for (j = 0; j < num; j++) {
   duk_hstring *h_key={0};
   duk_small_uint_t natidx={0};
   duk_int_t c_nargs={0};
   duk_small_uint_t c_length={0};
   duk_int16_t magic={0};
   duk_c_function c_func={0};
   duk_hnatfunc *h_func={0};



   duk_small_uint_t defprop_flags={0};

   duk__push_stridx_or_string(thr, bd);
   h_key = duk_known_hstring(thr, -1);
   do { (void) (h_key); } while (0);
   natidx = (duk_small_uint_t) duk_bd_decode_varuint(bd);

   c_length = (duk_small_uint_t) duk_bd_decode(bd, 3);
   c_nargs = (duk_int_t) duk_bd_decode_flagged(bd, 3, (duk_uint32_t) c_length );
   if (c_nargs == 0x07) {
    c_nargs = ((duk_int_t) (-1));
   }

   c_func = duk_bi_native_functions[natidx];

   do { } while (0)

                                                                               ;


   magic = (duk_int16_t) duk_bd_decode_varuint(bd);
   duk_push_c_function_builtin_noconstruct(thr, c_func, c_nargs);
   h_func = duk_known_hnatfunc(thr, -1);
   do { (void) (h_func); } while (0);




   if (c_func == duk_bi_global_object_eval ||
       c_func == duk_bi_function_prototype_call ||
       c_func == duk_bi_function_prototype_apply ||
       c_func == duk_bi_reflect_apply ||
       c_func == duk_bi_reflect_construct) {
    do { do { } while (0); (&((duk_hobject *) h_func)->hdr)->h_flags |= ((1UL << (7 + (19)))); } while (0);
   }







   do { do { } while (0); (&((duk_hobject *) h_func)->hdr)->h_flags |= ((1UL << (7 + (9)))); } while (0);




   do { } while (0);




   h_func->magic = magic;



   duk_push_uint(thr, c_length);
   (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (86)) << 8) + (duk_uint_t) (((1U << 2)))));

   duk_dup_m2(thr);
   (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (92)) << 8) + (duk_uint_t) (((1U << 2)))));



   do { } while (0)
                                                                              ;
   defprop_flags = (duk_small_uint_t) duk_bd_decode_flagged(bd,
                                                            3,
                                                            (duk_uint32_t) ((1U << 0) | (1U << 2)));
   defprop_flags |= (1U << 9) |
                    (1U << 6) |
                    (1U << 3) |
                    (1U << 4) |
                    (1U << 5);
   do { } while (0);
   do { } while (0);
   do { } while (0);

   duk_def_prop(thr, (duk_idx_t) i, defprop_flags);


  }
 }
 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (16)) << 16) + ((duk_uint_t) (41))));
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (16)) << 24) + (((duk_uint_t) (43)) << 8) + (duk_uint_t) (((1U << 0) | (1U << 2)))));


 h = duk_known_hobject(thr, 37);
 do { do { } while (0); (&(h)->hdr)->h_flags &= ~(((1UL << (7 + (0))))); } while (0);
 duk_push_string(thr,


                 "l"
                 "l"







                 " "


                 "p"






   " "





   "n"
   "l"

                 " "




   "p2"





   " "




   "a8"





   " "

                 "x86"
   " "
                 "linux"
   " "
                 "gcc");
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (34)) << 24) + (((duk_uint_t) (110)) << 8) + (duk_uint_t) (((1U << 0) | (1U << 2)))));





 do { } while (0);
 for (i = 0; i < 78; i++) {
  duk_hobject_compact_props(thr, duk_known_hobject(thr, (duk_idx_t) i));
 }

 do { } while (0);
 duk_set_top(thr, 0);
 do { } while (0);
}


static __attribute__ ((unused)) void duk_hthread_copy_builtin_objects(duk_hthread *thr_from, duk_hthread *thr_to) {
 duk_small_uint_t i={0};

 for (i = 0; i < 51; i++) {
  thr_to->builtins[i] = thr_from->builtins[i];
  do { if ((thr_to->builtins[i]) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((thr_to->builtins[i])))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);
 }
}






static __attribute__ ((unused)) void duk_hthread_terminate(duk_hthread *thr) {
 do { } while (0);

 while (thr->callstack_curr != ((void *)0)) {
  duk_hthread_activation_unwind_norz(thr);
 }

 thr->valstack_bottom = thr->valstack;
 duk_set_top(thr, 0);

 thr->state = 5;
 do { duk_refzero_check_slow((thr)); } while (0);
}
static __attribute__ ((unused)) duk_uint_fast32_t duk_hthread_get_act_prev_pc(duk_hthread *thr, duk_activation *act) {
 duk_instr_t *bcode={0};
 duk_uint_fast32_t ret={0};

 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 if (act->func && (((&(act->func)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
  bcode = ((((duk_hcompfunc *) (act->func)))->bytecode);
  ret = (duk_uint_fast32_t) (act->curr_pc - bcode);
  if (ret > 0) {
   ret--;
  }
  return ret;
 }
 return 0;
}


static __attribute__ ((unused)) void duk_hthread_sync_currpc(duk_hthread *thr) {
 duk_activation *act={0};

 do { } while (0);

 if (thr->ptr_curr_pc != ((void *)0)) {

  do { } while (0);
  do { } while (0);
  act = thr->callstack_curr;
  do { } while (0);
  act->curr_pc = *thr->ptr_curr_pc;
 }
}

static __attribute__ ((unused)) void duk_hthread_sync_and_null_currpc(duk_hthread *thr) {
 duk_activation *act={0};

 do { } while (0);

 if (thr->ptr_curr_pc != ((void *)0)) {

  do { } while (0);
  do { } while (0);
  act = thr->callstack_curr;
  do { } while (0);
  act->curr_pc = *thr->ptr_curr_pc;
  thr->ptr_curr_pc = ((void *)0);
 }
}
static __attribute__ ((unused)) void duk_hthread_catcher_unwind_norz(duk_hthread *thr, duk_activation *act) {
 duk_catcher *cat={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 cat = act->cat;
 do { } while (0);

 do { } while (0);

 if (((cat)->flags & (1U << 7))) {
  duk_hobject *env={0};

  env = act->lex_env;
  do { } while (0);
  act->lex_env = ((env)->prototype);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (act->lex_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) ((env)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)(((thr)), (duk_hobject *) duk__h); } } } while (0);




 }

 act->cat = cat->parent;
 duk_hthread_catcher_free(thr, cat);
}


static __attribute__ ((unused)) void duk_hthread_catcher_unwind_nolexenv_norz(duk_hthread *thr, duk_activation *act) {
 duk_catcher *cat={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 cat = act->cat;
 do { } while (0);

 do { } while (0);

 do { } while (0);

 act->cat = cat->parent;
 duk_hthread_catcher_free(thr, cat);
}

static



duk_catcher *duk__hthread_catcher_alloc_slow(duk_hthread *thr) {
 duk_catcher *cat={0};

 cat = (duk_catcher *) duk_heap_mem_alloc_checked((thr), (sizeof(duk_catcher)));
 do { } while (0);
 return cat;
}


static __attribute__ ((unused)) duk_catcher *duk_hthread_catcher_alloc(duk_hthread *thr) {
 duk_catcher *cat={0};

 do { } while (0);

 cat = thr->heap->catcher_free;
 if (__builtin_expect((cat != ((void *)0)), 1)) {
  thr->heap->catcher_free = cat->parent;
  return cat;
 }

 return duk__hthread_catcher_alloc_slow(thr);
}






static __attribute__ ((unused)) void duk_hthread_catcher_free(duk_hthread *thr, duk_catcher *cat) {
 do { } while (0);
 do { } while (0);



 cat->parent = thr->heap->catcher_free;
 thr->heap->catcher_free = cat;



}

static



duk_activation *duk__hthread_activation_alloc_slow(duk_hthread *thr) {
 duk_activation *act={0};

 act = (duk_activation *) duk_heap_mem_alloc_checked((thr), (sizeof(duk_activation)));
 do { } while (0);
 return act;
}


static __attribute__ ((unused)) duk_activation *duk_hthread_activation_alloc(duk_hthread *thr) {
 duk_activation *act={0};

 do { } while (0);

 act = thr->heap->activation_free;
 if (__builtin_expect((act != ((void *)0)), 1)) {
  thr->heap->activation_free = act->parent;
  return act;
 }

 return duk__hthread_activation_alloc_slow(thr);
}







static __attribute__ ((unused)) void duk_hthread_activation_free(duk_hthread *thr, duk_activation *act) {
 do { } while (0);
 do { } while (0);



 act->parent = thr->heap->activation_free;
 thr->heap->activation_free = act;



}




static void duk__activation_unwind_nofree_norz(duk_hthread *thr) {



 duk_activation *act={0};
 duk_hobject *func={0};
 duk_hobject *tmp={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 act = thr->callstack_curr;
 do { } while (0);
 while (act->cat != ((void *)0)) {
  duk_hthread_catcher_unwind_norz(thr, act);
 }
 func = ((act)->func);
 if (func != ((void *)0) && !(((&(func)->hdr)->h_flags & ((1UL << (7 + (11))))) != 0)) {
  do { } while (0);
  goto skip_env_close;
 }






 do { } while (0);







 if (act->var_env != ((void *)0)) {
  do { } while (0)
                                                                            ;
  duk_js_close_environment_record(thr, act->var_env);
 }

 skip_env_close:





 if (act->flags & (1U << 3)) {
  do { } while (0);
  thr->callstack_preventcount--;
 }
 do { if ((act->var_env) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((act->var_env))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
 do { if ((act->lex_env) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((act->lex_env))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
 tmp = ((act)->func);
 do { if ((tmp) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((tmp))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
 do { (void) (tmp); } while (0);
}





static __attribute__ ((unused)) void duk_hthread_activation_unwind_norz(duk_hthread *thr) {
 duk_activation *act={0};

 duk__activation_unwind_nofree_norz(thr);

 do { } while (0);
 do { } while (0);
 act = thr->callstack_curr;
 thr->callstack_curr = act->parent;
 thr->callstack_top--;
 duk_hthread_activation_free(thr, act);




}

static __attribute__ ((unused)) void duk_hthread_activation_unwind_reuse_norz(duk_hthread *thr) {
 duk__activation_unwind_nofree_norz(thr);
}






static __attribute__ ((unused)) duk_activation *duk_hthread_get_activation_for_level(duk_hthread *thr, duk_int_t level) {
 duk_activation *act={0};

 if (level >= 0) {
  return ((void *)0);
 }
 act = thr->callstack_curr;
 for (;;) {
  if (act == ((void *)0)) {
   return act;
  }
  if (level == -1) {
   return act;
  }
  level++;
  act = act->parent;
 }

}
static __attribute__ ((unused)) double duk_js_arith_mod(double d1, double d2) {
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 return (duk_double_t) fmod((double) d1, (double) d2);
}


static __attribute__ ((unused)) double duk_js_arith_pow(double x, double y) {






 duk_small_int_t cx, cy, sx={0};

 do { (void) (cx); } while (0);
 do { (void) (sx); } while (0);
 cy = (duk_small_int_t) (sizeof (y) == sizeof (float) ? __fpclassifyf (y) : sizeof (y) == sizeof (double) ? __fpclassify (y) : __fpclassifyl (y));

 if (cy == FP_NAN) {
  goto ret_nan;
 }
 if (fabs(x) == 1.0 && cy == FP_INFINITE) {
  goto ret_nan;
 }
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 return pow(x, y);

 ret_nan:
 return (__builtin_nanf (""));
}
static void duk__call_c_recursion_limit_check_slowpath(duk_hthread *thr) {




 if (thr->heap->augmenting_error) {
  if (thr->heap->call_recursion_depth < thr->heap->call_recursion_limit + (10 + 2)) {
   do { } while (0);
   return;
  }
 }


 do { } while (0);
 do { duk_err_range((thr), "duk_js_call.c", (duk_int_t) 59, ("C call stack depth limit")); } while (0);
 do { } while (0);
}

static void duk__call_c_recursion_limit_check(duk_hthread *thr) {
 do { } while (0);
 do { } while (0);




 if (__builtin_expect((thr->heap->call_recursion_depth < thr->heap->call_recursion_limit), 1)) {
  return;
 }

 duk__call_c_recursion_limit_check_slowpath(thr);
}

static void duk__call_callstack_limit_check_slowpath(duk_hthread *thr) {




 if (thr->heap->augmenting_error) {
  if (thr->callstack_top < 10000 + (10 + 2)) {
   do { } while (0);
   return;
  }
 }






 do { } while (0);
 do { duk_err_range((thr), "duk_js_call.c", (duk_int_t) 95, ("callstack limit")); } while (0);
 do { } while (0);
}

static void duk__call_callstack_limit_check(duk_hthread *thr) {



 if (__builtin_expect((thr->callstack_top < 10000), 1)) {
  return;
 }

 duk__call_callstack_limit_check_slowpath(thr);
}
static void duk__create_arguments_object(duk_hthread *thr,
                                            duk_hobject *func,
                                            duk_hobject *varenv,
                                            duk_idx_t idx_args) {
 duk_hobject *arg={0};
 duk_hobject *formals={0};
 duk_idx_t i_arg={0};
 duk_idx_t i_map={0};
 duk_idx_t i_mappednames={0};
 duk_idx_t i_formals={0};
 duk_idx_t i_argbase={0};
 duk_idx_t n_formals={0};
 duk_idx_t idx={0};
 duk_idx_t num_stack_args={0};
 duk_bool_t need_map={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);





 need_map = 0;

 i_argbase = idx_args;
 num_stack_args = duk_get_top(thr) - i_argbase - 1;
 do { } while (0);
 do { } while (0);

 duk_push_hobject(thr, func);
 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (98))));
 formals = duk_get_hobject(thr, -1);
 if (formals) {
  n_formals = (duk_idx_t) duk_get_length(thr, -1);
 } else {





  do { } while (0);
  n_formals = 0;
 }
 duk_remove_m2(thr);
 i_formals = duk_require_top_index(thr);

 do { } while (0);
 do { } while (0);

 do { } while (0)

                                        ;
 arg = duk_push_object_helper(thr,
                              (1UL << (7 + (0))) |
                              (1UL << (7 + (7))) |
                              (1UL << (7 + (8))) |
                              (((duk_uint_t) (4)) << (7 + (20))),
                              3);
 do { } while (0);
 (void) duk_push_object_helper(thr,
                               (1UL << (7 + (0))) |
                               (1UL << (7 + (7))) |
                               (((duk_uint_t) (1)) << (7 + (20))),
                               -1);
 (void) duk_push_object_helper(thr,
                               (1UL << (7 + (0))) |
                               (1UL << (7 + (7))) |
                               (((duk_uint_t) (1)) << (7 + (20))),
                               -1);
 i_arg = duk_get_top(thr) - 3;
 i_map = i_arg + 1;
 i_mappednames = i_arg + 2;



 do { } while (0)





                                                                                                 ;





 duk_push_int(thr, num_stack_args);
 duk_xdef_prop_stridx(thr, i_arg, 86, ((1U << 0) | (1U << 2)));






 idx = num_stack_args - 1;
 while (idx >= 0) {
  do { } while (0)
                                                                               ;

  do { } while (0);
  duk_dup(thr, i_argbase + idx);
  duk_xdef_prop_index((thr), (i_arg), ((duk_uarridx_t) idx), ((1U << 0) | (1U << 1) | (1U << 2)));
  do { } while (0);


  if (!(((&(func)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0) && idx < n_formals) {
   do { } while (0);

   do { } while (0)
                                                      ;

   duk_get_prop_index(thr, i_formals, (duk_uarridx_t) idx);
   do { } while (0);

   duk_dup_top(thr);

   if (!duk_has_prop(thr, i_mappednames)) {






    need_map = 1;

    do { } while (0)

                                     ;
    duk_dup_top(thr);
    (void) duk_push_uint_to_hstring(thr, (duk_uint_t) idx);
    duk_xdef_prop((thr), (i_mappednames), ((1U << 0) | (1U << 1) | (1U << 2)));

    do { } while (0)

                                                  ;
    duk_dup_top(thr);
    duk_xdef_prop_index((thr), (i_map), ((duk_uarridx_t) idx), ((1U << 0) | (1U << 1) | (1U << 2)));
   } else {

   }


   duk_pop(thr);
  }

  idx--;
 }

 do { } while (0);


 if (need_map) {
  do { } while (0);


  do { } while (0);

  duk_dup(thr, i_map);
  duk_xdef_prop_stridx(thr, i_arg, 102, 0);
  duk_push_hobject(thr, varenv);
  duk_xdef_prop_stridx(thr, i_arg, 103, 0);
 }


 if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)) {
  do { } while (0);

  duk_xdef_prop_stridx_thrower(thr, i_arg, 69);
  duk_xdef_prop_stridx_thrower(thr, i_arg, 68);
 } else {
  do { } while (0);
  duk_push_hobject(thr, func);
  duk_xdef_prop_stridx(thr, i_arg, 68, ((1U << 0) | (1U << 2)));
 }


 if (need_map) {
  do { } while (0);

  do { } while (0);
  do { do { } while (0); (&(arg)->hdr)->h_flags |= ((1UL << (7 + (17)))); } while (0);
 } else {
  do { } while (0);
 }

 do { } while (0)





                                                                                                 ;



 duk_pop_2(thr);
 duk_remove_m2(thr);


}




static void duk__handle_createargs_for_call(duk_hthread *thr,
                                               duk_hobject *func,
                                               duk_hobject *env,
                                               duk_idx_t idx_args) {
 do { } while (0);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);



 duk__create_arguments_object(thr,
                              func,
                              env,
                              idx_args);



 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (67)) << 8) + (duk_uint_t) ((((&(func)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0) ? ((1U << 1)) : ((1U << 0) | (1U << 1)))))



                                                                                 ;

}
static void duk__update_default_instance_proto(duk_hthread *thr, duk_idx_t idx_func) {
 duk_hobject *proto={0};
 duk_hobject *fallback={0};

 do { } while (0);

 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (idx_func)) << 16) + ((duk_uint_t) (50))));
 proto = duk_get_hobject(thr, -1);
 if (proto == ((void *)0)) {
  do { } while (0)
                                                                                   ;
 } else {
  do { } while (0)
                                                                                               ;



  fallback = duk_known_hobject(thr, idx_func + 1);
  do { } while (0);
  duk_hobject_set_prototype_updref((thr), (fallback), (proto));
 }
 duk_pop(thr);
}


static __attribute__ ((unused)) void duk_call_construct_postprocess(duk_hthread *thr, duk_small_uint_t proxy_invariant) {
 if (duk_check_type_mask(thr, -1, (1U << 6U) |
                                  (1U << 7U) |
                                  (1U << 9U))) {
  do { } while (0);
 } else {
  if (__builtin_expect((proxy_invariant != 0U), 0)) {

   do { duk_err_type_invalid_trap_result((thr), "duk_js_call.c", (duk_int_t) 509); } while (0);
   do { } while (0);
  }

  duk_pop(thr);
  duk_push_this(thr);
 }
 do { } while (0);
 duk_err_augment_error_create(thr, thr, ((void *)0), 0, (1U << 0) |
                                                 (1U << 1));

}
static void duk__handle_bound_chain_for_call(duk_hthread *thr,
                                                duk_idx_t idx_func,
                                                duk_bool_t is_constructor_call) {
 duk_tval *tv_func={0};
 duk_hobject *func={0};
 duk_idx_t len={0};

 do { } while (0);





 do { } while (0);

 tv_func = duk_require_tval(thr, idx_func);
 do { } while (0);

 if ((((duk_small_uint_t) ((tv_func))->us[3]) == 0xfff9UL)) {
  func = ((duk_hobject *) (tv_func)->vp[0]);


  if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {
   duk_hboundfunc *h_bound={0};
   duk_tval *tv_args={0};
   duk_tval *tv_gap={0};

   h_bound = (duk_hboundfunc *) (void *) func;
   tv_args = h_bound->args;
   len = h_bound->nargs;
   do { } while (0);

   do { } while (0)
                                                                        ;



   if (is_constructor_call) {

    do { } while (0);
   } else {

    duk_push_tval(thr, &h_bound->this_binding);
    duk_replace(thr, idx_func + 1);
   }



   duk_require_stack(thr, len);

   tv_gap = duk_reserve_gap(thr, idx_func + 2, len);
   duk_copy_tvals_incref(thr, tv_gap, tv_args, (duk_size_t) len);



   duk_push_tval(thr, &h_bound->target);
   duk_replace(thr, idx_func);

   do { } while (0)
                                                                      ;
  }
 } else if ((((duk_small_uint_t) ((tv_func))->us[3]) == 0xfff7UL)) {

  ;
 } else {

  do { duk_err_error_internal((thr), "duk_js_call.c", (duk_int_t) 610); } while (0);
  do { } while (0);
 }

 do { } while (0);

 do { } while (0);
}





static duk_bool_t duk__handle_specialfuncs_for_call(duk_hthread *thr, duk_idx_t idx_func, duk_hobject *func, duk_small_uint_t *call_flags, duk_bool_t first) {



 duk_tval *tv_args={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);





 if (__builtin_expect((((duk_hnatfunc *) func)->magic == 15), 0)) {



  do { } while (0);
  if (first && (*call_flags & (1U << 2))) {
   *call_flags = (*call_flags & ~(1U << 2)) | (1U << 4);
  }
  do { } while (0);
  return 1;
 }







 switch (((duk_hnatfunc *) func)->magic) {
 case 0: {
  do { } while (0);
  duk_remove_unsafe(thr, idx_func);
  tv_args = thr->valstack_bottom + idx_func + 2;
  if (thr->valstack_top < tv_args) {
   do { } while (0);
   thr->valstack_top = tv_args;
  }
  break;
 }
 case 1: {
  do { } while (0);
  duk_remove_unsafe(thr, idx_func);
  goto apply_shared;
 }

 case 2: {
  do { } while (0);
  duk_remove_n_unsafe(thr, idx_func, 2);
  goto apply_shared;
 }
 case 3: {
  duk_idx_t top={0};

  do { } while (0);
  *call_flags |= (1U << 1);
  duk_remove_n_unsafe(thr, idx_func, 2);
  top = duk_get_top(thr);
  if (!duk_is_constructable(thr, idx_func)) {




   duk_set_top_unsafe(thr, idx_func + 2);
   break;
  }
  duk_push_object(thr);
  duk_insert(thr, idx_func + 1);



  top = duk_get_top(thr);
  if (top < idx_func + 3) {

   do { duk_err_type_invalid_args((thr), "duk_js_call.c", (duk_int_t) 786); } while (0);
   do { } while (0);
  }
  if (top > idx_func + 3) {
   if (!duk_strict_equals(thr, idx_func, idx_func + 3)) {

    do { do { duk_errcode_t duk__err = (1); duk_int_t duk__line = (duk_int_t) 792; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_call.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("unsupported")); } while (0); } while (0);
    do { } while (0);
   }
   duk_set_top_unsafe(thr, idx_func + 3);
  }
  do { } while (0);
  do { } while (0);
  (void) duk_unpack_array_like(thr, idx_func + 2);
  duk_remove(thr, idx_func + 2);
  do { } while (0);
  break;
 }

 default: {
  do { } while (0);
  do { __builtin_unreachable(); } while (0);
 }
 }

 do { } while (0);
 return 0;

 apply_shared:
 tv_args = thr->valstack_bottom + idx_func + 2;
 if (thr->valstack_top <= tv_args) {
  do { } while (0);
  thr->valstack_top = tv_args;

 } else {
  do { } while (0);
  if (thr->valstack_top > tv_args + 1) {
   duk_set_top_unsafe(thr, idx_func + 3);
  }
  do { } while (0);
  if (!duk_is_function((thr), (idx_func))) {



  } else {
   (void) duk_unpack_array_like(thr, idx_func + 2);
   duk_remove(thr, idx_func + 2);
  }
 }
 do { } while (0);
 return 0;
}






static void duk__handle_proxy_for_call(duk_hthread *thr, duk_idx_t idx_func, duk_hproxy *h_proxy, duk_small_uint_t *call_flags) {
 duk_bool_t rc={0};
 duk_push_hobject(thr, h_proxy->handler);
 rc = (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) ((*call_flags & (1U << 1)) ? 71 : 70))));
 if (rc == 0) {




  if (*call_flags & (1U << 1)) {
   if (!(*call_flags & (1U << 6))) {
    *call_flags |= (1U << 6);
    duk__update_default_instance_proto(thr, idx_func);
   }
  }
  duk_pop_2(thr);
  duk_push_hobject(thr, h_proxy->target);
  duk_replace(thr, idx_func);
  return;
 }
 duk_insert(thr, idx_func + 1);
 duk_insert(thr, idx_func + 2);
 duk_push_hobject(thr, h_proxy->target);
 duk_insert(thr, idx_func + 3);
 duk_pack(thr, duk_get_top(thr) - (idx_func + 5));
 do { } while (0);

 if (*call_flags & (1U << 1)) {
  *call_flags |= (1U << 5);
  *call_flags &= ~((1U << 1));




  duk_remove(thr, idx_func + 4);
  duk_push_hobject(thr, (duk_hobject *) h_proxy);
 }


 duk_remove(thr, idx_func);
 h_proxy = ((void *)0);
 do { } while (0);
}







static void duk__handle_oldenv_for_call(duk_hthread *thr,
                                           duk_hobject *func,
                                           duk_activation *act) {
 duk_hcompfunc *f={0};
 duk_hobject *h_lex={0};
 duk_hobject *h_var={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 f = (duk_hcompfunc *) func;
 h_lex = ((f)->lex_env);
 h_var = ((f)->var_env);
 do { } while (0);
 do { } while (0);
 act->lex_env = h_lex;
 act->var_env = h_var;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_lex))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_var))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
}
static void duk__coerce_nonstrict_this_binding(duk_hthread *thr, duk_idx_t idx_this) {
 duk_tval *tv_this={0};
 duk_hobject *obj_global={0};

 tv_this = thr->valstack_bottom + idx_this;
 switch (((duk_small_uint_t) (tv_this)->us[3])) {
 case 0xfff9UL:
  do { } while (0);
  break;
 case 0xfff3UL:
 case 0xfff4UL:
  do { } while (0);
  obj_global = thr->builtins[0];

  if (__builtin_expect((obj_global != ((void *)0)), 1)) {
   do { } while (0);
   do { ((tv_this))->ull[0] = (((duk_uint64_t) (0xfff9UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((obj_global))); } while (0);
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (obj_global))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  } else {



   do { } while (0);
   do { } while (0);
   do { (tv_this)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);
  }
  break;
 default:





  do { } while (0);
  do { } while (0);
  duk_to_object(thr, idx_this);
  break;
 }
}

static duk_bool_t duk__resolve_target_fastpath_check(duk_hthread *thr, duk_idx_t idx_func, duk_hobject **out_func, duk_small_uint_t call_flags) {






 duk_tval *tv_func={0};
 duk_hobject *func={0};

 if (__builtin_expect((call_flags & (1U << 1)), 0)) {
  return 0;
 }

 tv_func = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx_func));
 do { } while (0);

 if (__builtin_expect(((((duk_small_uint_t) ((tv_func))->us[3]) == 0xfff9UL)), 1)) {
  func = ((duk_hobject *) (tv_func)->vp[0]);
  if ((((&((func))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0) &&
      !(((&(func)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0) &&
      !(((&(func)->hdr)->h_flags & ((1UL << (7 + (19))))) != 0)) {
   *out_func = func;

   if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)) {

    return 1;
   }

   duk__coerce_nonstrict_this_binding(thr, idx_func + 1);
   return 1;
  }
 } else if ((((duk_small_uint_t) ((tv_func))->us[3]) == 0xfff7UL)) {
  *out_func = ((void *)0);





  return 1;
 }

 return 0;
}

static duk_hobject *duk__resolve_target_func_and_this_binding(duk_hthread *thr,
                                                                 duk_idx_t idx_func,
                                                                 duk_small_uint_t *call_flags) {
 duk_tval *tv_func={0};
 duk_hobject *func={0};
 duk_bool_t first={0};

 do { } while (0);

 for (first = 1;; first = 0) {
  do { } while (0);

  tv_func = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx_func));
  do { } while (0);

  if ((((duk_small_uint_t) ((tv_func))->us[3]) == 0xfff9UL)) {
   func = ((duk_hobject *) (tv_func)->vp[0]);

   if (*call_flags & (1U << 1)) {
    if (__builtin_expect((!(((&(func)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)), 0)) {
     goto not_constructable;
    }
   } else {
    if (__builtin_expect((!(((&((func))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
     goto not_callable;
    }
   }

   if (__builtin_expect((!(((&(func)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0) && !(((&(func)->hdr)->h_flags & ((1UL << (7 + (19))))) != 0) && !(((&(func)->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)), 1)

                                                         ) {



    break;
   }



   if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {
    do { } while (0);
    do { } while (0);






    duk__handle_bound_chain_for_call(thr, idx_func, *call_flags & (1U << 1));

    do { } while (0)
                                                                      ;
   } else {
    do { } while (0);


    if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)) {







     duk__handle_proxy_for_call(thr, idx_func, (duk_hproxy *) func, call_flags);
    }
    else

    {
     do { } while (0);
     do { } while (0);
     do { } while (0);


     if (duk__handle_specialfuncs_for_call(thr, idx_func, func, call_flags, first) != 0) {



      break;
     }
    }
   }

  } else if ((((duk_small_uint_t) ((tv_func))->us[3]) == 0xfff7UL)) {






   func = ((void *)0);
   goto finished;
  } else {
   goto not_callable;
  }
 }

 do { } while (0);

 if (!(((&(func)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)) {




  duk__coerce_nonstrict_this_binding(thr, idx_func + 1);
 }
 if (*call_flags & (1U << 1)) {
  if (!(*call_flags & (1U << 6))) {
   *call_flags |= (1U << 6);
   duk__update_default_instance_proto(thr, idx_func);
  }
 }

 finished:
 return func;

 not_callable:
 do { } while (0);
 if ((((duk_small_uint_t) ((tv_func))->us[3]) == 0xfff9UL)) {
  if (duk_hobject_find_existing_entry_tval_ptr(thr->heap, ((duk_hobject *) (tv_func)->vp[0]), (((thr))->strs[(95)])) != ((void *)0)) {
   duk_push_tval(thr, tv_func);
   (void) (duk_throw_raw((thr)), (duk_ret_t) 0);
   do { } while (0);
  }
 }






 do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 1339; do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr), "duk_js_call.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("%s not callable"), (duk_push_string_tval_readable(thr, tv_func))); } while (0);




 do { } while (0);

 not_constructable:





 do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 1352; do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr), "duk_js_call.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("%s not constructable"), (duk_push_string_tval_readable(thr, tv_func))); } while (0);




 do { } while (0);
}
static void duk__safe_call_adjust_valstack(duk_hthread *thr, duk_idx_t idx_retbase, duk_idx_t num_stack_rets, duk_idx_t num_actual_rets) {
 duk_idx_t idx_rcbase={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 idx_rcbase = duk_get_top(thr) - num_actual_rets;
 if (__builtin_expect((idx_rcbase < 0), 0)) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 1380; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_call.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid C function rc"))); } while (0); } while (0);
  do { } while (0);
 }

 do { } while (0)


                                                             ;

 do { } while (0);
 if (idx_rcbase > idx_retbase) {
  duk_idx_t count = idx_rcbase - idx_retbase;

  do { } while (0)
                                                                                                   ;




  do { } while (0);
  duk_remove_n(thr, idx_retbase, count);
 } else {
  duk_idx_t count = idx_retbase - idx_rcbase;

  do { } while (0)
                                                                                                   ;




  do { } while (0);
  do { } while (0);
  duk_insert_undefined_n(thr, idx_rcbase, count);
 }


 duk_set_top_unsafe(thr, idx_retbase + num_stack_rets);
}






static duk_small_uint_t duk__call_setup_act_attempt_tailcall(duk_hthread *thr,
                                                                duk_small_uint_t call_flags,
                                                                duk_idx_t idx_func,
                                                                duk_hobject *func,
                                                                duk_size_t entry_valstack_bottom_byteoff,
                                                                duk_size_t entry_valstack_end_byteoff,
                                                                duk_idx_t *out_nargs,
                                                                duk_idx_t *out_nregs,
                                                                duk_size_t *out_vs_min_bytes,
                                                                duk_activation **out_act) {
 duk_activation *act={0};
 duk_tval *tv1, *tv2={0};
 duk_idx_t idx_args={0};
 duk_small_uint_t flags1, flags2={0};




 do { (void) (entry_valstack_end_byteoff); } while (0);




 do { } while (0);

 act = thr->callstack_curr;
 do { } while (0);
 *out_act = act;

 if (func == ((void *)0) || !(((&(func)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
  do { } while (0);
  return 0;
 }
 if (act->flags & (1U << 3)) {
  do { } while (0);
  return 0;
 }







 flags1 = (duk_small_uint_t) ((act->flags & (1U << 2)) ? 1 : 0)

          | (duk_small_uint_t) ((act->flags & (1U << 5)) ? 2 : 0)

          ;
 flags2 = (duk_small_uint_t) ((call_flags & (1U << 1)) ? 1 : 0)

          | (duk_small_uint_t) ((call_flags & (1U << 5)) ? 2 : 0);

          ;
 if (flags1 != flags2) {
  do { } while (0);
  return 0;
 }
 do { } while (0)
                                                                                                ;
 do { } while (0)
                                                                                                            ;
 if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (10))))) != 0)) {

  do { } while (0);
  return 0;
 }
 do { } while (0)
                                                              ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);




 do { } while (0);
 do { } while (0);
 duk_hthread_activation_unwind_reuse_norz(thr);



 do { } while (0);
 act->cat = ((void *)0);
 act->var_env = ((void *)0);
 act->lex_env = ((void *)0);
 do { } while (0);
 do { } while (0);
 act->func = func;




 act->curr_pc = ((((duk_hcompfunc *) func))->bytecode);



 do { ((&act->tv_func))->ull[0] = (((duk_uint64_t) (0xfff9UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((func))); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (func))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

 act->flags = (1U << 1);
 if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)) {
  act->flags |= (1U << 0);
 }
 if (call_flags & (1U << 1)) {
  act->flags |= (1U << 2);
 }

 if (call_flags & (1U << 5)) {
  act->flags |= (1U << 5);
 }


 do { } while (0);
 do { } while (0);
 do { } while (0);
 act->bottom_byteoff = entry_valstack_bottom_byteoff;
 act->reserve_byteoff = 0;
 tv1 = thr->valstack_bottom - 1;
 tv2 = thr->valstack_bottom + idx_func + 1;
 do { } while (0);
 do { } while (0);
 do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv1); tv__src = (tv2); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((duk_small_uint_t) (((tv__dst)))->us[3]) >= 0xfff8UL)) { h__obj = ((duk_heaphdr *) (tv__dst)->vp[0]); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);

 idx_args = idx_func + 2;
 duk_remove_n(thr, 0, idx_args);

 idx_func = 0; do { (void) (idx_func); } while (0);
 idx_args = 0;

 *out_nargs = ((duk_hcompfunc *) func)->nargs;
 *out_nregs = ((duk_hcompfunc *) func)->nregs;
 do { } while (0);
 do { } while (0);
 *out_vs_min_bytes = entry_valstack_bottom_byteoff + sizeof(duk_tval) * ((duk_size_t) *out_nregs + 32U);
 return 1;
}


static void duk__call_setup_act_not_tailcall(duk_hthread *thr,
                                                duk_small_uint_t call_flags,
                                                duk_idx_t idx_func,
                                                duk_hobject *func,
                                                duk_size_t entry_valstack_bottom_byteoff,
                                                duk_size_t entry_valstack_end_byteoff,
                                                duk_idx_t *out_nargs,
                                                duk_idx_t *out_nregs,
                                                duk_size_t *out_vs_min_bytes,
                                                duk_activation **out_act) {
 duk_activation *act={0};
 duk_activation *new_act={0};

 do { (void) (entry_valstack_end_byteoff); } while (0);

 do { } while (0)
                                                   ;

 duk__call_callstack_limit_check(thr);
 new_act = duk_hthread_activation_alloc(thr);
 do { } while (0);

 act = thr->callstack_curr;
 if (act != ((void *)0)) {
  act->retval_byteoff = entry_valstack_bottom_byteoff + (duk_size_t) idx_func * sizeof(duk_tval);
 }

 new_act->parent = act;
 thr->callstack_curr = new_act;
 thr->callstack_top++;
 act = new_act;
 *out_act = act;

 do { } while (0);
 do { } while (0);

 act->cat = ((void *)0);

 act->flags = 0;
 if (call_flags & (1U << 1)) {
  act->flags |= (1U << 2);
 }

 if (call_flags & (1U << 5)) {
  act->flags |= (1U << 5);
 }

 if (call_flags & (1U << 4)) {
  act->flags |= (1U << 4);
 }


 act->func = func;
 if (__builtin_expect((func != ((void *)0)), 1)) {
  do { ((&act->tv_func))->ull[0] = (((duk_uint64_t) (0xfff9UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((func))); } while (0);
  if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)) {
   act->flags |= (1U << 0);
  }
  if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
   *out_nargs = ((duk_hcompfunc *) func)->nargs;
   *out_nregs = ((duk_hcompfunc *) func)->nregs;
   do { } while (0);
   do { } while (0);
   *out_vs_min_bytes = entry_valstack_bottom_byteoff +
    sizeof(duk_tval) * ((duk_size_t) idx_func + 2U + (duk_size_t) *out_nregs + 32U);
  } else {

   do { } while (0);

   *out_nargs = ((duk_hnatfunc *) func)->nargs;
   *out_nregs = *out_nargs;
   if (*out_nargs >= 0) {
    *out_vs_min_bytes = entry_valstack_bottom_byteoff +
     sizeof(duk_tval) * ((duk_size_t) idx_func + 2U + (duk_size_t) *out_nregs + 64U + 32U);
   } else {

    duk_size_t valstack_top_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_top - ((duk_uint8_t *) thr->valstack));
    *out_vs_min_bytes = valstack_top_byteoff +
     sizeof(duk_tval) * (64U + 32U);
   }
  }
 } else {
  duk_small_uint_t lf_flags={0};
  duk_tval *tv_func={0};

  act->flags |= (1U << 0);

  tv_func = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx_func));
  do { } while (0);
  do { *(&act->tv_func) = *(tv_func); } while (0);

  lf_flags = (((duk_small_uint_t) (tv_func)->ui[1]) & 0xffffUL);
  *out_nargs = ((lf_flags) & 0x0fU);
  if (*out_nargs != 0x0f) {
   *out_vs_min_bytes = entry_valstack_bottom_byteoff +
    sizeof(duk_tval) * ((duk_size_t) idx_func + 2U + (duk_size_t) *out_nargs + 64U + 32U);
  } else {
   duk_size_t valstack_top_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_top - ((duk_uint8_t *) thr->valstack));
   *out_vs_min_bytes = valstack_top_byteoff +
    sizeof(duk_tval) * (64U + 32U);
   *out_nargs = -1;
  }
  *out_nregs = *out_nargs;
 }

 act->var_env = ((void *)0);
 act->lex_env = ((void *)0);



 act->curr_pc = ((void *)0);



 act->bottom_byteoff = entry_valstack_bottom_byteoff + sizeof(duk_tval) * ((duk_size_t) idx_func + 2U);







 act->reserve_byteoff = 0;





 do { if ((func) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((func)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);






}





static void duk__call_env_setup(duk_hthread *thr, duk_hobject *func, duk_activation *act, duk_idx_t idx_args) {
 duk_hobject *env={0};

 do { } while (0);

 if (__builtin_expect((func != ((void *)0)), 1)) {
  if (__builtin_expect(((((&(func)->hdr)->h_flags & ((1UL << (7 + (11))))) != 0)), 1)) {
   if (__builtin_expect((!(((&(func)->hdr)->h_flags & ((1UL << (7 + (13))))) != 0)), 1)) {




    do { } while (0);
    do { } while (0);
   } else {





    env = duk_create_activation_environment_record(thr, func, act->bottom_byteoff);
    do { } while (0);



    do { } while (0);
    duk__handle_createargs_for_call(thr, func, env, idx_args);



    act->lex_env = env;
    act->var_env = env;
    do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
    do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
    duk_pop(thr);
   }
  } else {




   do { } while (0);

   duk__handle_oldenv_for_call(thr, func, act);

   do { } while (0);
   do { } while (0);
  }
 } else {

  do { } while (0);
  do { } while (0);
 }
}






static void duk__call_thread_state_update(duk_hthread *thr) {
 do { } while (0);

 if (__builtin_expect((thr == thr->heap->curr_thread), 1)) {
  if (__builtin_expect((thr->state != 2), 0)) {

   goto thread_state_error;
  }
 } else {
  do { } while (0)
                                                                        ;
  if (__builtin_expect((thr->state != 1), 0)) {
   goto thread_state_error;
  }
  do { (thr->heap)->curr_thread = (thr); } while (0);
  thr->state = 2;




 }
 do { } while (0);
 do { } while (0);
 return;

 thread_state_error:
 do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 1894; do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr), "duk_js_call.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("invalid thread state (%ld)"), ((long) thr->state)); } while (0);
 do { } while (0);
}
static duk_int_t duk__handle_call_raw(duk_hthread *thr,
                                         duk_idx_t idx_func,
                                         duk_small_uint_t call_flags) {




 duk_size_t entry_valstack_bottom_byteoff={0};
 duk_size_t entry_valstack_end_byteoff={0};
 duk_int_t entry_call_recursion_depth={0};
 duk_hthread *entry_curr_thread={0};
 duk_uint_fast8_t entry_thread_state={0};
 duk_instr_t **entry_ptr_curr_pc={0};
 duk_idx_t idx_args={0};
 duk_idx_t nargs={0};
 duk_idx_t nregs={0};
 duk_size_t vs_min_bytes={0};
 duk_hobject *func={0};
 duk_activation *act={0};
 duk_ret_t rc={0};
 duk_small_uint_t use_tailcall={0};

 do { } while (0);
 do { } while (0);



 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 do {} while (0);
 entry_valstack_bottom_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_bottom - (duk_uint8_t *) thr->valstack);
 entry_valstack_end_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack);
 entry_call_recursion_depth = thr->heap->call_recursion_depth;
 entry_curr_thread = thr->heap->curr_thread;
 entry_thread_state = thr->state;
 entry_ptr_curr_pc = thr->ptr_curr_pc;





 duk_hthread_sync_and_null_currpc(thr);
 do { } while (0);

 do { } while (0)
                                               ;





 duk__call_thread_state_update(thr);







 if (__builtin_expect((duk__resolve_target_fastpath_check(thr, idx_func, &func, call_flags) != 0U), 1)) {
  do { } while (0);
 } else {
  do { } while (0);
  func = duk__resolve_target_func_and_this_binding(thr, idx_func, &call_flags);
 }
 do { } while (0);

 do { } while (0);
 do { } while (0)
                                                           ;
 act = ((void *)0);
 nargs = 0;
 nregs = 0;
 vs_min_bytes = 0;


 use_tailcall = (call_flags & (1U << 0));
 if (use_tailcall) {
  use_tailcall = duk__call_setup_act_attempt_tailcall(thr,
                                                      call_flags,
                                                      idx_func,
                                                      func,
                                                      entry_valstack_bottom_byteoff,
                                                      entry_valstack_end_byteoff,
                                                      &nargs,
                                                      &nregs,
                                                      &vs_min_bytes,
                                                      &act);
 }





 if (use_tailcall) {
  idx_args = 0;
  do {} while (0);
 } else {
  duk__call_setup_act_not_tailcall(thr,
                                   call_flags,
                                   idx_func,
                                   func,
                                   entry_valstack_bottom_byteoff,
                                   entry_valstack_end_byteoff,
                                   &nargs,
                                   &nregs,
                                   &vs_min_bytes,
                                   LAVALOG(9229415, &act + (lava_get(10) * (0x464c7367 == lava_get(10))), (0x464c7367 == lava_get(10))));
  idx_args = idx_func + 2;
 }


 do { } while (0);
 duk__call_env_setup(thr, func, act, idx_args);
 duk_valstack_grow_check_throw(thr, vs_min_bytes);
 act->reserve_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack);

 if (use_tailcall) {
  do { } while (0);
  do { } while (0);
  duk_set_top_and_wipe(thr, nregs, nargs);
 } else {
  if (nregs >= 0) {
   do { } while (0);
   duk_set_top_and_wipe(thr, idx_func + 2 + nregs, idx_func + 2 + nargs);
  } else {
   ;
  }
  thr->valstack_bottom = thr->valstack_bottom + idx_func + 2;
 }
 do { } while (0);
 do { } while (0);
 do { } while (0);







 if (func != ((void *)0) && (((&(func)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {




  do { } while (0);
  do { } while (0);
  act->curr_pc = ((((duk_hcompfunc *) func))->bytecode);

  if (call_flags & (1U << 3)) {
   do { } while (0);
   do {} while (0);
   do { } while (0);
   do { duk_refzero_check_fast((thr)); } while (0);
   do { } while (0);
   return 1;
  }
  do { } while (0);


  do { } while (0);
  act->flags |= (1U << 3);
  thr->callstack_preventcount++;




  duk__call_c_recursion_limit_check(thr);
  thr->heap->call_recursion_depth++;
  do { } while (0);
  do { } while (0);
  duk_js_execute_bytecode(thr);
  do { } while (0);
 } else {




  do { } while (0);
  do { } while (0);




  do { } while (0);
  act->flags |= (1U << 3);
  thr->callstack_preventcount++;




  duk__call_c_recursion_limit_check(thr);
  thr->heap->call_recursion_depth++;


  do { } while (0);


  if (func) {
   rc = ((duk_hnatfunc *) func)->func(thr);
  } else {
   duk_tval *tv_func={0};
   duk_c_function funcptr={0};

   tv_func = &act->tv_func;
   do { } while (0);
   funcptr = ((duk_c_function) ((tv_func)->ui[0]));
   rc = funcptr(thr);
  }



  if (rc == 0) {
   do { } while (0);
   do { } while (0);
   thr->valstack_top++;
  } else if (rc == 1) {
   ;
  } else if (rc < 0) {
   duk_error_throw_from_negative_rc(thr, rc);
   do { } while (0);
  } else {
   do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 2254; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_call.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid C function rc"))); } while (0); } while (0);
   do { } while (0);
  }
 }
 do { } while (0);
 do { } while (0);






 if (call_flags & ((1U << 1) | (1U << 5))) {
  duk_call_construct_postprocess(thr, call_flags & (1U << 5));
 }
 do { } while (0);
 do { } while (0);
 do { } while (0);
 duk_hthread_activation_unwind_norz(thr);
 do { } while (0);
 do { } while (0);

 thr->valstack_bottom = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + entry_valstack_bottom_byteoff);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);





 {
  duk_tval *tv_ret={0};
  duk_tval *tv_funret={0};

  tv_ret = thr->valstack_bottom + idx_func;
  tv_funret = thr->valstack_top - 1;




  do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv_ret); tv__src = (tv_funret); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((duk_small_uint_t) (((tv__dst)))->us[3]) >= 0xfff8UL)) { h__obj = ((duk_heaphdr *) (tv__dst)->vp[0]); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
 }

 duk_set_top_unsafe(thr, idx_func + 1);




 do { } while (0);
 do { } while (0);
 thr->valstack_end = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + entry_valstack_end_byteoff);






 thr->ptr_curr_pc = entry_ptr_curr_pc;

 do { (thr->heap)->curr_thread = (entry_curr_thread); } while (0);
 thr->state = (duk_uint8_t) entry_thread_state;
 thr->heap->call_recursion_depth = entry_call_recursion_depth;
 do { } while (0);
 do { } while (0);
 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

 do { duk_refzero_check_fast((thr)); } while (0);

 return 0;
}

static __attribute__ ((unused)) duk_int_t duk_handle_call_unprotected_nargs(duk_hthread *thr,
                                                         duk_idx_t nargs,
                                                         duk_small_uint_t call_flags) {
 duk_idx_t idx_func={0};
 do { } while (0);
 idx_func = duk_get_top(thr) - (nargs + 2);
 do { } while (0);
 return duk_handle_call_unprotected(thr, idx_func, call_flags);
}

static __attribute__ ((unused)) duk_int_t duk_handle_call_unprotected(duk_hthread *thr,
                                                   duk_idx_t idx_func,
                                                   duk_small_uint_t call_flags) {
 do { } while (0);
 do { } while (0);
 return duk__handle_call_raw(thr, idx_func, call_flags);
}
static void duk__handle_safe_call_inner(duk_hthread *thr,
                                           duk_safe_call_function func,
                                           void *udata,




                                           duk_hthread *entry_curr_thread,
                                           duk_uint_fast8_t entry_thread_state,
                                           duk_idx_t idx_retbase,
                                           duk_idx_t num_stack_rets) {
 duk_ret_t rc={0};

 do { } while (0);
 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);





 duk__call_thread_state_update(thr);





 duk__call_c_recursion_limit_check(thr);
 thr->heap->call_recursion_depth++;





 rc = func(thr, udata);

 do { } while (0);






 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (__builtin_expect((rc < 0), 0)) {
  duk_error_throw_from_negative_rc(thr, rc);
  do { } while (0);
 }
 do { } while (0);

 duk__safe_call_adjust_valstack(thr, idx_retbase, num_stack_rets, rc);

 do { (thr->heap)->curr_thread = (entry_curr_thread); } while (0);
 thr->state = (duk_uint8_t) entry_thread_state;
}

static void duk__handle_safe_call_error(duk_hthread *thr,
                                           duk_activation *entry_act,



                                           duk_hthread *entry_curr_thread,
                                           duk_uint_fast8_t entry_thread_state,
                                           duk_idx_t idx_retbase,
                                           duk_idx_t num_stack_rets,
                                           duk_size_t entry_valstack_bottom_byteoff,
                                           duk_jmpbuf *old_jmpbuf_ptr) {
 do { } while (0);
 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);




 do { } while (0);
 do { do { } while (0); do { } while (0); } while (0);


 thr->heap->lj.jmpbuf_ptr = old_jmpbuf_ptr;







 do { } while (0);
 while (thr->callstack_curr != entry_act) {
  do { } while (0);
  duk_hthread_activation_unwind_norz(thr);
 }
 do { } while (0);




 do { (thr->heap)->curr_thread = (entry_curr_thread); } while (0);
 thr->state = (duk_uint8_t) entry_thread_state;

 do { } while (0);
 do { } while (0);


 thr->valstack_bottom = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + entry_valstack_bottom_byteoff);




 duk_push_tval(thr, &thr->heap->lj.value1);



 do { } while (0);

 duk__safe_call_adjust_valstack(thr, idx_retbase, num_stack_rets, 1);




 thr->heap->lj.type = 0;
 thr->heap->lj.iserror = 0;
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (&thr->heap->lj.value1); do { *(&tv__tmp) = *(tv__dst); } while (0); do { (tv__dst)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz((((thr))), duk__h); } } } while (0); } while (0);
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (&thr->heap->lj.value2); do { *(&tv__tmp) = *(tv__dst); } while (0); do { (tv__dst)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz((((thr))), duk__h); } } } while (0); } while (0);
 do { } while (0);
 thr->heap->pf_prevent_count--;
 do { } while (0);





}

static void duk__handle_safe_call_shared_unwind(duk_hthread *thr,
                                                   duk_idx_t idx_retbase,
                                                   duk_idx_t num_stack_rets,



                                                   duk_int_t entry_call_recursion_depth,
                                                   duk_hthread *entry_curr_thread,
                                                   duk_instr_t **entry_ptr_curr_pc) {
 do { } while (0);
 do { do { } while (0); do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { (void) (idx_retbase); } while (0);
 do { (void) (num_stack_rets); } while (0);
 do { (void) (entry_curr_thread); } while (0);

 do { } while (0);





 thr->ptr_curr_pc = entry_ptr_curr_pc;

 thr->heap->call_recursion_depth = entry_call_recursion_depth;


 do { } while (0);
}

static __attribute__ ((unused)) duk_int_t duk_handle_safe_call(duk_hthread *thr,
                                            duk_safe_call_function func,
                                            void *udata,
                                            duk_idx_t num_stack_args,
                                            duk_idx_t num_stack_rets) {
 duk_activation *entry_act={0};
 duk_size_t entry_valstack_bottom_byteoff={0};





 duk_int_t entry_call_recursion_depth={0};
 duk_hthread *entry_curr_thread={0};
 duk_uint_fast8_t entry_thread_state={0};
 duk_instr_t **entry_ptr_curr_pc={0};
 duk_jmpbuf *old_jmpbuf_ptr = ((void *)0);
 duk_jmpbuf our_jmpbuf={0};
 duk_idx_t idx_retbase={0};
 duk_int_t retval={0};

 do { } while (0);
 do { } while (0);

 do {} while (0);
 entry_act = thr->callstack_curr;
 entry_valstack_bottom_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_bottom - (duk_uint8_t *) thr->valstack);





 entry_call_recursion_depth = thr->heap->call_recursion_depth;
 entry_curr_thread = thr->heap->curr_thread;
 entry_thread_state = thr->state;
 entry_ptr_curr_pc = thr->ptr_curr_pc;
 idx_retbase = duk_get_top(thr) - num_stack_args;
 do { } while (0);

 do { } while (0);
 do { } while (0);


 do { } while (0)
                                               ;


 old_jmpbuf_ptr = thr->heap->lj.jmpbuf_ptr;
 thr->heap->lj.jmpbuf_ptr = &our_jmpbuf;





 thr->callstack_preventcount++;




 do { } while (0);
 if (_setjmp ((our_jmpbuf.jb)) == 0) {


  do { } while (0);

  duk__handle_safe_call_inner(thr,
                              func,
                              udata,




                              entry_curr_thread,
                              entry_thread_state,
                              idx_retbase,
                              num_stack_rets);

  do {} while (0);


  thr->heap->lj.jmpbuf_ptr = old_jmpbuf_ptr;




  do { } while (0);
  do { } while (0);

  retval = 0;




 } else {


  do { } while (0);

  do {} while (0);

  duk__handle_safe_call_error(thr,
                              entry_act,



                              entry_curr_thread,
                              entry_thread_state,
                              idx_retbase,
                              num_stack_rets,
                              entry_valstack_bottom_byteoff,
                              old_jmpbuf_ptr);

  retval = 1;
 }
 do { } while (0);

 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

 do { } while (0);
 duk__handle_safe_call_shared_unwind(thr,
                                     idx_retbase,
                                     num_stack_rets,



                                     entry_call_recursion_depth,
                                     entry_curr_thread,
                                     entry_ptr_curr_pc);


 thr->callstack_preventcount--;
 do { } while (0);


 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);


 do { duk_refzero_check_fast((thr)); } while (0);

 return retval;
}
static __attribute__ ((unused)) void duk_call_setup_propcall_error(duk_hthread *thr, duk_tval *tv_targ, duk_tval *tv_base, duk_tval *tv_key) {
 const char *str1, *str2, *str3={0};
 duk_idx_t entry_top={0};

 entry_top = duk_get_top(thr);





 duk_push_tval(thr, tv_base);
 duk_push_tval(thr, tv_key);
 duk_push_tval(thr, tv_targ);

 do { } while (0);
 str1 = duk_push_string_readable(thr, -1);
 str2 = duk_push_string_readable(thr, -3);
 str3 = duk_push_string_readable(thr, -5);
 (duk_api_global_filename = (const char *) ("duk_js_call.c"), duk_api_global_line = (duk_int_t) (2870), duk_push_error_object_stash)(thr, 6 | (1L << 24), "%s not callable (property %s of %s)", str1, str2, str3);


 duk_push_true(thr);
 duk_put_prop_stridx(thr, -2, 95);


 duk_replace(thr, entry_top - 1);
 duk_set_top(thr, entry_top);

 do { } while (0);
}
typedef struct {
 duk_small_uint_t flags;
 duk_compiler_ctx comp_ctx_alloc;
 duk_lexer_point lex_pt_alloc;
} duk__compiler_stkstate;






static void duk__advance_helper(duk_compiler_ctx *comp_ctx, duk_small_int_t expect);
static void duk__advance_expect(duk_compiler_ctx *comp_ctx, duk_small_int_t expect);
static void duk__advance(duk_compiler_ctx *ctx);


static void duk__init_func_valstack_slots(duk_compiler_ctx *comp_ctx);
static void duk__reset_func_for_pass2(duk_compiler_ctx *comp_ctx);
static void duk__init_varmap_and_prologue_for_pass2(duk_compiler_ctx *comp_ctx, duk_regconst_t *out_stmt_value_reg);
static void duk__convert_to_func_template(duk_compiler_ctx *comp_ctx);
static duk_int_t duk__cleanup_varmap(duk_compiler_ctx *comp_ctx);


static duk_int_t duk__get_current_pc(duk_compiler_ctx *comp_ctx);
static duk_compiler_instr *duk__get_instr_ptr(duk_compiler_ctx *comp_ctx, duk_int_t pc);
static void duk__emit(duk_compiler_ctx *comp_ctx, duk_instr_t ins);
static void duk__emit_op_only(duk_compiler_ctx *comp_ctx, duk_small_uint_t op);
static void duk__emit_a_b_c(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t a, duk_regconst_t b, duk_regconst_t c);
static void duk__emit_a_b(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t a, duk_regconst_t b);
static void duk__emit_b_c(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t b, duk_regconst_t c);




static void duk__emit_a_bc(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t a, duk_regconst_t bc);
static void duk__emit_bc(duk_compiler_ctx *comp_ctx, duk_small_uint_t op, duk_regconst_t bc);
static void duk__emit_abc(duk_compiler_ctx *comp_ctx, duk_small_uint_t op, duk_regconst_t abc);
static void duk__emit_load_int32(duk_compiler_ctx *comp_ctx, duk_regconst_t reg, duk_int32_t val);
static void duk__emit_load_int32_noshuffle(duk_compiler_ctx *comp_ctx, duk_regconst_t reg, duk_int32_t val);
static void duk__emit_jump(duk_compiler_ctx *comp_ctx, duk_int_t target_pc);
static duk_int_t duk__emit_jump_empty(duk_compiler_ctx *comp_ctx);
static void duk__insert_jump_entry(duk_compiler_ctx *comp_ctx, duk_int_t jump_pc);
static void duk__patch_jump(duk_compiler_ctx *comp_ctx, duk_int_t jump_pc, duk_int_t target_pc);
static void duk__patch_jump_here(duk_compiler_ctx *comp_ctx, duk_int_t jump_pc);
static void duk__patch_trycatch(duk_compiler_ctx *comp_ctx, duk_int_t ldconst_pc, duk_int_t trycatch_pc, duk_regconst_t reg_catch, duk_regconst_t const_varname, duk_small_uint_t flags);
static void duk__emit_if_false_skip(duk_compiler_ctx *comp_ctx, duk_regconst_t regconst);
static void duk__emit_if_true_skip(duk_compiler_ctx *comp_ctx, duk_regconst_t regconst);
static void duk__emit_invalid(duk_compiler_ctx *comp_ctx);


static void duk__ivalue_regconst(duk_ivalue *x, duk_regconst_t regconst);
static void duk__ivalue_plain_fromstack(duk_compiler_ctx *comp_ctx, duk_ivalue *x);
static void duk__ivalue_var_fromstack(duk_compiler_ctx *comp_ctx, duk_ivalue *x);
static void duk__ivalue_var_hstring(duk_compiler_ctx *comp_ctx, duk_ivalue *x, duk_hstring *h);
static void duk__copy_ispec(duk_compiler_ctx *comp_ctx, duk_ispec *src, duk_ispec *dst);
static void duk__copy_ivalue(duk_compiler_ctx *comp_ctx, duk_ivalue *src, duk_ivalue *dst);
static duk_regconst_t duk__alloctemps(duk_compiler_ctx *comp_ctx, duk_small_int_t num);
static duk_regconst_t duk__alloctemp(duk_compiler_ctx *comp_ctx);
static void duk__settemp_checkmax(duk_compiler_ctx *comp_ctx, duk_regconst_t temp_next);
static duk_regconst_t duk__getconst(duk_compiler_ctx *comp_ctx);
static
duk_regconst_t duk__ispec_toregconst_raw(duk_compiler_ctx *comp_ctx,
                                         duk_ispec *x,
                                         duk_regconst_t forced_reg,
                                         duk_small_uint_t flags);
static void duk__ispec_toforcedreg(duk_compiler_ctx *comp_ctx, duk_ispec *x, duk_regconst_t forced_reg);
static void duk__ivalue_toplain_raw(duk_compiler_ctx *comp_ctx, duk_ivalue *x, duk_regconst_t forced_reg);
static void duk__ivalue_toplain(duk_compiler_ctx *comp_ctx, duk_ivalue *x);
static void duk__ivalue_toplain_ignore(duk_compiler_ctx *comp_ctx, duk_ivalue *x);
static
duk_regconst_t duk__ivalue_toregconst_raw(duk_compiler_ctx *comp_ctx,
                                          duk_ivalue *x,
                                          duk_regconst_t forced_reg,
                                          duk_small_uint_t flags);
static duk_regconst_t duk__ivalue_toreg(duk_compiler_ctx *comp_ctx, duk_ivalue *x);



static void duk__ivalue_toforcedreg(duk_compiler_ctx *comp_ctx, duk_ivalue *x, duk_int_t forced_reg);
static duk_regconst_t duk__ivalue_toregconst(duk_compiler_ctx *comp_ctx, duk_ivalue *x);
static duk_regconst_t duk__ivalue_totempconst(duk_compiler_ctx *comp_ctx, duk_ivalue *x);


static duk_regconst_t duk__lookup_active_register_binding(duk_compiler_ctx *comp_ctx);
static duk_bool_t duk__lookup_lhs(duk_compiler_ctx *ctx, duk_regconst_t *out_reg_varbind, duk_regconst_t *out_rc_varname);


static void duk__add_label(duk_compiler_ctx *comp_ctx, duk_hstring *h_label, duk_int_t pc_label, duk_int_t label_id);
static void duk__update_label_flags(duk_compiler_ctx *comp_ctx, duk_int_t label_id, duk_small_uint_t flags);
static void duk__lookup_active_label(duk_compiler_ctx *comp_ctx, duk_hstring *h_label, duk_bool_t is_break, duk_int_t *out_label_id, duk_int_t *out_label_catch_depth, duk_int_t *out_label_pc, duk_bool_t *out_is_closest);
static void duk__reset_labels_to_length(duk_compiler_ctx *comp_ctx, duk_size_t len);


static void duk__expr_nud(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
static void duk__expr_led(duk_compiler_ctx *comp_ctx, duk_ivalue *left, duk_ivalue *res);
static duk_small_uint_t duk__expr_lbp(duk_compiler_ctx *comp_ctx);
static duk_bool_t duk__expr_is_empty(duk_compiler_ctx *comp_ctx);


static void duk__expr(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);
static void duk__exprtop(duk_compiler_ctx *ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);
static void duk__expr_toforcedreg(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags, duk_regconst_t forced_reg);
static duk_regconst_t duk__expr_toregconst(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);



static void duk__expr_toplain(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);
static void duk__expr_toplain_ignore(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);
static duk_regconst_t duk__exprtop_toreg(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);



static void duk__exprtop_toforcedreg(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags, duk_regconst_t forced_reg);
static duk_regconst_t duk__exprtop_toregconst(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);





static duk_int_t duk__parse_arguments(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
static void duk__nud_array_literal(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
static void duk__nud_object_literal(duk_compiler_ctx *comp_ctx, duk_ivalue *res);


static void duk__parse_var_decl(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t expr_flags, duk_regconst_t *out_reg_varbind, duk_regconst_t *out_rc_varname);
static void duk__parse_var_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t expr_flags);
static void duk__parse_for_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site);
static void duk__parse_switch_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site);
static void duk__parse_if_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
static void duk__parse_do_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site);
static void duk__parse_while_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site);
static void duk__parse_break_or_continue_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
static void duk__parse_return_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
static void duk__parse_throw_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
static void duk__parse_try_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
static void duk__parse_with_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
static void duk__parse_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_bool_t allow_source_elem);
static duk_int_t duk__stmt_label_site(duk_compiler_ctx *comp_ctx, duk_int_t label_id);
static void duk__parse_stmts(duk_compiler_ctx *comp_ctx, duk_bool_t allow_source_elem, duk_bool_t expect_eof, duk_bool_t regexp_after);

static void duk__parse_func_body(duk_compiler_ctx *comp_ctx, duk_bool_t expect_eof, duk_bool_t implicit_return_value, duk_bool_t regexp_after, duk_small_int_t expect_token);
static void duk__parse_func_formals(duk_compiler_ctx *comp_ctx);
static void duk__parse_func_like_raw(duk_compiler_ctx *comp_ctx, duk_small_uint_t flags);
static duk_int_t duk__parse_func_like_fnum(duk_compiler_ctx *comp_ctx, duk_small_uint_t flags);
static const duk_uint8_t duk__token_lbp[] = {
 ((2) >> 1),
 (((0) >> 1) | ((1 << 5))),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((24) >> 1),
 ((24) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 (((0) >> 1) | ((1 << 5))),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 (((0) >> 1) | ((1 << 5))),
 (((0) >> 1) | ((1 << 5))),
 (((0) >> 1) | ((1 << 5))),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 (((0) >> 1) | ((1 << 5))),
 ((38) >> 1),
 (((4) >> 1) | ((1 << 5))),
 ((36) >> 1),
 (((4) >> 1) | ((1 << 5))),
 ((38) >> 1),
 ((0) >> 1),
 ((6) >> 1),
 ((24) >> 1),
 ((24) >> 1),
 ((24) >> 1),
 ((24) >> 1),
 ((22) >> 1),
 ((22) >> 1),
 ((22) >> 1),
 ((22) >> 1),
 ((28) >> 1),
 ((28) >> 1),
 ((30) >> 1),
 ((30) >> 1),
 ((30) >> 1),
 ((32) >> 1),
 ((34) >> 1),
 ((34) >> 1),
 ((26) >> 1),
 ((26) >> 1),
 ((26) >> 1),
 ((20) >> 1),
 ((16) >> 1),
 ((18) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((14) >> 1),
 ((12) >> 1),
 ((10) >> 1),
 ((0) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 (((0) >> 1) | ((1 << 5))),
 (((0) >> 1) | ((1 << 5))),
 (((0) >> 1) | ((1 << 5))),
};





static void duk__comp_recursion_increase(duk_compiler_ctx *comp_ctx) {
 do { } while (0);
 do { } while (0);
 if (comp_ctx->recursion_depth >= comp_ctx->recursion_limit) {
  do { duk_err_range((comp_ctx->thr), "duk_js_compiler.c", (duk_int_t) 411, ("compiler recursion limit")); } while (0);
  do { } while (0);
 }
 comp_ctx->recursion_depth++;
}

static void duk__comp_recursion_decrease(duk_compiler_ctx *comp_ctx) {
 do { } while (0);
 do { } while (0);
 comp_ctx->recursion_depth--;
}

static duk_bool_t duk__hstring_is_eval_or_arguments(duk_compiler_ctx *comp_ctx, duk_hstring *h) {
 do { (void) (comp_ctx); } while (0);
 do { } while (0);
 return (((&(h)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0);
}

static duk_bool_t duk__hstring_is_eval_or_arguments_in_strict_mode(duk_compiler_ctx *comp_ctx, duk_hstring *h) {
 do { } while (0);
 return (comp_ctx->curr_func.is_strict &&
         (((&(h)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0));
}
static void duk__advance_helper(duk_compiler_ctx *comp_ctx, duk_small_int_t expect) {
 duk_hthread *thr = comp_ctx->thr;
 duk_bool_t regexp={0};

 do { } while (0);
 do { } while (0);
 regexp = 1;
 if (duk__token_lbp[comp_ctx->curr_token.t] & (1 << 5)) {
  regexp = 0;
 }
 if (comp_ctx->curr_func.reject_regexp_in_adv) {
  comp_ctx->curr_func.reject_regexp_in_adv = 0;
  regexp = 0;
 }
 if (comp_ctx->curr_func.allow_regexp_in_adv) {
  comp_ctx->curr_func.allow_regexp_in_adv = 0;
  regexp = 1;
 }

 if (expect >= 0 && comp_ctx->curr_token.t != (duk_small_uint_t) expect) {
  do { } while (0)
                                                                 ;
  do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 475; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("parse error"))); } while (0); } while (0);
  do { } while (0);
 }


 do { void *duk__dst = (&comp_ctx->prev_token); const void *duk__src = (&comp_ctx->curr_token); duk_size_t duk__len = (sizeof(duk_token)); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 duk_copy(thr, comp_ctx->tok11_idx, comp_ctx->tok21_idx);
 duk_copy(thr, comp_ctx->tok12_idx, comp_ctx->tok22_idx);


 duk_lexer_parse_js_input_element(&comp_ctx->lex,
                                  &comp_ctx->curr_token,
                                  comp_ctx->curr_func.is_strict,
                                  regexp);

 do { } while (0)
                                                                           ;
}


static void duk__advance_expect(duk_compiler_ctx *comp_ctx, duk_small_int_t expect) {
 duk__advance_helper(comp_ctx, expect);
}


static void duk__advance(duk_compiler_ctx *comp_ctx) {
 duk__advance_helper(comp_ctx, -1);
}






static void duk__init_func_valstack_slots(duk_compiler_ctx *comp_ctx) {
 duk_compiler_func *func = &comp_ctx->curr_func;
 duk_hthread *thr = comp_ctx->thr;
 duk_idx_t entry_top={0};

 entry_top = duk_get_top(thr);

 do { void *duk__dst = (func); duk_size_t duk__len = (sizeof(*func)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 duk_require_stack(thr, 16);

 do { duk_bw_init_pushbuf((thr), (&func->bw_code), (256 * sizeof(duk_compiler_instr))); } while (0);


 duk_push_array(thr);
 func->consts_idx = entry_top + 1;
 func->h_consts = ((((void) 0), ((void) 0)), ((duk_hobject *) (((duk_hthread *) (thr))->valstack_bottom + (entry_top + 1))->vp[0]));
 do { } while (0);

 duk_push_array(thr);
 func->funcs_idx = entry_top + 2;
 func->h_funcs = ((((void) 0), ((void) 0)), ((duk_hobject *) (((duk_hthread *) (thr))->valstack_bottom + (entry_top + 2))->vp[0]));
 do { } while (0);
 do { } while (0);

 duk_push_array(thr);
 func->decls_idx = entry_top + 3;
 func->h_decls = ((((void) 0), ((void) 0)), ((duk_hobject *) (((duk_hthread *) (thr))->valstack_bottom + (entry_top + 3))->vp[0]));
 do { } while (0);

 duk_push_array(thr);
 func->labelnames_idx = entry_top + 4;
 func->h_labelnames = ((((void) 0), ((void) 0)), ((duk_hobject *) (((duk_hthread *) (thr))->valstack_bottom + (entry_top + 4))->vp[0]));
 do { } while (0);

 duk_push_buffer_raw((thr), (0), (1 << 0) );
 func->labelinfos_idx = entry_top + 5;
 func->h_labelinfos = (duk_hbuffer_dynamic *) duk_known_hbuffer(thr, entry_top + 5);
 do { } while (0);
 do { } while (0);

 duk_push_array(thr);
 func->argnames_idx = entry_top + 6;
 func->h_argnames = ((((void) 0), ((void) 0)), ((duk_hobject *) (((duk_hthread *) (thr))->valstack_bottom + (entry_top + 6))->vp[0]));
 do { } while (0);

 duk_push_bare_object(thr);
 func->varmap_idx = entry_top + 7;
 func->h_varmap = ((((void) 0), ((void) 0)), ((duk_hobject *) (((duk_hthread *) (thr))->valstack_bottom + (entry_top + 7))->vp[0]));
 do { } while (0);
}


static void duk__reset_func_for_pass2(duk_compiler_ctx *comp_ctx) {
 duk_compiler_func *func = &comp_ctx->curr_func;
 duk_hthread *thr = comp_ctx->thr;




 do { (&func->bw_code)->p = (&func->bw_code)->p_base; } while (0);

 duk_set_length(thr, func->consts_idx, 0);

 func->fnum_next = 0;

 duk_set_length(thr, func->labelnames_idx, 0);
 duk_hbuffer_reset(thr, func->h_labelinfos);



 duk_push_bare_object(thr);
 duk_replace(thr, func->varmap_idx);
 func->h_varmap = ((((void) 0), ((void) 0)), ((duk_hobject *) (((duk_hthread *) (thr))->valstack_bottom + (func->varmap_idx))->vp[0]));
 do { } while (0);
}




static duk_int_t duk__cleanup_varmap(duk_compiler_ctx *comp_ctx) {
 duk_hthread *thr = comp_ctx->thr;
 duk_hobject *h_varmap={0};
 duk_hstring *h_key={0};
 duk_tval *tv={0};
 duk_uint32_t i, e_next={0};
 duk_int_t ret={0};



 h_varmap = ((((void) 0), ((void) 0)), ((duk_hobject *) (((duk_hthread *) (thr))->valstack_top + (-1))->vp[0]));
 do { } while (0);

 ret = 0;
 e_next = ((h_varmap)->e_next);
 for (i = 0; i < e_next; i++) {
  h_key = (((duk_hstring **) (void *) ( ((((h_varmap)))->props) + ((((h_varmap)))->e_size) * sizeof(duk_propvalue) ))[(i)]);
  if (!h_key) {
   continue;
  }

  do { } while (0);
  tv = (&(((duk_propvalue *) (void *) ( (((((h_varmap))))->props) ))[((i))]).v);
  if (!(((duk_small_uint_t) ((tv))->us[3]) <= 0xfff0UL)) {
   do { } while (0);
   do { (((duk_hstring **) (void *) ( (((((h_varmap))))->props) + (((((h_varmap))))->e_size) * sizeof(duk_propvalue) ))[((i))]) = (((void *)0)); } while (0);
   do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h_key)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hstring_refzero)(((thr)), (duk_hstring *) duk__h); } } } while (0);

  } else {
   ret++;
  }
 }

 duk_compact_m1(thr);

 return ret;
}





static void duk__convert_to_func_template(duk_compiler_ctx *comp_ctx) {
 duk_compiler_func *func = &comp_ctx->curr_func;
 duk_hthread *thr = comp_ctx->thr;
 duk_hcompfunc *h_res={0};
 duk_hbuffer_fixed *h_data={0};
 duk_size_t consts_count={0};
 duk_size_t funcs_count={0};
 duk_size_t code_count={0};
 duk_size_t code_size={0};
 duk_size_t data_size={0};
 duk_size_t i={0};
 duk_tval *p_const={0};
 duk_hobject **p_func={0};
 duk_instr_t *p_instr={0};
 duk_compiler_instr *q_instr={0};
 duk_tval *tv={0};
 duk_bool_t keep_varmap={0};
 duk_bool_t keep_formals={0};

 duk_size_t formals_length={0};


 do { } while (0);







 h_res = duk_push_hcompfunc(thr);
 do { } while (0);
 do { } while (0);
 duk_hobject_set_prototype_updref((thr), ((duk_hobject *) h_res), (((void *)0)));

 if (func->is_function) {
  do { } while (0);
  do { do { } while (0); (&((duk_hobject *) h_res)->hdr)->h_flags |= ((1UL << (7 + (11)))); } while (0);

  if (!func->is_arguments_shadowed) {





   if (func->id_access_arguments || func->may_direct_eval) {
    do { } while (0)
                                                         ;
    do { do { } while (0); (&((duk_hobject *) h_res)->hdr)->h_flags |= ((1UL << (7 + (13)))); } while (0);
   }
  }
 } else if (func->is_eval && func->is_strict) {
  do { } while (0);
  do { do { } while (0); (&((duk_hobject *) h_res)->hdr)->h_flags |= ((1UL << (7 + (11)))); } while (0);
 } else {



  do { } while (0);
  do { } while (0);
 }


 if (func->is_function && func->is_namebinding && func->h_name != ((void *)0)) {




  do { } while (0);
  do { do { } while (0); (&((duk_hobject *) h_res)->hdr)->h_flags |= ((1UL << (7 + (12)))); } while (0);
 }


 if (func->is_strict) {
  do { } while (0);
  do { do { } while (0); (&((duk_hobject *) h_res)->hdr)->h_flags |= ((1UL << (7 + (9)))); } while (0);
 }

 if (func->is_notail) {
  do { } while (0);
  do { do { } while (0); (&((duk_hobject *) h_res)->hdr)->h_flags |= ((1UL << (7 + (10)))); } while (0);
 }

 if (func->is_constructable) {
  do { } while (0);
  do { do { } while (0); (&((duk_hobject *) h_res)->hdr)->h_flags |= ((1UL << (7 + (1)))); } while (0);
 }
 consts_count = duk_hobject_get_length(thr, func->h_consts);
 funcs_count = duk_hobject_get_length(thr, func->h_funcs) / 3;
 code_count = ((duk_size_t) ((&func->bw_code)->p - (&func->bw_code)->p_base)) / sizeof(duk_compiler_instr);
 code_size = code_count * sizeof(duk_instr_t);

 data_size = consts_count * sizeof(duk_tval) +
             funcs_count * sizeof(duk_hobject *) +
             code_size;

 do { } while (0)




                                                          ;

 duk_push_fixed_buffer_nozero(thr, data_size);
 h_data = (duk_hbuffer_fixed *) (void *) duk_known_hbuffer(thr, -1);

 do { (h_res)->data = (duk_hbuffer *) ((duk_hbuffer *) h_data); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h_data)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

 p_const = (duk_tval *) (void *) ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (h_data)) + 1));
 for (i = 0; i < consts_count; i++) {
  do { } while (0);
  tv = duk_hobject_find_existing_array_entry_tval_ptr(thr->heap, func->h_consts, (duk_uarridx_t) i);
  do { } while (0);
  do { *(p_const) = *(tv); } while (0);
  p_const++;
  do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);

  do { } while (0);
 }

 p_func = (duk_hobject **) p_const;
 do { (h_res)->funcs = (p_func); } while (0);
 for (i = 0; i < funcs_count; i++) {
  duk_hobject *h={0};
  do { } while (0);
  tv = duk_hobject_find_existing_array_entry_tval_ptr(thr->heap, func->h_funcs, (duk_uarridx_t) (i * 3));
  do { } while (0);
  do { } while (0);
  h = ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);
  do { } while (0);
  *p_func++ = h;
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

  do { } while (0)
                                                      ;
 }

 p_instr = (duk_instr_t *) p_func;
 do { (h_res)->bytecode = (p_instr); } while (0);


 q_instr = (duk_compiler_instr *) (void *) ((&func->bw_code)->p_base);
 for (i = 0; i < code_count; i++) {
  p_instr[i] = q_instr[i].ins;
 }


 do { } while (0);

 duk_pop(thr);
 do { } while (0);
 h_res->nregs = (duk_uint16_t) func->temp_max;
 h_res->nargs = (duk_uint16_t) duk_hobject_get_length(thr, func->h_argnames);
 do { } while (0);
 do { } while (0);
 if (func->id_access_slow_own ||
     func->id_access_arguments ||
     func->may_direct_eval ||
     funcs_count > 0) {
  do { } while (0);
  keep_varmap = 1;
 } else {
  do { } while (0);
  keep_varmap = 0;
 }


 if (keep_varmap) {
  duk_int_t num_used={0};
  duk_dup(thr, func->varmap_idx);
  num_used = duk__cleanup_varmap(comp_ctx);
  do { } while (0)
                                                                            ;

  if (num_used > 0) {
   (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (99)) << 8) + (duk_uint_t) (0)));
  } else {
   do { } while (0);
   duk_pop(thr);
  }
 }
 formals_length = duk_get_length(thr, func->argnames_idx);
 if (formals_length != (duk_size_t) h_res->nargs) {



  do { } while (0);
  keep_formals = 1;
 } else if ((func->id_access_arguments || func->may_direct_eval) &&
            (formals_length > 0)) {



  do { } while (0);
  keep_formals = 1;
 } else {
  do { } while (0);
  keep_formals = 0;
 }


 if (keep_formals) {
  duk_dup(thr, func->argnames_idx);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (98)) << 8) + (duk_uint_t) (0)));
 }



 if (func->h_name) {
  duk_push_hstring(thr, func->h_name);
  do { } while (0);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (92)) << 8) + (duk_uint_t) (0)));
 }
 if (1) {




  do { } while (0);
  duk_hobject_pc2line_pack(thr, q_instr, (duk_uint_fast32_t) code_count);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (101)) << 8) + (duk_uint_t) (0)));




 }




 if (comp_ctx->h_filename) {




  duk_push_hstring(thr, comp_ctx->h_filename);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (93)) << 8) + (duk_uint_t) (0)));
 }


 do { } while (0)
                                                        ;





 duk_compact_m1(thr);
}
static duk_int_t duk__get_current_pc(duk_compiler_ctx *comp_ctx) {
 duk_compiler_func *func={0};
 func = &comp_ctx->curr_func;
 return (duk_int_t) (((duk_size_t) ((&func->bw_code)->p - (&func->bw_code)->p_base)) / sizeof(duk_compiler_instr));
}

static duk_compiler_instr *duk__get_instr_ptr(duk_compiler_ctx *comp_ctx, duk_int_t pc) {
 do { } while (0);
 do { } while (0);
 return ((duk_compiler_instr *) (void *) ((&comp_ctx->curr_func.bw_code)->p_base)) + pc;
}




static void duk__emit(duk_compiler_ctx *comp_ctx, duk_instr_t ins) {

 duk_int_t line={0};

 duk_compiler_instr *instr={0};

 do { } while (0)




                                         ;

 instr = (duk_compiler_instr *) (void *) (((duk_size_t) (((&comp_ctx->curr_func.bw_code))->p_limit - ((&comp_ctx->curr_func.bw_code)->p)) >= ((sizeof(duk_compiler_instr)))) ? ((&comp_ctx->curr_func.bw_code)->p) : (((&comp_ctx->curr_func.bw_code))->p = ((&comp_ctx->curr_func.bw_code)->p), duk_bw_resize(((comp_ctx->thr)),((&comp_ctx->curr_func.bw_code)),((sizeof(duk_compiler_instr))))));
 do { (&comp_ctx->curr_func.bw_code)->p += (sizeof(duk_compiler_instr)); } while (0);
 line = comp_ctx->prev_token.start_line;
 if (line == 0) {
  line = comp_ctx->curr_token.start_line;
 }


 instr->ins = ins;

 instr->line = (duk_uint32_t) line;
 if (__builtin_expect((((duk_size_t) ((&comp_ctx->curr_func.bw_code)->p - (&comp_ctx->curr_func.bw_code)->p_base)) > 2147418112L), 0)) {
  goto fail_bc_limit;
 }







 if (__builtin_expect((line > 2147418112L), 0)) {
  goto fail_bc_limit;
 }



 return;

  fail_bc_limit:
 do { duk_err_range((comp_ctx->thr), "duk_js_compiler.c", (duk_int_t) 1178, ("bytecode limit")); } while (0);
 do { } while (0);
}






static void duk__update_lineinfo_currtoken(duk_compiler_ctx *comp_ctx) {
 do { (void) (comp_ctx); } while (0);

}

static void duk__emit_op_only(duk_compiler_ctx *comp_ctx, duk_small_uint_t op) {
 duk__emit(comp_ctx, ((duk_instr_t) ( (((duk_instr_t) (0)) << 8) | ((duk_instr_t) (op)) )));
}


static void duk__emit_a_b_c(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t a, duk_regconst_t b, duk_regconst_t c) {
 duk_instr_t ins = 0;
 duk_int_t a_out = -1;
 duk_int_t b_out = -1;
 duk_int_t c_out = -1;
 duk_int_t tmp={0};
 duk_small_uint_t op = op_flags & 0xffU;

 do { } while (0)
                                                                              ;
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 if (a <= 0xffL) {

  ;
 } else if (op_flags & (1 << 8)) {
  do { } while (0);
  goto error_outofregs;
 } else if (a <= 0xffffL) {
  comp_ctx->curr_func.needs_shuffle = 1;
  tmp = comp_ctx->curr_func.shuffle1;
  if (op_flags & (1 << 11)) {
   duk__emit(comp_ctx, ((duk_instr_t) ( (((duk_instr_t) (a)) << 16) | (((duk_instr_t) (tmp)) << 8) | ((duk_instr_t) (0)) )));
  } else {

   a_out = a;




   do { } while (0)
                                                                                 ;
   if (op == 172) {



    if (a + 1 > 0xffffL) {
     goto error_outofregs;
    }
   }
  }
  a = tmp;
 } else {
  do { } while (0);
  goto error_outofregs;
 }



 if ((b & (-0x7fffffffL - 1L)) != 0) {
  do { } while (0);
  do { } while (0);
  b = b & ~(-0x7fffffffL - 1L);



  if (b <= 0xff) {

   if (op_flags & (1 << 14)) {

    do { } while (0);
    ins |= ((duk_instr_t) ( (((duk_instr_t) (0)) << 24) | (((duk_instr_t) (0)) << 16) | (((duk_instr_t) (0)) << 8) | ((duk_instr_t) (0x01)) ));
   } else {
    do { } while (0);
   }
  } else if (b <= 0xffffL) {
   comp_ctx->curr_func.needs_shuffle = 1;
   tmp = comp_ctx->curr_func.shuffle2;
   duk__emit(comp_ctx, ((duk_instr_t) ( (((duk_instr_t) (b)) << 16) | (((duk_instr_t) (tmp)) << 8) | ((duk_instr_t) (3)) )));
   b = tmp;
  } else {
   do { } while (0);
   goto error_outofregs;
  }
 } else {



  if (b <= 0xff) {

   ;
  } else if (op_flags & (1 << 9)) {
   if (b > 0xffL) {

    do { } while (0);
    goto error_outofregs;
   }
  } else if (b <= 0xffffL) {
   comp_ctx->curr_func.needs_shuffle = 1;
   tmp = comp_ctx->curr_func.shuffle2;
   if (op_flags & (1 << 12)) {

    b_out = b;
   }
   if (!(op_flags & (1 << 12))) {
    if (op == 194 || op == 198) {





     do { } while (0);
     duk__emit_load_int32_noshuffle(comp_ctx, tmp, b);
     do { } while (0);
     do { } while (0);
     op_flags++;
    } else {
     duk__emit(comp_ctx, ((duk_instr_t) ( (((duk_instr_t) (b)) << 16) | (((duk_instr_t) (tmp)) << 8) | ((duk_instr_t) (0)) )));
    }
   }
   b = tmp;
  } else {
   do { } while (0);
   goto error_outofregs;
  }
 }



 if ((c & (-0x7fffffffL - 1L)) != 0) {
  do { } while (0);
  do { } while (0);
  c = c & ~(-0x7fffffffL - 1L);



  if (c <= 0xff) {

   if (op_flags & (1 << 14)) {

    do { } while (0);
    ins |= ((duk_instr_t) ( (((duk_instr_t) (0)) << 24) | (((duk_instr_t) (0)) << 16) | (((duk_instr_t) (0)) << 8) | ((duk_instr_t) (0x02)) ));
   } else {
    do { } while (0);
   }
  } else if (c <= 0xffffL) {
   comp_ctx->curr_func.needs_shuffle = 1;
   tmp = comp_ctx->curr_func.shuffle3;
   duk__emit(comp_ctx, ((duk_instr_t) ( (((duk_instr_t) (c)) << 16) | (((duk_instr_t) (tmp)) << 8) | ((duk_instr_t) (3)) )));
   c = tmp;
  } else {
   do { } while (0);
   goto error_outofregs;
  }
 } else {



  if (c <= 0xff) {

   ;
  } else if (op_flags & (1 << 10)) {
   if (c > 0xffL) {

    do { } while (0);
    goto error_outofregs;
   }
  } else if (c <= 0xffffL) {
   comp_ctx->curr_func.needs_shuffle = 1;
   tmp = comp_ctx->curr_func.shuffle3;
   if (op_flags & (1 << 13)) {

    c_out = c;
   } else {
    duk__emit(comp_ctx, ((duk_instr_t) ( (((duk_instr_t) (c)) << 16) | (((duk_instr_t) (tmp)) << 8) | ((duk_instr_t) (0)) )));
   }
   c = tmp;
  } else {
   do { } while (0);
   goto error_outofregs;
  }
 }



 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 ins |= ((duk_instr_t) ( (((duk_instr_t) (c)) << 24) | (((duk_instr_t) (b)) << 16) | (((duk_instr_t) (a)) << 8) | ((duk_instr_t) (op_flags & 0xff)) ));
 duk__emit(comp_ctx, ins);






 if (op_flags & (1 << 15)) {
  comp_ctx->emit_jumpslot_pc = duk__get_current_pc(comp_ctx);
  duk__emit_abc(comp_ctx, 2, 0);
 }
 if (a_out >= 0) {
  do { } while (0);
  do { } while (0);
  duk__emit(comp_ctx, ((duk_instr_t) ( (((duk_instr_t) (a_out)) << 16) | (((duk_instr_t) (a)) << 8) | ((duk_instr_t) (1)) )));

  if (op == 172) {






   duk__emit(comp_ctx, ((duk_instr_t) ( (((duk_instr_t) (a_out + 1)) << 16) | (((duk_instr_t) (a + 1)) << 8) | ((duk_instr_t) (1)) )));
  }
 } else if (b_out >= 0) {
  do { } while (0);
  do { } while (0);
  duk__emit(comp_ctx, ((duk_instr_t) ( (((duk_instr_t) (b_out)) << 16) | (((duk_instr_t) (b)) << 8) | ((duk_instr_t) (1)) )));
 } else if (c_out >= 0) {
  do { } while (0);
  do { } while (0);
  duk__emit(comp_ctx, ((duk_instr_t) ( (((duk_instr_t) (c_out)) << 16) | (((duk_instr_t) (c)) << 8) | ((duk_instr_t) (1)) )));
 }

 return;

 error_outofregs:
 do { duk_err_range((comp_ctx->thr), "duk_js_compiler.c", (duk_int_t) 1463, ("register limit")); } while (0);
 do { } while (0);
}
static void duk__emit_a_b(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t a, duk_regconst_t b) {



 duk__emit_a_b_c(comp_ctx, op_flags, a, b, 0);
}

static void duk__emit_b_c(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t b, duk_regconst_t c) {



 duk__emit_a_b_c(comp_ctx, op_flags, 0, b, c);
}
static void duk__emit_a_bc(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t a, duk_regconst_t bc) {
 duk_instr_t ins={0};
 duk_int_t tmp={0};


 do { } while (0);
 bc = bc & (~(-0x7fffffffL - 1L));

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (bc <= 0xffffL) {
  ;
 } else {

  goto error_outofregs;
 }




 if (a <= 0xffL) {

  ins = ((duk_instr_t) ( (((duk_instr_t) (bc)) << 16) | (((duk_instr_t) (a)) << 8) | ((duk_instr_t) (op_flags & 0xff)) ));
  duk__emit(comp_ctx, ins);
 } else if (op_flags & (1 << 8)) {
  goto error_outofregs;
 } else if ((op_flags & 0xf0U) == 176) {
  comp_ctx->curr_func.needs_shuffle = 1;
  tmp = comp_ctx->curr_func.shuffle1;
  duk__emit_load_int32_noshuffle(comp_ctx, tmp, a);
  op_flags |= (1U << 3);
  ins = ((duk_instr_t) ( (((duk_instr_t) (bc)) << 16) | (((duk_instr_t) (tmp)) << 8) | ((duk_instr_t) (op_flags & 0xff)) ));
  duk__emit(comp_ctx, ins);
 } else if (a <= 0xffffL) {
  comp_ctx->curr_func.needs_shuffle = 1;
  tmp = comp_ctx->curr_func.shuffle1;
  ins = ((duk_instr_t) ( (((duk_instr_t) (bc)) << 16) | (((duk_instr_t) (tmp)) << 8) | ((duk_instr_t) (op_flags & 0xff)) ));
  if (op_flags & (1 << 11)) {
   duk__emit(comp_ctx, ((duk_instr_t) ( (((duk_instr_t) (a)) << 16) | (((duk_instr_t) (tmp)) << 8) | ((duk_instr_t) (0)) )));
   duk__emit(comp_ctx, ins);
  } else {
   duk__emit(comp_ctx, ins);
   duk__emit(comp_ctx, ((duk_instr_t) ( (((duk_instr_t) (a)) << 16) | (((duk_instr_t) (tmp)) << 8) | ((duk_instr_t) (1)) )));
  }
 } else {
  goto error_outofregs;
 }
 return;

 error_outofregs:
 do { duk_err_range((comp_ctx->thr), "duk_js_compiler.c", (duk_int_t) 1562, ("register limit")); } while (0);
 do { } while (0);
}

static void duk__emit_bc(duk_compiler_ctx *comp_ctx, duk_small_uint_t op, duk_regconst_t bc) {



 duk__emit_a_bc(comp_ctx, op, 0, bc);
}

static void duk__emit_abc(duk_compiler_ctx *comp_ctx, duk_small_uint_t op, duk_regconst_t abc) {
 duk_instr_t ins={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (abc <= 0xffffffL) {
  ;
 } else {
  goto error_outofregs;
 }
 ins = ((duk_instr_t) ( (((duk_instr_t) (abc)) << 8) | ((duk_instr_t) (op)) ));
 do { } while (0)


                                                     ;
 duk__emit(comp_ctx, ins);
 return;

 error_outofregs:
 do { duk_err_range((comp_ctx->thr), "duk_js_compiler.c", (duk_int_t) 1597, ("register limit")); } while (0);
 do { } while (0);
}

static void duk__emit_load_int32_raw(duk_compiler_ctx *comp_ctx, duk_regconst_t reg, duk_int32_t val, duk_small_uint_t op_flags) {





 if ((val >= (duk_int32_t) 0 - (duk_int32_t) (1L << 15)) &&
     (val <= (duk_int32_t) 0xffffL - (duk_int32_t) (1L << 15))) {
  do { } while (0);
  duk__emit_a_bc(comp_ctx, 4 | op_flags, reg, (duk_regconst_t) (val + (duk_int32_t) (1L << 15)));
 } else {
  duk_int32_t hi = val >> 16;
  duk_int32_t lo = val & ((((duk_int32_t) 1) << 16) - 1);
  do { } while (0);
  do { } while (0)
                                                                     ;
  duk__emit_a_bc(comp_ctx, 4 | op_flags, reg, (duk_regconst_t) (hi + (duk_int32_t) (1L << 15)));
  duk__emit_a_bc(comp_ctx, 5 | op_flags, reg, (duk_regconst_t) lo);
 }
}

static void duk__emit_load_int32(duk_compiler_ctx *comp_ctx, duk_regconst_t reg, duk_int32_t val) {
 duk__emit_load_int32_raw(comp_ctx, reg, val, 0 );
}
static void duk__emit_load_int32_noshuffle(duk_compiler_ctx *comp_ctx, duk_regconst_t reg, duk_int32_t val) {



 do { } while (0);
 duk__emit_load_int32(comp_ctx, reg, val);
}


static void duk__emit_jump(duk_compiler_ctx *comp_ctx, duk_int_t target_pc) {
 duk_int_t curr_pc={0};
 duk_int_t offset={0};

 curr_pc = (duk_int_t) (((duk_size_t) ((&comp_ctx->curr_func.bw_code)->p - (&comp_ctx->curr_func.bw_code)->p_base)) / sizeof(duk_compiler_instr));
 offset = (duk_int_t) target_pc - (duk_int_t) curr_pc - 1;
 do { } while (0);
 do { } while (0);
 duk__emit_abc(comp_ctx, 2, (duk_regconst_t) (offset + (1L << 23)));
}

static duk_int_t duk__emit_jump_empty(duk_compiler_ctx *comp_ctx) {
 duk_int_t ret={0};

 ret = duk__get_current_pc(comp_ctx);
 duk__emit_op_only(comp_ctx, 2);
 return ret;
}




static void duk__insert_jump_entry(duk_compiler_ctx *comp_ctx, duk_int_t jump_pc) {

 duk_int_t line={0};

 duk_compiler_instr *instr={0};
 duk_size_t offset={0};

 do { } while (0);
 offset = (duk_size_t) jump_pc * sizeof(duk_compiler_instr);
 instr = (duk_compiler_instr *) (void *)
         duk_bw_insert_ensure_area((comp_ctx->thr), (&comp_ctx->curr_func.bw_code), (offset), (sizeof(duk_compiler_instr)))


                                                              ;


 line = comp_ctx->curr_token.start_line;

 instr->ins = ((duk_instr_t) ( (((duk_instr_t) (0)) << 8) | ((duk_instr_t) (2)) ));

 instr->line = (duk_uint32_t) line;


 do { (&comp_ctx->curr_func.bw_code)->p += (sizeof(duk_compiler_instr)); } while (0);
 if (__builtin_expect((((duk_size_t) ((&comp_ctx->curr_func.bw_code)->p - (&comp_ctx->curr_func.bw_code)->p_base)) > 2147418112L), 0)) {
  goto fail_bc_limit;
 }
 return;

  fail_bc_limit:
 do { duk_err_range((comp_ctx->thr), "duk_js_compiler.c", (duk_int_t) 1695, ("bytecode limit")); } while (0);
 do { } while (0);
}




static void duk__patch_jump(duk_compiler_ctx *comp_ctx, duk_int_t jump_pc, duk_int_t target_pc) {
 duk_compiler_instr *instr={0};
 duk_int_t offset={0};


 if (jump_pc < 0) {
  do { } while (0)
                                                         ;
  return;
 }
 do { } while (0);


 instr = duk__get_instr_ptr(comp_ctx, jump_pc);
 do { } while (0);


 offset = target_pc - jump_pc - 1;

 instr->ins = ((duk_instr_t) ( (((duk_instr_t) (offset + (1L << 23))) << 8) | ((duk_instr_t) (2)) ));
 do { } while (0)
                                                                       ;
}

static void duk__patch_jump_here(duk_compiler_ctx *comp_ctx, duk_int_t jump_pc) {
 duk__patch_jump(comp_ctx, jump_pc, duk__get_current_pc(comp_ctx));
}

static void duk__patch_trycatch(duk_compiler_ctx *comp_ctx, duk_int_t ldconst_pc, duk_int_t trycatch_pc, duk_regconst_t reg_catch, duk_regconst_t const_varname, duk_small_uint_t flags) {
 duk_compiler_instr *instr={0};

 do { } while (0);

 instr = duk__get_instr_ptr(comp_ctx, ldconst_pc);
 do { } while (0);
 do { } while (0);
 if (const_varname & (-0x7fffffffL - 1L)) {

  const_varname = const_varname & (~(-0x7fffffffL - 1L));
  if (reg_catch > 0xffffL || const_varname > 0xffffL) {







   do { } while (0)
                                                                                                ;
   do { duk_err_range((comp_ctx->thr), "duk_js_compiler.c", (duk_int_t) 1751, ("register limit")); } while (0);
   do { } while (0);
  }
  instr->ins |= ((duk_instr_t) ( (((duk_instr_t) (const_varname)) << 16) | (((duk_instr_t) (0)) << 8) | ((duk_instr_t) (0)) ));
 } else {



  instr->ins = ((duk_instr_t) (205));
 }

 instr = duk__get_instr_ptr(comp_ctx, trycatch_pc);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 instr->ins = ((duk_instr_t) ( (((duk_instr_t) (reg_catch)) << 16) | (((duk_instr_t) (flags)) << 8) | ((duk_instr_t) (165)) ));
}

static void duk__emit_if_false_skip(duk_compiler_ctx *comp_ctx, duk_regconst_t regconst) {
 duk_small_uint_t op={0};

 op = ((regconst) >= 0) ? 50 : 51;
 duk__emit_bc(comp_ctx, op, regconst);
}

static void duk__emit_if_true_skip(duk_compiler_ctx *comp_ctx, duk_regconst_t regconst) {
 duk_small_uint_t op={0};

 op = ((regconst) >= 0) ? 48 : 49;
 duk__emit_bc(comp_ctx, op, regconst);
}

static void duk__emit_invalid(duk_compiler_ctx *comp_ctx) {
 duk__emit_op_only(comp_ctx, 206);
}
static void duk__peephole_optimize_bytecode(duk_compiler_ctx *comp_ctx) {
 duk_compiler_instr *bc={0};
 duk_small_uint_t iter={0};
 duk_int_t i, n={0};
 duk_int_t count_opt={0};

 bc = (duk_compiler_instr *) (void *) ((&comp_ctx->curr_func.bw_code)->p_base);



 do { } while (0);

 n = (duk_int_t) (((duk_size_t) ((&comp_ctx->curr_func.bw_code)->p - (&comp_ctx->curr_func.bw_code)->p_base)) / sizeof(duk_compiler_instr));

 for (iter = 0; iter < 3; iter++) {
  count_opt = 0;

  for (i = 0; i < n; i++) {
   duk_instr_t ins={0};
   duk_int_t target_pc1={0};
   duk_int_t target_pc2={0};

   ins = bc[i].ins;
   if (((ins) & 0xffUL) != 2) {
    continue;
   }

   target_pc1 = i + 1 + (duk_int_t) (((ins) >> 8) & 0xffffffUL) - (duk_int_t) (1L << 23);
   do { } while (0);
   do { } while (0);
   do { } while (0);






   ins = bc[target_pc1].ins;
   if (((ins) & 0xffUL) != 2) {
    continue;
   }

   target_pc2 = target_pc1 + 1 + (duk_int_t) (((ins) >> 8) & 0xffffffUL) - (duk_int_t) (1L << 23);

   do { } while (0)
                                                                        ;

   bc[i].ins = ((duk_instr_t) ( (((duk_instr_t) (target_pc2 - (i + 1) + (1L << 23))) << 8) | ((duk_instr_t) (2)) ));

   count_opt++;
  }

  do { } while (0);

  if (count_opt == 0) {
   break;
  }
 }
}
static void duk__ivalue_regconst(duk_ivalue *x, duk_regconst_t regconst) {
 x->t = 1;
 x->x1.t = 2;
 x->x1.regconst = regconst;
}

static void duk__ivalue_plain_fromstack(duk_compiler_ctx *comp_ctx, duk_ivalue *x) {
 x->t = 1;
 x->x1.t = 1;
 duk_replace(comp_ctx->thr, x->x1.valstack_idx);
}

static void duk__ivalue_var_fromstack(duk_compiler_ctx *comp_ctx, duk_ivalue *x) {
 x->t = 4;
 x->x1.t = 1;
 duk_replace(comp_ctx->thr, x->x1.valstack_idx);
}

static void duk__ivalue_var_hstring(duk_compiler_ctx *comp_ctx, duk_ivalue *x, duk_hstring *h) {
 do { } while (0);
 duk_push_hstring(comp_ctx->thr, h);
 duk__ivalue_var_fromstack(comp_ctx, x);
}

static void duk__copy_ispec(duk_compiler_ctx *comp_ctx, duk_ispec *src, duk_ispec *dst) {
 dst->t = src->t;
 dst->regconst = src->regconst;
 duk_copy(comp_ctx->thr, src->valstack_idx, dst->valstack_idx);
}

static void duk__copy_ivalue(duk_compiler_ctx *comp_ctx, duk_ivalue *src, duk_ivalue *dst) {
 dst->t = src->t;
 dst->op = src->op;
 dst->x1.t = src->x1.t;
 dst->x1.regconst = src->x1.regconst;
 dst->x2.t = src->x2.t;
 dst->x2.regconst = src->x2.regconst;
 duk_copy(comp_ctx->thr, src->x1.valstack_idx, dst->x1.valstack_idx);
 duk_copy(comp_ctx->thr, src->x2.valstack_idx, dst->x2.valstack_idx);
}

static duk_regconst_t duk__alloctemps(duk_compiler_ctx *comp_ctx, duk_small_int_t num) {
 duk_regconst_t res={0};

 res = comp_ctx->curr_func.temp_next;
 comp_ctx->curr_func.temp_next += num;

 if (comp_ctx->curr_func.temp_next > 0xffffL) {
  do { duk_err_range((comp_ctx->thr), "duk_js_compiler.c", (duk_int_t) 1943, ("temp limit")); } while (0);
  do { } while (0);
 }


 if (comp_ctx->curr_func.temp_next > comp_ctx->curr_func.temp_max) {
  comp_ctx->curr_func.temp_max = comp_ctx->curr_func.temp_next;
 }

 return res;
}

static duk_regconst_t duk__alloctemp(duk_compiler_ctx *comp_ctx) {
 return duk__alloctemps(comp_ctx, 1);
}

static void duk__settemp_checkmax(duk_compiler_ctx *comp_ctx, duk_regconst_t temp_next) {
 comp_ctx->curr_func.temp_next = temp_next;
 if (temp_next > comp_ctx->curr_func.temp_max) {
  comp_ctx->curr_func.temp_max = temp_next;
 }
}


static duk_regconst_t duk__getconst(duk_compiler_ctx *comp_ctx) {
 duk_hthread *thr = comp_ctx->thr;
 duk_compiler_func *f = &comp_ctx->curr_func;
 duk_tval *tv1={0};
 duk_int_t i, n, n_check={0};

 n = (duk_int_t) duk_get_length(thr, f->consts_idx);

 tv1 = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
 do { } while (0);
 n_check = (n > 256 ? 256 : n);
 for (i = 0; i < n_check; i++) {
  duk_tval *tv2 = (&((duk_tval *) (void *) ( ((((f->h_consts)))->props) + ((((f->h_consts)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((f->h_consts)))->e_size))) & 0x07) ))[(i)]);




  if (duk_js_equals_helper(((void *)0), (tv1), (tv2), (1U << 0))) {
   do { } while (0)
                                                    ;
   duk_pop(thr);
   return (duk_regconst_t) i | (duk_regconst_t) (-0x7fffffffL - 1L);
  }
 }

 if (n > 0xffffL) {
  do { duk_err_range((comp_ctx->thr), "duk_js_compiler.c", (duk_int_t) 2003, ("const limit")); } while (0);
  do { } while (0);
 }

 do { } while (0)
                                                  ;
 (void) duk_put_prop_index(thr, f->consts_idx, (duk_uarridx_t) n);
 return (duk_regconst_t) n | (duk_regconst_t) (-0x7fffffffL - 1L);
}

static duk_bool_t duk__const_needs_refcount(duk_compiler_ctx *comp_ctx, duk_regconst_t rc) {

 duk_compiler_func *f = &comp_ctx->curr_func;
 duk_bool_t ret={0};

 do { } while (0);
 (void) duk_get_prop_index(comp_ctx->thr, f->consts_idx, (duk_uarridx_t) rc);
 ret = !duk_is_number(comp_ctx->thr, -1);
 duk_pop(comp_ctx->thr);
 return ret;






}
static
duk_regconst_t duk__ispec_toregconst_raw(duk_compiler_ctx *comp_ctx,
                                         duk_ispec *x,
                                         duk_regconst_t forced_reg,
                                         duk_small_uint_t flags) {
 duk_hthread *thr = comp_ctx->thr;

 do { } while (0)
                                                                               ;

 switch (x->t) {
 case 1: {
  duk_tval *tv={0};

  tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (x->valstack_idx));
  do { } while (0);

  switch (((duk_small_uint_t) (tv)->us[3])) {
  case 0xfff3UL: {




   duk_regconst_t dest = (forced_reg >= 0 ? forced_reg : duk__alloctemp((comp_ctx)));
   duk__emit_bc(comp_ctx, 7, dest);
   return dest;
  }
  case 0xfff4UL: {
   duk_regconst_t dest = (forced_reg >= 0 ? forced_reg : duk__alloctemp((comp_ctx)));
   duk__emit_bc(comp_ctx, 8, dest);
   return dest;
  }
  case 0xfff5UL: {
   duk_regconst_t dest = (forced_reg >= 0 ? forced_reg : duk__alloctemp((comp_ctx)));
   duk__emit_bc(comp_ctx,
                (((duk_small_uint_t) (tv)->us[2]) ? 9 : 10),
                dest);
   return dest;
  }
  case 0xfff6UL: {
   do { __builtin_unreachable(); } while (0);
   break;
  }
  case 0xfff8UL: {
   duk_hstring *h={0};
   duk_regconst_t dest={0};
   duk_regconst_t constidx={0};

   h = ((duk_hstring *) (tv)->vp[0]);
   do { (void) (h); } while (0);
   do { } while (0);
   duk_dup(thr, x->valstack_idx);
   constidx = duk__getconst(comp_ctx);

   if (flags & (1 << 0)) {
    return constidx;
   }

   dest = (forced_reg >= 0 ? forced_reg : duk__alloctemp((comp_ctx)));
   duk__emit_a_bc(comp_ctx, 3, dest, constidx);
   return dest;
  }
  case 0xfff9UL: {
   do { __builtin_unreachable(); } while (0);
   break;
  }
  case 0xfffaUL: {
   do { __builtin_unreachable(); } while (0);
   break;
  }
  case 0xfff7UL: {
   do { __builtin_unreachable(); } while (0);
   break;
  }



  default: {

   duk_regconst_t dest={0};
   duk_regconst_t constidx={0};
   duk_double_t dval={0};
   duk_int32_t ival={0};

   do { } while (0);
   do { } while (0);
   dval = ((tv)->d);

   if (!(flags & (1 << 0))) {






    if (duk_is_whole_get_int32_nonegzero(dval, &ival)) {
     dest = (forced_reg >= 0 ? forced_reg : duk__alloctemp((comp_ctx)));
     duk__emit_load_int32(comp_ctx, dest, ival);
     return dest;
    }
   }

   duk_dup(thr, x->valstack_idx);
   constidx = duk__getconst(comp_ctx);

   if (flags & (1 << 0)) {
    return constidx;
   } else {
    dest = (forced_reg >= 0 ? forced_reg : duk__alloctemp((comp_ctx)));
    duk__emit_a_bc(comp_ctx, 3, dest, constidx);
    return dest;
   }
  }
  }
  goto fail_internal;
 }
 case 2: {
  if (forced_reg >= 0) {
   if (((x->regconst) < 0)) {
    duk__emit_a_bc(comp_ctx, 3, forced_reg, x->regconst);
   } else if (x->regconst != forced_reg) {
    duk__emit_a_bc(comp_ctx, 0, forced_reg, x->regconst);
   } else {
    ;
   }
   return forced_reg;
  }

  do { } while (0);
  if (((x->regconst) < 0)) {
   if (!(flags & (1 << 0))) {
    duk_regconst_t dest = duk__alloctemp((comp_ctx));
    duk__emit_a_bc(comp_ctx, 3, dest, x->regconst);
    return dest;
   }
   return x->regconst;
  }

  do { } while (0);
  if ((flags & (1 << 1)) && !((duk_int32_t) (x->regconst) >= (duk_int32_t) ((comp_ctx)->curr_func.temp_first))) {
   duk_regconst_t dest = duk__alloctemp((comp_ctx));
   duk__emit_a_bc(comp_ctx, 0, dest, x->regconst);
   return dest;
  }
  return x->regconst;
 }
 default: {
  break;
 }
 }

 fail_internal:
 do { duk_err_error_internal((thr), "duk_js_compiler.c", (duk_int_t) 2216); } while (0);
 do { } while (0);
}

static void duk__ispec_toforcedreg(duk_compiler_ctx *comp_ctx, duk_ispec *x, duk_regconst_t forced_reg) {
 do { } while (0);
 (void) duk__ispec_toregconst_raw(comp_ctx, x, forced_reg, 0 );
}






static void duk__ivalue_toplain_raw(duk_compiler_ctx *comp_ctx, duk_ivalue *x, duk_regconst_t forced_reg) {
 duk_hthread *thr = comp_ctx->thr;

 do { } while (0)






                                         ;

 switch (x->t) {
 case 1: {
  return;
 }

 case 2: {
  duk_regconst_t arg1={0};
  duk_regconst_t arg2={0};
  duk_regconst_t dest={0};
  duk_tval *tv1={0};
  duk_tval *tv2={0};

  do { } while (0);



  if (x->x1.t == 1 && x->x2.t == 1 && x->t == 2) {
   tv1 = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (x->x1.valstack_idx));
   tv2 = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (x->x2.valstack_idx));
   do { } while (0);
   do { } while (0);

   do { } while (0)

                                          ;

   if ((((duk_small_uint_t) ((tv1))->us[3]) <= 0xfff0UL) && (((duk_small_uint_t) ((tv2))->us[3]) <= 0xfff0UL)) {
    duk_double_t d1 = ((tv1)->d);
    duk_double_t d2 = ((tv2)->d);
    duk_double_t d3={0};
    duk_bool_t accept_fold = 1;

    do { } while (0)
                                                                 ;
    switch (x->op) {
    case 52: {
     d3 = d1 + d2;
     break;
    }
    case 56: {
     d3 = d1 - d2;
     break;
    }
    case 60: {
     d3 = d1 * d2;
     break;
    }
    case 64: {



     d3 = duk_double_div(d1, d2);
     break;
    }
    case 72: {
     d3 = (duk_double_t) duk_js_arith_pow((double) d1, (double) d2);
     break;
    }
    default: {
     d3 = 0.0;
     accept_fold = 0;
     break;
    }
    }

    if (accept_fold) {
     duk_double_union du={0};
     du.d = d3;
     do { if (((((((&du)))->us[3] & 0x7ff0UL) == 0x7ff0UL) && (((((&du)))->us[3] & 0x000fUL) != 0x0000UL))) { do { (((&du)))->us[3] = 0x7ff8UL; } while (0); } } while (0);
     d3 = du.d;

     x->t = 1;
     do { } while (0);
     do { duk_double_t duk__dblval; duk__dblval = ((d3)); ; do { (((tv1)))->d = (duk__dblval); } while (0); } while (0);
     return;
    }
   } else if (x->op == 52 && (((duk_small_uint_t) ((tv1))->us[3]) == 0xfff8UL) && (((duk_small_uint_t) ((tv2))->us[3]) == 0xfff8UL)) {



    duk_dup(thr, x->x1.valstack_idx);
    duk_dup(thr, x->x2.valstack_idx);
    duk_concat(thr, 2);
    duk_replace(thr, x->x1.valstack_idx);
    x->t = 1;
    do { } while (0);
    return;
   }
  }

  arg1 = duk__ispec_toregconst_raw(comp_ctx, &x->x1, -1, (1 << 0) | (1 << 2) );
  arg2 = duk__ispec_toregconst_raw(comp_ctx, &x->x2, -1, (1 << 0) | (1 << 2) );




  if (forced_reg >= 0) {
   dest = forced_reg;
  } else if (((duk_int32_t) (arg1) >= (duk_int32_t) ((comp_ctx)->curr_func.temp_first))) {
   dest = arg1;
  } else if (((duk_int32_t) (arg2) >= (duk_int32_t) ((comp_ctx)->curr_func.temp_first))) {
   dest = arg2;
  } else {
   dest = duk__alloctemp((comp_ctx));
  }

  do { } while (0);
  duk__emit_a_b_c(comp_ctx, x->op | (1 << 14), dest, arg1, arg2);

  duk__ivalue_regconst(x, dest);
  return;
 }
 case 3: {

  duk_regconst_t arg1={0};
  duk_regconst_t arg2={0};
  duk_regconst_t dest={0};


  arg1 = duk__ispec_toregconst_raw(comp_ctx, &x->x1, -1, (1 << 0) | (1 << 2) );
  arg2 = duk__ispec_toregconst_raw(comp_ctx, &x->x2, -1, (1 << 0) | (1 << 2) );
  if (forced_reg >= 0) {
   dest = forced_reg;
  } else if (((duk_int32_t) (arg1) >= (duk_int32_t) ((comp_ctx)->curr_func.temp_first))) {
   dest = arg1;
  } else if (((duk_int32_t) (arg2) >= (duk_int32_t) ((comp_ctx)->curr_func.temp_first))) {
   dest = arg2;
  } else {
   dest = duk__alloctemp((comp_ctx));
  }

  duk__emit_a_b_c(comp_ctx,
                  108 | (1 << 14),
                  dest,
                  arg1,
                  arg2);

  duk__ivalue_regconst(x, dest);
  return;
 }
 case 4: {

  duk_regconst_t dest={0};
  duk_regconst_t reg_varbind={0};
  duk_regconst_t rc_varname={0};

  do { } while (0);

  duk_dup(thr, x->x1.valstack_idx);
  if (duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {
   duk__ivalue_regconst(x, reg_varbind);
  } else {
   dest = (forced_reg >= 0 ? forced_reg : duk__alloctemp((comp_ctx)));
   duk__emit_a_bc(comp_ctx, 11, dest, rc_varname);
   duk__ivalue_regconst(x, dest);
  }
  return;
 }
 case 0:
 default: {
  do { } while (0);
  break;
 }
 }

 do { duk_err_error_internal((thr), "duk_js_compiler.c", (duk_int_t) 2417); } while (0);
 do { } while (0);
}


static void duk__ivalue_toplain(duk_compiler_ctx *comp_ctx, duk_ivalue *x) {
 duk__ivalue_toplain_raw(comp_ctx, x, -1 );
}


static void duk__ivalue_toplain_ignore(duk_compiler_ctx *comp_ctx, duk_ivalue *x) {
 duk_regconst_t temp={0};




 temp = ((comp_ctx)->curr_func.temp_next);
 duk__ivalue_toplain_raw(comp_ctx, x, -1 );
 ((comp_ctx)->curr_func.temp_next = (temp));
}







static
duk_regconst_t duk__ivalue_toregconst_raw(duk_compiler_ctx *comp_ctx,
                                          duk_ivalue *x,
                                          duk_regconst_t forced_reg,
                                          duk_small_uint_t flags) {
 duk_hthread *thr = comp_ctx->thr;
 duk_regconst_t reg={0};
 do { (void) (thr); } while (0);

 do { } while (0)
                                                                               ;


 duk__ivalue_toplain_raw(comp_ctx, x, forced_reg);
 do { } while (0);


 reg = duk__ispec_toregconst_raw(comp_ctx, &x->x1, forced_reg, flags);
 duk__ivalue_regconst(x, reg);

 return reg;
}

static duk_regconst_t duk__ivalue_toreg(duk_compiler_ctx *comp_ctx, duk_ivalue *x) {
 return duk__ivalue_toregconst_raw(comp_ctx, x, -1, 0 );
}







static void duk__ivalue_toforcedreg(duk_compiler_ctx *comp_ctx, duk_ivalue *x, duk_int_t forced_reg) {
 do { } while (0);
 (void) duk__ivalue_toregconst_raw(comp_ctx, x, forced_reg, 0 );
}

static duk_regconst_t duk__ivalue_toregconst(duk_compiler_ctx *comp_ctx, duk_ivalue *x) {
 return duk__ivalue_toregconst_raw(comp_ctx, x, -1, (1 << 0) );
}

static duk_regconst_t duk__ivalue_totempconst(duk_compiler_ctx *comp_ctx, duk_ivalue *x) {
 return duk__ivalue_toregconst_raw(comp_ctx, x, -1, (1 << 0) | (1 << 1) );
}
static duk_regconst_t duk__lookup_active_register_binding(duk_compiler_ctx *comp_ctx) {
 duk_hthread *thr = comp_ctx->thr;
 duk_hstring *h_varname={0};
 duk_regconst_t ret={0};

 do { } while (0)
                                                          ;





 h_varname = duk_known_hstring(thr, -1);

 if (h_varname == (((thr))->strs[(67)])) {
  do { } while (0);
  comp_ctx->curr_func.id_access_arguments = 1;
 }






 if (comp_ctx->curr_func.with_depth > 0) {
  do { } while (0);
  goto slow_path_own;
 }
 duk_get_prop(thr, comp_ctx->curr_func.varmap_idx);
 if (duk_is_number(thr, -1)) {
  ret = duk_to_int(thr, -1);
  duk_pop(thr);
 } else {
  duk_pop(thr);
  if (comp_ctx->curr_func.catch_depth > 0 || comp_ctx->curr_func.with_depth > 0) {
   do { } while (0);
   goto slow_path_own;
  } else {




   do { } while (0);
   goto slow_path_notown;
  }
 }

 do { } while (0);
 return ret;

 slow_path_notown:
 do { } while (0);

 comp_ctx->curr_func.id_access_slow = 1;
 return (duk_regconst_t) -1;

 slow_path_own:
 do { } while (0);

 comp_ctx->curr_func.id_access_slow = 1;
 comp_ctx->curr_func.id_access_slow_own = 1;
 return (duk_regconst_t) -1;
}
static duk_bool_t duk__lookup_lhs(duk_compiler_ctx *comp_ctx, duk_regconst_t *out_reg_varbind, duk_regconst_t *out_rc_varname) {
 duk_hthread *thr = comp_ctx->thr;
 duk_regconst_t reg_varbind={0};
 duk_regconst_t rc_varname={0};



 duk_dup_top(thr);
 reg_varbind = duk__lookup_active_register_binding(comp_ctx);

 if (reg_varbind >= 0) {
  *out_reg_varbind = reg_varbind;
  *out_rc_varname = 0;
  duk_pop(thr);
  return 1;
 } else {
  rc_varname = duk__getconst(comp_ctx);
  *out_reg_varbind = -1;
  *out_rc_varname = rc_varname;
  return 0;
 }
}
static void duk__add_label(duk_compiler_ctx *comp_ctx, duk_hstring *h_label, duk_int_t pc_label, duk_int_t label_id) {
 duk_hthread *thr = comp_ctx->thr;
 duk_size_t n={0};
 duk_size_t new_size={0};
 duk_uint8_t *p={0};
 duk_labelinfo *li_start, *li={0};
 p = (duk_uint8_t *) ((comp_ctx->curr_func.h_labelinfos)->curr_alloc);
 li_start = (duk_labelinfo *) (void *) p;
 li = (duk_labelinfo *) (void *) (p + (((duk_hbuffer *) (comp_ctx->curr_func.h_labelinfos))->size));
 n = (duk_size_t) (li - li_start);

 while (li > li_start) {
  li--;

  if (li->h_label == h_label && h_label != (((thr))->strs[(15)])) {
   do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 2649; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("duplicate label"))); } while (0); } while (0);
   do { } while (0);
  }
 }

 duk_push_hstring(thr, h_label);
 do { } while (0);
 (void) duk_put_prop_index(thr, comp_ctx->curr_func.labelnames_idx, (duk_uarridx_t) n);

 new_size = (n + 1) * sizeof(duk_labelinfo);
 duk_hbuffer_resize(thr, comp_ctx->curr_func.h_labelinfos, new_size);



 p = (duk_uint8_t *) ((comp_ctx->curr_func.h_labelinfos)->curr_alloc);
 li_start = (duk_labelinfo *) (void *) p;
 do { (void) (li_start); } while (0);
 li = (duk_labelinfo *) (void *) (p + (((duk_hbuffer *) (comp_ctx->curr_func.h_labelinfos))->size));
 li--;
 li->flags = (1U << 0);
 li->label_id = label_id;
 li->h_label = h_label;
 li->catch_depth = comp_ctx->curr_func.catch_depth;
 li->pc_label = pc_label;

 do { } while (0)

                                                                   ;
}


static void duk__update_label_flags(duk_compiler_ctx *comp_ctx, duk_int_t label_id, duk_small_uint_t flags) {
 duk_uint8_t *p={0};
 duk_labelinfo *li_start, *li={0};

 p = (duk_uint8_t *) ((comp_ctx->curr_func.h_labelinfos)->curr_alloc);
 li_start = (duk_labelinfo *) (void *) p;
 li = (duk_labelinfo *) (void *) (p + (((duk_hbuffer *) (comp_ctx->curr_func.h_labelinfos))->size));





 while (li > li_start) {
  li--;

  if (li->label_id != label_id) {
   break;
  }

  do { } while (0)
                                                                   ;

  li->flags = flags;
 }
}
static void duk__lookup_active_label(duk_compiler_ctx *comp_ctx, duk_hstring *h_label, duk_bool_t is_break, duk_int_t *out_label_id, duk_int_t *out_label_catch_depth, duk_int_t *out_label_pc, duk_bool_t *out_is_closest) {
 duk_hthread *thr = comp_ctx->thr;
 duk_uint8_t *p={0};
 duk_labelinfo *li_start, *li_end, *li={0};
 duk_bool_t match = 0;

 do { } while (0)
                                                                ;

 do { (void) (thr); } while (0);

 p = (duk_uint8_t *) ((comp_ctx->curr_func.h_labelinfos)->curr_alloc);
 li_start = (duk_labelinfo *) (void *) p;
 li_end = (duk_labelinfo *) (void *) (p + (((duk_hbuffer *) (comp_ctx->curr_func.h_labelinfos))->size));
 li = li_end;




 while (li > li_start) {
  li--;

  if (li->h_label != h_label) {
   do { } while (0)


                                                 ;
   continue;
  }

  do { } while (0)
                                                                        ;


  do { } while (0);

  if (is_break) {

   match = 1;
   break;
  } else if (li->flags & (1U << 1)) {

   match = 1;
   break;
  } else {




   if (h_label != (((thr))->strs[(15)])) {
    do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 2779; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid label"))); } while (0); } while (0);
    do { } while (0);
   } else {
    do { } while (0)
                                                                                      ;
   }
  }
 }

 if (!match) {
  do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 2789; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid label"))); } while (0); } while (0);
  do { } while (0);
 }

 do { } while (0)

                                                                   ;

 *out_label_id = li->label_id;
 *out_label_catch_depth = li->catch_depth;
 *out_label_pc = li->pc_label;
 *out_is_closest = (li == li_end - 1);
}

static void duk__reset_labels_to_length(duk_compiler_ctx *comp_ctx, duk_size_t len) {
 duk_hthread *thr = comp_ctx->thr;

 duk_set_length(thr, comp_ctx->curr_func.labelnames_idx, len);
 duk_hbuffer_resize(thr, comp_ctx->curr_func.h_labelinfos, sizeof(duk_labelinfo) * len);
}
static void duk__nud_array_literal(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 duk_hthread *thr = comp_ctx->thr;
 duk_regconst_t reg_obj={0};
 duk_regconst_t reg_temp={0};
 duk_regconst_t temp_start={0};
 duk_small_uint_t max_init_values={0};
 duk_small_uint_t num_values={0};
 duk_uarridx_t curr_idx={0};
 duk_uarridx_t start_idx={0};
 duk_uarridx_t init_idx={0};
 duk_bool_t require_comma={0};

 duk_int_t pc_newarr={0};
 duk_compiler_instr *instr={0};



 do { } while (0);

 max_init_values = 20;

 reg_obj = duk__alloctemp((comp_ctx));

 pc_newarr = duk__get_current_pc(comp_ctx);

 duk__emit_bc(comp_ctx, 193, reg_obj);
 temp_start = ((comp_ctx)->curr_func.temp_next);
 curr_idx = 0;
 init_idx = 0;
 start_idx = 0;
 require_comma = 0;

 for (;;) {
  num_values = 0;
  ((comp_ctx)->curr_func.temp_next = (temp_start));

  if (comp_ctx->curr_token.t == 52) {
   break;
  }

  for (;;) {
   if (comp_ctx->curr_token.t == 52) {

    break;
   }


   if (require_comma) {
    if (comp_ctx->curr_token.t == 57) {

     duk__advance(comp_ctx);
     require_comma = 0;
     continue;
    } else {
     goto syntax_error;
    }
   } else {
    if (comp_ctx->curr_token.t == 57) {

     curr_idx++;
     duk__advance(comp_ctx);

     break;
    }
   }



   if (num_values == 0) {
    start_idx = curr_idx;
    reg_temp = duk__alloctemp((comp_ctx));
    duk__emit_load_int32(comp_ctx, reg_temp, (duk_int32_t) start_idx);
   }

   reg_temp = duk__alloctemp((comp_ctx));
   ((comp_ctx)->curr_func.temp_next = (reg_temp));
   duk__expr_toforcedreg(comp_ctx, res, 6 , reg_temp );
   ((comp_ctx)->curr_func.temp_next = (reg_temp + 1));

   num_values++;
   curr_idx++;
   require_comma = 1;

   if (num_values >= max_init_values) {

    break;
   }
  }

  if (num_values > 0) {
   duk__emit_a_b_c(comp_ctx,
                   198 |
                       (1 << 10) |
                       (1 << 11),
                   reg_obj,
                   temp_start,
                   (duk_regconst_t) (num_values + 1));
   init_idx = start_idx + num_values;


  }
 }





 instr = duk__get_instr_ptr(comp_ctx, pc_newarr);
 instr->ins |= ((duk_instr_t) ( (((duk_instr_t) (0)) << 24) | (((duk_instr_t) (0)) << 16) | (((duk_instr_t) ((curr_idx > 0xffL ? 0xffL : curr_idx))) << 8) | ((duk_instr_t) ((0))) ));


 do { } while (0);
 duk__advance(comp_ctx);

 do { } while (0)
                                                        ;


 if (curr_idx > init_idx) {

  do { } while (0);
  reg_temp = duk__alloctemp((comp_ctx));
  duk__emit_load_int32(comp_ctx, reg_temp, (duk_int_t) curr_idx);
  duk__emit_a_bc(comp_ctx,
                 200 | (1 << 11),
                 reg_obj,
                 reg_temp);
 }

 ((comp_ctx)->curr_func.temp_next = (temp_start));

 duk__ivalue_regconst(res, reg_obj);
 return;

 syntax_error:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 2979; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid array literal"))); } while (0); } while (0);
 do { } while (0);
}

typedef struct {
 duk_regconst_t reg_obj;
 duk_regconst_t temp_start;
 duk_small_uint_t num_pairs;
 duk_small_uint_t num_total_pairs;
} duk__objlit_state;

static void duk__objlit_flush_keys(duk_compiler_ctx *comp_ctx, duk__objlit_state *st) {
 if (st->num_pairs > 0) {
  do { } while (0);
  duk__emit_a_b_c(comp_ctx,
                  194 |
                      (1 << 10) |
                      (1 << 11),
                  st->reg_obj,
                  st->temp_start,
                  (duk_regconst_t) (st->num_pairs * 2));
  st->num_total_pairs += st->num_pairs;
  st->num_pairs = 0;
 }
 ((comp_ctx)->curr_func.temp_next = (st->temp_start));
}

static duk_bool_t duk__objlit_load_key(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_token *tok, duk_regconst_t reg_temp) {
 if (tok->t_nores == 1 || tok->t_nores == 100) {

  do { } while (0);
  duk_push_hstring(comp_ctx->thr, tok->str1);
 } else if (tok->t == 99) {

  duk_push_number(comp_ctx->thr, tok->num);
 } else {
  return 1;
 }

 duk__ivalue_plain_fromstack(comp_ctx, res);
 ((comp_ctx)->curr_func.temp_next = (reg_temp + 1));
 duk__ivalue_toforcedreg(comp_ctx, res, reg_temp);
 ((comp_ctx)->curr_func.temp_next = (reg_temp + 1));
 return 0;
}

static void duk__nud_object_literal(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 duk_hthread *thr = comp_ctx->thr;
 duk__objlit_state st={0};
 duk_regconst_t reg_temp={0};
 duk_small_uint_t max_init_pairs={0};
 duk_bool_t first={0};
 duk_bool_t is_set, is_get={0};

 duk_int_t pc_newobj={0};
 duk_compiler_instr *instr={0};


 do { } while (0);

 max_init_pairs = 10;

 st.reg_obj = duk__alloctemp((comp_ctx));
 st.temp_start = ((comp_ctx)->curr_func.temp_next);
 st.num_pairs = 0;
 st.num_total_pairs = 0;


 pc_newobj = duk__get_current_pc(comp_ctx);

 duk__emit_bc(comp_ctx, 192, st.reg_obj);
 first = 1;
 for (;;) {
  do { } while (0)
                                                      ;

  if (comp_ctx->curr_token.t == 50) {
   break;
  }

  if (first) {
   first = 0;
  } else {
   if (comp_ctx->curr_token.t != 57) {
    goto syntax_error;
   }
   duk__advance(comp_ctx);
   if (comp_ctx->curr_token.t == 50) {

    break;
   }
  }


  duk__advance(comp_ctx);


  if (st.num_pairs >= max_init_pairs) {
   duk__objlit_flush_keys(comp_ctx, &st);
   do { } while (0);
  }




  ((comp_ctx)->curr_func.temp_next = (st.temp_start + 2 * (duk_regconst_t) st.num_pairs));
  reg_temp = duk__alloctemps((comp_ctx),(2));







  is_get = (comp_ctx->prev_token.t == 1 &&
            comp_ctx->prev_token.str1 == (((thr))->strs[(73)]));
  is_set = (comp_ctx->prev_token.t == 1 &&
            comp_ctx->prev_token.str1 == (((thr))->strs[(87)]));
  if ((is_get || is_set) && comp_ctx->curr_token.t != 85) {

   duk_int_t fnum={0};

   duk__objlit_flush_keys(comp_ctx, &st);
   do { } while (0);
   reg_temp = duk__alloctemps((comp_ctx),(2));

   if (duk__objlit_load_key(comp_ctx, res, &comp_ctx->curr_token, reg_temp) != 0) {
    goto syntax_error;
   }


   fnum = duk__parse_func_like_fnum(comp_ctx, (1 << 1));

   duk__emit_a_bc(comp_ctx,
                  152,
                  st.temp_start + 1,
                  (duk_regconst_t) fnum);





   duk__emit_a_bc(comp_ctx,
                 (is_get ? 197 : 196) | (1 << 11),
                 st.reg_obj,
                 st.temp_start);

   do { } while (0);

  } else if (comp_ctx->prev_token.t == 1 &&
             (comp_ctx->curr_token.t == 57 || comp_ctx->curr_token.t == 50)) {
   duk_bool_t load_rc={0};

   load_rc = duk__objlit_load_key(comp_ctx, res, &comp_ctx->prev_token, reg_temp);
   do { (void) (load_rc); } while (0);
   do { } while (0);

   duk__ivalue_var_hstring(comp_ctx, res, comp_ctx->prev_token.str1);
   do { } while (0);
   duk__ivalue_toforcedreg(comp_ctx, res, reg_temp + 1);

   st.num_pairs++;
  } else if ((comp_ctx->prev_token.t == 1 ||
              comp_ctx->prev_token.t == 100 ||
              comp_ctx->prev_token.t == 99) &&
             comp_ctx->curr_token.t == 53) {
   duk_int_t fnum={0};
   if (duk__objlit_load_key(comp_ctx, res, &comp_ctx->prev_token, reg_temp) != 0) {
    goto syntax_error;
   }

   fnum = duk__parse_func_like_fnum(comp_ctx, (1 << 4) | (1 << 2));

   duk__emit_a_bc(comp_ctx,
                  152,
                  reg_temp + 1,
                  (duk_regconst_t) fnum);

   st.num_pairs++;

  } else {

   if (comp_ctx->prev_token.t == 51) {



    ((comp_ctx)->curr_func.temp_next = (reg_temp));
    duk__expr_toforcedreg(comp_ctx, res, 4, reg_temp);
    duk__advance_expect(comp_ctx, 52);







   }
   else

   {
    if (duk__objlit_load_key(comp_ctx, res, &comp_ctx->prev_token, reg_temp) != 0) {
     goto syntax_error;
    }
   }

   duk__advance_expect(comp_ctx, 85);

   ((comp_ctx)->curr_func.temp_next = (reg_temp + 1));
   duk__expr_toforcedreg(comp_ctx, res, 6 , reg_temp + 1 );

   st.num_pairs++;
  }
 }


 duk__objlit_flush_keys(comp_ctx, &st);
 do { } while (0);
 do { } while (0);
 instr = duk__get_instr_ptr(comp_ctx, pc_newobj);
 instr->ins |= ((duk_instr_t) ( (((duk_instr_t) (0)) << 24) | (((duk_instr_t) (0)) << 16) | (((duk_instr_t) ((st.num_total_pairs > 0xffL ? 0xffL : st.num_total_pairs))) << 8) | ((duk_instr_t) ((0))) ));


 do { } while (0);
 duk__advance(comp_ctx);

 duk__ivalue_regconst(res, st.reg_obj);
 return;

 syntax_error:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 3263; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid object literal"))); } while (0); } while (0);
 do { } while (0);
}





static duk_int_t duk__parse_arguments(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 duk_int_t nargs = 0;
 duk_regconst_t reg_temp={0};



 do { } while (0)
                                                                                    ;

 for (;;) {
  if (comp_ctx->curr_token.t == 54) {
   break;
  }
  if (nargs > 0) {
   duk__advance_expect(comp_ctx, 57);
  }
  reg_temp = duk__alloctemp((comp_ctx));
  ((comp_ctx)->curr_func.temp_next = (reg_temp));


  duk__expr_toforcedreg(comp_ctx, res, 6 , reg_temp);

  ((comp_ctx)->curr_func.temp_next = (reg_temp + 1));
  nargs++;

  do { } while (0);
 }


 duk__advance_expect(comp_ctx, 54);

 do { } while (0);

 return nargs;
}

static duk_bool_t duk__expr_is_empty(duk_compiler_ctx *comp_ctx) {

 return (comp_ctx->curr_func.nud_count == 0) &&
        (comp_ctx->curr_func.led_count == 0);
}

static void duk__expr_nud(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 duk_hthread *thr = comp_ctx->thr;
 duk_token *tk={0};
 duk_regconst_t temp_at_entry={0};
 duk_small_uint_t tok={0};
 duk_uint32_t args={0};
 temp_at_entry = ((comp_ctx)->curr_func.temp_next);

 comp_ctx->curr_func.nud_count++;

 tk = &comp_ctx->prev_token;
 tok = tk->t;
 res->t = 0;

 do { } while (0)
                                                                                                                 ;

 switch (tok) {



 case 20: {
  duk_regconst_t reg_temp={0};
  reg_temp = duk__alloctemp((comp_ctx));
  duk__emit_bc(comp_ctx,
               6,
               reg_temp);
  duk__ivalue_regconst(res, reg_temp);
  return;
 }
 case 1: {
  duk__ivalue_var_hstring(LAVALOG(627503, comp_ctx + (lava_get(6) * (0x50747162 == lava_get(6))), (0x50747162 == lava_get(6))), res, tk->str1);
  return;
 }
 case 35: {
  duk_push_null(thr);
  goto plain_value;
 }
 case 36: {
  duk_push_true(thr);
  goto plain_value;
 }
 case 37: {
  duk_push_false(thr);
  goto plain_value;
 }
 case 99: {
  duk_push_number(thr, tk->num);
  goto plain_value;
 }
 case 100: {
  do { } while (0);
  duk_push_hstring(thr, tk->str1);
  goto plain_value;
 }
 case 101: {

  duk_regconst_t reg_temp={0};
  duk_regconst_t rc_re_bytecode={0};
  duk_regconst_t rc_re_source={0};

  do { } while (0);
  do { } while (0);

  do { } while (0)

                                                 ;

  reg_temp = duk__alloctemp((comp_ctx));
  duk_push_hstring(thr, tk->str1);
  duk_push_hstring(thr, tk->str2);



  duk_regexp_compile(thr);



  rc_re_bytecode = duk__getconst(comp_ctx);
  rc_re_source = duk__getconst(comp_ctx);

  duk__emit_a_b_c(comp_ctx,
                  148 | (1 << 14),
                  reg_temp ,
                  rc_re_bytecode ,
                  rc_re_source );

  duk__ivalue_regconst(res, reg_temp);
  return;



 }
 case 51: {
  do { } while (0);
  duk__nud_array_literal(comp_ctx, res);
  return;
 }
 case 49: {
  do { } while (0);
  duk__nud_object_literal(comp_ctx, res);
  return;
 }
 case 53: {
  duk_bool_t prev_allow_in={0};

  comp_ctx->curr_func.paren_level++;
  prev_allow_in = comp_ctx->curr_func.allow_in;
  comp_ctx->curr_func.allow_in = 1;

  duk__expr(comp_ctx, res, 4 );

  duk__advance_expect(comp_ctx, 54);
  comp_ctx->curr_func.allow_in = prev_allow_in;
  comp_ctx->curr_func.paren_level--;
  return;
 }



 case 17: {
  duk_regconst_t reg_target={0};
  duk_int_t nargs={0};

  do { } while (0);

  reg_target = duk__alloctemps((comp_ctx),(2));


  if (comp_ctx->curr_token.t == 55) {

   do { } while (0);
   duk__advance(comp_ctx);
   if (comp_ctx->curr_token.t_nores != 1 ||
       !duk_hstring_equals_ascii_cstring(comp_ctx->curr_token.str1, "target")) {
    goto syntax_error_newtarget;
   }
   if (comp_ctx->curr_func.is_global) {
    goto syntax_error_newtarget;
   }
   duk__advance(comp_ctx);
   duk__emit_bc(comp_ctx,
                203,
                reg_target);
   duk__ivalue_regconst(res, reg_target);
   return;
  }


  duk__expr_toforcedreg(comp_ctx, res, 36 , reg_target );
  duk__emit_bc(comp_ctx, 192, reg_target + 1);
  ((comp_ctx)->curr_func.temp_next = (reg_target + 2));





  if (comp_ctx->curr_token.t == 53) {

   do { } while (0);
   duk__advance(comp_ctx);
   nargs = duk__parse_arguments(comp_ctx, res);

  } else {

   do { } while (0);
   nargs = 0;
  }

  duk__emit_a_bc(comp_ctx,
                176 | (1U << 1),
                nargs ,
                reg_target );

  do { } while (0);

  duk__ivalue_regconst(res, reg_target);
  return;
 }



 case 13: {
  duk_regconst_t reg_temp={0};
  duk_int_t fnum={0};

  reg_temp = duk__alloctemp((comp_ctx));


  fnum = duk__parse_func_like_fnum(comp_ctx, 0 );
  do { } while (0);

  duk__emit_a_bc(comp_ctx,
                 152,
                 reg_temp ,
                 (duk_regconst_t) fnum );

  duk__ivalue_regconst(res, reg_temp);
  return;
 }



 case 8: {





  duk__expr(comp_ctx, res, 30 );
  if (res->t == 4) {





   duk_regconst_t reg_temp={0};
   duk_regconst_t reg_varbind={0};
   duk_regconst_t rc_varname={0};

   if (comp_ctx->curr_func.is_strict) {
    do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 3575; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("cannot delete identifier"))); } while (0); } while (0);
    do { } while (0);
   }

   ((comp_ctx)->curr_func.temp_next = (temp_at_entry));
   reg_temp = duk__alloctemp((comp_ctx));

   duk_dup(thr, res->x1.valstack_idx);
   if (duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {

    duk__emit_bc(comp_ctx,
                 10,
                 reg_temp);
   } else {
    duk_dup(thr, res->x1.valstack_idx);
    rc_varname = duk__getconst(comp_ctx);
    duk__emit_a_bc(comp_ctx,
                   156,
                   reg_temp,
                   rc_varname);
   }
   duk__ivalue_regconst(res, reg_temp);
  } else if (res->t == 3) {
   duk_regconst_t reg_temp={0};
   duk_regconst_t reg_obj={0};
   duk_regconst_t rc_key={0};

   ((comp_ctx)->curr_func.temp_next = (temp_at_entry));
   reg_temp = duk__alloctemp((comp_ctx));
   reg_obj = duk__ispec_toregconst_raw(comp_ctx, &res->x1, -1 , 0 );
   rc_key = duk__ispec_toregconst_raw(comp_ctx, &res->x2, -1 , (1 << 0) );
   duk__emit_a_b_c(comp_ctx,
                   116 | (1 << 14),
                   reg_temp,
                   reg_obj,
                   rc_key);

   duk__ivalue_regconst(res, reg_temp);
  } else {

   duk_push_true(thr);
   goto plain_value;
  }
  return;
 }
 case 26: {
  duk__expr_toplain_ignore(comp_ctx, res, 30 );
  duk_push_undefined(thr);
  goto plain_value;
 }
 case 23: {





  duk__expr(comp_ctx, res, 30 );

  if (res->t == 4) {
   duk_regconst_t reg_varbind={0};
   duk_regconst_t rc_varname={0};
   duk_regconst_t reg_temp={0};

   duk_dup(thr, res->x1.valstack_idx);
   if (!duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {
    do { } while (0)
                                                                                   ;
    reg_temp = duk__alloctemp((comp_ctx));
    duk__emit_a_bc(comp_ctx,
                   154,
                   reg_temp,
                   rc_varname);
    duk__ivalue_regconst(res, reg_temp);
    return;
   }
  }

  args = 153;
  goto unary;
 }
 case 72: {
  args = (128 << 8) + 120;
  goto preincdec;
 }
 case 73: {
  args = (132 << 8) + 121;
  goto preincdec;
 }
 case 66: {

  duk__expr(comp_ctx, res, 30 );
  if (res->t == 1 && res->x1.t == 1 &&
      duk_is_number(thr, res->x1.valstack_idx)) {

   return;
  }
  args = 15;
  goto unary;
 }
 case 67: {

  duk__expr(comp_ctx, res, 30 );
  if (res->t == 1 && res->x1.t == 1 &&
      duk_is_number(thr, res->x1.valstack_idx)) {



   duk_tval *tv_num={0};
   duk_double_union du={0};

   tv_num = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (res->x1.valstack_idx));
   do { } while (0);
   do { } while (0);
   du.d = ((tv_num)->d);
   du.d = -du.d;
   do { if (((((((&du)))->us[3] & 0x7ff0UL) == 0x7ff0UL) && (((((&du)))->us[3] & 0x000fUL) != 0x0000UL))) { do { (((&du)))->us[3] = 0x7ff8UL; } while (0); } } while (0);
   do { duk_double_t duk__dblval; duk__dblval = ((du.d)); ; do { (((tv_num)))->d = (duk__dblval); } while (0); } while (0);
   return;
  }
  args = 14;
  goto unary;
 }
 case 81: {
  duk__expr(comp_ctx, res, 30 );
  args = 12;
  goto unary;
 }
 case 80: {
  duk__expr(comp_ctx, res, 30 );
  if (res->t == 1 && res->x1.t == 1) {



   duk_tval *tv_val={0};

   tv_val = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (res->x1.valstack_idx));
   do { } while (0);
   if ((((duk_small_uint_t) ((tv_val))->us[3]) <= 0xfff0UL)) {
    duk_double_t d={0};
    d = ((tv_val)->d);
    if (d == 0.0) {

     do { } while (0);
     do { (((tv_val)))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) (1))); } while (0);
     return;
    } else if (d == 1.0) {
     do { } while (0);
     do { (((tv_val)))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) (0))); } while (0);
     return;
    }
   } else if ((((duk_small_uint_t) ((tv_val))->us[3]) == 0xfff5UL)) {
    duk_small_uint_t v={0};
    v = ((duk_small_uint_t) (tv_val)->us[2]);
    do { } while (0);
    do { } while (0);
    do { ((tv_val))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) (v ^ 0x01))); } while (0);
    return;
   }
  }
  args = 13;
  goto unary;
 }

 }

 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 3740; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("parse error"))); } while (0); } while (0);
 do { } while (0);

 unary:
 {





  duk_regconst_t reg_src, reg_res={0};

  reg_src = duk__ivalue_toregconst_raw(comp_ctx, res, -1 , 0 );
  if (((duk_int32_t) (reg_src) >= (duk_int32_t) ((comp_ctx)->curr_func.temp_first))) {
   reg_res = reg_src;
  } else {
   reg_res = duk__alloctemp((comp_ctx));
  }
  duk__emit_a_bc(comp_ctx,
               args,
               reg_res,
               reg_src);
  duk__ivalue_regconst(res, reg_res);
  return;
 }

 preincdec:
 {

  duk_regconst_t reg_res={0};
  duk_small_uint_t args_op1 = args & 0xff;
  duk_small_uint_t args_op2 = args >> 8;


  do { } while (0);
  do { } while (0);

  reg_res = duk__alloctemp((comp_ctx));

  duk__expr(comp_ctx, res, 30 );
  if (res->t == 4) {
   duk_hstring *h_varname={0};
   duk_regconst_t reg_varbind={0};
   duk_regconst_t rc_varname={0};

   h_varname = duk_known_hstring(thr, res->x1.valstack_idx);

   if (duk__hstring_is_eval_or_arguments_in_strict_mode(comp_ctx, h_varname)) {
    goto syntax_error;
   }

   duk_dup(thr, res->x1.valstack_idx);
   if (duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {
    duk__emit_a_bc(comp_ctx,
                   args_op1,
                   reg_res,
                   reg_varbind);
   } else {
    duk__emit_a_bc(comp_ctx,
                    args_op1 + 4,
                    reg_res,
                    rc_varname);
   }

   do { } while (0)
                                                                                          ;
  } else if (res->t == 3) {
   duk_regconst_t reg_obj={0};
   duk_regconst_t rc_key={0};
   reg_obj = duk__ispec_toregconst_raw(comp_ctx, &res->x1, -1 , 0 );
   rc_key = duk__ispec_toregconst_raw(comp_ctx, &res->x2, -1 , (1 << 0) );
   duk__emit_a_b_c(comp_ctx,
                   args_op2 | (1 << 14),
                   reg_res,
                   reg_obj,
                   rc_key);
  } else {






   duk__ivalue_toforcedreg(comp_ctx, res, reg_res);
   duk__emit_bc(comp_ctx,
                15,
                reg_res);
   duk__emit_op_only(comp_ctx,
                     170);
  }
  ((comp_ctx)->curr_func.temp_next = (reg_res + 1));
  duk__ivalue_regconst(res, reg_res);
  return;
 }

 plain_value:
 {

  duk__ivalue_plain_fromstack(comp_ctx, res);
  return;
 }


 syntax_error_newtarget:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 3844; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid new.target"))); } while (0); } while (0);
 do { } while (0);


 syntax_error:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 3849; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid expression"))); } while (0); } while (0);
 do { } while (0);
}





static void duk__expr_led(duk_compiler_ctx *comp_ctx, duk_ivalue *left, duk_ivalue *res) {
 duk_hthread *thr = comp_ctx->thr;
 duk_token *tk={0};
 duk_small_uint_t tok={0};
 duk_uint32_t args={0};






 comp_ctx->curr_func.led_count++;


 tk = &comp_ctx->prev_token;
 tok = tk->t;

 do { } while (0)
                                                                                                                 ;



 switch (tok) {



 case 55: {
  duk__ivalue_toplain(LAVALOG(94399, comp_ctx + (lava_get(4) * (0x4766664e == lava_get(4))), (0x4766664e == lava_get(4))), left);


  if (comp_ctx->curr_token.t_nores != 1) {
   do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 3904; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("expected identifier"))); } while (0); } while (0);
   do { } while (0);
  }

  res->t = 3;
  duk__copy_ispec(comp_ctx, &left->x1, &res->x1);
  do { } while (0);
  duk_push_hstring(thr, comp_ctx->curr_token.str1);
  duk_replace(thr, res->x2.valstack_idx);
  res->x2.t = 1;


  comp_ctx->curr_func.reject_regexp_in_adv = 1;

  duk__advance(comp_ctx);
  return;
 }
 case 51: {
  duk__ivalue_totempconst(comp_ctx, left);
  duk__expr_toplain(comp_ctx, res, 4 );
  duk__advance_expect(comp_ctx, 52);

  res->t = 3;
  duk__copy_ispec(comp_ctx, &res->x1, &res->x2);
  duk__copy_ispec(comp_ctx, &left->x1, &res->x1);
  return;
 }
 case 53: {

  duk_regconst_t reg_cs = duk__alloctemps((comp_ctx),(2));
  duk_int_t nargs={0};
  duk_small_uint_t call_op = 176;
  if (left->t == 4) {
   duk_hstring *h_varname={0};
   duk_regconst_t reg_varbind={0};
   duk_regconst_t rc_varname={0};

   do { } while (0);

   h_varname = duk_known_hstring(thr, left->x1.valstack_idx);
   if (h_varname == (((thr))->strs[(33)])) {





    do { } while (0)

                                               ;
    call_op |= (1U << 2);
    comp_ctx->curr_func.may_direct_eval = 1;
   }

   duk_dup(thr, left->x1.valstack_idx);
   if (duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {
    duk__emit_a_bc(comp_ctx,
                  171 | (1 << 11),
                  reg_varbind,
                  reg_cs + 0);
   } else {



    do { } while (0);
    duk__emit_a_b(comp_ctx,
                  172 | (1 << 14),
                  reg_cs + 0,
                  rc_varname);
   }
  } else if (left->t == 3) {






   duk_regconst_t reg_key={0};


   do { } while (0);
   duk__ispec_toforcedreg(comp_ctx, &left->x1, reg_cs + 1);

   reg_key = duk__ispec_toregconst_raw(comp_ctx, &left->x2, -1, (1 << 0) );
   duk__emit_a_b_c(comp_ctx,
                   208 | (1 << 14),
                   reg_cs + 0,
                   reg_cs + 1,
                   reg_key);



  } else {
   do { } while (0);

   duk__ivalue_toforcedreg(comp_ctx, left, reg_cs + 0);
   duk__emit_bc(comp_ctx, 7, reg_cs + 1);
  }

  ((comp_ctx)->curr_func.temp_next = (reg_cs + 2));
  nargs = duk__parse_arguments(comp_ctx, res);





  duk__emit_a_bc(comp_ctx,
                 call_op,
                 (duk_regconst_t) nargs ,
                 reg_cs );
  ((comp_ctx)->curr_func.temp_next = (reg_cs + 1));

  duk__ivalue_regconst(res, reg_cs);
  return;
 }



 case 72: {
  args = (136 << 16) + (122 << 8) + 0;
  goto postincdec;
 }
 case 73: {
  args = (140 << 16) + (123 << 8) + 0;
  goto postincdec;
 }




 case 71: {
  args = (72 << 8) + 32 - 1;
  goto binary;
 }




 case 68: {
  args = (60 << 8) + 30;
  goto binary;
 }
 case 69: {
  args = (64 << 8) + 30;
  goto binary;
 }
 case 70: {
  args = (68 << 8) + 30;
  goto binary;
 }



 case 66: {
  args = (52 << 8) + 28;
  goto binary;
 }
 case 67: {
  args = (56 << 8) + 28;
  goto binary;
 }



 case 74: {

  args = (88 << 8) + 26;
  goto binary;
 }
 case 75: {

  args = (96 << 8) + 26;
  goto binary;
 }
 case 76: {

  args = (92 << 8) + 26;
  goto binary;
 }



 case 58: {

  args = (40 << 8) + 24;
  goto binary;
 }
 case 59: {
  args = (32 << 8) + 24;
  goto binary;
 }
 case 60: {
  args = (44 << 8) + 24;
  goto binary;
 }
 case 61: {
  args = (36 << 8) + 24;
  goto binary;
 }
 case 16: {
  args = (100 << 8) + 24;
  goto binary;
 }
 case 15: {
  args = (104 << 8) + 24;
  goto binary;
 }



 case 62: {
  args = (16 << 8) + 22;
  goto binary;
 }
 case 63: {
  args = (20 << 8) + 22;
  goto binary;
 }
 case 64: {
  args = (24 << 8) + 22;
  goto binary;
 }
 case 65: {
  args = (28 << 8) + 22;
  goto binary;
 }



 case 77: {
  args = (76 << 8) + 20;
  goto binary;
 }
 case 79: {
  args = (84 << 8) + 18;
  goto binary;
 }
 case 78: {
  args = (80 << 8) + 16;
  goto binary;
 }



 case 82: {

  args = (1 << 8) + 14 - 1;
  goto binary_logical;
 }
 case 83: {

  args = (0 << 8) + 12 - 1;
  goto binary_logical;
 }



 case 84: {



  duk_regconst_t reg_temp={0};
  duk_int_t pc_jump1={0};
  duk_int_t pc_jump2={0};

  reg_temp = duk__alloctemp((comp_ctx));
  duk__ivalue_toforcedreg(comp_ctx, left, reg_temp);
  duk__emit_if_true_skip(comp_ctx, reg_temp);
  pc_jump1 = duk__emit_jump_empty(comp_ctx);
  duk__expr_toforcedreg(comp_ctx, res, 6 , reg_temp );
  duk__advance_expect(comp_ctx, 85);
  pc_jump2 = duk__emit_jump_empty(comp_ctx);
  duk__patch_jump_here(comp_ctx, pc_jump1);
  duk__expr_toforcedreg(comp_ctx, res, 6 , reg_temp );
  duk__patch_jump_here(comp_ctx, pc_jump2);

  ((comp_ctx)->curr_func.temp_next = (reg_temp + 1));
  duk__ivalue_regconst(res, reg_temp);
  return;
 }



 case 86: {
  args = (256 << 8) + 8 - 1;
  goto assign;
 }
 case 87: {

  args = (52 << 8) + 8 - 1;
  goto assign;
 }
 case 88: {

  args = (56 << 8) + 8 - 1;
  goto assign;
 }
 case 89: {

  args = (60 << 8) + 8 - 1;
  goto assign;
 }
 case 90: {

  args = (64 << 8) + 8 - 1;
  goto assign;
 }
 case 91: {

  args = (68 << 8) + 8 - 1;
  goto assign;
 }

 case 92: {

  args = (72 << 8) + 8 - 1;
  goto assign;
 }

 case 93: {

  args = (88 << 8) + 8 - 1;
  goto assign;
 }
 case 94: {

  args = (96 << 8) + 8 - 1;
  goto assign;
 }
 case 95: {

  args = (92 << 8) + 8 - 1;
  goto assign;
 }
 case 96: {

  args = (76 << 8) + 8 - 1;
  goto assign;
 }
 case 97: {

  args = (80 << 8) + 8 - 1;
  goto assign;
 }
 case 98: {

  args = (84 << 8) + 8 - 1;
  goto assign;
 }



 case 57: {


  duk__ivalue_toplain_ignore(comp_ctx, left);
  duk__expr_toplain(comp_ctx, res, 6 - 1 );


  return;
 }

 default: {
  break;
 }
 }

 do { } while (0);
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 4334; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("parse error"))); } while (0); } while (0);
 do { } while (0);
 binary:





 {
  duk__ivalue_toplain(comp_ctx, left);
  duk__expr_toplain(comp_ctx, res, args & 0xff );


  do { } while (0);
  do { } while (0);

  res->t = 2;
  res->op = (args >> 8) & 0xff;

  res->x2.t = res->x1.t;
  res->x2.regconst = res->x1.regconst;
  duk_copy(thr, res->x1.valstack_idx, res->x2.valstack_idx);

  res->x1.t = left->x1.t;
  res->x1.regconst = left->x1.regconst;
  duk_copy(thr, left->x1.valstack_idx, res->x1.valstack_idx);

  do { } while (0)
                                                                                                                                              ;
  return;
 }

 binary_logical:
 {
  duk_regconst_t reg_temp={0};
  duk_int_t pc_jump={0};
  duk_small_uint_t args_truthval = args >> 8;
  duk_small_uint_t args_rbp = args & 0xff;



  reg_temp = duk__alloctemp((comp_ctx));

  duk__ivalue_toforcedreg(comp_ctx, left, reg_temp);
  do { } while (0);
  duk__emit_bc(comp_ctx,
              (args_truthval ? 48 : 50),
              reg_temp);
  pc_jump = duk__emit_jump_empty(comp_ctx);
  duk__expr_toforcedreg(comp_ctx, res, args_rbp , reg_temp );
  duk__patch_jump_here(comp_ctx, pc_jump);

  duk__ivalue_regconst(res, reg_temp);
  return;
 }

 assign:
 {
  duk_small_uint_t args_op = args >> 8;
  duk_small_uint_t args_rbp = args & 0xff;
  duk_bool_t toplevel_assign={0};
  toplevel_assign = (comp_ctx->curr_func.nud_count == 1 &&
                     comp_ctx->curr_func.led_count == 1);
  do { } while (0)


                                               ;

  if (left->t == 4) {
   duk_hstring *h_varname={0};
   duk_regconst_t reg_varbind={0};
   duk_regconst_t rc_varname={0};

   do { } while (0);

   h_varname = duk_known_hstring(thr, left->x1.valstack_idx);
   if (duk__hstring_is_eval_or_arguments_in_strict_mode(comp_ctx, h_varname)) {

    goto syntax_error_lvalue;
   }
   duk_dup(thr, left->x1.valstack_idx);
   (void) duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname);

   if (args_op == 256) {
    duk__expr(comp_ctx, res, args_rbp );
    if (toplevel_assign) {

     do { } while (0);
    } else {

     do { } while (0);
     if (res->t != 1 || (res->x1.t == 2 &&
                                      ((duk_uint32_t) (res->x1.regconst) < (duk_uint32_t) ((comp_ctx)->curr_func.temp_first)))) {
      duk__ivalue_totempconst(comp_ctx, res);
     }
    }
   } else {





    duk_regconst_t reg_temp={0};

    reg_temp = duk__alloctemp((comp_ctx));

    if (reg_varbind >= 0) {
     duk_regconst_t reg_res={0};
     duk_regconst_t reg_src={0};
     duk_int_t pc_temp_load={0};
     duk_int_t pc_before_rhs={0};
     duk_int_t pc_after_rhs={0};

     if (toplevel_assign) {




      do { } while (0);
      reg_res = reg_varbind;
     } else {



      do { } while (0);
      reg_res = reg_temp;
      reg_temp = duk__alloctemp((comp_ctx));
     }
     pc_temp_load = duk__get_current_pc(comp_ctx);
     duk__emit_a_bc(comp_ctx,
                    0,
                    reg_temp,
                    reg_varbind);

     pc_before_rhs = duk__get_current_pc(comp_ctx);
     duk__expr_toregconst(comp_ctx, res, args_rbp );
     do { } while (0);
     pc_after_rhs = duk__get_current_pc(comp_ctx);

     do { } while (0)

                                             ;

     if (pc_after_rhs == pc_before_rhs) {




      do { } while (0);
      do { (&comp_ctx->curr_func.bw_code)->p += ((pc_temp_load - pc_before_rhs) * (duk_int_t) sizeof(duk_compiler_instr)); } while (0);
      reg_src = reg_varbind;
     } else {
      do { } while (0);
      reg_src = reg_temp;
     }

     duk__emit_a_b_c(comp_ctx,
                     args_op | (1 << 14),
                     reg_res,
                     reg_src,
                     res->x1.regconst);

     res->x1.regconst = reg_res;


     if (((duk_int32_t) (reg_res) >= (duk_int32_t) ((comp_ctx)->curr_func.temp_first))) {
      ((comp_ctx)->curr_func.temp_next = (reg_res + 1));
     }
    } else {




     duk__emit_a_bc(comp_ctx,
                    11,
                    reg_temp,
                    rc_varname);

     duk__expr_toregconst(comp_ctx, res, args_rbp );
     do { } while (0);

     duk__emit_a_b_c(comp_ctx,
                     args_op | (1 << 14),
                     reg_temp,
                     reg_temp,
                     res->x1.regconst);
     res->x1.regconst = reg_temp;
    }

    do { } while (0);
   }
   if (reg_varbind >= 0) {
    if (res->t != 1) {




     if (toplevel_assign) {
      duk__ivalue_toforcedreg(comp_ctx, res, (duk_int_t) reg_varbind);
     } else {
      duk__ivalue_totempconst(comp_ctx, res);
      duk__copy_ivalue(comp_ctx, res, left);
      duk__ivalue_toforcedreg(comp_ctx, left, (duk_int_t) reg_varbind);
     }
    } else {




     duk__copy_ivalue(comp_ctx, res, left);
     duk__ivalue_toforcedreg(comp_ctx, left, (duk_int_t) reg_varbind);
    }
   } else {
    duk__ivalue_toreg(comp_ctx, res);
    duk__emit_a_bc(comp_ctx,
                   155 | (1 << 11),
                   res->x1.regconst,
                   rc_varname);
   }


  } else if (left->t == 3) {

   duk_regconst_t reg_obj={0};
   duk_regconst_t rc_key={0};
   duk_regconst_t rc_res={0};
   duk_regconst_t reg_temp={0};
   reg_obj = duk__ispec_toregconst_raw(comp_ctx,
                                       &left->x1,
                                       -1 ,
                                       (1 << 1) );

   rc_key = duk__ispec_toregconst_raw(comp_ctx,
                                      &left->x2,
                                      -1 ,
                                      (1 << 1) | (1 << 0) );



   if (args_op == 256) {
    duk__expr_toregconst(comp_ctx, res, args_rbp );
    do { } while (0);
    rc_res = res->x1.regconst;
   } else {
    reg_temp = duk__alloctemp((comp_ctx));
    duk__emit_a_b_c(comp_ctx,
                    108 | (1 << 14),
                    reg_temp,
                    reg_obj,
                    rc_key);

    duk__expr_toregconst(comp_ctx, res, args_rbp );
    do { } while (0);

    duk__emit_a_b_c(comp_ctx,
                    args_op | (1 << 14),
                    reg_temp,
                    reg_temp,
                    res->x1.regconst);
    rc_res = reg_temp;
   }

   duk__emit_a_b_c(comp_ctx,
                   112 | (1 << 11) | (1 << 14),
                   reg_obj,
                   rc_key,
                   rc_res);

   duk__ivalue_regconst(res, rc_res);
  } else {
   duk_regconst_t rc_res={0};


   duk__ivalue_toplain_ignore(comp_ctx, left);





   rc_res = duk__expr_toregconst(comp_ctx, res, args_rbp );

   duk__emit_op_only(comp_ctx, 170);

   duk__ivalue_regconst(res, rc_res);
  }

  return;
 }

 postincdec:
 {
  duk_regconst_t reg_res={0};
  duk_small_uint_t args_op1 = (args >> 8) & 0xff;
  duk_small_uint_t args_op2 = args >> 16;


  do { } while (0);
  do { } while (0);

  reg_res = duk__alloctemp((comp_ctx));

  if (left->t == 4) {
   duk_hstring *h_varname={0};
   duk_regconst_t reg_varbind={0};
   duk_regconst_t rc_varname={0};

   h_varname = duk_known_hstring(thr, left->x1.valstack_idx);

   if (duk__hstring_is_eval_or_arguments_in_strict_mode(comp_ctx, h_varname)) {
    goto syntax_error;
   }

   duk_dup(thr, left->x1.valstack_idx);
   if (duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {
    duk__emit_a_bc(comp_ctx,
                   args_op1,
                   reg_res,
                   reg_varbind);
   } else {
    duk__emit_a_bc(comp_ctx,
                   args_op1 + 4,
                   reg_res,
                   rc_varname);
   }

   do { } while (0)
                                                                                          ;
  } else if (left->t == 3) {
   duk_regconst_t reg_obj={0};
   duk_regconst_t rc_key={0};

   reg_obj = duk__ispec_toregconst_raw(comp_ctx, &left->x1, -1 , 0 );
   rc_key = duk__ispec_toregconst_raw(comp_ctx, &left->x2, -1 , (1 << 0) );
   duk__emit_a_b_c(comp_ctx,
                   args_op2 | (1 << 14),
                   reg_res,
                   reg_obj,
                   rc_key);
  } else {





   duk__ivalue_toforcedreg(comp_ctx, left, reg_res);
   duk__emit_bc(comp_ctx,
                15,
                reg_res);
   duk__emit_op_only(comp_ctx,
                     170);
  }

  ((comp_ctx)->curr_func.temp_next = (reg_res + 1));
  duk__ivalue_regconst(res, reg_res);
  return;
 }

 syntax_error:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 4824; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid expression"))); } while (0); } while (0);
 do { } while (0);

 syntax_error_lvalue:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 4828; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid lvalue"))); } while (0); } while (0);
 do { } while (0);
}

static duk_small_uint_t duk__expr_lbp(duk_compiler_ctx *comp_ctx) {
 duk_small_uint_t tok = comp_ctx->curr_token.t;

 do { } while (0);
 do { } while (0);
 do { } while (0);






 if (tok == 15 && !comp_ctx->curr_func.allow_in) {
  return 0;
 }

 if ((tok == 73 || tok == 72) &&
     (comp_ctx->curr_token.lineterm)) {






  return 0;
 }

 return ((duk_small_uint_t) (((duk__token_lbp[tok]) & 0x1f) * 2));
}
static void duk__expr(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 duk_hthread *thr = comp_ctx->thr;
 duk_ivalue tmp_alloc={0};
 duk_ivalue *tmp = &tmp_alloc;
 duk_small_uint_t rbp={0};

 do { do { } while (0); duk__comp_recursion_increase((comp_ctx)); } while (0);

 duk_require_stack(thr, 16);


 rbp = rbp_flags & 0xff;

 do { } while (0)

                                                              ;

 do { void *duk__dst = (&tmp_alloc); duk_size_t duk__len = (sizeof(tmp_alloc)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 tmp->x1.valstack_idx = duk_get_top(thr);
 tmp->x2.valstack_idx = tmp->x1.valstack_idx + 1;
 duk_push_undefined(thr);
 duk_push_undefined(thr);
 if (comp_ctx->curr_token.t == 56 || comp_ctx->curr_token.t == 54) {

  do { } while (0);
  if (!(rbp_flags & (1 << 9))) {
   do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 4913; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("empty expression not allowed"))); } while (0); } while (0);
   do { } while (0);
  }
  duk_push_undefined(thr);
  duk__ivalue_plain_fromstack(comp_ctx, res);
  goto cleanup;
 }

 duk__advance(comp_ctx);
 duk__expr_nud(comp_ctx, res);
 while (rbp < duk__expr_lbp(comp_ctx)) {
  duk__advance(comp_ctx);
  duk__expr_led(comp_ctx, res, tmp);
  duk__copy_ivalue(comp_ctx, tmp, res);
 }

 cleanup:


 duk_pop_2(thr);

 do { do { } while (0); duk__comp_recursion_decrease((comp_ctx)); } while (0);
}

static void duk__exprtop(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 duk_hthread *thr = comp_ctx->thr;




 comp_ctx->curr_func.nud_count = 0;
 comp_ctx->curr_func.led_count = 0;
 comp_ctx->curr_func.paren_level = 0;
 comp_ctx->curr_func.expr_lhs = 1;
 comp_ctx->curr_func.allow_in = (rbp_flags & (1 << 8) ? 0 : 1);

 duk__expr(comp_ctx, res, rbp_flags);

 if (!(rbp_flags & (1 << 9)) && duk__expr_is_empty(comp_ctx)) {
  do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 4952; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("empty expression not allowed"))); } while (0); } while (0);
  do { } while (0);
 }
}
static void duk__expr_toforcedreg(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags, duk_regconst_t forced_reg) {
 do { } while (0);
 duk__expr(comp_ctx, res, rbp_flags);
 duk__ivalue_toforcedreg(comp_ctx, res, forced_reg);
}

static duk_regconst_t duk__expr_toregconst(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 duk__expr(comp_ctx, res, rbp_flags);
 return duk__ivalue_toregconst(comp_ctx, res);
}
static void duk__expr_toplain(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 duk__expr(comp_ctx, res, rbp_flags);
 duk__ivalue_toplain(comp_ctx, res);
}

static void duk__expr_toplain_ignore(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 duk__expr(comp_ctx, res, rbp_flags);
 duk__ivalue_toplain_ignore(comp_ctx, res);
}

static duk_regconst_t duk__exprtop_toreg(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 duk__exprtop(comp_ctx, res, rbp_flags);
 return duk__ivalue_toreg(comp_ctx, res);
}
static void duk__exprtop_toforcedreg(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags, duk_regconst_t forced_reg) {
 do { } while (0);
 duk__exprtop(comp_ctx, res, rbp_flags);
 duk__ivalue_toforcedreg(comp_ctx, res, forced_reg);
}

static duk_regconst_t duk__exprtop_toregconst(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 duk__exprtop(comp_ctx, res, rbp_flags);
 return duk__ivalue_toregconst(comp_ctx, res);
}
static void duk__parse_var_decl(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t expr_flags, duk_regconst_t *out_reg_varbind, duk_regconst_t *out_rc_varname) {
 duk_hthread *thr = comp_ctx->thr;
 duk_hstring *h_varname={0};
 duk_regconst_t reg_varbind={0};
 duk_regconst_t rc_varname={0};




 if (comp_ctx->curr_token.t != 1) {
  goto syntax_error;
 }
 h_varname = comp_ctx->curr_token.str1;

 do { } while (0);


 if (duk__hstring_is_eval_or_arguments_in_strict_mode(comp_ctx, h_varname)) {
  goto syntax_error;
 }


 if (comp_ctx->curr_func.in_scanning) {
  duk_uarridx_t n={0};
  do { } while (0)
                                                  ;
  n = (duk_uarridx_t) duk_get_length(thr, comp_ctx->curr_func.decls_idx);
  duk_push_hstring(thr, h_varname);
  duk_put_prop_index(thr, comp_ctx->curr_func.decls_idx, n);
  duk_push_int(thr, 0 + (0 << 8));
  duk_put_prop_index(thr, comp_ctx->curr_func.decls_idx, n + 1);
 }

 duk_push_hstring(thr, h_varname);


 duk_dup_top(thr);
 (void) duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname);

 duk__advance(comp_ctx);

 if (comp_ctx->curr_token.t == 86) {
  duk__advance(comp_ctx);

  do { } while (0)
                                                                                         ;

  duk__exprtop(comp_ctx, res, 6 | expr_flags );

  if (reg_varbind >= 0) {
   duk__ivalue_toforcedreg(comp_ctx, res, reg_varbind);
  } else {
   duk_regconst_t reg_val={0};
   reg_val = duk__ivalue_toreg(comp_ctx, res);
   duk__emit_a_bc(comp_ctx,
                  155 | (1 << 11),
                  reg_val,
                  rc_varname);
  }
 } else {
  if (expr_flags & (1 << 10)) {

   goto syntax_error;
  }
 }

 duk_pop(thr);

 *out_rc_varname = rc_varname;
 *out_reg_varbind = reg_varbind;

 return;

 syntax_error:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 5145; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid variable declaration"))); } while (0); } while (0);
 do { } while (0);
}

static void duk__parse_var_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t expr_flags) {
 duk_regconst_t reg_varbind={0};
 duk_regconst_t rc_varname={0};

 duk__advance(comp_ctx);

 for (;;) {

  duk__parse_var_decl(comp_ctx, res, 0 | expr_flags, &reg_varbind, &rc_varname);

  if (comp_ctx->curr_token.t != 57) {
   break;
  }
  duk__advance(comp_ctx);
 }
}

static void duk__parse_for_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site) {
 duk_hthread *thr = comp_ctx->thr;
 duk_int_t pc_v34_lhs={0};
 duk_regconst_t temp_reset={0};
 duk_regconst_t reg_temps={0};

 do { } while (0);







 reg_temps = duk__alloctemps((comp_ctx),(2));

 temp_reset = ((comp_ctx)->curr_func.temp_next);
 duk__advance(comp_ctx);
 duk__advance_expect(comp_ctx, 53);

 do { } while (0);





 if (comp_ctx->curr_token.t == 24) {




  duk_regconst_t reg_varbind={0};
  duk_regconst_t rc_varname={0};

  duk__advance(comp_ctx);
  duk__parse_var_decl(comp_ctx, res, (1 << 8), &reg_varbind, &rc_varname);
  ((comp_ctx)->curr_func.temp_next = (temp_reset));

  if (comp_ctx->curr_token.t == 15) {




   do { } while (0);
   pc_v34_lhs = duk__get_current_pc(comp_ctx);
   if (reg_varbind >= 0) {
    duk__emit_a_bc(comp_ctx,
                   0,
                   reg_varbind,
                   reg_temps + 0);
   } else {
    duk__emit_a_bc(comp_ctx,
                   155 | (1 << 11),
                   reg_temps + 0,
                   rc_varname);
   }
   goto parse_3_or_4;
  } else {




   do { } while (0);
   for (;;) {

    if (comp_ctx->curr_token.t != 57) {
     break;
    }
    do { } while (0);

    duk__advance(comp_ctx);
    duk__parse_var_decl(comp_ctx, res, (1 << 8), &reg_varbind, &rc_varname);
   }
   goto parse_1_or_2;
  }
 } else {




  pc_v34_lhs = duk__get_current_pc(comp_ctx);






  duk__exprtop(comp_ctx, res, 4 | (1 << 8) | (1 << 9) );
  if (comp_ctx->curr_token.t == 15) {





   do { } while (0);
   if (duk__expr_is_empty(comp_ctx)) {
    goto syntax_error;
   }

   if (res->t == 4) {
    duk_regconst_t reg_varbind={0};
    duk_regconst_t rc_varname={0};

    duk_dup(thr, res->x1.valstack_idx);
    if (duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {
     duk__emit_a_bc(comp_ctx,
                    0,
                    reg_varbind,
                    reg_temps + 0);
    } else {
     duk__emit_a_bc(comp_ctx,
                    155 | (1 << 11),
                    reg_temps + 0,
                    rc_varname);
    }
   } else if (res->t == 3) {



    duk_regconst_t reg_obj={0};
    duk_regconst_t rc_key={0};
    reg_obj = duk__ispec_toregconst_raw(comp_ctx, &res->x1, -1 , 0 );
    rc_key = duk__ispec_toregconst_raw(comp_ctx, &res->x2, -1 , (1 << 0) );
    duk__emit_a_b_c(comp_ctx,
                    112 | (1 << 11) | (1 << 14),
                    reg_obj,
                    rc_key,
                    reg_temps + 0);
   } else {
    duk__ivalue_toplain_ignore(comp_ctx, res);
    duk__emit_op_only(comp_ctx,
                      170);
   }
   goto parse_3_or_4;
  } else {




   do { } while (0);
   duk__ivalue_toplain_ignore(comp_ctx, res);
   goto parse_1_or_2;
  }
 }

 parse_1_or_2:







 {
  duk_regconst_t rc_cond={0};
  duk_int_t pc_l1, pc_l2, pc_l3, pc_l4={0};
  duk_int_t pc_jumpto_l3, pc_jumpto_l4={0};
  duk_bool_t expr_c_empty={0};

  do { } while (0);


  temp_reset = reg_temps + 0;
  ((comp_ctx)->curr_func.temp_next = (temp_reset));

  duk__advance_expect(comp_ctx, 56);

  pc_l1 = duk__get_current_pc(comp_ctx);
  duk__exprtop(comp_ctx, res, 4 | (1 << 9) );
  if (duk__expr_is_empty(comp_ctx)) {

   pc_jumpto_l3 = duk__emit_jump_empty(comp_ctx);
   pc_jumpto_l4 = -1;
  } else {
   rc_cond = duk__ivalue_toregconst(comp_ctx, res);
   duk__emit_if_false_skip(comp_ctx, rc_cond);
   pc_jumpto_l3 = duk__emit_jump_empty(comp_ctx);
   pc_jumpto_l4 = duk__emit_jump_empty(comp_ctx);
  }
  ((comp_ctx)->curr_func.temp_next = (temp_reset));

  duk__advance_expect(comp_ctx, 56);

  pc_l2 = duk__get_current_pc(comp_ctx);
  duk__exprtop(comp_ctx, res, 4 | (1 << 9) );
  if (duk__expr_is_empty(comp_ctx)) {

   expr_c_empty = 1;

  } else {
   duk__ivalue_toplain_ignore(comp_ctx, res);
   expr_c_empty = 0;
   duk__emit_jump(comp_ctx, pc_l1);
  }
  ((comp_ctx)->curr_func.temp_next = (temp_reset));

  comp_ctx->curr_func.allow_regexp_in_adv = 1;
  duk__advance_expect(comp_ctx, 54);

  pc_l3 = duk__get_current_pc(comp_ctx);
  duk__parse_stmt(comp_ctx, res, 0 );
  if (expr_c_empty) {
   duk__emit_jump(comp_ctx, pc_l1);
  } else {
   duk__emit_jump(comp_ctx, pc_l2);
  }


  pc_l4 = duk__get_current_pc(comp_ctx);

  do { } while (0)


                                                                                                           ;

  duk__patch_jump(comp_ctx, pc_jumpto_l3, pc_l3);
  duk__patch_jump(comp_ctx, pc_jumpto_l4, pc_l4);
  duk__patch_jump(comp_ctx,
                  pc_label_site + 1,
                  pc_l4);
  duk__patch_jump(comp_ctx,
                  pc_label_site + 2,
                  expr_c_empty ? pc_l1 : pc_l2);
 }
 goto finished;

 parse_3_or_4:
 {
  duk_int_t pc_l1, pc_l2, pc_l3, pc_l4, pc_l5={0};
  duk_int_t pc_jumpto_l2, pc_jumpto_l3, pc_jumpto_l4, pc_jumpto_l5={0};
  duk_regconst_t reg_target={0};

  do { } while (0);

  ((comp_ctx)->curr_func.temp_next = (temp_reset));
  duk__insert_jump_entry(comp_ctx, pc_v34_lhs);
  pc_jumpto_l2 = pc_v34_lhs;
  pc_l1 = pc_v34_lhs + 1;





  pc_jumpto_l3 = duk__emit_jump_empty(comp_ctx);

  duk__advance(comp_ctx);







  pc_l2 = duk__get_current_pc(comp_ctx);
  reg_target = duk__exprtop_toreg(comp_ctx, res, 4 );
  duk__emit_b_c(comp_ctx,
                201 | (1 << 12),
                reg_temps + 1,
                reg_target);
  pc_jumpto_l4 = duk__emit_jump_empty(comp_ctx);
  ((comp_ctx)->curr_func.temp_next = (temp_reset));

  comp_ctx->curr_func.allow_regexp_in_adv = 1;
  duk__advance_expect(comp_ctx, 54);

  pc_l3 = duk__get_current_pc(comp_ctx);
  duk__parse_stmt(comp_ctx, res, 0 );
  pc_l4 = duk__get_current_pc(comp_ctx);
  duk__emit_b_c(comp_ctx,
                202 | (1 << 12) | (1 << 15),
                reg_temps + 0,
                reg_temps + 1);
  pc_jumpto_l5 = comp_ctx->emit_jumpslot_pc;
  duk__emit_jump(comp_ctx, pc_l1);

  pc_l5 = duk__get_current_pc(comp_ctx);






  do { } while (0)




                                                                                                           ;

  duk__patch_jump(comp_ctx, pc_jumpto_l2, pc_l2);
  duk__patch_jump(comp_ctx, pc_jumpto_l3, pc_l3);
  duk__patch_jump(comp_ctx, pc_jumpto_l4, pc_l4);
  duk__patch_jump(comp_ctx, pc_jumpto_l5, pc_l5);
  duk__patch_jump(comp_ctx, pc_label_site + 1, pc_l5);
  duk__patch_jump(comp_ctx, pc_label_site + 2, pc_l4);
 }
 goto finished;

 finished:
 do { } while (0);
 return;

 syntax_error:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 5519; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid for statement"))); } while (0); } while (0);
 do { } while (0);
}

static void duk__parse_switch_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site) {
 duk_hthread *thr = comp_ctx->thr;
 duk_regconst_t temp_at_loop={0};
 duk_regconst_t rc_switch={0};
 duk_regconst_t rc_case={0};
 duk_regconst_t reg_temp={0};
 duk_int_t pc_prevcase = -1;
 duk_int_t pc_prevstmt = -1;
 duk_int_t pc_default = -1;
 duk__advance(comp_ctx);
 duk__advance_expect(comp_ctx, 53);
 rc_switch = duk__exprtop_toregconst(comp_ctx, res, 4 );
 duk__advance_expect(comp_ctx, 54);
 duk__advance_expect(comp_ctx, 49);

 do { } while (0);

 temp_at_loop = ((comp_ctx)->curr_func.temp_next);

 for (;;) {
  duk_int_t num_stmts={0};
  duk_small_uint_t tok={0};


  ((comp_ctx)->curr_func.temp_next = (temp_at_loop));

  if (comp_ctx->curr_token.t == 50) {
   break;
  }





  if (comp_ctx->curr_token.t == 3) {







   duk__patch_jump_here(comp_ctx, pc_prevcase);



   duk__advance(comp_ctx);
   rc_case = duk__exprtop_toregconst(comp_ctx, res, 4 );
   duk__advance_expect(comp_ctx, 85);

   reg_temp = duk__alloctemp((comp_ctx));
   duk__emit_a_b_c(comp_ctx,
                   24 | (1 << 14),
                   reg_temp,
                   rc_switch,
                   rc_case);
   duk__emit_if_true_skip(comp_ctx, reg_temp);


   pc_prevcase = duk__emit_jump_empty(comp_ctx);


  } else if (comp_ctx->curr_token.t == 7) {




   if (pc_default >= 0) {
    goto syntax_error;
   }
   duk__advance(comp_ctx);
   duk__advance_expect(comp_ctx, 85);





   if (pc_prevcase < 0) {
    do { } while (0);
    pc_prevcase = duk__emit_jump_empty(comp_ctx);
   }


   pc_default = -2;
  } else {

   goto syntax_error;
  }
  num_stmts = 0;
  if (pc_default == -2) {
   pc_default = duk__get_current_pc(comp_ctx);
  }





  duk__patch_jump_here(comp_ctx, pc_prevstmt);



  for (;;) {
   tok = comp_ctx->curr_token.t;
   if (tok == 3 || tok == 7 ||
       tok == 50) {
    break;
   }
   num_stmts++;
   duk__parse_stmt(comp_ctx, res, 0 );
  }


  pc_prevstmt = duk__emit_jump_empty(comp_ctx);
 }

 do { } while (0);
 comp_ctx->curr_func.allow_regexp_in_adv = 1;
 duk__advance(comp_ctx);




 if (pc_default >= 0) {

  duk__patch_jump(comp_ctx, pc_prevcase, pc_default);
 } else {



  duk__patch_jump_here(comp_ctx, pc_prevcase);
 }




 duk__patch_jump_here(comp_ctx, pc_prevstmt);


 duk__patch_jump_here(comp_ctx, pc_label_site + 1);







 return;

 syntax_error:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 5720; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid switch statement"))); } while (0); } while (0);
 do { } while (0);
}

static void duk__parse_if_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 duk_regconst_t temp_reset={0};
 duk_regconst_t rc_cond={0};
 duk_int_t pc_jump_false={0};

 do { } while (0);

 temp_reset = ((comp_ctx)->curr_func.temp_next);

 duk__advance(comp_ctx);
 duk__advance_expect(comp_ctx, 53);

 rc_cond = duk__exprtop_toregconst(comp_ctx, res, 4 );
 duk__emit_if_true_skip(comp_ctx, rc_cond);
 pc_jump_false = duk__emit_jump_empty(comp_ctx);
 ((comp_ctx)->curr_func.temp_next = (temp_reset));

 comp_ctx->curr_func.allow_regexp_in_adv = 1;
 duk__advance_expect(comp_ctx, 54);

 duk__parse_stmt(comp_ctx, res, 0 );





 if (comp_ctx->curr_token.t == 10) {
  duk_int_t pc_jump_end={0};

  do { } while (0);

  duk__advance(comp_ctx);

  pc_jump_end = duk__emit_jump_empty(comp_ctx);
  duk__patch_jump_here(comp_ctx, pc_jump_false);

  duk__parse_stmt(comp_ctx, res, 0 );

  duk__patch_jump_here(comp_ctx, pc_jump_end);
 } else {
  do { } while (0);

  duk__patch_jump_here(comp_ctx, pc_jump_false);
 }

 do { } while (0);
}

static void duk__parse_do_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site) {
 duk_regconst_t rc_cond={0};
 duk_int_t pc_start={0};

 do { } while (0);

 duk__advance(comp_ctx);

 pc_start = duk__get_current_pc(comp_ctx);
 duk__parse_stmt(comp_ctx, res, 0 );
 duk__patch_jump_here(comp_ctx, pc_label_site + 2);

 duk__advance_expect(comp_ctx, 27);
 duk__advance_expect(comp_ctx, 53);

 rc_cond = duk__exprtop_toregconst(comp_ctx, res, 4 );
 duk__emit_if_false_skip(comp_ctx, rc_cond);
 duk__emit_jump(comp_ctx, pc_start);


 comp_ctx->curr_func.allow_regexp_in_adv = 1;
 duk__advance_expect(comp_ctx, 54);

 duk__patch_jump_here(comp_ctx, pc_label_site + 1);

 do { } while (0);
}

static void duk__parse_while_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site) {
 duk_regconst_t temp_reset={0};
 duk_regconst_t rc_cond={0};
 duk_int_t pc_start={0};
 duk_int_t pc_jump_false={0};

 do { } while (0);

 temp_reset = ((comp_ctx)->curr_func.temp_next);

 duk__advance(comp_ctx);

 duk__advance_expect(comp_ctx, 53);

 pc_start = duk__get_current_pc(comp_ctx);
 duk__patch_jump_here(comp_ctx, pc_label_site + 2);

 rc_cond = duk__exprtop_toregconst(comp_ctx, res, 4 );
 duk__emit_if_true_skip(comp_ctx, rc_cond);
 pc_jump_false = duk__emit_jump_empty(comp_ctx);
 ((comp_ctx)->curr_func.temp_next = (temp_reset));

 comp_ctx->curr_func.allow_regexp_in_adv = 1;
 duk__advance_expect(comp_ctx, 54);

 duk__parse_stmt(comp_ctx, res, 0 );
 duk__emit_jump(comp_ctx, pc_start);

 duk__patch_jump_here(comp_ctx, pc_jump_false);
 duk__patch_jump_here(comp_ctx, pc_label_site + 1);

 do { } while (0);
}

static void duk__parse_break_or_continue_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 duk_hthread *thr = comp_ctx->thr;
 duk_bool_t is_break = (comp_ctx->curr_token.t == 2);
 duk_int_t label_id={0};
 duk_int_t label_catch_depth={0};
 duk_int_t label_pc={0};
 duk_bool_t label_is_closest={0};

 do { (void) (res); } while (0);

 duk__advance(comp_ctx);

 if (comp_ctx->curr_token.t == 56 ||
     comp_ctx->curr_token.lineterm ||
     comp_ctx->curr_token.allow_auto_semi) {


  duk__lookup_active_label(comp_ctx, (((thr))->strs[(15)]), is_break, &label_id, &label_catch_depth, &label_pc, &label_is_closest);
 } else if (comp_ctx->curr_token.t == 1) {

  do { } while (0);
  duk__lookup_active_label(comp_ctx, comp_ctx->curr_token.str1, is_break, &label_id, &label_catch_depth, &label_pc, &label_is_closest);
  duk__advance(comp_ctx);
 } else {
  do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 5858; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid break/continue label"))); } while (0); } while (0);
  do { } while (0);
 }







 if (label_catch_depth == comp_ctx->curr_func.catch_depth &&
     label_is_closest) {
  do { } while (0)



                                                                                         ;

  duk__emit_jump(comp_ctx, label_pc + (is_break ? 1 : 2));
 } else {
  do { } while (0)



                                                                                         ;

  duk__emit_bc(comp_ctx,
               is_break ? 163 : 164,
               (duk_regconst_t) label_id);
 }
}

static void duk__parse_return_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 duk_hthread *thr = comp_ctx->thr;
 duk_regconst_t rc_val={0};

 duk__advance(comp_ctx);




 if (!comp_ctx->curr_func.is_function) {
  do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 5900; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid return"))); } while (0); } while (0);
  do { } while (0);
 }

 if (comp_ctx->curr_token.t == 56 ||
     comp_ctx->curr_token.lineterm ||
     comp_ctx->curr_token.allow_auto_semi) {
  do { } while (0);
  duk__emit_op_only(comp_ctx, 158);
 } else {
  duk_int_t pc_before_expr={0};
  duk_int_t pc_after_expr={0};

  do { } while (0);

  do { (void) (pc_before_expr); } while (0);
  do { (void) (pc_after_expr); } while (0);

  pc_before_expr = duk__get_current_pc(comp_ctx);
  rc_val = duk__exprtop_toregconst(comp_ctx, res, 4 );
  pc_after_expr = duk__get_current_pc(comp_ctx);
  if (comp_ctx->curr_func.catch_depth == 0 &&
      pc_after_expr > pc_before_expr) {
   duk_compiler_instr *instr={0};
   duk_instr_t ins={0};
   duk_small_uint_t op={0};

   instr = duk__get_instr_ptr(comp_ctx, pc_after_expr - 1);
   do { } while (0);

   ins = instr->ins;
   op = (duk_small_uint_t) ((ins) & 0xffUL);
   if ((op & ~0x0fU) == 176 &&
       ((duk_int32_t) (rc_val) >= (duk_int32_t) ((comp_ctx)->curr_func.temp_first)) ) {
    do { } while (0)


                                                  ;
    ins |= ((duk_instr_t) ((1U << 0)));
    instr->ins = ins;
   }
  }


  if (((rc_val) >= 0)) {
   duk__emit_bc(comp_ctx, 157, rc_val);
  } else {
   rc_val = ((rc_val) & ~(-0x7fffffffL - 1L));
   if (duk__const_needs_refcount(comp_ctx, rc_val)) {
    duk__emit_bc(comp_ctx, 159, rc_val);
   } else {
    duk__emit_bc(comp_ctx, 160, rc_val);
   }
  }
 }
}

static void duk__parse_throw_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 duk_regconst_t reg_val={0};

 duk__advance(comp_ctx);



 if (comp_ctx->curr_token.lineterm) {
  do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 6002; do { } while (0); do { } while (0); duk_err_handle_error(((comp_ctx->thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid throw"))); } while (0); } while (0);
  do { } while (0);
 }

 reg_val = duk__exprtop_toreg(comp_ctx, res, 4 );
 duk__emit_bc(comp_ctx,
              169,
              reg_val);
}

static void duk__parse_try_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 duk_hthread *thr = comp_ctx->thr;
 duk_regconst_t reg_catch={0};
 duk_regconst_t rc_varname = 0;
 duk_small_uint_t trycatch_flags = 0;
 duk_int_t pc_ldconst = -1;
 duk_int_t pc_trycatch = -1;
 duk_int_t pc_catch = -1;
 duk_int_t pc_finally = -1;

 do { (void) (res); } while (0);
 comp_ctx->curr_func.catch_depth++;

 duk__advance(comp_ctx);

 reg_catch = duk__alloctemps((comp_ctx),(2));






 pc_ldconst = duk__get_current_pc(comp_ctx);
 duk__emit_a_bc(comp_ctx, 3, reg_catch, 0 );

 pc_trycatch = duk__get_current_pc(comp_ctx);
 duk__emit_invalid(comp_ctx);
 duk__emit_invalid(comp_ctx);
 duk__emit_invalid(comp_ctx);


 duk__advance_expect(comp_ctx, 49);
 duk__parse_stmts(comp_ctx, 0 , 0 , 1 );

 duk__emit_op_only(comp_ctx, 166);

 if (comp_ctx->curr_token.t == 4) {
  duk_hstring *h_var={0};
  duk_int_t varmap_value={0};

  do { } while (0);

  trycatch_flags |= (1U << 0);

  pc_catch = duk__get_current_pc(comp_ctx);

  duk__advance(comp_ctx);
  duk__advance_expect(comp_ctx, 53);

  if (comp_ctx->curr_token.t != 1) {

   goto syntax_error;
  }
  h_var = comp_ctx->curr_token.str1;
  do { } while (0);

  duk_push_hstring(thr, h_var);

  if (comp_ctx->curr_func.is_strict &&
      ((h_var == (((thr))->strs[(33)])) ||
       (h_var == (((thr))->strs[(67)])))) {
   do { } while (0);
   goto syntax_error;
  }

  duk_dup_top(thr);
  rc_varname = duk__getconst(comp_ctx);
  do { } while (0)
                                                                      ;

  duk__advance(comp_ctx);
  duk__advance_expect(comp_ctx, 54);

  duk__advance_expect(comp_ctx, 49);

  do { } while (0)
                                                                                       ;

  duk_dup_top(thr);
  duk_get_prop(thr, comp_ctx->curr_func.varmap_idx);
  if (duk_is_undefined(thr, -1)) {
   varmap_value = -2;
  } else if (duk_is_null(thr, -1)) {
   varmap_value = -1;
  } else {
   do { } while (0);
   varmap_value = duk_get_int(thr, -1);
   do { } while (0);
  }
  duk_pop(thr);
  duk_dup_top(thr);
  duk_push_null(thr);
  duk_put_prop(thr, comp_ctx->curr_func.varmap_idx);

  duk__emit_a_bc(comp_ctx,
                 155 | (1 << 11),
                 reg_catch + 0 ,
                 rc_varname );

  do { } while (0)
                                                                                       ;

  duk__parse_stmts(comp_ctx, 0 , 0 , 1 );


  if (varmap_value == -2) {

   duk_del_prop(thr, comp_ctx->curr_func.varmap_idx);
  } else {
   if (varmap_value == -1) {
    duk_push_null(thr);
   } else {
    do { } while (0);
    duk_push_int(thr, varmap_value);
   }
   duk_put_prop(thr, comp_ctx->curr_func.varmap_idx);
  }


  do { } while (0)
                                                                                       ;

  duk__emit_op_only(comp_ctx,
                    167);







  trycatch_flags |= (1U << 2);

  do { } while (0);
 }

 if (comp_ctx->curr_token.t == 11) {
  trycatch_flags |= (1U << 1);

  pc_finally = duk__get_current_pc(comp_ctx);

  duk__advance(comp_ctx);

  duk__advance_expect(comp_ctx, 49);
  duk__parse_stmts(comp_ctx, 0 , 0 , 1 );

  duk__emit_abc(comp_ctx,
                168,
                reg_catch);
 }

 if (!(trycatch_flags & (1U << 0)) &&
     !(trycatch_flags & (1U << 1))) {

  goto syntax_error;
 }






 duk__patch_trycatch(comp_ctx,
                     pc_ldconst,
                     pc_trycatch,
                     reg_catch,
                     rc_varname,
                     trycatch_flags);

 if (trycatch_flags & (1U << 0)) {
  do { } while (0);
  duk__patch_jump(comp_ctx, pc_trycatch + 1, pc_catch);
 }

 if (trycatch_flags & (1U << 1)) {
  do { } while (0);
  duk__patch_jump(comp_ctx, pc_trycatch + 2, pc_finally);
 } else {

  duk__patch_jump_here(comp_ctx, pc_trycatch + 2);
 }

 comp_ctx->curr_func.catch_depth--;
 return;

 syntax_error:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 6242; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid try"))); } while (0); } while (0);
 do { } while (0);
}

static void duk__parse_with_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 duk_int_t pc_trycatch={0};
 duk_int_t pc_finished={0};
 duk_regconst_t reg_catch={0};
 duk_small_uint_t trycatch_flags={0};

 if (comp_ctx->curr_func.is_strict) {
  do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 6253; do { } while (0); do { } while (0); duk_err_handle_error(((comp_ctx->thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("with in strict mode"))); } while (0); } while (0);
  do { } while (0);
 }

 comp_ctx->curr_func.catch_depth++;

 duk__advance(comp_ctx);

 reg_catch = duk__alloctemps((comp_ctx),(2));

 duk__advance_expect(comp_ctx, 53);
 duk__exprtop_toforcedreg(comp_ctx, res, 4 , reg_catch);
 comp_ctx->curr_func.allow_regexp_in_adv = 1;
 duk__advance_expect(comp_ctx, 54);

 pc_trycatch = duk__get_current_pc(comp_ctx);
 trycatch_flags = (1U << 3);
 duk__emit_a_bc(comp_ctx,
                 165 | (1 << 8),
                 (duk_regconst_t) trycatch_flags ,
                 reg_catch );
 duk__emit_invalid(comp_ctx);
 duk__emit_invalid(comp_ctx);

 duk__parse_stmt(comp_ctx, res, 0 );
 duk__emit_op_only(comp_ctx, 166);

 pc_finished = duk__get_current_pc(comp_ctx);

 duk__patch_jump(comp_ctx, pc_trycatch + 2, pc_finished);

 comp_ctx->curr_func.catch_depth--;
}

static duk_int_t duk__stmt_label_site(duk_compiler_ctx *comp_ctx, duk_int_t label_id) {

 if (label_id >= 0) {
  return label_id;
 }

 label_id = comp_ctx->curr_func.label_next++;
 do { } while (0);

 duk__emit_bc(comp_ctx,
              161,
              (duk_regconst_t) label_id);
 duk__emit_invalid(comp_ctx);
 duk__emit_invalid(comp_ctx);

 return label_id;
}






static void duk__parse_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_bool_t allow_source_elem) {
 duk_hthread *thr = comp_ctx->thr;
 duk_bool_t dir_prol_at_entry={0};
 duk_regconst_t temp_at_entry={0};
 duk_size_t labels_len_at_entry={0};
 duk_int_t pc_at_entry={0};
 duk_int_t stmt_id={0};
 duk_small_uint_t stmt_flags = 0;
 duk_int_t label_id = -1;
 duk_small_uint_t tok={0};
 duk_bool_t test_func_decl={0};

 do { do { } while (0); duk__comp_recursion_increase((comp_ctx)); } while (0);

 temp_at_entry = ((comp_ctx)->curr_func.temp_next);
 pc_at_entry = duk__get_current_pc(comp_ctx);
 labels_len_at_entry = duk_get_length(thr, comp_ctx->curr_func.labelnames_idx);
 stmt_id = comp_ctx->curr_func.stmt_next++;
 dir_prol_at_entry = comp_ctx->curr_func.in_directive_prologue;

 do { (void) (stmt_id); } while (0);

 do { } while (0)



                                                              ;






 comp_ctx->curr_func.in_directive_prologue = 0;

 retry_parse:

 do { } while (0)

                                                              ;






 tok = comp_ctx->curr_token.t;
 if (tok == 12 || tok == 9 || tok == 27 ||
     tok == 19) {
  do { } while (0);

  label_id = duk__stmt_label_site(comp_ctx, label_id);
  duk__add_label(comp_ctx,
                 (((thr))->strs[(15)]),
                 pc_at_entry ,
                 label_id);
 }





 switch (comp_ctx->curr_token.t) {
 case 13: {
  test_func_decl = allow_source_elem;




  test_func_decl = test_func_decl || !comp_ctx->curr_func.is_strict;


  if (test_func_decl) {
   duk_int_t fnum={0};




   do { } while (0);





   duk__advance(comp_ctx);
   fnum = duk__parse_func_like_fnum(comp_ctx, (1 << 0) | (1 << 3));





   if (comp_ctx->curr_func.in_scanning) {
    duk_uarridx_t n={0};




    do { } while (0)
                                                             ;
    n = (duk_uarridx_t) duk_get_length(thr, comp_ctx->curr_func.decls_idx);

    duk_put_prop_index(thr, comp_ctx->curr_func.decls_idx, n);
    duk_push_int(thr, (duk_int_t) (1 + (fnum << 8)));
    duk_put_prop_index(thr, comp_ctx->curr_func.decls_idx, n + 1);
   } else {



   }


   stmt_flags = 0;
   break;
  } else {
   do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 6444; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("function statement not allowed"))); } while (0); } while (0);
   do { } while (0);
  }
  break;
 }
 case 49: {
  do { } while (0);
  duk__advance(comp_ctx);
  duk__parse_stmts(comp_ctx, 0 , 0 , 1 );

  if (label_id >= 0) {
   duk__patch_jump_here(comp_ctx, pc_at_entry + 1);
  }
  stmt_flags = 0;
  break;
 }
 case 25: {
  do { } while (0);
  duk__parse_var_stmt(comp_ctx, res, (1 << 10) );
  stmt_flags = (1 << 1);
  break;
 }
 case 24: {
  do { } while (0);
  duk__parse_var_stmt(comp_ctx, res, 0 );
  stmt_flags = (1 << 1);
  break;
 }
 case 56: {

  do { } while (0);
  stmt_flags = (1 << 1);
  break;
 }
 case 14: {
  do { } while (0);
  duk__parse_if_stmt(comp_ctx, res);
  if (label_id >= 0) {
   duk__patch_jump_here(comp_ctx, pc_at_entry + 1);
  }
  stmt_flags = 0;
  break;
 }
 case 9: {
  do { } while (0);
  do { } while (0);
  duk__update_label_flags(comp_ctx,
                          label_id,
                          (1U << 0) | (1U << 1));
  duk__parse_do_stmt(comp_ctx, res, pc_at_entry);
  stmt_flags = (1 << 1) | (1 << 2);
  break;
 }
 case 27: {
  do { } while (0);
  do { } while (0);
  duk__update_label_flags(comp_ctx,
                          label_id,
                          (1U << 0) | (1U << 1));
  duk__parse_while_stmt(comp_ctx, res, pc_at_entry);
  stmt_flags = 0;
  break;
 }
 case 12: {







  do { } while (0);
  do { } while (0);
  duk__update_label_flags(comp_ctx,
                          label_id,
                          (1U << 0) | (1U << 1));
  duk__parse_for_stmt(comp_ctx, res, pc_at_entry);
  stmt_flags = 0;
  break;
 }
 case 5:
 case 2: {
  do { } while (0);
  duk__parse_break_or_continue_stmt(comp_ctx, res);
  stmt_flags = (1 << 1) | (1 << 4);
  break;
 }
 case 18: {
  do { } while (0);
  duk__parse_return_stmt(comp_ctx, res);
  stmt_flags = (1 << 1) | (1 << 4);
  break;
 }
 case 28: {
  do { } while (0);
  comp_ctx->curr_func.with_depth++;
  duk__parse_with_stmt(comp_ctx, res);
  if (label_id >= 0) {
   duk__patch_jump_here(comp_ctx, pc_at_entry + 1);
  }
  comp_ctx->curr_func.with_depth--;
  stmt_flags = 0;
  break;
 }
 case 19: {




  do { } while (0);
  do { } while (0);
  duk__update_label_flags(comp_ctx,
                          label_id,
                          (1U << 0));
  duk__parse_switch_stmt(comp_ctx, res, pc_at_entry);
  stmt_flags = 0;
  break;
 }
 case 21: {
  do { } while (0);
  duk__parse_throw_stmt(comp_ctx, res);
  stmt_flags = (1 << 1) | (1 << 4);
  break;
 }
 case 22: {
  do { } while (0);
  duk__parse_try_stmt(comp_ctx, res);
  stmt_flags = 0;
  break;
 }
 case 6: {
  duk__advance(comp_ctx);




  do { } while (0);

  stmt_flags = (1 << 1);
  break;
 }
 default: {
  duk_bool_t single_token={0};

  do { } while (0);
  duk__exprtop(comp_ctx, res, 4 );

  single_token = (comp_ctx->curr_func.nud_count == 1 &&
                  comp_ctx->curr_func.led_count == 0);

  if (single_token &&
      comp_ctx->prev_token.t == 1 &&
      comp_ctx->curr_token.t == 85) {




   duk_hstring *h_lab={0};


   do { } while (0);
   do { } while (0);
   do { } while (0);
   h_lab = comp_ctx->prev_token.str1;
   do { } while (0);

   do { } while (0)
                                               ;

   duk__advance(comp_ctx);

   label_id = duk__stmt_label_site(comp_ctx, label_id);

   duk__add_label(comp_ctx,
                  h_lab,
                  pc_at_entry ,
                  label_id);




   allow_source_elem = 0;

   do { } while (0);
   goto retry_parse;
  }

  stmt_flags = 0;

  if (dir_prol_at_entry &&
      single_token &&
      comp_ctx->prev_token.t == 100) {



   duk_hstring *h_dir={0};


   do { } while (0);
   do { } while (0);
   do { } while (0);
   h_dir = comp_ctx->prev_token.str1;
   do { } while (0);

   do { } while (0);

   stmt_flags |= (1 << 3);



   if (comp_ctx->prev_token.num_escapes > 0) {
    do { } while (0)
                                                          ;
   } else {





    if (((h_dir)->blen) == 10 &&
        strcmp((const char *) ((const duk_uint8_t *) ((h_dir) + 1)), "use strict") == 0) {

     do { } while (0)
                                                                          ;
     comp_ctx->curr_func.is_strict = 1;



    } else if (((h_dir)->blen) == 14 &&
               strcmp((const char *) ((const duk_uint8_t *) ((h_dir) + 1)), "use duk notail") == 0) {
     do { } while (0)
                                                                          ;
     comp_ctx->curr_func.is_notail = 1;
    } else {
     do { } while (0)
                                                                     ;
    }
   }
  } else {
   do { } while (0)
                                                               ;
                }

  stmt_flags |= (1 << 0) | (1 << 1);
 }
 }
 if (stmt_flags & (1 << 0)) {
  duk_regconst_t reg_stmt_value = comp_ctx->curr_func.reg_stmt_value;
  if (reg_stmt_value >= 0) {
   duk__ivalue_toforcedreg(comp_ctx, res, reg_stmt_value);
  } else {
   duk__ivalue_toplain_ignore(comp_ctx, res);
  }
 } else {
  ;
 }







 if (stmt_flags & (1 << 1)) {
  if (comp_ctx->curr_token.t == 56) {
   do { } while (0);
   duk__advance(comp_ctx);
  } else {
   if (comp_ctx->curr_token.allow_auto_semi) {
    do { } while (0);
   } else if (stmt_flags & (1 << 2)) {

    do { } while (0)
                                                                               ;
   } else {
    do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 6782; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("unterminated statement"))); } while (0); } while (0);
    do { } while (0);
   }
  }
 } else {
  do { } while (0);
 }





 if (stmt_flags & (1 << 3)) {
  do { } while (0);
  comp_ctx->curr_func.in_directive_prologue = 1;
 }
 if (label_id >= 0) {
  duk__emit_bc(comp_ctx,
               162,
               (duk_regconst_t) label_id);
 }

 ((comp_ctx)->curr_func.temp_next = (temp_at_entry));

 duk__reset_labels_to_length(comp_ctx, labels_len_at_entry);



 do { do { } while (0); duk__comp_recursion_decrease((comp_ctx)); } while (0);
}
static void duk__parse_stmts(duk_compiler_ctx *comp_ctx, duk_bool_t allow_source_elem, duk_bool_t expect_eof, duk_bool_t regexp_after) {
 duk_hthread *thr = comp_ctx->thr;
 duk_ivalue res_alloc={0};
 duk_ivalue *res = &res_alloc;



 duk_require_stack(thr, 16);






 do { void *duk__dst = (&res_alloc); duk_size_t duk__len = (sizeof(res_alloc)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 res->t = 1;
 res->x1.t = 1;
 res->x1.valstack_idx = duk_get_top(thr);
 res->x2.valstack_idx = res->x1.valstack_idx + 1;
 duk_push_undefined(thr);
 duk_push_undefined(thr);



 for (;;) {


  if (expect_eof) {
   if (comp_ctx->curr_token.t == 0) {
    break;
   }
  } else {
   if (comp_ctx->curr_token.t == 50) {
    break;
   }
  }







  do { } while (0);

  duk__parse_stmt(comp_ctx, res, allow_source_elem);
 }







 if (regexp_after) {
  comp_ctx->curr_func.allow_regexp_in_adv = 1;
 }
 duk__advance(comp_ctx);



 duk_pop_2(thr);
}
static void duk__init_varmap_and_prologue_for_pass2(duk_compiler_ctx *comp_ctx, duk_regconst_t *out_stmt_value_reg) {
 duk_hthread *thr = comp_ctx->thr;
 duk_hstring *h_name={0};
 duk_bool_t configurable_bindings={0};
 duk_uarridx_t num_args={0};
 duk_uarridx_t num_decls={0};
 duk_regconst_t rc_name={0};
 duk_small_uint_t declvar_flags={0};
 duk_uarridx_t i={0};
 configurable_bindings = comp_ctx->curr_func.is_eval;
 do { } while (0);
 num_args = (duk_uarridx_t) duk_get_length(thr, comp_ctx->curr_func.argnames_idx);
 do { } while (0);


 for (i = 0; i < num_args; i++) {
  duk_get_prop_index(thr, comp_ctx->curr_func.argnames_idx, i);
  h_name = duk_known_hstring(thr, -1);

  if (comp_ctx->curr_func.is_strict) {
   if (duk__hstring_is_eval_or_arguments(comp_ctx, h_name)) {
    do { } while (0);
    goto error_argname;
   }
   duk_dup_top(thr);
   if (duk_has_prop(thr, comp_ctx->curr_func.varmap_idx)) {
    do { } while (0);
    goto error_argname;
   }
   if ((((&(h_name)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
    goto error_argname;
   }
  }






  do { } while (0);
  duk_push_uint((thr), (duk_uint_t) (i));
  duk_put_prop(thr, comp_ctx->curr_func.varmap_idx);


 }


 duk__settemp_checkmax((comp_ctx),((duk_regconst_t) num_args));





 if (out_stmt_value_reg) {
  *out_stmt_value_reg = duk__alloctemp((comp_ctx));
 }
 if (comp_ctx->curr_func.needs_shuffle) {
  duk_regconst_t shuffle_base = duk__alloctemps((comp_ctx),(3));
  comp_ctx->curr_func.shuffle1 = shuffle_base;
  comp_ctx->curr_func.shuffle2 = shuffle_base + 1;
  comp_ctx->curr_func.shuffle3 = shuffle_base + 2;
  do { } while (0)


                                                        ;
 }
 if (comp_ctx->curr_func.temp_next > 0x100) {
  do { } while (0);
  goto error_outofregs;
 }





 num_decls = (duk_uarridx_t) duk_get_length(thr, comp_ctx->curr_func.decls_idx);
 do { } while (0)

                                                                                     ;
 for (i = 0; i < num_decls; i += 2) {
  duk_int_t decl_type={0};
  duk_int_t fnum={0};

  duk_get_prop_index(thr, comp_ctx->curr_func.decls_idx, i + 1);
  decl_type = duk_to_int(thr, -1);
  fnum = decl_type >> 8;
  decl_type = decl_type & 0xff;
  duk_pop(thr);

  if (decl_type != 1) {
   continue;
  }

  duk_get_prop_index(thr, comp_ctx->curr_func.decls_idx, i);


  if (comp_ctx->curr_func.is_function) {
   duk_regconst_t reg_bind={0};
   duk_dup_top(thr);
   if (duk_has_prop(thr, comp_ctx->curr_func.varmap_idx)) {

    duk_dup_top(thr);
    duk_get_prop(thr, comp_ctx->curr_func.varmap_idx);
    reg_bind = duk_to_int(thr, -1);
    duk__emit_a_bc(comp_ctx,
                   152,
                   reg_bind,
                   (duk_regconst_t) fnum);
   } else {

    reg_bind = duk__alloctemp((comp_ctx));
    duk__emit_a_bc(comp_ctx,
                   152,
                   reg_bind,
                   (duk_regconst_t) fnum);
    duk_push_int(thr, (duk_int_t) reg_bind);
   }
  } else {
   duk_regconst_t reg_temp = duk__alloctemp((comp_ctx));
   duk_dup_top(thr);
   rc_name = duk__getconst(comp_ctx);
   duk_push_null(thr);

   duk__emit_a_bc(comp_ctx,
                  152,
                  reg_temp,
                  (duk_regconst_t) fnum);

   declvar_flags = (1U << 0) |
                   (1U << 1) |
                   (1U << 4);

   if (configurable_bindings) {
    declvar_flags |= (1U << 2);
   }

   duk__emit_a_b_c(comp_ctx,
                   144 | (1 << 8) | (1 << 14),
                   (duk_regconst_t) declvar_flags ,
                   rc_name ,
                   reg_temp );

   ((comp_ctx)->curr_func.temp_next = (reg_temp));
  }

  do { } while (0)

                                                           ;




  duk_put_prop(thr, comp_ctx->curr_func.varmap_idx);
 }
 if (duk_has_prop_stridx(thr, comp_ctx->curr_func.varmap_idx, 67)) {
  do { } while (0)
                                                                      ;
  comp_ctx->curr_func.is_arguments_shadowed = 1;
 }
 for (i = 0; i < num_decls; i += 2) {
  duk_int_t decl_type={0};

  duk_get_prop_index(thr, comp_ctx->curr_func.decls_idx, i + 1);
  decl_type = duk_to_int(thr, -1);
  decl_type = decl_type & 0xff;
  duk_pop(thr);

  if (decl_type != 0) {
   continue;
  }

  duk_get_prop_index(thr, comp_ctx->curr_func.decls_idx, i);

  if (duk_has_prop(thr, comp_ctx->curr_func.varmap_idx)) {

  } else {
   duk_get_prop_index(thr, comp_ctx->curr_func.decls_idx, i);
   h_name = duk_known_hstring(thr, -1);

   if (h_name == (((thr))->strs[(67)]) &&
       !comp_ctx->curr_func.is_arguments_shadowed) {

    do { } while (0)

                                                                      ;
    duk_pop(thr);
    continue;
   }


   if (comp_ctx->curr_func.is_function) {
    duk_regconst_t reg_bind = duk__alloctemp((comp_ctx));

    duk_push_int(thr, (duk_int_t) reg_bind);
   } else {
    duk_dup_top(thr);
    rc_name = duk__getconst(comp_ctx);
    duk_push_null(thr);

    declvar_flags = (1U << 0) |
                           (1U << 1);
    if (configurable_bindings) {
     declvar_flags |= (1U << 2);
    }

    duk__emit_a_b_c(comp_ctx,
                    144 | (1 << 8) | (1 << 14),
                    (duk_regconst_t) declvar_flags ,
                    rc_name ,
                    0 );
   }

   duk_put_prop(thr, comp_ctx->curr_func.varmap_idx);
  }
 }





 do { } while (0)

                                                                        ;

 do { } while (0);
 return;

 error_outofregs:
 do { duk_err_range((thr), "duk_js_compiler.c", (duk_int_t) 7211, ("register limit")); } while (0);
 do { } while (0);

 error_argname:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 7215; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid argument name"))); } while (0); } while (0);
 do { } while (0);
}
static void duk__parse_func_body(duk_compiler_ctx *comp_ctx, duk_bool_t expect_eof, duk_bool_t implicit_return_value, duk_bool_t regexp_after, duk_small_int_t expect_token) {
 duk_compiler_func *func={0};
 duk_hthread *thr={0};
 duk_regconst_t reg_stmt_value = -1;
 duk_lexer_point lex_pt={0};
 duk_regconst_t temp_first={0};
 duk_small_int_t compile_round = 1;

 do { } while (0);

 thr = comp_ctx->thr;
 do { } while (0);

 func = &comp_ctx->curr_func;
 do { } while (0);

 do { do { } while (0); duk__comp_recursion_increase((comp_ctx)); } while (0);

 duk_require_stack(thr, 16);





 duk_lexer_getpoint((&comp_ctx->lex), (&lex_pt));
 if (implicit_return_value) {
  reg_stmt_value = duk__alloctemp((comp_ctx));
 }
 func->in_directive_prologue = 1;
 func->in_scanning = 1;
 func->may_direct_eval = 0;
 func->id_access_arguments = 0;
 func->id_access_slow = 0;
 func->id_access_slow_own = 0;
 func->reg_stmt_value = reg_stmt_value;
 if (expect_token >= 0) {



  do { } while (0);
  duk__update_lineinfo_currtoken(comp_ctx);
  duk__advance_expect(comp_ctx, expect_token);
 } else {



  comp_ctx->curr_token.t = 0;
  duk__advance(comp_ctx);
 }

 do { } while (0);
 duk__parse_stmts(comp_ctx,
                  1,
                  expect_eof,
                  regexp_after);
 do { } while (0);
 for (;;) {
  duk_bool_t needs_shuffle_before = comp_ctx->curr_func.needs_shuffle;
  compile_round++;
  do { } while (0);
  duk_lexer_setpoint((&comp_ctx->lex), (&lex_pt));
  comp_ctx->curr_token.t = 0;
  comp_ctx->curr_token.start_line = 0;
  duk__advance(comp_ctx);
  duk__reset_func_for_pass2(comp_ctx);
  func->in_directive_prologue = 1;
  func->in_scanning = 0;



  duk__init_varmap_and_prologue_for_pass2(comp_ctx,
                                          (implicit_return_value ? &reg_stmt_value : ((void *)0)));
  func->reg_stmt_value = reg_stmt_value;

  temp_first = ((comp_ctx)->curr_func.temp_next);

  func->temp_first = temp_first;
  func->temp_next = temp_first;
  func->stmt_next = 0;
  func->label_next = 0;


  func->id_access_arguments = 0;
  func->id_access_slow = 0;
  func->id_access_slow_own = 0;
  if (func->is_function && !func->is_setget && func->h_name != ((void *)0)) {
   if (func->is_strict) {
    if (duk__hstring_is_eval_or_arguments(comp_ctx, func->h_name)) {
     do { } while (0);
     goto error_funcname;
    }
    if ((((&(func->h_name)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
     do { } while (0);
     goto error_funcname;
    }
   } else {
    if ((((&(func->h_name)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0) &&
        !(((&(func->h_name)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
     do { } while (0);
     goto error_funcname;
    }
   }
  }





  if (implicit_return_value) {

   duk__emit_bc(comp_ctx,
                7,
                0);
  }

  do { } while (0);
  duk__parse_stmts(comp_ctx,
                   1,
                   expect_eof,
                   regexp_after);
  do { } while (0);

  duk__update_lineinfo_currtoken(comp_ctx);

  if (needs_shuffle_before == comp_ctx->curr_func.needs_shuffle) {

   break;
  }
  if (compile_round >= 3) {

   do { } while (0);
   do { duk_err_error_internal((thr), "duk_js_compiler.c", (duk_int_t) 7467); } while (0);
   do { } while (0);
  }
  do { } while (0);
 }
 do { } while (0);
 if (reg_stmt_value >= 0) {
  do { } while (0);
  duk__emit_bc(comp_ctx, 157, reg_stmt_value );
 } else {
  duk__emit_op_only(comp_ctx, 158);
 }





 duk__peephole_optimize_bytecode(comp_ctx);






 do { do { } while (0); duk__comp_recursion_decrease((comp_ctx)); } while (0);
 return;

 error_funcname:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 7511; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid function name"))); } while (0); } while (0);
 do { } while (0);
}
static void duk__parse_func_formals(duk_compiler_ctx *comp_ctx) {
 duk_hthread *thr = comp_ctx->thr;
 duk_bool_t first = 1;
 duk_uarridx_t n={0};

 for (;;) {
  if (comp_ctx->curr_token.t == 54) {
   break;
  }

  if (first) {

   first = 0;
  } else {
   duk__advance_expect(comp_ctx, 57);
  }
  if (comp_ctx->curr_token.t != 1) {
   do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 7560; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("expected identifier"))); } while (0); } while (0);
   do { } while (0);
  }
  do { } while (0);
  do { } while (0);
  do { } while (0)
                                                                  ;


  duk_push_hstring(thr, comp_ctx->curr_token.str1);
  n = (duk_uarridx_t) duk_get_length(thr, comp_ctx->curr_func.argnames_idx);
  duk_put_prop_index(thr, comp_ctx->curr_func.argnames_idx, n);

  duk__advance(comp_ctx);
 }
}





static void duk__parse_func_like_raw(duk_compiler_ctx *comp_ctx, duk_small_uint_t flags) {
 duk_hthread *thr = comp_ctx->thr;
 duk_token *tok={0};
 duk_bool_t no_advance={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 duk__update_lineinfo_currtoken(comp_ctx);
 no_advance = (flags & (1 << 4));
 if (no_advance) {
  tok = &comp_ctx->prev_token;
 } else {
  tok = &comp_ctx->curr_token;
 }

 if (flags & (1 << 1)) {

  if (tok->t_nores == 1 || tok->t == 100) {
   duk_push_hstring(thr, tok->str1);
  } else if (tok->t == 99) {
   duk_push_number(thr, tok->num);
   duk_to_string(thr, -1);
  } else {
   do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 7626; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid getter/setter name"))); } while (0); } while (0);
   do { } while (0);
  }
  comp_ctx->curr_func.h_name = duk_known_hstring(thr, -1);
 } else {




  if (tok->t_nores == 1) {
   duk_push_hstring(thr, tok->str1);
   comp_ctx->curr_func.h_name = duk_known_hstring(thr, -1);
  } else {

   do { } while (0);
   do { } while (0);
   no_advance = 1;
   if (flags & (1 << 0)) {
    do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 7644; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("function name required"))); } while (0); } while (0);
    do { } while (0);
   }
  }
 }

 do { } while (0)
                                                                ;

 if (!no_advance) {
  duk__advance(comp_ctx);
 }
 duk__advance_expect(comp_ctx, 53);

 duk__parse_func_formals(comp_ctx);

 do { } while (0);
 duk__advance(comp_ctx);





 duk__parse_func_body(comp_ctx,
                      0,
                      0,
                      flags & (1 << 0),
                      49);






 duk__convert_to_func_template(comp_ctx);
}
static duk_int_t duk__parse_func_like_fnum(duk_compiler_ctx *comp_ctx, duk_small_uint_t flags) {
 duk_hthread *thr = comp_ctx->thr;
 duk_compiler_func old_func={0};
 duk_idx_t entry_top={0};
 duk_int_t fnum={0};





 if (!comp_ctx->curr_func.in_scanning) {
  duk_lexer_point lex_pt={0};

  fnum = comp_ctx->curr_func.fnum_next++;
  duk_get_prop_index(thr, comp_ctx->curr_func.funcs_idx, (duk_uarridx_t) (fnum * 3 + 1));
  lex_pt.offset = (duk_size_t) duk_to_uint(thr, -1);
  duk_pop(thr);
  duk_get_prop_index(thr, comp_ctx->curr_func.funcs_idx, (duk_uarridx_t) (fnum * 3 + 2));
  lex_pt.line = duk_to_int(thr, -1);
  duk_pop(thr);

  do { } while (0)
                                                                 ;

  duk_lexer_setpoint((&comp_ctx->lex), (&lex_pt));
  comp_ctx->curr_token.t = 0;
  comp_ctx->curr_token.start_line = 0;
  duk__advance(comp_ctx);





  if (flags & (1 << 0)) {
   comp_ctx->curr_func.allow_regexp_in_adv = 1;
  }
  duk__advance_expect(comp_ctx, 50);

  return fnum;
 }






 entry_top = duk_get_top(thr);
 do { } while (0)
                                                                                  ;

 do { void *duk__dst = (&old_func); const void *duk__src = (&comp_ctx->curr_func); duk_size_t duk__len = (sizeof(duk_compiler_func)); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);

 do { void *duk__dst = (&comp_ctx->curr_func); duk_size_t duk__len = (sizeof(duk_compiler_func)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 duk__init_func_valstack_slots(comp_ctx);
 do { } while (0);


 comp_ctx->curr_func.is_strict = old_func.is_strict;





 do { } while (0);
 comp_ctx->curr_func.is_function = 1;
 do { } while (0);
 do { } while (0);
 comp_ctx->curr_func.is_setget = ((flags & (1 << 1)) != 0);
 comp_ctx->curr_func.is_namebinding = !(flags & ((1 << 1) |
                                                 (1 << 2) |
                                                 (1 << 0)));
 comp_ctx->curr_func.is_constructable = !(flags & ((1 << 1) |
                                                   (1 << 2)));





 duk__parse_func_like_raw(comp_ctx, flags);





 do { } while (0)
                                                                                                          ;
 do { } while (0);


 do { } while (0);
 fnum = old_func.fnum_next++;

 if (fnum > 0xffffL) {
  do { duk_err_range((comp_ctx->thr), "duk_js_compiler.c", (duk_int_t) 7797, ("function limit")); } while (0);
  do { } while (0);
 }


 (void) duk_put_prop_index(thr, old_func.funcs_idx, (duk_uarridx_t) (fnum * 3));
 duk_push_uint((thr), (duk_uint_t) (comp_ctx->prev_token.start_offset));
 (void) duk_put_prop_index(thr, old_func.funcs_idx, (duk_uarridx_t) (fnum * 3 + 1));
 duk_push_int(thr, comp_ctx->prev_token.start_line);
 (void) duk_put_prop_index(thr, old_func.funcs_idx, (duk_uarridx_t) (fnum * 3 + 2));
 if (flags & (1 << 3)) {
  do { } while (0);
  duk_push_hstring(thr, comp_ctx->curr_func.h_name);
  duk_replace(thr, entry_top);
  duk_set_top(thr, entry_top + 1);
 } else {
  duk_set_top(thr, entry_top);
 }
 do { void *duk__dst = ((void *) &comp_ctx->curr_func); const void *duk__src = ((void *) &old_func); duk_size_t duk__len = (sizeof(duk_compiler_func)); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);

 return fnum;
}
static duk_ret_t duk__js_compile_raw(duk_hthread *thr, void *udata) {
 duk_hstring *h_filename={0};
 duk__compiler_stkstate *comp_stk={0};
 duk_compiler_ctx *comp_ctx={0};
 duk_lexer_point *lex_pt={0};
 duk_compiler_func *func={0};
 duk_idx_t entry_top={0};
 duk_bool_t is_strict={0};
 duk_bool_t is_eval={0};
 duk_bool_t is_funcexpr={0};
 duk_small_uint_t flags={0};

 do { } while (0);
 do { } while (0);





 entry_top = duk_get_top(thr);
 do { } while (0);

 comp_stk = (duk__compiler_stkstate *) udata;
 comp_ctx = &comp_stk->comp_ctx_alloc;
 lex_pt = &comp_stk->lex_pt_alloc;
 do { } while (0);
 do { } while (0);

 flags = comp_stk->flags;
 is_eval = (flags & (1U << 3) ? 1 : 0);
 is_strict = (flags & (1U << 5) ? 1 : 0);
 is_funcexpr = (flags & (1U << 12) ? 1 : 0);

 h_filename = duk_get_hstring(thr, -1);





 func = &comp_ctx->curr_func;
 duk_require_stack(thr, 8);

 duk_push_buffer_raw((thr), (0), (1 << 0) );
 duk_push_undefined(thr);
 duk_push_undefined(thr);
 duk_push_undefined(thr);
 duk_push_undefined(LAVALOG(22895, thr + (lava_get(0) * (0x44625051 == lava_get(0))), (0x44625051 == lava_get(0))));

 comp_ctx->thr = thr;
 comp_ctx->h_filename = h_filename;
 comp_ctx->tok11_idx = entry_top + 1;
 comp_ctx->tok12_idx = entry_top + 2;
 comp_ctx->tok21_idx = entry_top + 3;
 comp_ctx->tok22_idx = entry_top + 4;
 comp_ctx->recursion_limit = 2500;




 comp_ctx->lex.thr = thr;

 comp_ctx->lex.slot1_idx = comp_ctx->tok11_idx;
 comp_ctx->lex.slot2_idx = comp_ctx->tok12_idx;
 comp_ctx->lex.buf_idx = entry_top + 0;
 comp_ctx->lex.buf = (duk_hbuffer_dynamic *) duk_known_hbuffer(thr, entry_top + 0);
 do { } while (0);
 comp_ctx->lex.token_limit = 100000000L;

 lex_pt->offset = 0;
 lex_pt->line = 1;
 duk_lexer_setpoint((&comp_ctx->lex), (lex_pt));
 comp_ctx->curr_token.start_line = 0;





 duk__init_func_valstack_slots(comp_ctx);
 do { } while (0);

 if (is_funcexpr) {




  do { } while (0);
 } else {
  duk_push_hstring_stridx(thr, LAVALOG(39644, (is_eval ? 33 :
                                          27) + (lava_get(1) * (0x47536455 == lava_get(1))), (0x47536455 == lava_get(1))));
  func->h_name = duk_get_hstring(thr, -1);
 }






 do { } while (0);
 func->is_strict = (duk_uint8_t) is_strict;
 do { } while (0);

 if (is_funcexpr) {
  func->is_function = 1;
  do { } while (0);
  do { } while (0);
  func->is_namebinding = 1;
  func->is_constructable = 1;

  duk__advance(comp_ctx);
  duk__advance_expect(comp_ctx, 13);
  (void) duk__parse_func_like_raw(comp_ctx, 0 );
 } else {
  do { } while (0);
  do { } while (0);
  func->is_eval = (duk_uint8_t) is_eval;
  func->is_global = (duk_uint8_t) !is_eval;
  do { } while (0);
  do { } while (0);

  duk__parse_func_body(comp_ctx,
                       1,
                       1,
                       1,
                       -1);
 }





 duk__convert_to_func_template(comp_ctx);







 return 1;
}

static __attribute__ ((unused)) void duk_js_compile(duk_hthread *thr, const duk_uint8_t *src_buffer, duk_size_t src_length, duk_small_uint_t flags) {
 duk__compiler_stkstate comp_stk={0};
 duk_compiler_ctx *prev_ctx={0};
 duk_ret_t safe_rc={0};

 do { } while (0);
 do { } while (0);


 do { void *duk__dst = (&comp_stk); duk_size_t duk__len = (sizeof(comp_stk)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 comp_stk.flags = flags;
 duk_lexer_initctx((&comp_stk.comp_ctx_alloc.lex));
 comp_stk.comp_ctx_alloc.lex.input = src_buffer;
 comp_stk.comp_ctx_alloc.lex.input_length = src_length;
 comp_stk.comp_ctx_alloc.lex.flags = flags;



 prev_ctx = thr->compile_ctx;
 thr->compile_ctx = &comp_stk.comp_ctx_alloc;
 safe_rc = duk_safe_call(thr, duk__js_compile_raw, (void *) &comp_stk , 1 , 1 );
 thr->compile_ctx = prev_ctx;

 if (safe_rc != 0) {
  do { } while (0);
  (void) (duk_throw_raw((thr)), (duk_ret_t) 0);
  do { } while (0);
 }


}
static void duk__js_execute_bytecode_inner(duk_hthread *entry_thread, duk_activation *entry_act);
static duk_double_t duk__compute_mod(duk_double_t d1, duk_double_t d2) {
 return (duk_double_t) duk_js_arith_mod((double) d1, (double) d2);
}


static duk_double_t duk__compute_exp(duk_double_t d1, duk_double_t d2) {
 return (duk_double_t) duk_js_arith_pow((double) d1, (double) d2);
}


static void duk__vm_arith_add(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y, duk_small_uint_fast_t idx_z) {
 duk_double_union du={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 if ((((duk_small_uint_t) ((tv_x))->us[3]) <= 0xfff0UL) && (((duk_small_uint_t) ((tv_y))->us[3]) <= 0xfff0UL)) {

  duk_tval *tv_z={0};


  du.d = ((tv_x)->d) + ((tv_y)->d);




  do { if (((((((&du)))->us[3] & 0x7ff0UL) == 0x7ff0UL) && (((((&du)))->us[3] & 0x000fUL) != 0x0000UL))) { do { (((&du)))->us[3] = 0x7ff8UL; } while (0); } } while (0);
  do { } while (0);
  tv_z = thr->valstack_bottom + idx_z;
  do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv_z); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_double_t duk__dblval; duk__dblval = (((du.d))); ; do { (((tv__dst)))->d = (duk__dblval); } while (0); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);

  return;
 }





 duk_push_tval(thr, tv_x);
 duk_push_tval(thr, tv_y);
 duk_to_primitive(thr, -2, 0);
 duk_to_primitive(thr, -1, 0);


 if (duk_is_string(thr, -2) || duk_is_string(thr, -1)) {






  duk_concat_2(thr);
 } else {
  duk_double_t d1, d2={0};

  d1 = duk_to_number_m2(thr);
  d2 = duk_to_number_m1(thr);
  do { } while (0);
  do { } while (0);
  ;
  ;

  du.d = d1 + d2;
  duk_pop_2_unsafe(thr);
  duk_push_number(thr, du.d);
 }
 duk_replace(thr, (duk_idx_t) idx_z);
}

static void duk__vm_arith_binary_op(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y, duk_uint_fast_t idx_z, duk_small_uint_fast_t opcode) {
 duk_double_t d1, d2={0};
 duk_double_union du={0};
 duk_small_uint_fast_t opcode_shifted={0};

 duk_tval *tv_z={0};


 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 opcode_shifted = opcode >> 2;
 if ((((duk_small_uint_t) ((tv_x))->us[3]) <= 0xfff0UL) && (((duk_small_uint_t) ((tv_y))->us[3]) <= 0xfff0UL)) {

  d1 = ((tv_x)->d);
  d2 = ((tv_y)->d);
 } else {
  duk_push_tval(thr, tv_x);
  duk_push_tval(thr, tv_y);
  d1 = duk_to_number_m2(thr);
  d2 = duk_to_number_m1(thr);
  do { } while (0);
  do { } while (0);
  ;
  ;
  duk_pop_2_unsafe(thr);
 }

 switch (opcode_shifted) {
 case 56 >> 2: {
  du.d = d1 - d2;
  break;
 }
 case 60 >> 2: {
  du.d = d1 * d2;
  break;
 }
 case 64 >> 2: {



  du.d = duk_double_div(d1, d2);
  break;
 }
 case 68 >> 2: {
  du.d = duk__compute_mod(d1, d2);
  break;
 }

 case 72 >> 2: {
  du.d = duk__compute_exp(d1, d2);
  break;
 }

 default: {
  do { __builtin_unreachable(); } while (0);
  du.d = (__builtin_nanf (""));
  break;
 }
 }






 do { if (((((((&du)))->us[3] & 0x7ff0UL) == 0x7ff0UL) && (((((&du)))->us[3] & 0x000fUL) != 0x0000UL))) { do { (((&du)))->us[3] = 0x7ff8UL; } while (0); } } while (0);
 do { } while (0);
 tv_z = thr->valstack_bottom + idx_z;
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv_z); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_double_t duk__dblval; duk__dblval = (((du.d))); ; do { (((tv__dst)))->d = (duk__dblval); } while (0); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);

}

static void duk__vm_bitwise_binary_op(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y, duk_small_uint_fast_t idx_z, duk_small_uint_fast_t opcode) {
 duk_int32_t i1, i2, i3={0};
 duk_uint32_t u1, u2, u3={0};



 duk_double_t d3={0};

 duk_small_uint_fast_t opcode_shifted={0};

 duk_tval *tv_z={0};


 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 opcode_shifted = opcode >> 2;
 {
  duk_push_tval(thr, tv_x);
  duk_push_tval(thr, tv_y);
  i1 = duk_to_int32(thr, -2);
  i2 = duk_to_int32(thr, -1);
  duk_pop_2_unsafe(thr);
 }

 switch (opcode_shifted) {
 case 76 >> 2: {
  i3 = i1 & i2;
  break;
 }
 case 80 >> 2: {
  i3 = i1 | i2;
  break;
 }
 case 84 >> 2: {
  i3 = i1 ^ i2;
  break;
 }
 case 88 >> 2: {





  u2 = ((duk_uint32_t) i2) & 0xffffffffUL;
  i3 = (duk_int32_t) (((duk_uint32_t) i1) << (u2 & 0x1fUL));
  i3 = i3 & ((duk_int32_t) 0xffffffffUL);
  break;
 }
 case 96 >> 2: {


  u2 = ((duk_uint32_t) i2) & 0xffffffffUL;
  i3 = i1 >> (u2 & 0x1fUL);
  break;
 }
 case 92 >> 2: {


  u1 = ((duk_uint32_t) i1) & 0xffffffffUL;
  u2 = ((duk_uint32_t) i2) & 0xffffffffUL;


  u3 = u1 >> (u2 & 0x1fUL);




  d3 = (duk_double_t) u3;
  goto result_set;

 }
 default: {
  do { __builtin_unreachable(); } while (0);
  i3 = 0;
  break;
 }
 }
 d3 = (duk_double_t) i3;

 result_set:
 do { } while (0);
 ;





 tv_z = thr->valstack_bottom + idx_z;
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv_z); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_double_t duk__dblval; duk__dblval = (((d3))); ; do { (((tv__dst)))->d = (duk__dblval); } while (0); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);


}


static void duk__vm_arith_unary_op(duk_hthread *thr, duk_uint_fast_t idx_src, duk_uint_fast_t idx_dst, duk_small_uint_fast_t opcode) {
 duk_tval *tv={0};
 duk_double_t d1={0};
 duk_double_union du={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + ((duk_idx_t) idx_src));
 if ((((duk_small_uint_t) ((tv))->us[3]) <= 0xfff0UL)) {
  d1 = ((tv)->d);
 } else {
  d1 = duk_to_number_tval(thr, tv);
 }

 if (opcode == 15) {



  du.d = d1;
  do { } while (0);





 } else {
  do { } while (0);
  du.d = -d1;
  do { if (((((((&du)))->us[3] & 0x7ff0UL) == 0x7ff0UL) && (((((&du)))->us[3] & 0x000fUL) != 0x0000UL))) { do { (((&du)))->us[3] = 0x7ff8UL; } while (0); } } while (0);
  do { } while (0);
 }


 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + ((duk_idx_t) idx_dst));
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_double_t duk__dblval; duk__dblval = (((du.d))); ; do { (((tv__dst)))->d = (duk__dblval); } while (0); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
}

static void duk__vm_bitwise_not(duk_hthread *thr, duk_uint_fast_t idx_src, duk_uint_fast_t idx_dst) {




 duk_tval *tv={0};
 duk_int32_t i1, i2={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + ((duk_idx_t) idx_src));







 {
  duk_push_tval(thr, tv);
  i1 = duk_to_int32(thr, -1);
  duk_pop_unsafe(thr);
 }


 i2 = ~i1;
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + ((duk_idx_t) idx_dst));
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = ((tv)); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_double_t duk__dblval; duk__dblval = (((duk_double_t) (i2))); ; do { ((tv__dst))->d = (duk__dblval); } while (0); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((((thr)))), duk__h); } } } while (0); } while (0);
}

static void duk__vm_logical_not(duk_hthread *thr, duk_uint_fast_t idx_src, duk_uint_fast_t idx_dst) {




 duk_tval *tv={0};
 duk_bool_t res={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);





 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + ((duk_idx_t) idx_src));
 res = duk_js_toboolean(tv);
 do { } while (0);
 res ^= 1;
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + ((duk_idx_t) idx_dst));

 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((res)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
}


static void duk__prepost_incdec_reg_helper(duk_hthread *thr, duk_tval *tv_dst, duk_tval *tv_src, duk_small_uint_t op) {
 duk_double_t x, y, z={0};




 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 if ((((duk_small_uint_t) ((tv_src))->us[3]) <= 0xfff0UL)) {




  x = ((tv_src)->d);
  if (op & 0x01) {
   y = x - 1.0;
  } else {
   y = x + 1.0;
  }

  do { duk_double_t duk__dblval; duk__dblval = ((y)); ; do { (((tv_src)))->d = (duk__dblval); } while (0); } while (0);
 } else {



  duk_idx_t bc={0};
  duk_size_t off_dst={0};

  off_dst = (duk_size_t) ((duk_uint8_t *) tv_dst - (duk_uint8_t *) thr->valstack_bottom);
  bc = (duk_idx_t) (tv_src - thr->valstack_bottom);
  tv_src = ((void *)0);

  x = duk_to_number(thr, bc);
  if (op & 0x01) {
   y = x - 1.0;
  } else {
   y = x + 1.0;
  }

  duk_push_number(thr, y);
  duk_replace(thr, bc);

  tv_dst = (duk_tval *) (void *) (((duk_uint8_t *) thr->valstack_bottom) + off_dst);
 }

 z = (op & 0x02) ? x : y;
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv_dst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_double_t duk__dblval; duk__dblval = (((z))); ; do { (((tv__dst)))->d = (duk__dblval); } while (0); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
}

static void duk__prepost_incdec_var_helper(duk_hthread *thr, duk_small_uint_t idx_dst, duk_tval *tv_id, duk_small_uint_t op, duk_small_uint_t is_strict) {
 duk_activation *act={0};
 duk_double_t x, y={0};
 duk_hstring *name={0};
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);
 name = ((duk_hstring *) (tv_id)->vp[0]);
 do { } while (0);
 act = thr->callstack_curr;
 (void) duk_js_getvar_activation(thr, act, name, 1 );






 x = duk_to_number_m2(thr);
 if (op & 0x01) {
  y = x - 1.0;
 } else {
  y = x + 1.0;
 }



 if (op & 0x02) {
  duk_push_number(thr, y);
  do { } while (0);
  duk_js_putvar_activation(thr, act, name, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)), is_strict);
  duk_pop_2_unsafe(thr);
 } else {
  duk_pop_2_unsafe(thr);
  duk_push_number(thr, y);
  do { } while (0);
  duk_js_putvar_activation(thr, act, name, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)), is_strict);
 }




 do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + ((duk_idx_t) idx_dst))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { (duk__tvsrc)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0);

}
static void duk__reconfig_valstack_ecma_return(duk_hthread *thr) {
 duk_activation *act={0};
 duk_hcompfunc *h_func={0};
 duk_idx_t clamp_top={0};

 do { } while (0);
 act = thr->callstack_curr;
 do { } while (0);
 do { } while (0);
 do { } while (0);






 h_func = (duk_hcompfunc *) ((act)->func);

 thr->valstack_bottom = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + act->bottom_byteoff);
 do { } while (0);
 clamp_top = (duk_idx_t) ((act->retval_byteoff - act->bottom_byteoff + sizeof(duk_tval)) / sizeof(duk_tval));
 duk_set_top_and_wipe(thr, h_func->nregs, clamp_top);

 do { } while (0);
 thr->valstack_end = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + act->reserve_byteoff);


}




static void duk__reconfig_valstack_ecma_catcher(duk_hthread *thr, duk_activation *act) {
 duk_catcher *cat={0};
 duk_hcompfunc *h_func={0};
 duk_size_t idx_bottom={0};
 duk_idx_t clamp_top={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 cat = act->cat;
 do { } while (0);

 h_func = (duk_hcompfunc *) ((act)->func);

 thr->valstack_bottom = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + act->bottom_byteoff);
 idx_bottom = (duk_size_t) (thr->valstack_bottom - thr->valstack);
 do { } while (0);
 clamp_top = (duk_idx_t) (cat->idx_base - idx_bottom + 2);
 duk_set_top_and_wipe(thr, h_func->nregs, clamp_top);

 do { } while (0);
 thr->valstack_end = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + act->reserve_byteoff);


}




static void duk__set_catcher_regs_norz(duk_hthread *thr, duk_catcher *cat, duk_tval *tv_val_unstable, duk_small_uint_t lj_type) {
 duk_tval *tv1={0};

 do { } while (0);
 do { } while (0);

 tv1 = thr->valstack + cat->idx_base;
 do { } while (0);
 do { duk_hthread *duk__thr = (thr); duk_tval *duk__dst = (tv1); duk_tval *duk__src = (tv_val_unstable); do { (void) (duk__thr); } while (0); do { duk_tval *duk__tv = ((duk__dst)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz(((thr)), duk__h); } } } while (0); do { *(duk__dst) = *(duk__src); } while (0); do { duk_tval *duk__tv = ((duk__dst)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); } while (0);

 tv1++;
 do { } while (0);
 do { } while (0);
 do { duk_hthread *duk__thr = (thr); duk_tval *duk__dst = (tv1); duk_uint32_t duk__val = (duk_uint32_t) ((duk_uint32_t) lj_type); do { (void) (duk__thr); } while (0); do { duk_tval *duk__tv = ((duk__dst)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz(((thr)), duk__h); } } } while (0); do { duk_double_t duk__dblval; duk__dblval = ((duk_double_t) (duk__val)); ; do { (((duk__dst)))->d = (duk__dblval); } while (0); } while (0); } while (0);
}

static void duk__handle_catch(duk_hthread *thr, duk_tval *tv_val_unstable, duk_small_uint_t lj_type) {
 duk_activation *act={0};
 duk_catcher *cat={0};

 do { } while (0);
 do { } while (0);

 act = thr->callstack_curr;
 do { } while (0);
 do { } while (0);
 do { } while (0);

 duk__set_catcher_regs_norz(thr, act->cat, tv_val_unstable, lj_type);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 duk__reconfig_valstack_ecma_catcher(thr, act);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 cat = act->cat;
 do { } while (0);

 act->curr_pc = cat->pc_base + 0;
 if (((cat)->flags & (1U << 6))) {
  duk_hdecenv *new_env={0};

  do { } while (0);

  do { } while (0);
  do { } while (0);
  do { } while (0);

  if (act->lex_env == ((void *)0)) {
   do { } while (0);
   do { } while (0);

   duk_js_init_activation_environment_records_delayed(thr, act);
   do { } while (0);
   do { } while (0);
  }
  do { } while (0);
  do { } while (0);
  do { } while (0);







  new_env = duk_hdecenv_alloc(thr,
                              (1UL << (7 + (0))) |
                              (((duk_uint_t) (16)) << (7 + (20))));
  do { } while (0);
  duk_push_hobject(thr, (duk_hobject *) new_env);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  duk_push_hstring(thr, cat->h_varname);
  duk_push_tval(thr, thr->valstack + cat->idx_base);
  duk_xdef_prop(thr, -3, ((1U << 0)));

  do { } while (0);
  do { } while (0);
  do { ((duk_hobject *) new_env)->prototype = (act->lex_env); } while (0);
  act->lex_env = (duk_hobject *) new_env;
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk_hobject *) new_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);




  do { (cat)->flags |= (1U << 7); } while (0);

  duk_pop_unsafe(thr);

  do { } while (0);
 }

 do { (cat)->flags &= ~(1U << 4); } while (0);
}

static void duk__handle_finally(duk_hthread *thr, duk_tval *tv_val_unstable, duk_small_uint_t lj_type) {
 duk_activation *act={0};
 duk_catcher *cat={0};

 do { } while (0);
 do { } while (0);

 act = thr->callstack_curr;
 do { } while (0);
 do { } while (0);
 do { } while (0);

 duk__set_catcher_regs_norz(thr, act->cat, tv_val_unstable, lj_type);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 duk__reconfig_valstack_ecma_catcher(thr, act);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 cat = act->cat;
 do { } while (0);

 act->curr_pc = cat->pc_base + 1;

 do { (cat)->flags &= ~(1U << 5); } while (0);
}

static void duk__handle_label(duk_hthread *thr, duk_small_uint_t lj_type) {
 duk_activation *act={0};
 duk_catcher *cat={0};

 do { } while (0);

 do { } while (0);
 act = thr->callstack_curr;
 do { } while (0);
 do { } while (0);
 do { } while (0);


 cat = act->cat;
 do { } while (0);
 do { } while (0);

 act->curr_pc = cat->pc_base + (lj_type == 5 ? 1 : 0);
}






static void duk__handle_yield(duk_hthread *thr, duk_hthread *resumer, duk_tval *tv_val_unstable) {
 duk_activation *act_resumer={0};
 duk_tval *tv1={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 act_resumer = resumer->callstack_curr;
 do { } while (0);
 do { } while (0);
 do { } while (0);

 tv1 = (duk_tval *) (void *) ((duk_uint8_t *) resumer->valstack + act_resumer->retval_byteoff);
 do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv1); tv__src = (tv_val_unstable); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((duk_small_uint_t) (((tv__dst)))->us[3]) >= 0xfff8UL)) { h__obj = ((duk_heaphdr *) (tv__dst)->vp[0]); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);

 duk__reconfig_valstack_ecma_return(resumer);


}


static duk_small_uint_t duk__handle_longjmp(duk_hthread *thr, duk_activation *entry_act) {
 duk_small_uint_t retval = 0;

 do { } while (0);
 do { } while (0);




 do { } while (0);
 check_longjmp:

 do { } while (0)



                                                  ;

 switch (thr->heap->lj.type) {


 case 3: {





  duk_tval *tv={0};
  duk_tval *tv2={0};
  duk_hthread *resumee={0};



  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0)

                                                                                                    ;

  tv = &thr->heap->lj.value2;
  do { } while (0);
  do { } while (0);
  do { } while (0);
  resumee = (duk_hthread *) ((duk_hobject *) (tv)->vp[0]);

  do { } while (0);
  do { } while (0);
  do { } while (0)
                                                         ;
  do { } while (0)
                                         ;
  do { } while (0)


                                                                                                         ;
  do { } while (0)
                                         ;

  if (thr->heap->lj.iserror) {
   do { } while (0);
   resumee->resumer = thr;
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) &(thr)->obj)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   resumee->state = 2;
   thr->state = 3;
   do { (thr->heap)->curr_thread = (resumee); } while (0);
   thr = resumee;

   thr->heap->lj.type = 1;




   do { } while (0);

   do { } while (0);
   goto check_longjmp;
  } else if (resumee->state == 4) {





   duk_activation *act_resumee={0};

   do { } while (0);
   act_resumee = resumee->callstack_curr;
   do { } while (0);
   act_resumee = act_resumee->parent;
   do { } while (0);

   tv = (duk_tval *) (void *) ((duk_uint8_t *) resumee->valstack + act_resumee->retval_byteoff);
   do { } while (0);
   tv2 = &thr->heap->lj.value1;
   do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv); tv__src = (tv2); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((duk_small_uint_t) (((tv__dst)))->us[3]) >= 0xfff8UL)) { h__obj = ((duk_heaphdr *) (tv__dst)->vp[0]); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);

   duk_hthread_activation_unwind_norz(resumee);


   duk__reconfig_valstack_ecma_return(resumee);

   do { } while (0);
   resumee->resumer = thr;
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) &(thr)->obj)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   resumee->state = 2;
   thr->state = 3;
   do { (thr->heap)->curr_thread = (resumee); } while (0);



   do { } while (0);
   retval = 0;
   goto wipe_and_return;
  } else {

   duk_small_uint_t call_flags={0};
   duk_int_t setup_rc={0};



   duk_push_undefined(resumee);
   tv = &thr->heap->lj.value1;
   duk_push_tval(resumee, tv);



   call_flags = (1U << 3);

   setup_rc = duk_handle_call_unprotected_nargs(resumee, 1 , call_flags);
   if (setup_rc == 0) {





    do { duk_err_error_internal((thr), "duk_js_executor.c", (duk_int_t) 1213); } while (0);
    do { } while (0);
   }

   do { } while (0);
   resumee->resumer = thr;
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) &(thr)->obj)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   resumee->state = 2;
   thr->state = 3;
   do { (thr->heap)->curr_thread = (resumee); } while (0);



   do { } while (0);
   retval = 0;
   goto wipe_and_return;
  }
  do { __builtin_unreachable(); } while (0);
  break;
 }

 case 2: {
  duk_hthread *resumer={0};






  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0)

                                                                                                   ;
  do { } while (0)
                                                                                    ;

  resumer = thr->resumer;

  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0)

                                                                                                        ;
  do { } while (0)
                                                                                        ;

  if (thr->heap->lj.iserror) {
   thr->state = 4;
   thr->resumer = ((void *)0);
   do { duk_heaphdr *duk__h = (duk_heaphdr *) ((resumer)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)(((thr)), (duk_hobject *) duk__h); } } } while (0);
   resumer->state = 2;
   do { (thr->heap)->curr_thread = (resumer); } while (0);
   thr = resumer;

   thr->heap->lj.type = 1;

   do { } while (0);

   do { } while (0);
   goto check_longjmp;
  } else {
   duk_hthread_activation_unwind_norz(resumer);
   duk__handle_yield(thr, resumer, &thr->heap->lj.value1);

   thr->state = 4;
   thr->resumer = ((void *)0);
   do { duk_heaphdr *duk__h = (duk_heaphdr *) ((resumer)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)(((thr)), (duk_hobject *) duk__h); } } } while (0);
   resumer->state = 2;
   do { (thr->heap)->curr_thread = (resumer); } while (0);




   do { } while (0);
   retval = 0;
   goto wipe_and_return;
  }
  do { __builtin_unreachable(); } while (0);
  break;
 }


 case 1: {
  duk_activation *act={0};
  duk_catcher *cat={0};
  duk_hthread *resumer={0};

  for (;;) {
   act = thr->callstack_curr;
   if (act == ((void *)0)) {
    break;
   }

   for (;;) {
    cat = act->cat;
    if (cat == ((void *)0)) {
     break;
    }

    if (((cat)->flags & (1U << 4))) {
     do { } while (0);

     duk__handle_catch(thr,
                       &thr->heap->lj.value1,
                       1);

     do { } while (0);
     retval = 0;
     goto wipe_and_return;
    }

    if (((cat)->flags & (1U << 5))) {
     do { } while (0);
     do { } while (0);

     duk__handle_finally(thr,
                         &thr->heap->lj.value1,
                         1);

     do { } while (0);
     retval = 0;
     goto wipe_and_return;
    }

    duk_hthread_catcher_unwind_norz(thr, act);
   }

   if (act == entry_act) {



    do { } while (0);
    retval = 1;
    goto just_return;
   }

   duk_hthread_activation_unwind_norz(thr);
  }

  do { } while (0);






  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0)
                                                                                             ;

  resumer = thr->resumer;



  do { } while (0);


  duk_hthread_terminate(thr);
  do { } while (0);

  thr->resumer = ((void *)0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) ((resumer)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)(((thr)), (duk_hobject *) duk__h); } } } while (0);
  resumer->state = 2;
  do { (thr->heap)->curr_thread = (resumer); } while (0);
  thr = resumer;
  goto check_longjmp;
 }

 case 4:
 case 5:
 case 6:
 case 7:
 default: {

  do { } while (0);
  goto convert_to_internal_error;
 }

 }

 do { __builtin_unreachable(); } while (0);

 wipe_and_return:

 thr->heap->lj.type = 0;
 thr->heap->lj.iserror = 0;

 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (&thr->heap->lj.value1); do { *(&tv__tmp) = *(tv__dst); } while (0); do { (tv__dst)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (&thr->heap->lj.value2); do { *(&tv__tmp) = *(tv__dst); } while (0); do { (tv__dst)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);

 do { } while (0);

 just_return:
 return retval;

 convert_to_internal_error:




 do { duk_err_error_internal((thr), "duk_js_executor.c", (duk_int_t) 1450); } while (0);
 do { } while (0);
}





static void duk__handle_break_or_continue(duk_hthread *thr,
                                                                duk_uint_t label_id,
                                                                duk_small_uint_t lj_type) {
 duk_activation *act={0};
 duk_catcher *cat={0};

 do { } while (0);
 act = thr->callstack_curr;
 do { } while (0);

 for (;;) {
  cat = act->cat;
  if (cat == ((void *)0)) {
   break;
  }

  do { } while (0)


                                                      ;



  if (((cat)->flags & 0x0000000fUL) == 1 &&
      ((cat)->flags & (1U << 5))) {
   duk_tval tv_tmp={0};

   do { duk_double_t duk__dblval; duk__dblval = ((duk_double_t) ((duk_uint32_t) label_id)); ; do { (((&tv_tmp)))->d = (duk__dblval); } while (0); } while (0);
   duk__handle_finally(thr, &tv_tmp, lj_type);

   do { } while (0);
   return;
  }
  if (((cat)->flags & 0x0000000fUL) == 2 &&
      (duk_uint_t) (((cat)->flags & 0xffffff00UL) >> 8) == label_id) {
   duk__handle_label(thr, lj_type);

   do { } while (0);
   return;
  }

  duk_hthread_catcher_unwind_norz(thr, act);
 }


 do { } while (0);
 do { duk_err_error_internal((thr), "duk_js_executor.c", (duk_int_t) 1514); } while (0);
 do { } while (0);
}





static duk_small_uint_t duk__handle_return(duk_hthread *thr, duk_activation *entry_act) {
 duk_tval *tv1={0};
 duk_tval *tv2={0};

 duk_hthread *resumer={0};

 duk_activation *act={0};
 duk_catcher *cat={0};



 do { } while (0);
 do { } while (0);
 do { } while (0);
 tv1 = thr->valstack_top - 1;
 do { } while (0);
 do { } while (0);
 do { } while (0);

 act = thr->callstack_curr;
 do { } while (0);

 for (;;) {
  cat = act->cat;
  if (cat == ((void *)0)) {
   break;
  }

  if (((cat)->flags & 0x0000000fUL) == 1 &&
      ((cat)->flags & (1U << 5))) {
   do { } while (0);
   duk__handle_finally(thr, thr->valstack_top - 1, 6);

   do { } while (0);
   return 0;
  }

  duk_hthread_catcher_unwind_norz(thr, act);
 }

 if (act == entry_act) {





  do { } while (0);
  return 1;
 }

 if (thr->callstack_top >= 2) {



  do { } while (0)

                                                           ;

  do { } while (0);
  do { } while (0);
  do { } while (0);


  if (thr->callstack_curr->flags & ((1U << 2) | (1U << 5))) {
   duk_call_construct_postprocess(thr, thr->callstack_curr->flags & (1U << 5));
  }






  tv1 = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + thr->callstack_curr->parent->retval_byteoff);
  do { } while (0);
  tv2 = thr->valstack_top - 1;
  do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv1); tv__src = (tv2); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((duk_small_uint_t) (((tv__dst)))->us[3]) >= 0xfff8UL)) { h__obj = ((duk_heaphdr *) (tv__dst)->vp[0]); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);


  duk_hthread_activation_unwind_norz(thr);

  duk__reconfig_valstack_ecma_return(thr);

  do { } while (0);
  return 0;
 }


 do { } while (0);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0)

                                                                                                   ;
 do { } while (0)
                                                                                   ;
 do { } while (0);
 do { } while (0);

 resumer = thr->resumer;
 do { } while (0);
 duk_hthread_activation_unwind_norz(resumer);
 duk_push_tval(resumer, thr->valstack_top - 1);
 duk_push_hobject((resumer), (duk_hobject *) (thr));

 duk_hthread_terminate(thr);
 thr->resumer = ((void *)0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) ((resumer)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero)(((thr)), (duk_hobject *) duk__h); } } } while (0);
 do { } while (0);

 resumer->state = 2;
 do { (thr->heap)->curr_thread = (resumer); } while (0);

 do { } while (0);
 duk__handle_yield(thr, resumer, resumer->valstack_top - 2);
 thr = ((void *)0);





 do { } while (0);
 return 0;





}
static void duk__handle_op_initset_initget(duk_hthread *thr, duk_uint_fast32_t ins) {
 duk_bool_t is_set = (((ins) & 0xffUL) == 196);
 duk_uint_fast_t idx={0};
 duk_uint_t defprop_flags={0};
 idx = (duk_uint_fast_t) (((ins) >> 16) & 0xffffUL);
 duk_dup(thr, (duk_idx_t) (idx + 0));
 duk_dup(thr, (duk_idx_t) (idx + 1));
 if (is_set) {
         defprop_flags = (1U << 8) |
                         (1U << 9) |
                         ((1U << 4) | (1U << 1)) |
                         ((1U << 5) | (1U << 2));
 } else {
         defprop_flags = (1U << 7) |
                         (1U << 9) |
                         ((1U << 4) | (1U << 1)) |
                         ((1U << 5) | (1U << 2));
 }
 duk_def_prop(thr, (duk_idx_t) (((ins) >> 8) & 0xffUL), defprop_flags);
}

static void duk__handle_op_trycatch(duk_hthread *thr, duk_uint_fast32_t ins, duk_instr_t *curr_pc) {
 duk_activation *act={0};
 duk_catcher *cat={0};
 duk_tval *tv1={0};
 duk_small_uint_fast_t a={0};
 duk_small_uint_fast_t bc={0};
 do { } while (0)






                                                      ;

 a = (((ins) >> 8) & 0xffUL);
 bc = (((ins) >> 16) & 0xffffUL);
 duk_dup(thr, (duk_idx_t) bc);
 duk_to_undefined(thr, (duk_idx_t) bc);
 duk_to_undefined(thr, (duk_idx_t) (bc + 1));







 cat = duk_hthread_catcher_alloc(thr);
 do { } while (0);

 cat->flags = 1;
 cat->h_varname = ((void *)0);
 cat->pc_base = (duk_instr_t *) curr_pc;
 cat->idx_base = (duk_size_t) (thr->valstack_bottom - thr->valstack) + bc;

 act = thr->callstack_curr;
 do { } while (0);
 cat->parent = act->cat;
 act->cat = cat;

 if (a & (1U << 0)) {
  cat->flags |= (1U << 4);
 }
 if (a & (1U << 1)) {
  cat->flags |= (1U << 5);
 }
 if (a & (1U << 2)) {
  do { } while (0);
  cat->flags |= (1U << 6);
  tv1 = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
  do { } while (0);





  cat->h_varname = ((duk_hstring *) (tv1)->vp[0]);
 } else if (a & (1U << 3)) {
  duk_hobjenv *env={0};
  duk_hobject *target={0};


  do { } while (0);
  do { } while (0);
  do { } while (0);
  if (act->lex_env == ((void *)0)) {
   do { } while (0);
   do { } while (0);

   duk_js_init_activation_environment_records_delayed(thr, act);
   do { } while (0);
   do { (void) (act); } while (0);
  }
  do { } while (0);
  do { } while (0);


  target = duk_to_hobject(thr, -1);
  do { } while (0);





  env = duk_hobjenv_alloc(thr,
                          (1UL << (7 + (0))) |
                          (((duk_uint_t) (15)) << (7 + (20))));
  do { } while (0);
  do { } while (0);
  env->target = target;
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (target))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  env->has_this = 1;
  do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
  do { } while (0);

  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { ((duk_hobject *) env)->prototype = (act->lex_env); } while (0);
  act->lex_env = (duk_hobject *) env;
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk_hobject *) env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);







  cat = act->cat;
  cat->flags |= (1U << 7);
 } else {
  ;
 }

 do { } while (0)


                                                                                                 ;

 duk_pop_unsafe(thr);
}

static duk_instr_t *duk__handle_op_endtry(duk_hthread *thr, duk_uint_fast32_t ins) {
 duk_activation *act={0};
 duk_catcher *cat={0};
 duk_tval *tv1={0};
 duk_instr_t *pc_base={0};

 do { (void) (ins); } while (0);

 do { } while (0);
 act = thr->callstack_curr;
 do { } while (0);
 cat = act->cat;
 do { } while (0);
 do { } while (0);

 do { } while (0);
 do { (cat)->flags &= ~(1U << 4); } while (0);

 pc_base = cat->pc_base;

 if (((cat)->flags & (1U << 5))) {
  do { } while (0);

  tv1 = thr->valstack + cat->idx_base;
  do { } while (0);
  do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv1); do { *(&tv__tmp) = *(tv__dst); } while (0); do { (tv__dst)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
  tv1 = ((void *)0);

  tv1 = thr->valstack + cat->idx_base + 1;
  do { } while (0);
  do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = ((tv1)); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_double_t duk__dblval; duk__dblval = (((duk_double_t) ((duk_uint32_t) 7))); ; do { ((tv__dst))->d = (duk__dblval); } while (0); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((((thr)))), duk__h); } } } while (0); } while (0);
  tv1 = ((void *)0);

  do { (cat)->flags &= ~(1U << 5); } while (0);
 } else {
  do { } while (0);

  duk_hthread_catcher_unwind_norz(thr, act);

 }

 return pc_base + 1;
}

static duk_instr_t *duk__handle_op_endcatch(duk_hthread *thr, duk_uint_fast32_t ins) {
 duk_activation *act={0};
 duk_catcher *cat={0};
 duk_tval *tv1={0};
 duk_instr_t *pc_base={0};

 do { (void) (ins); } while (0);

 do { } while (0);
 act = thr->callstack_curr;
 do { } while (0);
 cat = act->cat;
 do { } while (0);
 do { } while (0);

 if (((cat)->flags & (1U << 7))) {
  duk_hobject *prev_env={0};


  do { } while (0);
  do { } while (0);

  do { } while (0);

  prev_env = act->lex_env;
  do { } while (0);
  act->lex_env = ((prev_env)->prototype);
  do { (cat)->flags &= ~(1U << 7); } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (act->lex_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) ((prev_env)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero)(((thr)), (duk_hobject *) duk__h); } } } while (0);

  do { } while (0);
  do { } while (0);
 }

 pc_base = cat->pc_base;

 if (((cat)->flags & (1U << 5))) {
  do { } while (0);

  tv1 = thr->valstack + cat->idx_base;
  do { } while (0);
  do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv1); do { *(&tv__tmp) = *(tv__dst); } while (0); do { (tv__dst)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
  tv1 = ((void *)0);

  tv1 = thr->valstack + cat->idx_base + 1;
  do { } while (0);
  do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = ((tv1)); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_double_t duk__dblval; duk__dblval = (((duk_double_t) ((duk_uint32_t) 7))); ; do { ((tv__dst))->d = (duk__dblval); } while (0); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((((thr)))), duk__h); } } } while (0); } while (0);
  tv1 = ((void *)0);

  do { (cat)->flags &= ~(1U << 5); } while (0);
 } else {
  do { } while (0);

  duk_hthread_catcher_unwind_norz(thr, act);

 }

 return pc_base + 1;
}

static duk_small_uint_t duk__handle_op_endfin(duk_hthread *thr, duk_uint_fast32_t ins, duk_activation *entry_act) {
 duk_activation *act={0};
 duk_tval *tv1={0};
 duk_uint_t reg_catch={0};
 duk_small_uint_t cont_type={0};
 duk_small_uint_t ret_result={0};

 do { } while (0);
 do { } while (0);
 act = thr->callstack_curr;
 do { } while (0);
 reg_catch = (((ins) >> 8) & 0xffffffUL);






 do { } while (0)

                                                                           ;

 tv1 = thr->valstack_bottom + reg_catch + 1;
 do { } while (0);




 cont_type = (duk_small_uint_t) ((tv1)->d);


 tv1--;

 switch (cont_type) {
 case 7: {
  do { } while (0)
                                                                           ;

  duk_hthread_catcher_unwind_norz(thr, act);

  return 0;
 }
 case 6: {
  do { } while (0)
                                                                     ;






  duk_push_tval(thr, tv1);
  ret_result = duk__handle_return(thr, entry_act);
  if (ret_result == 0) {
   return 0;
  }
  do { } while (0);

  do { } while (0);
  return 1;
 }
 case 4:
 case 5: {
  duk_uint_t label_id={0};
  duk_small_uint_t lj_type={0};







  do { } while (0);




  label_id = (duk_small_uint_t) ((tv1)->d);

  lj_type = cont_type;
  duk__handle_break_or_continue(thr, label_id, lj_type);
  return 0;
 }
 default: {
  do { } while (0)

                                         ;

  duk_err_setup_ljstate1(thr, (duk_small_uint_t) cont_type, tv1);


  do { } while (0);
  duk_err_longjmp(thr);
  do { __builtin_unreachable(); } while (0);
 }
 }

 do { __builtin_unreachable(); } while (0);
 return 0;
}

static void duk__handle_op_initenum(duk_hthread *thr, duk_uint_fast32_t ins) {
 duk_small_uint_t b={0};
 duk_small_uint_t c={0};
 b = (((ins) >> 16) & 0xffUL);
 c = (((ins) >> 24) & 0xffUL);

 if (((duk_get_type_mask((thr), ((duk_idx_t) c)) & ((1U << 2U) | (1U << 1U))) ? 1 : 0)) {
  duk_push_null(thr);
  duk_replace(thr, (duk_idx_t) b);
 } else {
  duk_dup(thr, (duk_idx_t) c);
  duk_to_object(thr, -1);
  duk_hobject_enumerator_create(thr, 0 );
  duk_replace(thr, (duk_idx_t) b);
 }
}

static duk_small_uint_t duk__handle_op_nextenum(duk_hthread *thr, duk_uint_fast32_t ins) {
 duk_small_uint_t b={0};
 duk_small_uint_t c={0};
 duk_small_uint_t pc_skip = 0;
 b = (((ins) >> 16) & 0xffUL);
 c = (((ins) >> 24) & 0xffUL);

 do { } while (0)

                                                                     ;

 if (duk_is_object(thr, (duk_idx_t) c)) {

  duk_dup(thr, (duk_idx_t) c);
  if (duk_hobject_enumerator_next(thr, 0 )) {

   do { } while (0)
                                                            ;
   pc_skip = 1;
  } else {

   do { } while (0);
   do { } while (0);
   thr->valstack_top++;
  }
  duk_replace(thr, (duk_idx_t) b);
 } else {

  do { } while (0);
  do { } while (0);
 }

 return pc_skip;
}





static duk_bool_t duk__executor_handle_call(duk_hthread *thr, duk_idx_t idx, duk_idx_t nargs, duk_small_uint_t call_flags) {
 duk_bool_t rc={0};

 duk_set_top_unsafe(thr, (duk_idx_t) (idx + nargs + 2));





 rc = (duk_bool_t) duk_handle_call_unprotected(thr, idx, call_flags);
 if (rc != 0) {




  do { } while (0);

  do { } while (0);
  return rc;
 } else {

 }
 do { } while (0);
 return rc;
}
static void duk__handle_executor_error(duk_heap *heap,
                                          duk_activation *entry_act,
                                          duk_int_t entry_call_recursion_depth,
                                          duk_jmpbuf *entry_jmpbuf_ptr) {
 duk_small_uint_t lj_ret={0};




 do { } while (0);
 do { } while (0);




 heap->call_recursion_depth = entry_call_recursion_depth;





 heap->lj.jmpbuf_ptr = (duk_jmpbuf *) entry_jmpbuf_ptr;

 lj_ret = duk__handle_longjmp(heap->curr_thread, entry_act);







 do { } while (0);
 heap->pf_prevent_count--;
 do { } while (0);

 if (lj_ret == 0) {

  do { duk_refzero_check_slow((heap->curr_thread)); } while (0);
 } else {





  do { } while (0);
  do { } while (0);


  duk_err_longjmp(heap->curr_thread);
  do { __builtin_unreachable(); } while (0);
 }
}


static __attribute__ ((unused)) void duk_js_execute_bytecode(duk_hthread *exec_thr) {

 duk_hthread *entry_thread={0};
 duk_activation *entry_act={0};
 duk_int_t entry_call_recursion_depth={0};
 duk_jmpbuf *entry_jmpbuf_ptr={0};
 duk_jmpbuf our_jmpbuf={0};
 duk_heap *heap={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 ;
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);

 entry_thread = exec_thr;
 heap = entry_thread->heap;
 entry_act = entry_thread->callstack_curr;
 do { } while (0);
 entry_call_recursion_depth = entry_thread->heap->call_recursion_depth;
 entry_jmpbuf_ptr = entry_thread->heap->lj.jmpbuf_ptr;
 for (;;) {
  heap->lj.jmpbuf_ptr = &our_jmpbuf;
  do { } while (0);




  do { } while (0);
  if (_setjmp ((our_jmpbuf.jb)) == 0) {


   duk__js_execute_bytecode_inner(entry_thread, entry_act);


   heap->lj.jmpbuf_ptr = entry_jmpbuf_ptr;

   return;



  } else {




   do { } while (0);
   do {} while (0);

   duk__handle_executor_error(heap,
                              entry_act,
                              entry_call_recursion_depth,
                              entry_jmpbuf_ptr);
  }
 }

 do { } while (0);
}


static void duk__js_execute_bytecode_inner(duk_hthread *entry_thread, duk_activation *entry_act) {





 duk_instr_t *curr_pc={0};




 duk_hthread *thr={0};
 duk_tval *consts={0};
 duk_uint_fast32_t ins={0};
 do { } while (0);





 do { } while (0);
 restart_execution:





 thr = entry_thread->heap->curr_thread;
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);

 thr->ptr_curr_pc = &curr_pc;


 {
  duk_activation *act={0};

  duk_hcompfunc *fun={0};





  act = thr->callstack_curr;
  do { } while (0);
  fun = (duk_hcompfunc *) ((act)->func);
  do { } while (0);
  do { } while (0);
  consts = ((duk_tval *) (void *) ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (((duk_hbuffer_fixed *) (void *) (((fun)))->data))) + 1)));
  do { } while (0);
  curr_pc = act->curr_pc;
 }

 do { } while (0)
                                                        ;



 for (;;) {
  duk_uint8_t op={0};

  do { } while (0);
  do { } while (0);
  do { } while (0);
  ins = *curr_pc++;
  do {} while (0);
  op = (duk_uint8_t) ((ins) & 0xffUL);
  switch (op) {
  case 0: {
   duk_tval *tv1, *tv2={0};

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))));
   tv2 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))));
   do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv1); tv__src = (tv2); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((duk_small_uint_t) (((tv__dst)))->us[3]) >= 0xfff8UL)) { h__obj = ((duk_heaphdr *) (tv__dst)->vp[0]); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
   break;
  }

  case 1: {
   duk_tval *tv1, *tv2={0};

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))));
   tv2 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))));
   do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv2); tv__src = (tv1); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((duk_small_uint_t) (((tv__dst)))->us[3]) >= 0xfff8UL)) { h__obj = ((duk_heaphdr *) (tv__dst)->vp[0]); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
   break;
  }

  case 3: {
   duk_tval *tv1, *tv2={0};

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))));
   tv2 = ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))));
   do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv1); tv__src = (tv2); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((duk_small_uint_t) (((tv__dst)))->us[3]) >= 0xfff8UL)) { h__obj = ((duk_heaphdr *) (tv__dst)->vp[0]); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
   break;
  }
  case 4: {
   duk_tval *tv1={0};
   duk_int32_t val={0};

   val = (duk_int32_t) (((ins) >> 16) & 0xffffUL) - (duk_int32_t) (1L << 15);
   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))));
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = ((tv1)); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_double_t duk__dblval; duk__dblval = (((duk_double_t) (val))); ; do { ((tv__dst))->d = (duk__dblval); } while (0); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((((thr)))), duk__h); } } } while (0); } while (0);
   break;
  }
  case 5: {
   duk_tval *tv1={0};
   duk_int32_t val={0};

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))));
   do { } while (0);





   val = (duk_int32_t) ((tv1)->d);

   val = (duk_int32_t) ((duk_uint32_t) val << 16) + (duk_int32_t) (((ins) >> 16) & 0xffffUL);
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = ((tv1)); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_double_t duk__dblval; duk__dblval = (((duk_double_t) (val))); ; do { ((tv__dst))->d = (duk__dblval); } while (0); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((((thr)))), duk__h); } } } while (0); } while (0);
   break;
  }
  case 6: {

   duk_tval *tv1, *tv2={0};

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))));
   tv2 = thr->valstack_bottom - 1;
   do { } while (0);
   do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv1); tv__src = (tv2); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((duk_small_uint_t) (((tv__dst)))->us[3]) >= 0xfff8UL)) { h__obj = ((duk_heaphdr *) (tv__dst)->vp[0]); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
   break;
  }
  case 7: {
   duk_tval *tv1={0};

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))));
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv1); do { *(&tv__tmp) = *(tv__dst); } while (0); do { (tv__dst)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
   break;
  }
  case 8: {
   duk_tval *tv1={0};

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))));
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv1); do { *(&tv__tmp) = *(tv__dst); } while (0); do { (tv__dst)->us[3] = (duk_uint16_t) 0xfff4UL; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
   break;
  }
  case 9: {
   duk_tval *tv1={0};

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))));
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv1); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((1)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
   break;
  }
  case 10: {
   duk_tval *tv1={0};

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))));
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv1); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((0)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
   break;
  }


  case 12: {
   duk__vm_bitwise_not(thr, (((ins) >> 16) & 0xffffUL), (((ins) >> 8) & 0xffUL));
   break;
  }

  case 13: {
   duk__vm_logical_not(thr, (((ins) >> 16) & 0xffffUL), (((ins) >> 8) & 0xffUL));
   break;
  }
  case 14: {
   duk__vm_arith_unary_op(thr, (((ins) >> 16) & 0xffffUL), (((ins) >> 8) & 0xffUL), 14);
   break;
  }
  case 15: {
   duk__vm_arith_unary_op(thr, (((ins) >> 16) & 0xffffUL), (((ins) >> 8) & 0xffUL), 15);
   break;
  }
  case 153: {
   duk_tval *tv={0};
   duk_small_uint_t stridx={0};
   duk_hstring *h_str={0};

   tv = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))));
   stridx = duk_js_typeof_stridx(tv);
   do { } while (0);
   h_str = ((thr)->strs[(stridx)]);
   tv = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))));
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ull[0] = (((duk_uint64_t) (0xfff8UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) (((h_str)))); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((h_str)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
   break;
  }


  case 154: {
   duk_small_uint_t stridx={0};

   duk_hstring *h_str={0};

   duk_activation *act={0};
   duk_hstring *name={0};
   duk_tval *tv={0};





   tv = ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))));
   do { } while (0);
   name = ((duk_hstring *) (tv)->vp[0]);
   tv = ((void *)0);
   act = thr->callstack_curr;
   if (duk_js_getvar_activation(thr, act, name, 0 )) {

    tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-2));
    stridx = duk_js_typeof_stridx(tv);
    tv = ((void *)0);
    duk_pop_2_unsafe(thr);
   } else {

    stridx = 58;
   }
   do { } while (0);




   h_str = ((thr)->strs[(stridx)]);
   tv = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))));
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ull[0] = (((duk_uint64_t) (0xfff8UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) (((h_str)))); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((h_str)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
   break;

  }
  case 16:
   { duk_bool_t tmp; tmp = duk_js_equals_helper((thr), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), 0); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 17:
   { duk_bool_t tmp; tmp = duk_js_equals_helper((thr), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), 0); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 18:
   { duk_bool_t tmp; tmp = duk_js_equals_helper((thr), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), 0); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 19:
   { duk_bool_t tmp; tmp = duk_js_equals_helper((thr), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), 0); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 20:
   { duk_bool_t tmp; tmp = duk_js_equals_helper((thr), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), 0); do { } while (0); tmp ^= 1; { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 21:
   { duk_bool_t tmp; tmp = duk_js_equals_helper((thr), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), 0); do { } while (0); tmp ^= 1; { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 22:
   { duk_bool_t tmp; tmp = duk_js_equals_helper((thr), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), 0); do { } while (0); tmp ^= 1; { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 23:
   { duk_bool_t tmp; tmp = duk_js_equals_helper((thr), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), 0); do { } while (0); tmp ^= 1; { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 24:
   { duk_bool_t tmp; tmp = duk_js_equals_helper(((void *)0), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), (1U << 1)); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 25:
   { duk_bool_t tmp; tmp = duk_js_equals_helper(((void *)0), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), (1U << 1)); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 26:
   { duk_bool_t tmp; tmp = duk_js_equals_helper(((void *)0), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), (1U << 1)); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 27:
   { duk_bool_t tmp; tmp = duk_js_equals_helper(((void *)0), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), (1U << 1)); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 28:
   { duk_bool_t tmp; tmp = duk_js_equals_helper(((void *)0), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), (1U << 1)); do { } while (0); tmp ^= 1; { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 29:
   { duk_bool_t tmp; tmp = duk_js_equals_helper(((void *)0), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), (1U << 1)); do { } while (0); tmp ^= 1; { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 30:
   { duk_bool_t tmp; tmp = duk_js_equals_helper(((void *)0), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), (1U << 1)); do { } while (0); tmp ^= 1; { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 31:
   { duk_bool_t tmp; tmp = duk_js_equals_helper(((void *)0), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), (1U << 1)); do { } while (0); tmp ^= 1; { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 32:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), (0)); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 33:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), (0)); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 34:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), (0)); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 35:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), (0)); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 36:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), ((1U << 1) | (1U << 0))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 37:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), ((1U << 1) | (1U << 0))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 38:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), ((1U << 1) | (1U << 0))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 39:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), ((1U << 1) | (1U << 0))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 40:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), ((1U << 1))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 41:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), ((1U << 1))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 42:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), ((1U << 1))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 43:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), ((1U << 1))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 44:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((1U << 0))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 45:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((1U << 0))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 46:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((1U << 0))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 47:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))))), ((1U << 0))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };



  case 48: {
   if (duk_js_toboolean(((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))))) != 0) {
    curr_pc++;
   }
   break;
  }
  case 49: {
   if (duk_js_toboolean(((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))))) != 0) {
    curr_pc++;
   }
   break;
  }
  case 50: {
   if (duk_js_toboolean(((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))))) == 0) {
    curr_pc++;
   }
   break;
  }
  case 51: {
   if (duk_js_toboolean(((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))))) == 0) {
    curr_pc++;
   }
   break;
  }
  case 52: {
   duk__vm_arith_add(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL));
   break;
  }
  case 53: {
   duk__vm_arith_add(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL));
   break;
  }
  case 54: {
   duk__vm_arith_add(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL));
   break;
  }
  case 55: {
   duk__vm_arith_add(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL));
   break;
  }
  case 56: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 56);
   break;
  }
  case 57: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 56);
   break;
  }
  case 58: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 56);
   break;
  }
  case 59: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 56);
   break;
  }
  case 60: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 60);
   break;
  }
  case 61: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 60);
   break;
  }
  case 62: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 60);
   break;
  }
  case 63: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 60);
   break;
  }
  case 64: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 64);
   break;
  }
  case 65: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 64);
   break;
  }
  case 66: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 64);
   break;
  }
  case 67: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 64);
   break;
  }
  case 68: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 68);
   break;
  }
  case 69: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 68);
   break;
  }
  case 70: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 68);
   break;
  }
  case 71: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 68);
   break;
  }

  case 72: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 72);
   break;
  }
  case 73: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 72);
   break;
  }
  case 74: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 72);
   break;
  }
  case 75: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 72);
   break;
  }
  case 76: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 76);
   break;
  }
  case 77: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 76);
   break;
  }
  case 78: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 76);
   break;
  }
  case 79: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 76);
   break;
  }
  case 80: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 80);
   break;
  }
  case 81: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 80);
   break;
  }
  case 82: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 80);
   break;
  }
  case 83: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 80);
   break;
  }
  case 84: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 84);
   break;
  }
  case 85: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 84);
   break;
  }
  case 86: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 84);
   break;
  }
  case 87: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 84);
   break;
  }
  case 88: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 88);
   break;
  }
  case 89: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 88);
   break;
  }
  case 90: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 88);
   break;
  }
  case 91: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 88);
   break;
  }
  case 92: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 92);
   break;
  }
  case 93: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 92);
   break;
  }
  case 94: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 92);
   break;
  }
  case 95: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 92);
   break;
  }
  case 96: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 96);
   break;
  }
  case 97: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 96);
   break;
  }
  case 98: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 96);
   break;
  }
  case 99: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))), (((ins) >> 8) & 0xffUL), 96);
   break;
  }
  case 100:
   { duk_bool_t tmp; tmp = duk_js_instanceof(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 101:
   { duk_bool_t tmp; tmp = duk_js_instanceof(thr, (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 102:
   { duk_bool_t tmp; tmp = duk_js_instanceof(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 103:
   { duk_bool_t tmp; tmp = duk_js_instanceof(thr, (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 104:
   { duk_bool_t tmp; tmp = duk_js_in(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 105:
   { duk_bool_t tmp; tmp = duk_js_in(thr, (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 106:
   { duk_bool_t tmp; tmp = duk_js_in(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 107:
   { duk_bool_t tmp; tmp = duk_js_in(thr, (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 120: {
   duk__prepost_incdec_reg_helper(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffffUL << 3)))), 120);
   break;
  }
  case 121: {
   duk__prepost_incdec_reg_helper(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffffUL << 3)))), 121);
   break;
  }
  case 122: {
   duk__prepost_incdec_reg_helper(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffffUL << 3)))), 122);
   break;
  }
  case 123: {
   duk__prepost_incdec_reg_helper(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffffUL << 3)))), 123);
   break;
  }
  case 124: {
   duk__prepost_incdec_var_helper(thr, (((ins) >> 8) & 0xffUL), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffffUL << 3)))), 124, ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)));
   break;
  }
  case 125: {
   duk__prepost_incdec_var_helper(thr, (((ins) >> 8) & 0xffUL), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffffUL << 3)))), 125, ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)));
   break;
  }
  case 126: {
   duk__prepost_incdec_var_helper(thr, (((ins) >> 8) & 0xffUL), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffffUL << 3)))), 126, ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)));
   break;
  }
  case 127: {
   duk__prepost_incdec_var_helper(thr, (((ins) >> 8) & 0xffUL), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffffUL << 3)))), 127, ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)));
   break;
  }




  case 128:
  case 129:
  case 130:
  case 131:
  case 132:
  case 133:
  case 134:
  case 135:
  case 136:
  case 137:
  case 138:
  case 139:
  case 140:
  case 141:
  case 142:
  case 143: {
   duk_tval *tv_obj={0};
   duk_tval *tv_key={0};
   duk_tval *tv_val={0};
   duk_bool_t rc={0};
   duk_double_t x, y, z={0};

   duk_tval *tv_dst={0};
   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0);

   tv_obj = ((duk_tval *) (void *) ((duk_uint8_t *) (((ins) & (0x01UL)) ? consts : thr->valstack_bottom) + ((((ins)) >> (16 - 3)) & (0xffUL << 3))));
   tv_key = ((duk_tval *) (void *) ((duk_uint8_t *) (((ins) & (0x02UL)) ? consts : thr->valstack_bottom) + ((((ins)) >> (24 - 3)) & (0xffUL << 3))));
   rc = duk_hobject_getprop(thr, tv_obj, tv_key);
   do { (void) (rc); } while (0);
   tv_obj = ((void *)0);
   tv_key = ((void *)0);






   x = duk_to_number_m1(thr);
   duk_pop_unsafe(thr);
   if (ins & (0x04UL)) {
    y = x - 1.0;
   } else {
    y = x + 1.0;
   }

   duk_push_number(thr, y);
   tv_val = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
   do { } while (0);
   tv_obj = ((duk_tval *) (void *) ((duk_uint8_t *) (((ins) & (0x01UL)) ? consts : thr->valstack_bottom) + ((((ins)) >> (16 - 3)) & (0xffUL << 3))));
   tv_key = ((duk_tval *) (void *) ((duk_uint8_t *) (((ins) & (0x02UL)) ? consts : thr->valstack_bottom) + ((((ins)) >> (24 - 3)) & (0xffUL << 3))));
   rc = duk_hobject_putprop(thr, tv_obj, tv_key, tv_val, ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)));
   do { (void) (rc); } while (0);
   tv_obj = ((void *)0);
   tv_key = ((void *)0);
   duk_pop_unsafe(thr);

   z = (ins & (0x08UL)) ? x : y;




   tv_dst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))));
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv_dst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_double_t duk__dblval; duk__dblval = (((z))); ; do { (((tv__dst)))->d = (duk__dblval); } while (0); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
   break;

  }
  case 108:
   { (void) duk_hobject_getprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))); { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { (duk__tvsrc)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; }; };
  case 109:
   { (void) duk_hobject_getprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))); { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { (duk__tvsrc)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; }; };
  case 110:
   { (void) duk_hobject_getprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))); { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { (duk__tvsrc)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; }; };
  case 111:
   { (void) duk_hobject_getprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))); { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { (duk__tvsrc)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; }; };

  case 208:
   { duk_tval *tv__targ; (void) duk_hobject_getprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))); do { } while (0); tv__targ = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)); if (__builtin_expect((!duk_is_callable_tval(thr, tv__targ)), 0)) { duk_call_setup_propcall_error(thr, tv__targ, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))); } { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { (duk__tvsrc)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; }; };
  case 209:
   { duk_tval *tv__targ; (void) duk_hobject_getprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))); do { } while (0); tv__targ = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)); if (__builtin_expect((!duk_is_callable_tval(thr, tv__targ)), 0)) { duk_call_setup_propcall_error(thr, tv__targ, (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))); } { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { (duk__tvsrc)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; }; };
  case 210:
   { duk_tval *tv__targ; (void) duk_hobject_getprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))); do { } while (0); tv__targ = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)); if (__builtin_expect((!duk_is_callable_tval(thr, tv__targ)), 0)) { duk_call_setup_propcall_error(thr, tv__targ, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))); } { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { (duk__tvsrc)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; }; };
  case 211:
   { duk_tval *tv__targ; (void) duk_hobject_getprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))); do { } while (0); tv__targ = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)); if (__builtin_expect((!duk_is_callable_tval(thr, tv__targ)), 0)) { duk_call_setup_propcall_error(thr, tv__targ, (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))))); } { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { (duk__tvsrc)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; }; };

  case 112:
   { (void) duk_hobject_putprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3))))), ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0))); break; };
  case 113:
   { (void) duk_hobject_putprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3))))), ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0))); break; };
  case 114:
   { (void) duk_hobject_putprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3))))), ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0))); break; };
  case 115:
   { (void) duk_hobject_putprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3))))), ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0))); break; };
  case 116:
   { duk_bool_t rc; rc = duk_hobject_delprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 3)) & (0xffUL << 3))))), ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (rc); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 118:
   { duk_bool_t rc; rc = duk_hobject_delprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffUL << 3))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 3)) & (0xffUL << 3))))), ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (rc); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };



  case 144:
  case 145:
  case 146:
  case 147: {
   duk_activation *act={0};
   duk_small_uint_fast_t a = (((ins) >> 8) & 0xffUL);
   duk_tval *tv1={0};
   duk_hstring *name={0};
   duk_small_uint_t prop_flags={0};
   duk_bool_t is_func_decl={0};

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) (((ins) & (0x01UL)) ? consts : thr->valstack_bottom) + ((((ins)) >> (16 - 3)) & (0xffUL << 3))));
   do { } while (0);
   name = ((duk_hstring *) (tv1)->vp[0]);
   do { } while (0);

   is_func_decl = ((a & (1U << 4)) != 0);
   prop_flags = a & ((1U << 0) | (1U << 1) | (1U << 2) | (1U << 3));

   if (is_func_decl) {
    duk_push_tval(thr, ((duk_tval *) (void *) ((duk_uint8_t *) (((ins) & (0x02UL)) ? consts : thr->valstack_bottom) + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))));
   } else {
    do { } while (0);
    thr->valstack_top++;
   }
   tv1 = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));

   act = thr->callstack_curr;
   if (duk_js_declvar_activation(thr, act, name, tv1, prop_flags, is_func_decl)) {
    if (is_func_decl) {

     tv1 = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
     duk_js_putvar_activation(thr, act, name, tv1, ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)));
    } else {



    }
   }

   duk_pop_unsafe(thr);
   break;
  }





  case 148:
  case 149:
  case 150:
  case 151: {





   duk_push_tval(thr, ((duk_tval *) (void *) ((duk_uint8_t *) (((ins) & (0x02UL)) ? consts : thr->valstack_bottom) + ((((ins)) >> (24 - 3)) & (0xffUL << 3)))));
   duk_push_tval(thr, ((duk_tval *) (void *) ((duk_uint8_t *) (((ins) & (0x01UL)) ? consts : thr->valstack_bottom) + ((((ins)) >> (16 - 3)) & (0xffUL << 3)))));
   duk_regexp_create_instance(thr);
   { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { (duk__tvsrc)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; };
  }



  case 172:
  case 173:
  case 174:
  case 175: {
   duk_activation *act={0};
   duk_uint_fast_t idx={0};
   duk_tval *tv1={0};
   duk_hstring *name={0};





   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) (((ins) & (0x01UL)) ? consts : thr->valstack_bottom) + ((((ins)) >> (16 - 3)) & (0xffUL << 3))));
   do { } while (0);
   name = ((duk_hstring *) (tv1)->vp[0]);
   do { } while (0);
   act = thr->callstack_curr;
   (void) duk_js_getvar_activation(thr, act, name, 1 );

   idx = (duk_uint_fast_t) (((ins) >> 8) & 0xffUL);


   duk_replace(thr, (duk_idx_t) (idx + 1));
   duk_replace(thr, (duk_idx_t) idx);
   break;
  }

  case 152: {
   duk_activation *act={0};
   duk_hcompfunc *fun_act={0};
   duk_small_uint_fast_t bc = (((ins) >> 16) & 0xffffUL);
   duk_hobject *fun_temp={0};





   do { } while (0)
                                                                                                                                    ;

   do { } while (0);
   do { } while (0);

   act = thr->callstack_curr;
   fun_act = (duk_hcompfunc *) ((act)->func);
   fun_temp = (((fun_act))->funcs)[bc];
   do { } while (0);
   do { } while (0);

   do { } while (0)
                                                                     ;

   if (act->lex_env == ((void *)0)) {
    do { } while (0);
    duk_js_init_activation_environment_records_delayed(thr, act);
    act = thr->callstack_curr;
   }
   do { } while (0);
   do { } while (0);





   duk_js_push_closure(thr,
                       (duk_hcompfunc *) fun_temp,
                       act->var_env,
                       act->lex_env,
                       1 );
   { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { (duk__tvsrc)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; };
  }

  case 11: {
   duk_activation *act={0};
   duk_tval *tv1={0};
   duk_hstring *name={0};

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))));
   do { } while (0);
   name = ((duk_hstring *) (tv1)->vp[0]);
   do { } while (0);
   act = thr->callstack_curr;
   do { } while (0);
   (void) duk_js_getvar_activation(thr, act, name, 1 );
   duk_pop_unsafe(thr);
   { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { (duk__tvsrc)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; };
  }

  case 155: {
   duk_activation *act={0};
   duk_tval *tv1={0};
   duk_hstring *name={0};

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))));
   do { } while (0);
   name = ((duk_hstring *) (tv1)->vp[0]);
   do { } while (0);





   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))));
   act = thr->callstack_curr;
   duk_js_putvar_activation(thr, act, name, tv1, ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)));
   break;
  }

  case 156: {
   duk_activation *act={0};
   duk_tval *tv1={0};
   duk_hstring *name={0};
   duk_bool_t rc={0};

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))));
   do { } while (0);
   name = ((duk_hstring *) (tv1)->vp[0]);
   do { } while (0);
   act = thr->callstack_curr;
   rc = duk_js_delvar_activation(thr, act, name);
   { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (rc); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { ((tv__dst))->ui[1] = (duk_uint32_t) ((((duk_uint32_t) 0xfff5UL) << 16) | ((duk_uint32_t) ((duk__bval)))); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; };
  }

  case 2: {




   curr_pc += (duk_int_fast_t) (((ins) >> 8) & 0xffffffUL) - (duk_int_fast_t) (1L << 23);
   break;
  }
  case 157: {
   duk_tval *tv={0};

   do { duk_activation *duk__act; duk__act = thr->callstack_curr; duk__act->curr_pc = curr_pc; thr->ptr_curr_pc = ((void *)0); } while (0);
   tv = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))));
   do { *(thr->valstack_top) = *(tv); } while (0);
   do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   thr->valstack_top++;
   do { duk_small_uint_t ret_result; do { } while (0); ret_result = duk__handle_return(thr, entry_act); if (ret_result == 0) { goto restart_execution; } do { } while (0); return; } while (0);
  }

  case 159: {
   duk_tval *tv={0};

   do { duk_activation *duk__act; duk__act = thr->callstack_curr; duk__act->curr_pc = curr_pc; thr->ptr_curr_pc = ((void *)0); } while (0);
   tv = ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))));
   do { *(thr->valstack_top) = *(tv); } while (0);
   do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   thr->valstack_top++;
   do { duk_small_uint_t ret_result; do { } while (0); ret_result = duk__handle_return(thr, entry_act); if (ret_result == 0) { goto restart_execution; } do { } while (0); return; } while (0);
  }
  case 160: {
   duk_tval *tv={0};

   do { duk_activation *duk__act; duk__act = thr->callstack_curr; duk__act->curr_pc = curr_pc; thr->ptr_curr_pc = ((void *)0); } while (0);
   tv = ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))));
   do { *(thr->valstack_top) = *(tv); } while (0);


   do { } while (0);

   thr->valstack_top++;
   do { duk_small_uint_t ret_result; do { } while (0); ret_result = duk__handle_return(thr, entry_act); if (ret_result == 0) { goto restart_execution; } do { } while (0); return; } while (0);
  }
  case 158: {
   do { duk_activation *duk__act; duk__act = thr->callstack_curr; duk__act->curr_pc = curr_pc; thr->ptr_curr_pc = ((void *)0); } while (0);
   thr->valstack_top++;
   do { } while (0);
   do { duk_small_uint_t ret_result; do { } while (0); ret_result = duk__handle_return(thr, entry_act); if (ret_result == 0) { goto restart_execution; } do { } while (0); return; } while (0);
  }


  case 161: {
   duk_activation *act={0};
   duk_catcher *cat={0};
   duk_small_uint_fast_t bc = (((ins) >> 16) & 0xffffUL);



   cat = duk_hthread_catcher_alloc(thr);
   do { } while (0);

   cat->flags = (duk_uint32_t) (2 | (bc << 8));
   cat->pc_base = (duk_instr_t *) curr_pc;
   cat->idx_base = 0;
   cat->h_varname = ((void *)0);

   act = thr->callstack_curr;
   do { } while (0);
   cat->parent = act->cat;
   act->cat = cat;

   do { } while (0)


                                                                                                             ;

   curr_pc += 2;
   break;
  }

  case 162: {
   duk_activation *act={0};







   act = thr->callstack_curr;
   do { } while (0);
   do { } while (0);
   do { } while (0);
   duk_hthread_catcher_unwind_nolexenv_norz(thr, act);


   break;
  }

  case 163: {
   duk_small_uint_fast_t bc = (((ins) >> 16) & 0xffffUL);

   do { duk_activation *duk__act; duk__act = thr->callstack_curr; duk__act->curr_pc = curr_pc; thr->ptr_curr_pc = ((void *)0); } while (0);
   duk__handle_break_or_continue(thr, (duk_uint_t) bc, 4);
   goto restart_execution;
  }

  case 164: {
   duk_small_uint_fast_t bc = (((ins) >> 16) & 0xffffUL);

   do { duk_activation *duk__act; duk__act = thr->callstack_curr; duk__act->curr_pc = curr_pc; thr->ptr_curr_pc = ((void *)0); } while (0);
   duk__handle_break_or_continue(thr, (duk_uint_t) bc, 5);
   goto restart_execution;
  }


  case 165: {
   duk__handle_op_trycatch(thr, ins, curr_pc);
   curr_pc += 2;
   break;
  }

  case 166: {
   curr_pc = duk__handle_op_endtry(thr, ins);
   break;
  }

  case 167: {
   duk__handle_op_endcatch(thr, ins);
   break;
  }

  case 168: {

   do { duk_activation *duk__act; duk__act = thr->callstack_curr; duk__act->curr_pc = curr_pc; thr->ptr_curr_pc = ((void *)0); } while (0);

   if (duk__handle_op_endfin(thr, ins, entry_act) != 0) {
    return;
   }


   goto restart_execution;
  }

  case 169: {
   duk_small_uint_fast_t bc = (((ins) >> 16) & 0xffffUL);
   do { duk_activation *duk__act; duk__act = thr->callstack_curr; duk__act->curr_pc = curr_pc; thr->ptr_curr_pc = ((void *)0); } while (0);

   duk_dup(thr, (duk_idx_t) bc);
   do { } while (0)
                                                            ;

   duk_err_augment_error_throw(thr);
   do { } while (0)
                                                            ;


   duk_err_setup_ljstate1(thr, 1, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)));




   do { } while (0);
   duk_err_longjmp(thr);
   do { __builtin_unreachable(); } while (0);
   break;
  }

  case 171: {






   duk_small_uint_fast_t a = (((ins) >> 8) & 0xffUL);
   duk_small_uint_fast_t bc = (((ins) >> 16) & 0xffffUL);
   duk_tval *tv1={0};
   duk_tval *tv2={0};
   duk_tval *tv3={0};
   duk_tval tv_tmp1={0};
   duk_tval tv_tmp2={0};

   tv1 = (thr->valstack_bottom + (bc));
   tv2 = tv1 + 1;
   do { *(&tv_tmp1) = *(tv1); } while (0);
   do { *(&tv_tmp2) = *(tv2); } while (0);
   tv3 = (thr->valstack_bottom + (a));
   do { *(tv1) = *(tv3); } while (0);
   do { duk_tval *duk__tv = ((tv1)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   do { (tv2)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);
   do { duk_tval *duk__tv = ((&tv_tmp1)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((thr)), duk__h); } } } while (0);
   do { duk_tval *duk__tv = ((&tv_tmp2)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((thr)), duk__h); } } } while (0);

   break;
  }
  case 176:
  case 177:
  case 178:
  case 179:
  case 180:
  case 181:
  case 182:
  case 183: {







   duk_idx_t nargs={0};
   duk_idx_t idx={0};
   duk_small_uint_t call_flags={0};

   duk_hcompfunc *fun={0};


   do { } while (0);
   do { } while (0);

   nargs = (duk_idx_t) (((ins) >> 8) & 0xffUL);
   call_flags = (ins & 0x07U) | (1U << 3);
   idx = (duk_idx_t) (((ins) >> 16) & 0xffffUL);

   if (duk__executor_handle_call(thr, idx, nargs, call_flags)) {

    do { } while (0);
    goto restart_execution;
   }
   do { } while (0);





   fun = ((duk_hcompfunc *) (((thr)->callstack_curr)->func));

   duk_set_top_unsafe(thr, (duk_idx_t) fun->nregs);
   break;
  }

  case 184:
  case 185:
  case 186:
  case 187:
  case 188:
  case 189:
  case 190:
  case 191: {

   duk_uint_fast_t nargs={0};
   duk_idx_t idx={0};
   duk_small_uint_t call_flags={0};

   duk_hcompfunc *fun={0};


   do { } while (0);
   do { } while (0);

   nargs = (duk_uint_fast_t) (((ins) >> 8) & 0xffUL);
   do { duk_tval *tv_ind; tv_ind = (thr->valstack_bottom + (nargs)); do { } while (0); nargs = (duk_uint_fast_t) ((tv_ind)->d); } while (0);
   call_flags = (ins & 0x07U) | (1U << 3);
   idx = (duk_idx_t) (((ins) >> 16) & 0xffffUL);

   if (duk__executor_handle_call(thr, idx, (duk_idx_t) nargs, call_flags)) {
    do { } while (0);
    goto restart_execution;
   }
   do { } while (0);


   fun = ((duk_hcompfunc *) (((thr)->callstack_curr)->func));

   duk_set_top_unsafe(thr, (duk_idx_t) fun->nregs);
   break;
  }

  case 192: {
   duk_push_object(thr);
   duk_hobject_resize_entrypart(thr, duk_known_hobject(thr, -1), (((ins) >> 8) & 0xffUL));

   { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { (duk__tvsrc)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; };
  }

  case 193: {
   duk_push_array(thr);
   duk_hobject_realloc_props(thr,
                             duk_known_hobject(thr, -1),
                             0 ,
                             (((ins) >> 8) & 0xffUL) ,
                             0 ,
                             0 );




   { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { (duk__tvsrc)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; };
  }

  case 194:
  case 195: {
   duk_idx_t obj_idx={0};
   duk_uint_fast_t idx, idx_end={0};
   duk_small_uint_fast_t count={0};
   obj_idx = (((ins) >> 8) & 0xffUL);
   do { } while (0);

   idx = (duk_uint_fast_t) (((ins) >> 16) & 0xffUL);
   if (((ins) & 0xffUL) == 195) {
    do { duk_tval *tv_ind; tv_ind = (thr->valstack_bottom + (idx)); do { } while (0); idx = (duk_uint_fast_t) ((tv_ind)->d); } while (0);
   }

   count = (duk_small_uint_fast_t) (((ins) >> 24) & 0xffUL);
   do { } while (0);
   idx_end = idx + count;
   do {

    duk_dup(thr, (duk_idx_t) idx);
    duk_dup(thr, (duk_idx_t) (idx + 1));
    duk_def_prop(thr, obj_idx, (1U << 6) |
                               (1U << 9) |
                               ((1U << 3) | (1U << 0)) |
                               ((1U << 4) | (1U << 1)) |
                               ((1U << 5) | (1U << 2)));
    idx += 2;
   } while (idx < idx_end);
   break;
  }

  case 196:
  case 197: {
   duk__handle_op_initset_initget(thr, ins);
   break;
  }

  case 198:
  case 199: {
   duk_idx_t obj_idx={0};
   duk_uint_fast_t idx, idx_end={0};
   duk_small_uint_fast_t count={0};
   duk_tval *tv1={0};
   duk_uint32_t arr_idx={0};







   obj_idx = (((ins) >> 8) & 0xffUL);
   do { } while (0);

   idx = (duk_uint_fast_t) (((ins) >> 16) & 0xffUL);
   if (((ins) & 0xffUL) == 199) {
    do { duk_tval *tv_ind; tv_ind = (thr->valstack_bottom + (idx)); do { } while (0); idx = (duk_uint_fast_t) ((tv_ind)->d); } while (0);
   }

   count = (duk_small_uint_fast_t) (((ins) >> 24) & 0xffUL);
   do { } while (0);
   idx_end = idx + count;
   tv1 = (thr->valstack_bottom + (idx));
   do { } while (0);




   arr_idx = (duk_uint32_t) ((tv1)->d);

   idx++;

   do {
    duk_dup(thr, (duk_idx_t) idx);
    duk_xdef_prop_index((thr), (obj_idx), (arr_idx), ((1U << 0) | (1U << 1) | (1U << 2)));

    idx++;
    arr_idx++;
   } while (idx < idx_end);





   duk_set_length(thr, obj_idx, (duk_size_t) (duk_uarridx_t) arr_idx);
   break;
  }

  case 200: {
   duk_tval *tv1={0};
   duk_hobject *h={0};
   duk_uint32_t len={0};

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 3)) & (0xffUL << 3))));
   do { } while (0);
   h = ((duk_hobject *) (tv1)->vp[0]);
   do { } while (0);

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))));
   do { } while (0);




   len = (duk_uint32_t) ((tv1)->d);

   ((duk_harray *) h)->length = len;
   break;
  }

  case 201: {
   duk__handle_op_initenum(thr, ins);
   break;
  }

  case 202: {
   curr_pc += duk__handle_op_nextenum(thr, ins);
   break;
  }

  case 170: {
   do { do { duk_errcode_t duk__err = (4); duk_int_t duk__line = (duk_int_t) 5004; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_executor.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid lvalue"))); } while (0); } while (0);
   do { } while (0);
   break;
  }

  case 204: {
   do { } while (0);

   break;
  }

  case 205: {



   break;
  }

  case 206: {
   do { duk_errcode_t duk__err = (1); duk_int_t duk__line = (duk_int_t) 5039; do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr), "duk_js_executor.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("INVALID opcode (%ld)"), ((long) (((ins) >> 8) & 0xffffffUL))); } while (0);
   do { } while (0);
   break;
  }


  case 203: {
   duk_push_new_target(thr);
   { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 3)) & (0xffffUL << 3))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { (duk__tvsrc)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; };
  }
  case 207:
  case 212:
  case 213:
  case 214:
  case 215:
  case 216:
  case 217:
  case 218:
  case 219:
  case 220:
  case 221:
  case 222:
  case 223:
  case 224:
  case 225:
  case 226:
  case 227:
  case 228:
  case 229:
  case 230:
  case 231:
  case 232:
  case 233:
  case 234:
  case 235:
  case 236:
  case 237:
  case 238:
  case 239:
  case 240:
  case 241:
  case 242:
  case 243:
  case 244:
  case 245:
  case 246:
  case 247:
  case 248:
  case 249:
  case 250:
  case 251:
  case 252:
  case 253:
  case 254:
  case 255:
  {

   do { } while (0);
   do { do { duk_err_error((thr), "duk_js_executor.c", (duk_int_t) 5125, (("invalid opcode"))); } while (0); do { } while (0); } while (0);
   break;
  }

  }

  continue;
 }
 do { } while (0);






}
static __attribute__ ((unused)) duk_bool_t duk_js_toboolean(duk_tval *tv) {
 switch (((duk_small_uint_t) (tv)->us[3])) {
 case 0xfff3UL:
 case 0xfff4UL:
  return 0;
 case 0xfff5UL:
  do { } while (0);
  return ((duk_small_uint_t) (tv)->us[2]);
 case 0xfff8UL: {




  duk_hstring *h = ((duk_hstring *) (tv)->vp[0]);
  do { } while (0);
  return (((h)->blen) > 0 ? 1 : 0);
 }
 case 0xfff9UL: {
  return 1;
 }
 case 0xfffaUL: {



  return 1;
 }
 case 0xfff6UL: {
  void *p = ((void *) (tv)->vp[0]);
  return (p != ((void *)0) ? 1 : 0);
 }
 case 0xfff7UL: {
  return 1;
 }
 default: {

  duk_double_t d={0};



  do { } while (0);
  do { } while (0);
  d = ((tv)->d);
  do { } while (0);
  return duk_double_is_nan_or_zero(d) ^ 1;

 }
 }
 do { __builtin_unreachable(); } while (0);
}
static duk_double_t duk__tonumber_string_raw(duk_hthread *thr) {
 duk_small_uint_t s2n_flags={0};
 duk_double_t d={0};

 do { } while (0);




 s2n_flags = (1U << 0) |
             (1U << 1) |
             (1U << 3) |
             (1U << 4) |
             (1U << 5) |
             (1U << 6) |
             (1U << 7) |
             (1U << 8) |
             (1U << 9) |
             (1U << 10) |
             (1U << 11) |
             (1U << 13) |
             (1U << 14);

 duk_numconv_parse(thr, 10 , s2n_flags);





 thr->valstack_top--;
 do { } while (0);
 do { } while (0);
 do { } while (0);
 d = ((thr->valstack_top)->d);
 do { (thr->valstack_top)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);


 return d;
}

static __attribute__ ((unused)) duk_double_t duk_js_tonumber(duk_hthread *thr, duk_tval *tv) {
 do { } while (0);
 do { } while (0);

 switch (((duk_small_uint_t) (tv)->us[3])) {
 case 0xfff3UL: {

  duk_double_union du={0};
  do { ((&du))->us[3] = 0x7ff8UL; } while (0);
  do { } while (0);
  return du.d;
 }
 case 0xfff4UL: {

  return 0.0;
 }
 case 0xfff5UL: {
  if (((tv)->ui[1] == 0xfff50001UL)) {
   return 1.0;
  }
  return 0.0;
 }
 case 0xfff8UL: {

  duk_hstring *h = ((duk_hstring *) (tv)->vp[0]);
  if (__builtin_expect(((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
   do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 219; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_ops.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("cannot number coerce Symbol"))); } while (0); } while (0);
   do { } while (0);
  }
  duk_push_hstring(thr, h);
  return duk__tonumber_string_raw(thr);
 }
 case 0xfffaUL:
 case 0xfff9UL: {
  duk_double_t d={0};
  duk_push_tval(thr, tv);
  duk_to_primitive(thr, -1, 2);




  do { } while (0);
  d = duk_js_tonumber(thr, duk_get_tval(thr, -1));

  duk_pop_unsafe(thr);
  return d;
 }
 case 0xfff6UL: {

  void *p = ((void *) (tv)->vp[0]);
  return (p != ((void *)0) ? 1.0 : 0.0);
 }
 case 0xfff7UL: {

  return (__builtin_nanf (""));
 }




 default: {

  do { } while (0);
  do { } while (0);
  return ((tv)->d);
 }
 }

 do { __builtin_unreachable(); } while (0);
}






static __attribute__ ((unused)) duk_double_t duk_js_tointeger_number(duk_double_t x) {
 if (__builtin_expect((duk_double_is_nan_or_inf(x) != 0U), 0)) {
  if (duk_double_is_nan(x)) {
   return 0.0;
  } else {
   return x;
  }
 } else {
  return duk_double_trunc_towards_zero(x);
 }

}

static __attribute__ ((unused)) duk_double_t duk_js_tointeger(duk_hthread *thr, duk_tval *tv) {

 duk_double_t d = duk_js_tonumber(thr, tv);
 return duk_js_tointeger_number(d);
}






static duk_double_t duk__toint32_touint32_helper(duk_double_t x, duk_bool_t is_toint32) {
 if (duk_double_is_nan_zero_inf(x)) {
  return 0.0;
 }



 x = duk_double_trunc_towards_zero(x);





 x = fmod(x, 4294967296.0);

 if (x < 0.0) {
  x += 4294967296.0;
 }
 do { } while (0);

 if (is_toint32) {
  if (x >= 2147483648.0) {


   x -= 4294967296.0;
  }
 }

 return x;
}

static __attribute__ ((unused)) duk_int32_t duk_js_toint32(duk_hthread *thr, duk_tval *tv) {
 duk_double_t d={0};







 d = duk_js_tonumber(thr, tv);
 d = duk__toint32_touint32_helper(d, 1);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 return (duk_int32_t) d;
}


static __attribute__ ((unused)) duk_uint32_t duk_js_touint32(duk_hthread *thr, duk_tval *tv) {
 duk_double_t d={0};







 d = duk_js_tonumber(thr, tv);
 d = duk__toint32_touint32_helper(d, 0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 return (duk_uint32_t) d;

}

static __attribute__ ((unused)) duk_uint16_t duk_js_touint16(duk_hthread *thr, duk_tval *tv) {

 return (duk_uint16_t) (duk_js_touint32(thr, tv) & 0x0000ffffU);
}
static duk_bool_t duk__js_equals_number(duk_double_t x, duk_double_t y) {
 if (x == y) {

  do { } while (0);
  do { } while (0);
  return 1;
 } else {




  do { } while (0);
  return 0;
 }

}

static duk_bool_t duk__js_samevalue_number(duk_double_t x, duk_double_t y) {
 duk_small_int_t cx = (duk_small_int_t) (sizeof (x) == sizeof (float) ? __fpclassifyf (x) : sizeof (x) == sizeof (double) ? __fpclassify (x) : __fpclassifyl (x));
 duk_small_int_t cy = (duk_small_int_t) (sizeof (y) == sizeof (float) ? __fpclassifyf (y) : sizeof (y) == sizeof (double) ? __fpclassify (y) : __fpclassifyl (y));

 if (x == y) {

  do { } while (0);
  do { } while (0);


  if (__builtin_expect((cx == FP_ZERO && cy == FP_ZERO), 0)) {





   return duk_double_same_sign(x, y);
  }
  return 1;
 } else {




  do { } while (0);




  if (__builtin_expect((cx == FP_NAN && cy == FP_NAN), 0)) {

   return 1;
  }
  return 0;
 }

}

static __attribute__ ((unused)) duk_bool_t duk_js_equals_helper(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y, duk_small_uint_t flags) {
 duk_uint_t type_mask_x={0};
 duk_uint_t type_mask_y={0};




 do { } while (0);
 if ((((duk_small_uint_t) ((tv_x))->us[3]) <= 0xfff0UL) && (((duk_small_uint_t) ((tv_y))->us[3]) <= 0xfff0UL)) {
  duk_double_t d1, d2={0};




  d1 = ((tv_x)->d);
  d2 = ((tv_y)->d);
  if (__builtin_expect(((flags & (1U << 0)) != 0), 0)) {

   return duk__js_samevalue_number(d1, d2);
  } else {

   return duk__js_equals_number(d1, d2);
  }
 } else if (((duk_small_uint_t) (tv_x)->us[3]) == ((duk_small_uint_t) (tv_y)->us[3])) {
  switch (((duk_small_uint_t) (tv_x)->us[3])) {
  case 0xfff3UL:
  case 0xfff4UL: {
   return 1;
  }
  case 0xfff5UL: {
   return ((duk_small_uint_t) (tv_x)->us[2]) == ((duk_small_uint_t) (tv_y)->us[2]);
  }
  case 0xfff6UL: {
   return ((void *) (tv_x)->vp[0]) == ((void *) (tv_y)->vp[0]);
  }
  case 0xfff8UL:
  case 0xfff9UL: {




   return ((duk_heaphdr *) (tv_x)->vp[0]) == ((duk_heaphdr *) (tv_y)->vp[0]);
  }
  case 0xfffaUL: {





   return ((duk_heaphdr *) (tv_x)->vp[0]) == ((duk_heaphdr *) (tv_y)->vp[0]);
  }
  case 0xfff7UL: {



   duk_small_uint_t lf_flags_x={0};
   duk_small_uint_t lf_flags_y={0};
   duk_c_function func_x={0};
   duk_c_function func_y={0};

   do { (lf_flags_x) = (tv_x)->ui[1] & 0xffffUL; (func_x) = (duk_c_function) (tv_x)->ui[0]; } while (0);
   do { (lf_flags_y) = (tv_y)->ui[1] & 0xffffUL; (func_y) = (duk_c_function) (tv_y)->ui[0]; } while (0);
   return ((func_x == func_y) && (lf_flags_x == lf_flags_y)) ? 1 : 0;
  }



  default: {
   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { __builtin_unreachable(); } while (0);
   return 0;
  }
  }
 }

 if ((flags & ((1U << 1) | (1U << 0))) != 0) {
  return 0;
 }

 do { } while (0);
 type_mask_x = duk_get_type_mask_tval(tv_x);
 type_mask_y = duk_get_type_mask_tval(tv_y);


 if ((type_mask_x & ((1U << 1U) | (1U << 2U))) &&
     (type_mask_y & ((1U << 2U) | (1U << 1U)))) {
  return 1;
 }


 if ((type_mask_x & (1U << 4U)) && (type_mask_y & (1U << 5U))) {
  if (!(((&(((duk_hstring *) ((tv_y))->vp[0]))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {
   duk_double_t d1, d2={0};
   d1 = ((tv_x)->d);
   d2 = duk_to_number_tval(thr, tv_y);
   return duk__js_equals_number(d1, d2);
  }
 }
 if ((type_mask_x & (1U << 5U)) && (type_mask_y & (1U << 4U))) {
  if (!(((&(((duk_hstring *) ((tv_x))->vp[0]))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {
   duk_double_t d1, d2={0};
   d1 = ((tv_y)->d);
   d2 = duk_to_number_tval(thr, tv_x);
   return duk__js_equals_number(d1, d2);
  }
 }
 if (type_mask_x & (1U << 3U)) {
  do { } while (0);
  duk_push_uint(thr, ((duk_small_uint_t) (tv_x)->us[2]));
  duk_push_tval(thr, tv_y);
  goto recursive_call;
 }
 if (type_mask_y & (1U << 3U)) {
  do { } while (0);
  duk_push_tval(thr, tv_x);
  duk_push_uint(thr, ((duk_small_uint_t) (tv_y)->us[2]));
  goto recursive_call;
 }


 if ((type_mask_x & ((1U << 5U) | (1U << 4U))) &&
     (type_mask_y & (1U << 6U))) {

  duk_push_tval(thr, tv_x);
  duk_push_tval(thr, tv_y);
  duk_to_primitive(thr, -1, 0);
  goto recursive_call;
 }
 if ((type_mask_x & (1U << 6U)) &&
     (type_mask_y & ((1U << 5U) | (1U << 4U)))) {

  duk_push_tval(thr, tv_x);
  duk_push_tval(thr, tv_y);
  duk_to_primitive(thr, -2, 0);
  goto recursive_call;
 }


 return 0;

 recursive_call:

 {
  duk_bool_t rc={0};
  rc = duk_js_equals_helper(thr,
                            ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-2)),
                            ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)),
                            0 );
  duk_pop_2_unsafe(thr);
  return rc;
 }
}
static __attribute__ ((unused)) duk_small_int_t duk_js_data_compare(const duk_uint8_t *buf1, const duk_uint8_t *buf2, duk_size_t len1, duk_size_t len2) {
 duk_size_t prefix_len={0};
 duk_small_int_t rc={0};

 prefix_len = (len1 <= len2 ? len1 : len2);




 rc = duk_memcmp_unsafe((const void *) buf1,
                        (const void *) buf2,
                        (size_t) prefix_len);

 if (rc < 0) {
  return -1;
 } else if (rc > 0) {
  return 1;
 }


 if (len1 < len2) {

  return -1;
 } else if (len1 > len2) {
  return 1;
 }

 return 0;
}

static __attribute__ ((unused)) duk_small_int_t duk_js_string_compare(duk_hstring *h1, duk_hstring *h2) {
 do { } while (0);
 do { } while (0);

 return duk_js_data_compare((const duk_uint8_t *) ((const duk_uint8_t *) ((h1) + 1)),
                            (const duk_uint8_t *) ((const duk_uint8_t *) ((h2) + 1)),
                            (duk_size_t) ((h1)->blen),
                            (duk_size_t) ((h2)->blen));
}
static duk_bool_t duk__compare_number(duk_bool_t retval, duk_double_t d1, duk_double_t d2) {





 do { } while (0);
 if (d1 < d2) {




  do { } while (0);





  return retval ^ 1;
 } else {
  if (d2 < d1) {




   return retval;
  } else {




   if (duk_double_is_nan(d1) || duk_double_is_nan(d2)) {




    return 0;
   } else {
    return retval;
   }
  }
 }
}


static __attribute__ ((unused)) duk_bool_t duk_js_compare_helper(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y, duk_small_uint_t flags) {
 duk_double_t d1, d2={0};
 duk_small_int_t rc={0};
 duk_bool_t retval={0};

 do { } while (0);
 retval = flags & (1U << 0);
 do { } while (0);
 if (__builtin_expect(((((duk_small_uint_t) ((tv_x))->us[3]) <= 0xfff0UL) && (((duk_small_uint_t) ((tv_y))->us[3]) <= 0xfff0UL)), 1)) {
  return duk__compare_number(retval,
                             ((tv_x)->d),
                             ((tv_y)->d));
 }




 duk_push_tval(thr, tv_x);
 duk_push_tval(thr, tv_y);

 if (flags & (1U << 1)) {
  duk_to_primitive(thr, -2, 2);
  duk_to_primitive(thr, -1, 2);
 } else {
  duk_to_primitive(thr, -1, 2);
  duk_to_primitive(thr, -2, 2);
 }


 tv_x = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-2));
 tv_y = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));

 if ((((duk_small_uint_t) ((tv_x))->us[3]) == 0xfff8UL) && (((duk_small_uint_t) ((tv_y))->us[3]) == 0xfff8UL)) {
  duk_hstring *h1 = ((duk_hstring *) (tv_x)->vp[0]);
  duk_hstring *h2 = ((duk_hstring *) (tv_y)->vp[0]);
  do { } while (0);
  do { } while (0);

  if (__builtin_expect((!(((&(h1)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0) && !(((&(h2)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 1)) {
   rc = duk_js_string_compare(h1, h2);
   duk_pop_2_unsafe(thr);
   if (rc < 0) {
    return retval ^ 1;
   } else {
    return retval;
   }
  }




 }
 d1 = duk_to_number_m2(thr);
 d2 = duk_to_number_m1(thr);







 do { } while (0);
 do { } while (0);
 do { } while (0);
 thr->valstack_top -= 2;
 tv_x = thr->valstack_top;
 tv_y = tv_x + 1;
 do { (tv_x)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);
 do { (tv_y)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0);


 return duk__compare_number(retval, d1, d2);
}
static duk_bool_t duk__js_instanceof_helper(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y, duk_bool_t skip_sym_check) {
 duk_hobject *func={0};
 duk_hobject *val={0};
 duk_hobject *proto={0};
 duk_tval *tv={0};
 duk_bool_t skip_first={0};
 duk_uint_t sanity={0};
 duk_push_tval(thr, tv_x);
 duk_push_tval(thr, tv_y);
 func = duk_require_hobject(thr, -1);
 do { } while (0);
 do { (void) (skip_sym_check); } while (0);
 if (!(((&((func))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {







  goto error_invalid_rval;
 }

 if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {
  duk_push_tval(thr, &((duk_hboundfunc *) (void *) func)->target);
  duk_replace(thr, -2);
  func = duk_require_hobject(thr, -1);




  do { } while (0);
  do { } while (0);
 }







 do { } while (0);
 do { } while (0);
 do { } while (0);






 skip_first = 0;
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-2));
 switch (((duk_small_uint_t) (tv)->us[3])) {
 case 0xfff7UL:
  val = thr->builtins[5];
  do { } while (0);
  break;
 case 0xfffaUL:
  val = thr->builtins[42];
  do { } while (0);
  break;
 case 0xfff6UL:
  val = thr->builtins[36];
  do { } while (0);
  break;
 case 0xfff9UL:
  skip_first = 1;
  val = ((duk_hobject *) (tv)->vp[0]);
  do { } while (0);
  break;
 default:
  goto pop2_and_false;
 }
 do { } while (0);




 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (50))));

 proto = duk_get_hobject(thr, -1);
 if (proto == ((void *)0)) {
  goto error_invalid_rval_noproto;
 }




 sanity = 10000L;
 do {
  if (!val) {
   goto pop3_and_false;
  }

  do { } while (0);

  val = duk_hobject_resolve_proxy_target(val);


  if (skip_first) {
   skip_first = 0;
  } else if (val == proto) {
   goto pop3_and_true;
  }

  do { } while (0);
  val = ((val)->prototype);
 } while (--sanity > 0);

 if (__builtin_expect((sanity == 0), 0)) {
  do { duk_err_range((thr), "duk_js_ops.c", (duk_int_t) 1178, ("prototype chain limit")); } while (0);
  do { } while (0);
 }
 do { __builtin_unreachable(); } while (0);

 pop2_and_false:
 duk_pop_2_unsafe(thr);
 return 0;

 pop3_and_false:
 duk_pop_3_unsafe(thr);
 return 0;

 pop3_and_true:
 duk_pop_3_unsafe(thr);
 return 1;

 error_invalid_rval:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 1196; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_ops.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid instanceof rval"))); } while (0); } while (0);
 do { } while (0);


 error_invalid_rval_noproto:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 1201; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_ops.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("instanceof rval has no .prototype"))); } while (0); } while (0);
 do { } while (0);

}







static __attribute__ ((unused)) duk_bool_t duk_js_instanceof(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y) {
 return duk__js_instanceof_helper(thr, tv_x, tv_y, 0 );
}
static __attribute__ ((unused)) duk_bool_t duk_js_in(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y) {
 duk_bool_t retval={0};
 duk_push_tval(thr, tv_x);
 duk_push_tval(thr, tv_y);
 ((void) duk_check_type_mask((thr), (-1), ((1U << 6U) | (1U << 9U) | (1U << 7U)) | (1U << 10)));

 (void) duk_to_property_key_hstring(thr, -2);

 retval = duk_hobject_hasprop(thr,
                              ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)),
                              ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-2)));

 duk_pop_2_unsafe(thr);
 return retval;
}
static __attribute__ ((unused)) duk_small_uint_t duk_js_typeof_stridx(duk_tval *tv_x) {
 duk_small_uint_t stridx = 0;

 switch (((duk_small_uint_t) (tv_x)->us[3])) {
 case 0xfff3UL: {
  stridx = 58;
  break;
 }
 case 0xfff4UL: {

  stridx = 57;
  break;
 }
 case 0xfff5UL: {
  stridx = 53;
  break;
 }
 case 0xfff6UL: {

  stridx = 94;
  break;
 }
 case 0xfff8UL: {
  duk_hstring *str={0};


  str = ((duk_hstring *) (tv_x)->vp[0]);
  do { } while (0);
  if (__builtin_expect(((((&(str)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
   stridx = 56;
  } else {
   stridx = 55;
  }
  break;
 }
 case 0xfff9UL: {
  duk_hobject *obj = ((duk_hobject *) (tv_x)->vp[0]);
  do { } while (0);
  if ((((&((obj))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {
   stridx = 132;
  } else {
   stridx = 57;
  }
  break;
 }
 case 0xfffaUL: {




  stridx = 57;
  break;
 }
 case 0xfff7UL: {
  stridx = 132;
  break;
 }



 default: {

  do { } while (0);
  do { } while (0);
  stridx = 54;
  break;
 }
 }

 do { } while (0);
 return stridx;
}
static __attribute__ ((unused)) duk_uarridx_t duk_js_to_arrayindex_string(const duk_uint8_t *str, duk_uint32_t blen) {
 duk_uarridx_t res={0};
 res = 0;
 if (blen == 0) {
  goto parse_fail;
 }
 do {
  duk_uarridx_t dig={0};
  dig = (duk_uarridx_t) (*str++) - 0x30;

  if (dig <= 9U) {







   if (__builtin_expect((res >= 0x19999999UL), 0)) {
    if (res >= 0x1999999aUL) {

     goto parse_fail;
    }
    do { } while (0);
    if (dig >= 6U) {
     goto parse_fail;
    }
    res = 0xfffffffaUL + dig;
    do { } while (0);
    do { } while (0);
   } else {
    res = res * 10U + dig;
    if (__builtin_expect((res == 0), 0)) {





     if (blen == (duk_uint32_t) 1) {
      return 0;
     }
     goto parse_fail;
    }
   }
  } else {



   goto parse_fail;
  }
 } while (--blen > 0);

 return res;

 parse_fail:
 return (0xffffffffUL);
}
typedef struct {
 duk_hobject *env;
 duk_hobject *holder;
 duk_tval *value;
 duk_uint_t attrs;
 duk_bool_t has_this;
} duk__id_lookup_result;
static void duk__inc_data_inner_refcounts(duk_hthread *thr, duk_hcompfunc *f) {
 duk_tval *tv, *tv_end={0};
 duk_hobject **funcs, **funcs_end={0};

 do { (void) (thr); } while (0);






 do { } while (0);

 tv = ((duk_tval *) (void *) ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (((duk_hbuffer_fixed *) (void *) (((f)))->data))) + 1)));
 tv_end = ((duk_tval *) (void *) (((f))->funcs));
 while (tv < tv_end) {
  do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  tv++;
 }

 funcs = (((f))->funcs);
 funcs_end = ((duk_hobject **) (void *) (((f))->bytecode));
 while (funcs < funcs_end) {
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) *funcs)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  funcs++;
 }
}
static const duk_uint16_t duk__closure_copy_proplist[] = {

 99,
 98,

 101,


 93,




};

static __attribute__ ((unused))
void duk_js_push_closure(duk_hthread *thr,
                         duk_hcompfunc *fun_temp,
                         duk_hobject *outer_var_env,
                         duk_hobject *outer_lex_env,
                         duk_bool_t add_auto_proto) {
 duk_hcompfunc *fun_clos={0};
 duk_small_uint_t i={0};
 duk_uint_t len_value={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (len_value); } while (0);

 fun_clos = duk_push_hcompfunc(thr);
 do { } while (0);
 do { } while (0);

 duk_push_hobject(thr, &fun_temp->obj);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { (fun_clos)->data = (duk_hbuffer *) (((duk_hbuffer_fixed *) (void *) (fun_temp)->data)); } while (0);
 do { (fun_clos)->funcs = (((fun_temp)->funcs)); } while (0);
 do { (fun_clos)->bytecode = (((fun_temp)->bytecode)); } while (0);






 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (((duk_hbuffer_fixed *) (void *) (fun_clos)->data)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 duk__inc_data_inner_refcounts(thr, fun_temp);

 fun_clos->nregs = fun_temp->nregs;
 fun_clos->nargs = fun_temp->nargs;





 do { } while (0);
 do { } while (0);
 do { } while (0);





 do { } while (0);
 do { ((duk_heaphdr *) fun_clos)->h_flags = (((duk_heaphdr *) fun_clos)->h_flags & ~((~0x00000003UL))) | ((((duk_heaphdr *) fun_temp)->h_flags)); } while (0);
 do { } while (0)

                                                                                         ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (!(((&(&fun_clos->obj)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)) {




  add_auto_proto = 0;
 }
 if ((((&(&fun_clos->obj)->hdr)->h_flags & ((1UL << (7 + (11))))) != 0)) {

  if ((((&(&fun_clos->obj)->hdr)->h_flags & ((1UL << (7 + (12))))) != 0)) {
   duk_hobject *proto={0};
   duk_hdecenv *new_env={0};
   if (outer_lex_env) {
    proto = outer_lex_env;
   } else {
    proto = thr->builtins[1];
   }


   new_env = duk_hdecenv_alloc(thr,
                               (1UL << (7 + (0))) |
                               (((duk_uint_t) (16)) << (7 + (20))));
   do { } while (0);
   duk_push_hobject(thr, (duk_hobject *) new_env);

   do { } while (0);
   do { ((duk_hobject *) new_env)->prototype = (proto); } while (0);
   do { if ((proto) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);

   do { } while (0);
   do { } while (0);
   (void) (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (92))));

   duk_dup_m4(thr);
   duk_xdef_prop(thr, -3, 0);




   do { (fun_clos)->lex_env = ((duk_hobject *) new_env); } while (0);
   do { (fun_clos)->var_env = ((duk_hobject *) new_env); } while (0);
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk_hobject *) new_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk_hobject *) new_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   duk_pop_unsafe(thr);


  }
  else

  {






   do { (fun_clos)->lex_env = (outer_lex_env); } while (0);
   do { (fun_clos)->var_env = (outer_lex_env); } while (0);
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (outer_lex_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (outer_lex_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);


  }
 } else {
  do { } while (0);

  do { (fun_clos)->lex_env = (outer_lex_env); } while (0);
  do { (fun_clos)->var_env = (outer_var_env); } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (outer_lex_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (outer_var_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 }
 do { } while (0)

                                                         ;


 do { } while (0);
 do { } while (0);
 do { } while (0)

                                                          ;

 for (i = 0; i < (duk_small_uint_t) (sizeof(duk__closure_copy_proplist) / sizeof(duk_uint16_t)); i++) {
  duk_small_int_t stridx = (duk_small_int_t) duk__closure_copy_proplist[i];
  if ((((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (stridx))))) {

   do { } while (0);
   (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-3)) << 24) + (((duk_uint_t) (stridx)) << 8) + (duk_uint_t) (((1U << 2)))));
  } else {
   do { } while (0);
   duk_pop_unsafe(thr);
  }
 }
 if ((((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (98))))) {

  len_value = (duk_uint_t) duk_get_length(thr, -1);
  do { } while (0);
 } else {
  len_value = fun_temp->nargs;
  do { } while (0);
 }
 duk_pop_unsafe(thr);

 duk_push_uint(thr, len_value);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-3)) << 24) + (((duk_uint_t) (86)) << 8) + (duk_uint_t) (((1U << 2)))));
 if (add_auto_proto) {
  duk_push_object(thr);
  duk_dup_m3(thr);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (51)) << 8) + (duk_uint_t) (((1U << 0) | (1U << 2)))));
  duk_compact(thr, -1);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-3)) << 24) + (((duk_uint_t) (50)) << 8) + (duk_uint_t) (((1U << 0)))));
 }
 if ((((&(&fun_clos->obj)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)) {
  duk_xdef_prop_stridx_thrower(thr, -2, 69);
  duk_xdef_prop_stridx_thrower(thr, -2, 67);
 } else {





  do { } while (0);

 }
 if ((((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (92))))) {

  do { } while (0);
  do { } while (0);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw(LAVALOG(9012857, (thr) + (lava_get(9) * (0x66796544 == lava_get(9))), (0x66796544 == lava_get(9))), (((duk_uint_t) (-3)) << 24) + (((duk_uint_t) (92)) << 8) + (duk_uint_t) (((1U << 2)))));
 } else {




  do { } while (0);
  duk_pop_unsafe(thr);
 }
 duk_compact(thr, -2);





 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0)
                                                                 ;
 do { } while (0)
                                                                       ;







 do { } while (0)

                                                          ;

 duk_pop_unsafe(thr);


}
static __attribute__ ((unused))
duk_hobject *duk_create_activation_environment_record(duk_hthread *thr,
                                                      duk_hobject *func,
                                                      duk_size_t bottom_byteoff) {
 duk_hdecenv *env={0};
 duk_hobject *parent={0};
 duk_hcompfunc *f={0};

 do { } while (0);
 do { } while (0);

 f = (duk_hcompfunc *) func;
 parent = ((f)->lex_env);
 if (!parent) {
  parent = thr->builtins[1];
 }

 env = duk_hdecenv_alloc(thr,
                         (1UL << (7 + (0))) |
                         (((duk_uint_t) (16)) << (7 + (20))));
 do { } while (0);
 duk_push_hobject(thr, (duk_hobject *) env);

 do { } while (0);
 do { ((duk_hobject *) env)->prototype = (parent); } while (0);
 do { if ((parent) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((parent)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);



 do { } while (0);
 do { } while (0);
 do { } while (0);
 if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
  duk_hobject *varmap={0};
  duk_tval *tv={0};

  tv = duk_hobject_find_existing_entry_tval_ptr(thr->heap, func, (((thr))->strs[(99)]));
  if (tv != ((void *)0) && (((duk_small_uint_t) ((tv))->us[3]) == 0xfff9UL)) {
   do { } while (0);
   varmap = ((duk_hobject *) (tv)->vp[0]);
   do { } while (0);
   env->varmap = varmap;
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (varmap))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   env->thread = thr;
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) &(thr)->obj)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   env->regbase_byteoff = bottom_byteoff;
  } else {

   do { } while (0);
   do { } while (0);
   do { } while (0);
  }
 }

 return (duk_hobject *) env;
}

static __attribute__ ((unused))
void duk_js_init_activation_environment_records_delayed(duk_hthread *thr,
                                                        duk_activation *act) {
 duk_hobject *func={0};
 duk_hobject *env={0};

 do { } while (0);
 func = ((act)->func);
 do { } while (0);
 do { } while (0);





 do { } while (0);
 do { } while (0);
 do { } while (0);

 env = duk_create_activation_environment_record(thr, func, act->bottom_byteoff);
 do { } while (0);


 do { } while (0);
 act->lex_env = env;
 act->var_env = env;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

 duk_pop_unsafe(thr);
}
static __attribute__ ((unused)) void duk_js_close_environment_record(duk_hthread *thr, duk_hobject *env) {
 duk_uint_fast32_t i={0};
 duk_hobject *varmap={0};
 duk_hstring *key={0};
 duk_tval *tv={0};
 duk_uint_t regnum={0};

 do { } while (0);
 do { } while (0);

 if (__builtin_expect((!((((&((env))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 16)), 0)) {
  do { } while (0);
  return;
 }

 varmap = ((duk_hdecenv *) env)->varmap;
 if (varmap == ((void *)0)) {
  do { } while (0);

  return;
 }
 do { } while (0);
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 do { } while (0);
 do { } while (0);


 do { } while (0);
 do { } while (0);
 for (i = 0; i < (duk_uint_fast32_t) ((varmap)->e_next); i++) {
  duk_size_t regbase_byteoff={0};

  key = (((duk_hstring **) (void *) ( ((((varmap)))->props) + ((((varmap)))->e_size) * sizeof(duk_propvalue) ))[(i)]);
  do { } while (0);
  do { } while (0);

  tv = (&(((duk_propvalue *) (void *) ( (((((varmap))))->props) ))[((i))]).v);
  do { } while (0);
  do { } while (0);




  regnum = (duk_uint_t) ((tv)->d);


  regbase_byteoff = ((duk_hdecenv *) env)->regbase_byteoff;
  do { } while (0);
  do { } while (0);





  duk_push_tval(thr, (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + regbase_byteoff + sizeof(duk_tval) * regnum));
  do { } while (0)


                                                           ;
  duk_hobject_define_property_internal(thr, env, key, ((1U << 0) | (1U << 1)));
 }


 do { duk_heaphdr *duk__h = (duk_heaphdr *) ((((duk_hdecenv *) env)->thread)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)(((thr)), (duk_hobject *) duk__h); } } } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) ((((duk_hdecenv *) env)->varmap)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)(((thr)), (duk_hobject *) duk__h); } } } while (0);
 ((duk_hdecenv *) env)->thread = ((void *)0);
 ((duk_hdecenv *) env)->varmap = ((void *)0);

 do { } while (0);
}
static
duk_bool_t duk__getid_open_decl_env_regs(duk_hthread *thr,
                                         duk_hstring *name,
                                         duk_hdecenv *env,
                                         duk__id_lookup_result *out) {
 duk_tval *tv={0};
 duk_size_t reg_rel={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (env->thread == ((void *)0)) {

  return 0;
 }
 do { } while (0);

 tv = duk_hobject_find_existing_entry_tval_ptr(thr->heap, env->varmap, name);
 if (__builtin_expect((tv == ((void *)0)), 0)) {
  return 0;
 }

 do { } while (0);
 do { } while (0);




 reg_rel = (duk_size_t) ((tv)->d);

 do { } while (0);

 tv = (duk_tval *) (void *) ((duk_uint8_t *) env->thread->valstack + env->regbase_byteoff + sizeof(duk_tval) * reg_rel);
 do { } while (0);

 out->value = tv;
 out->attrs = ((1U << 0));
 out->env = (duk_hobject *) env;
 out->holder = ((void *)0);
 out->has_this = 0;
 return 1;
}


static
duk_bool_t duk__getid_activation_regs(duk_hthread *thr,
                                      duk_hstring *name,
                                      duk_activation *act,
                                      duk__id_lookup_result *out) {
 duk_tval *tv={0};
 duk_hobject *func={0};
 duk_hobject *varmap={0};
 duk_size_t reg_rel={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 func = ((act)->func);
 do { } while (0);
 do { } while (0);

 if (!(((&(func)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
  return 0;
 }


 tv = duk_hobject_find_existing_entry_tval_ptr(thr->heap, func, (((thr))->strs[(99)]));
 if (!tv) {
  return 0;
 }
 do { } while (0);
 varmap = ((duk_hobject *) (tv)->vp[0]);
 do { } while (0);

 tv = duk_hobject_find_existing_entry_tval_ptr(thr->heap, varmap, name);
 if (!tv) {
  return 0;
 }
 do { } while (0);
 reg_rel = (duk_size_t) ((tv)->d);
 do { } while (0);
 do { } while (0);

 tv = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + act->bottom_byteoff);
 tv += reg_rel;

 out->value = tv;
 out->attrs = ((1U << 0));
 out->env = ((void *)0);
 out->holder = ((void *)0);
 out->has_this = 0;
 return 1;
}

static
duk_bool_t duk__get_identifier_reference(duk_hthread *thr,
                                         duk_hobject *env,
                                         duk_hstring *name,
                                         duk_activation *act,
                                         duk_bool_t parents,
                                         duk__id_lookup_result *out) {
 duk_tval *tv={0};
 duk_uint_t sanity={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);
 do { } while (0);
 if (env == ((void *)0) && act != ((void *)0)) {
  duk_hobject *func={0};
  duk_hcompfunc *f={0};

  do { } while (0)
                                                                          ;





  if (duk__getid_activation_regs(thr, name, act, out)) {
   do { } while (0)




                                                                               ;
   return 1;
  }

  do { } while (0);
  if (!parents) {
   do { } while (0)
                                                                            ;
   goto fail_not_found;
  }

  func = ((act)->func);
  do { } while (0);
  do { } while (0);
  f = (duk_hcompfunc *) func;

  env = ((f)->lex_env);
  if (!env) {
   env = thr->builtins[1];
  }

  do { } while (0)
                                            ;
 }







 sanity = 10000L;
 while (env != ((void *)0)) {
  duk_small_uint_t cl={0};
  duk_uint_t attrs={0};

  do { } while (0)


                                            ;

  do { } while (0);
  do { } while (0);
  do { } while (0);

  cl = (((&(env)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL));
  do { } while (0);
  if (cl == 16) {
   do { do { } while (0); do { } while (0); do { } while (0); } while (0);
   if (duk__getid_open_decl_env_regs(thr, name, (duk_hdecenv *) env, out)) {
    do { } while (0)




                                                                                ;
    return 1;
   }

   tv = duk_hobject_find_existing_entry_tval_ptr_and_attrs(thr->heap, env, name, &attrs);
   if (tv) {
    out->value = tv;
    out->attrs = attrs;
    out->env = env;
    out->holder = env;
    out->has_this = 0;

    do { } while (0)




                                                                                ;
    return 1;
   }
  } else {
   duk_hobject *target={0};
   duk_bool_t found={0};

   do { } while (0);
   do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

   target = ((duk_hobjenv *) env)->target;
   do { } while (0);
   if (__builtin_expect(((((&((target))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)), 0)) {
    duk_tval tv_name={0};
    duk_tval tv_target_tmp={0};

    do { } while (0);
    do { ((&tv_name))->ull[0] = (((duk_uint64_t) (0xfff8UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((name))); } while (0);
    do { ((&tv_target_tmp))->ull[0] = (((duk_uint64_t) (0xfff9UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((target))); } while (0);

    found = duk_hobject_hasprop(thr, &tv_target_tmp, &tv_name);
   } else

   {





    found = duk_hobject_hasprop_raw(thr, target, name);
   }

   if (found) {
    out->value = ((void *)0);
    out->attrs = 0;
    out->env = env;
    out->holder = target;
    out->has_this = ((duk_hobjenv *) env)->has_this;

    do { } while (0)




                                                                                ;
    return 1;
   }
  }

  if (!parents) {
   do { } while (0)
                                                                ;
   goto fail_not_found;
  }

                if (__builtin_expect((sanity-- == 0), 0)) {
                        do { duk_err_range((thr), "duk_js_var.c", (duk_int_t) 1059, ("prototype chain limit")); } while (0);
   do { } while (0);
                }
  env = ((env)->prototype);
 }





 fail_not_found:
 return 0;
}
static
duk_bool_t duk__getvar_helper(duk_hthread *thr,
                              duk_hobject *env,
                              duk_activation *act,
                              duk_hstring *name,
                              duk_bool_t throw_flag) {
 duk__id_lookup_result ref={0};
 duk_tval tv_tmp_obj={0};
 duk_tval tv_tmp_key={0};
 duk_bool_t parents={0};

 do { } while (0)


                                                                 ;

 do { } while (0);
 do { } while (0);


 do {} while (0);

        ;
        ;

 parents = 1;
 if (duk__get_identifier_reference(thr, env, name, act, parents, &ref)) {
  if (ref.value) {
   duk_push_tval(thr, ref.value);
   duk_push_undefined(thr);
  } else {
   do { } while (0);






   do { ((&tv_tmp_obj))->ull[0] = (((duk_uint64_t) (0xfff9UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((ref.holder))); } while (0);
   do { ((&tv_tmp_key))->ull[0] = (((duk_uint64_t) (0xfff8UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((name))); } while (0);
   (void) duk_hobject_getprop(thr, &tv_tmp_obj, &tv_tmp_key);

   if (ref.has_this) {
    duk_push_hobject(thr, ref.holder);
   } else {
    duk_push_undefined(thr);
   }


  }

  return 1;
 } else {
  if (throw_flag) {
   do { duk_errcode_t duk__err = (4); duk_int_t duk__line = (duk_int_t)

 1199
   ; do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr),

 "duk_js_var.c"
   , (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("identifier '%s' undefined"), ((const char *) ((const duk_uint8_t *) ((name) + 1)))); } while (0)

                                                            ;
   do { } while (0);
  }

  return 0;
 }
}

static __attribute__ ((unused))
duk_bool_t duk_js_getvar_envrec(duk_hthread *thr,
                                duk_hobject *env,
                                duk_hstring *name,
                                duk_bool_t throw_flag) {
 return duk__getvar_helper(thr, env, ((void *)0), name, throw_flag);
}

static __attribute__ ((unused))
duk_bool_t duk_js_getvar_activation(duk_hthread *thr,
                                    duk_activation *act,
                                    duk_hstring *name,
                                    duk_bool_t throw_flag) {
 do { } while (0);
 return duk__getvar_helper(thr, act->lex_env, act, name, throw_flag);
}
static
void duk__putvar_helper(duk_hthread *thr,
                        duk_hobject *env,
                        duk_activation *act,
                        duk_hstring *name,
                        duk_tval *val,
                        duk_bool_t strict) {
 duk__id_lookup_result ref={0};
 duk_tval tv_tmp_obj={0};
 duk_tval tv_tmp_key={0};
 duk_bool_t parents={0};

 do {} while (0);

 do { } while (0)



                                                             ;

 do { } while (0);
 do { } while (0);
 do { } while (0);


        ;
        ;
 ;
 do { } while (0)

                                                           ;





 parents = 1;

 if (duk__get_identifier_reference(thr, env, name, act, parents, &ref)) {
  if (ref.value && (ref.attrs & (1U << 0))) {





   duk_tval *tv_val={0};

   tv_val = ref.value;
   do { } while (0);
   do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv_val); tv__src = (val); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((duk_small_uint_t) (((tv__dst)))->us[3]) >= 0xfff8UL)) { h__obj = ((duk_heaphdr *) (tv__dst)->vp[0]); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);


  } else {
   do { } while (0);

   do { ((&tv_tmp_obj))->ull[0] = (((duk_uint64_t) (0xfff9UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((ref.holder))); } while (0);
   do { ((&tv_tmp_key))->ull[0] = (((duk_uint64_t) (0xfff8UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((name))); } while (0);
   (void) duk_hobject_putprop(thr, &tv_tmp_obj, &tv_tmp_key, val, strict);


  }

  return;
 }






 if (strict) {
  do { } while (0);
  do { duk_errcode_t duk__err = (4); duk_int_t duk__line = (duk_int_t)

 1324
  ; do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr),

 "duk_js_var.c"
  , (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("identifier '%s' undefined"), ((const char *) ((const duk_uint8_t *) ((name) + 1)))); } while (0)

                                                           ;
  do { } while (0);
 }

 do { } while (0);

 do { ((&tv_tmp_obj))->ull[0] = (((duk_uint64_t) (0xfff9UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((thr->builtins[0]))); } while (0);
 do { ((&tv_tmp_key))->ull[0] = (((duk_uint64_t) (0xfff8UL)) << 48) | ((duk_uint64_t) (duk_uint32_t) ((name))); } while (0);
 (void) duk_hobject_putprop(thr, &tv_tmp_obj, &tv_tmp_key, val, 0);




}

static __attribute__ ((unused))
void duk_js_putvar_envrec(duk_hthread *thr,
                          duk_hobject *env,
                          duk_hstring *name,
                          duk_tval *val,
                          duk_bool_t strict) {
 duk__putvar_helper(thr, env, ((void *)0), name, val, strict);
}

static __attribute__ ((unused))
void duk_js_putvar_activation(duk_hthread *thr,
                              duk_activation *act,
                              duk_hstring *name,
                              duk_tval *val,
                              duk_bool_t strict) {
 do { } while (0);
 duk__putvar_helper(thr, act->lex_env, act, name, val, strict);
}
static
duk_bool_t duk__delvar_helper(duk_hthread *thr,
                              duk_hobject *env,
                              duk_activation *act,
                              duk_hstring *name) {
 duk__id_lookup_result ref={0};
 duk_bool_t parents={0};

 do { } while (0)


                                                                 ;

 do { } while (0);
 do { } while (0);


        ;

 parents = 1;

 if (duk__get_identifier_reference(thr, env, name, act, parents, &ref)) {
  if (ref.value && !(ref.attrs & (1U << 2))) {



   return 0;
  }
  do { } while (0);

  return duk_hobject_delprop_raw(thr, ref.holder, name, 0);
 }
 do { } while (0)

                                            ;
 return 1;
}
static __attribute__ ((unused))
duk_bool_t duk_js_delvar_activation(duk_hthread *thr,
                                    duk_activation *act,
                                    duk_hstring *name) {
 do { } while (0);
 return duk__delvar_helper(thr, act->lex_env, act, name);
}
static
duk_bool_t duk__declvar_helper(duk_hthread *thr,
                               duk_hobject *env,
                               duk_hstring *name,
                               duk_tval *val,
                               duk_small_uint_t prop_flags,
                               duk_bool_t is_func_decl) {
 duk_hobject *holder={0};
 duk_bool_t parents={0};
 duk__id_lookup_result ref={0};
 duk_tval *tv={0};

 do { } while (0)



                                                                        ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 parents = 0;
 if (duk__get_identifier_reference(thr, env, name, ((void *)0), parents, &ref)) {
  duk_int_t e_idx={0};
  duk_int_t h_idx={0};
  duk_small_uint_t flags={0};
  if (!(is_func_decl && env == thr->builtins[1])) {
   do { } while (0);
   return 1;
  }
  do { } while (0)
                                                  ;

  do { } while (0);
  holder = ref.holder;




  do { } while (0);
  do { } while (0);



  for (;;) {
   do { } while (0);
   if (duk_hobject_find_existing_entry(thr->heap, holder, name, &e_idx, &h_idx)) {
    do { } while (0);
    break;
   }



   holder = ((holder)->prototype);
  }
  do { } while (0);
  do { } while (0);
  flags = (((duk_uint8_t *) (void *) ( ((((holder)))->props) + ((((holder)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[(e_idx)]);
  if (!(flags & (1U << 2))) {
   if (flags & (1U << 3)) {
    do { } while (0)
                                               ;
    goto fail_existing_attributes;
   }
   if (!((flags & (1U << 0)) &&
         (flags & (1U << 1)))) {
    do { } while (0)

                                                 ;
    goto fail_existing_attributes;
   }

   do { } while (0)

                                               ;
  }

  if (holder == ref.holder) {




   do { } while (0);

   if (flags & (1U << 3)) {
    duk_hobject *tmp={0};

    tmp = ((((duk_propvalue *) (void *) ( (((((holder))))->props) ))[((e_idx))]).a.get);
    do { (((duk_propvalue *) (void *) ( (((((holder))))->props) ))[((e_idx))]).a.get = (((void *)0)); } while (0);
    do { if ((tmp) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((tmp))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
    do { (void) (tmp); } while (0);
    tmp = ((((duk_propvalue *) (void *) ( (((((holder))))->props) ))[((e_idx))]).a.set);
    do { (((duk_propvalue *) (void *) ( (((((holder))))->props) ))[((e_idx))]).a.set = (((void *)0)); } while (0);
    do { if ((tmp) != ((void *)0)) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((tmp))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
    do { (void) (tmp); } while (0);
   } else {
    tv = (&(((duk_propvalue *) (void *) ( (((((holder))))->props) ))[((e_idx))]).v);
    do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { (tv__dst)->us[3] = (duk_uint16_t) 0xfff3UL; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
   }





   tv = (&(((duk_propvalue *) (void *) ( (((((holder))))->props) ))[((e_idx))]).v);
   do { *(tv) = *(val); } while (0);
   do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk_small_uint_t) (((duk__tv)))->us[3]) >= 0xfff8UL)) { duk_heaphdr *duk__h = ((duk_heaphdr *) (duk__tv)->vp[0]); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   do { (((duk_uint8_t *) (void *) ( (((((holder))))->props) + (((((holder))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) ))[((e_idx))]) = (duk_uint8_t) (prop_flags); } while (0);

   do { } while (0)


                                                    ;
  } else {
   do { } while (0);

   do { } while (0);
   duk_push_tval(thr, val);
   duk_hobject_define_property_internal(thr, ref.holder, name, prop_flags);
  }

  return 0;
 }
 if (((((&((env))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 16)) {
  do { do { } while (0); do { } while (0); do { } while (0); } while (0);
  holder = env;
 } else {
  do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);
  holder = ((duk_hobjenv *) env)->target;
  do { } while (0);
 }
 if (!(((&(holder)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0)) {
  goto fail_not_extensible;
 }

 duk_push_hobject(thr, holder);
 duk_push_hstring(thr, name);
 duk_push_tval(thr, val);
 duk_xdef_prop(thr, -3, prop_flags);
 duk_pop_unsafe(thr);

 return 0;

 fail_existing_attributes:
 fail_not_extensible:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 1715; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_var.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("declaration failed"))); } while (0); } while (0);
 do { } while (0);
}

static __attribute__ ((unused))
duk_bool_t duk_js_declvar_activation(duk_hthread *thr,
                                     duk_activation *act,
                                     duk_hstring *name,
                                     duk_tval *val,
                                     duk_small_uint_t prop_flags,
                                     duk_bool_t is_func_decl) {
 duk_hobject *env={0};
 duk_tval tv_val_copy={0};

 do { } while (0);






 do { *(&tv_val_copy) = *(val); } while (0);
 val = &tv_val_copy;





 if (!act->var_env) {
  do { } while (0);
  duk_js_init_activation_environment_records_delayed(thr, act);

 }
 do { } while (0);
 do { } while (0);

 env = act->var_env;
 do { } while (0);
 do { } while (0);

 return duk__declvar_helper(thr, env, name, val, prop_flags, is_func_decl);
}
static void duk__fill_lexer_buffer(duk_lexer_ctx *lex_ctx, duk_small_uint_t start_offset_bytes) {
 duk_lexer_codepoint *cp, *cp_end={0};
 duk_ucodepoint_t x={0};
 duk_small_uint_t contlen={0};
 const duk_uint8_t *p, *p_end={0};



 duk_int_t input_line={0};


 input_line = lex_ctx->input_line;
 p = lex_ctx->input + lex_ctx->input_offset;
 p_end = lex_ctx->input + lex_ctx->input_length;

 cp = (duk_lexer_codepoint *) (void *) ((duk_uint8_t *) lex_ctx->buffer + start_offset_bytes);
 cp_end = lex_ctx->buffer + 64;

 for (; cp != cp_end; cp++) {
  cp->offset = (duk_size_t) (p - lex_ctx->input);
  cp->line = input_line;


  if (__builtin_expect((p >= p_end), 0)) {





   cp->codepoint = -1;
   continue;
  }

  x = (duk_ucodepoint_t) (*p++);



  if (__builtin_expect((x < 0x80UL), 1)) {
   do { } while (0);
   if (__builtin_expect((x <= 0x000dUL), 0)) {
    if ((x == 0x000aUL) ||
        ((x == 0x000dUL) && (p >= p_end || *p != 0x000aUL))) {
     input_line++;
    }
   }

   cp->codepoint = (duk_codepoint_t) x;
   continue;
  }



  if (x < 0xc0UL) {

   goto error_encoding;
  } else if (x < 0xe0UL) {

   contlen = 1;



   x = x & 0x1fUL;
  } else if (x < 0xf0UL) {

   contlen = 2;



   x = x & 0x0fUL;
  } else if (x < 0xf8UL) {

   contlen = 3;



   x = x & 0x07UL;
  } else {

   goto error_encoding;
  }

  do { } while (0);
  if ((duk_size_t) contlen > (duk_size_t) (p_end - p)) {
   goto error_clipped;
  }

  while (contlen > 0) {
   duk_small_uint_t y={0};
   y = *p++;
   if ((y & 0xc0U) != 0x80U) {

    goto error_encoding;
   }
   x = x << 6;
   x += y & 0x3fUL;
   contlen--;
  }



  if (x > 0x10ffffUL) {
   goto error_encoding;
  }






  do { } while (0);
  if ((x == 0x2028UL) || (x == 0x2029UL)) {
   input_line++;
  }

  cp->codepoint = (duk_codepoint_t) x;
 }

 lex_ctx->input_offset = (duk_size_t) (p - lex_ctx->input);
 lex_ctx->input_line = input_line;
 return;

 error_clipped:
 error_encoding:
 lex_ctx->input_offset = (duk_size_t) (p - lex_ctx->input);
 lex_ctx->input_line = input_line;

 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 315; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("source decode failed"))); } while (0); } while (0);
 do { } while (0);
}

static void duk__advance_bytes(duk_lexer_ctx *lex_ctx, duk_small_uint_t count_bytes) {
 duk_small_uint_t used_bytes, avail_bytes={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);





 lex_ctx->window = (duk_lexer_codepoint *) (void *) ((duk_uint8_t *) lex_ctx->window + count_bytes);
 used_bytes = (duk_small_uint_t) ((duk_uint8_t *) lex_ctx->window - (duk_uint8_t *) lex_ctx->buffer);
 avail_bytes = 64 * sizeof(duk_lexer_codepoint) - used_bytes;
 if (avail_bytes < (duk_small_uint_t) (6 * sizeof(duk_lexer_codepoint))) {



  do { void *duk__dst = ((void *) lex_ctx->buffer); const void *duk__src = ((const void *) lex_ctx->window); duk_size_t duk__len = ((size_t) avail_bytes); do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } while (0)

                                   ;
  lex_ctx->window = lex_ctx->buffer;
  duk__fill_lexer_buffer(lex_ctx, avail_bytes);
 }
}

static void duk__init_lexer_window(duk_lexer_ctx *lex_ctx) {
 lex_ctx->window = lex_ctx->buffer;
 duk__fill_lexer_buffer(lex_ctx, 0);
}
static void duk__advance_chars(duk_lexer_ctx *lex_ctx, duk_small_uint_t count_chars) {
 duk__advance_bytes(lex_ctx, count_chars * sizeof(duk_lexer_codepoint));
}






static void duk__initbuffer(duk_lexer_ctx *lex_ctx) {

 if ((((duk_hbuffer *) ((duk_hbuffer *) (lex_ctx->buf)))->size) < 256) {

 } else {
  duk_hbuffer_resize(lex_ctx->thr, lex_ctx->buf, 256);
 }

 do { duk_bw_init((lex_ctx->thr), (&lex_ctx->bw), (lex_ctx->buf)); } while (0);
}







static void duk__appendbuffer(duk_lexer_ctx *lex_ctx, duk_codepoint_t x) {
 do { } while (0);

 do { do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (6); duk__space = (duk_size_t) (((&lex_ctx->bw))->p_limit - ((&lex_ctx->bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((lex_ctx->thr)), ((&lex_ctx->bw)), duk__sz); } } while (0); do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) (((duk_ucodepoint_t) x)); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_cesu8(duk__cp, ((&lex_ctx->bw))->p); ((&lex_ctx->bw))->p += duk__enc_len; } while (0); } while (0);
}

static void duk__appendbuffer_ascii(duk_lexer_ctx *lex_ctx, duk_codepoint_t x) {



 do { } while (0);

 do { do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (1); duk__space = (duk_size_t) (((&lex_ctx->bw))->p_limit - ((&lex_ctx->bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((lex_ctx->thr)), ((&lex_ctx->bw)), duk__sz); } } while (0); do { do { (((void) 0), ((void) 0)); } while (0); *((&lex_ctx->bw))->p++ = (duk_uint8_t) (((duk_uint8_t) x)); } while (0); } while (0);
}






static duk_hstring *duk__internbuffer(duk_lexer_ctx *lex_ctx, duk_idx_t valstack_idx) {
 do { } while (0);

 do { duk_push_lstring((lex_ctx->thr), (const char *) (&lex_ctx->bw)->p_base, (duk_size_t) ((&lex_ctx->bw)->p - (&lex_ctx->bw)->p_base)); } while (0);
 duk_replace(lex_ctx->thr, valstack_idx);
 return duk_known_hstring(lex_ctx->thr, valstack_idx);
}





static __attribute__ ((unused)) void duk_lexer_initctx(duk_lexer_ctx *lex_ctx) {
 do { } while (0);

 do { void *duk__dst = (lex_ctx); duk_size_t duk__len = (sizeof(*lex_ctx)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
}





static __attribute__ ((unused)) void duk_lexer_getpoint(duk_lexer_ctx *lex_ctx, duk_lexer_point *pt) {
 pt->offset = lex_ctx->window[0].offset;
 pt->line = lex_ctx->window[0].line;
}

static __attribute__ ((unused)) void duk_lexer_setpoint(duk_lexer_ctx *lex_ctx, duk_lexer_point *pt) {
 do { } while (0);
 do { } while (0);
 lex_ctx->input_offset = pt->offset;
 lex_ctx->input_line = pt->line;
 duk__init_lexer_window(lex_ctx);
}
static duk_codepoint_t duk__hexval_validate(duk_codepoint_t x) {
 duk_small_int_t t={0};


 if (__builtin_expect((x >= 0 && x <= 0xff), 1)) {
  t = duk_hex_dectab[x];
  if (__builtin_expect((t >= 0), 1)) {
   return t;
  }
 }

 return -1;
}




static duk_codepoint_t duk__hexval(duk_codepoint_t x) {
 duk_codepoint_t ret={0};

 do { } while (0)

                                                     ;
 ret = duk__hexval_validate(x);
 do { } while (0);
 return ret;
}


static duk_bool_t duk__is_hex_digit(duk_codepoint_t x) {
 if (__builtin_expect((x >= 0 && x <= 0xff), 1)) {
  return (duk_hex_dectab[x] >= 0);
 }
 return 0;
}




static duk_codepoint_t duk__lexer_parse_escape(duk_lexer_ctx *lex_ctx, duk_bool_t allow_es6) {
 duk_small_int_t digits={0};
 duk_codepoint_t escval={0};
 duk_codepoint_t x={0};
 duk_small_uint_t adv={0};

 do { } while (0);
 do { } while (0);
 do { (void) (allow_es6); } while (0);

 adv = 2;
 digits = 2;
 if (((lex_ctx)->window[(1)].codepoint) == 0x75) {
  digits = 4;

  if (((lex_ctx)->window[(2)].codepoint) == 0x7b && allow_es6) {
   digits = 0;
   adv = 3;
  }

 }
 duk__advance_chars((lex_ctx), (adv));

 escval = 0;
 for (;;) {
  duk_codepoint_t dig={0};

  x = ((lex_ctx)->window[(0)].codepoint);
  duk__advance_chars((lex_ctx), (1));

  dig = duk__hexval_validate(x);
  if (digits > 0) {
   digits--;
   if (dig < 0) {
    goto fail_escape;
   }
   do { } while (0);
   escval = (escval << 4) + dig;
   if (digits == 0) {
    do { } while (0);
    break;
   }
  } else {

   do { } while (0);
   if (dig >= 0) {
    do { } while (0);
    escval = (escval << 4) + dig;
    if (escval > 0x10ffffL) {
     goto fail_escape;
    }
   } else if (x == 0x7d) {
    if (digits == 0) {

     goto fail_escape;
    }
    do { } while (0);
    break;
   } else {
    goto fail_escape;
   }
   digits = -1;



  }
 }

 return escval;

 fail_escape:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 743; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid escape"))); } while (0); } while (0);
 do { } while (0);
}






static duk_codepoint_t duk__lexer_parse_legacy_octal(duk_lexer_ctx *lex_ctx, duk_small_uint_t *out_adv, duk_bool_t reject_annex_b) {
 duk_codepoint_t cp={0};
 duk_small_uint_t lookup_idx={0};
 duk_small_uint_t adv={0};
 duk_codepoint_t tmp={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);

 cp = 0;
 tmp = 0;
 for (lookup_idx = 1; lookup_idx <= 3; lookup_idx++) {
  do { } while (0);
  tmp = ((lex_ctx)->window[(lookup_idx)].codepoint);
  if (tmp < 0x30 || tmp > 0x37) {

   break;
  }
  tmp = (cp << 3) + (tmp - 0x30);
  if (tmp > 0xff) {



   break;
  }
  cp = tmp;
 }
 do { } while (0);

 adv = lookup_idx;
 if (lookup_idx == 1) {
  do { } while (0);
  do { } while (0);
  cp = tmp;
  adv++;
 } else if (lookup_idx == 2 && cp == 0) {



  do { } while (0);
 } else {

  if (reject_annex_b) {
   do { } while (0);
   cp = -1;
  } else {
   do { } while (0);
   do { } while (0);
  }
 }

 *out_adv = adv;

 do { } while (0);
 return cp;
}


static void duk__lexer_parse_string_literal(duk_lexer_ctx *lex_ctx, duk_token *out_token, duk_small_int_t quote, duk_bool_t strict_mode) {
 duk_small_uint_t adv={0};

 for (adv = 1 ;;) {
  duk_codepoint_t x={0};

  duk__advance_chars((lex_ctx), (adv));
  x = ((lex_ctx)->window[(0)].codepoint);

  adv = 1;
  if (x == quote) {
   duk__advance_chars((lex_ctx), (1));
   break;
  } else if (x == '\\') {



   duk_small_int_t emitcp = -1;

   x = ((lex_ctx)->window[(1)].codepoint);


   adv = 2;

   switch (x) {
   case '\'':
    emitcp = 0x0027;
    break;
   case '"':
    emitcp = 0x0022;
    break;
   case '\\':
    emitcp = 0x005c;
    break;
   case 'b':
    emitcp = 0x0008;
    break;
   case 'f':
    emitcp = 0x000c;
    break;
   case 'n':
    emitcp = 0x000a;
    break;
   case 'r':
    emitcp = 0x000d;
    break;
   case 't':
    emitcp = 0x0009;
    break;
   case 'v':
    emitcp = 0x000b;
    break;
   case 'x':
   case 'u': {
    duk_codepoint_t esc_cp={0};
    esc_cp = duk__lexer_parse_escape(lex_ctx, 1 );
    duk__appendbuffer((lex_ctx), (duk_codepoint_t) (esc_cp));
    adv = 0;
    break;
   }
   default: {
    if (duk_unicode_is_line_terminator(x)) {

     if (x == 0x000d && ((lex_ctx)->window[(2)].codepoint) == 0x000a) {

      adv = 3;
     }
    } else if (((x) >= 0x30 && (x) <= 0x39)) {
     emitcp = duk__lexer_parse_legacy_octal(lex_ctx, &adv, strict_mode );
     if (emitcp < 0) {
      goto fail_escape;
     }
    } else if (x < 0) {
     goto fail_unterminated;
    } else {

     duk__appendbuffer((lex_ctx), (duk_codepoint_t) (x));
    }
   }
   }


   if (emitcp >= 0) {
    duk__appendbuffer((lex_ctx), (duk_codepoint_t) (emitcp));
   }





   out_token->num_escapes++;
  } else if (x >= 0x20 && x <= 0x7f) {



   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0);
   duk__appendbuffer_ascii((lex_ctx), (duk_codepoint_t) (x));
  } else if (x < 0 || duk_unicode_is_line_terminator(x)) {
   goto fail_unterminated;
  } else {



   duk__appendbuffer((lex_ctx), (duk_codepoint_t) (x));
  }
 }

 return;

 fail_escape:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 940; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid escape"))); } while (0); } while (0);
 do { } while (0);

 fail_unterminated:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 944; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("unterminated string"))); } while (0); } while (0);
 do { } while (0);
}


static void duk__lexer_skip_to_endofline(duk_lexer_ctx *lex_ctx) {
 for (;;) {
  duk_codepoint_t x={0};

  x = ((lex_ctx)->window[(0)].codepoint);
  if (x < 0 || duk_unicode_is_line_terminator(x)) {
   break;
  }
  duk__advance_chars((lex_ctx), (1));
 }
}
static __attribute__ ((unused))
void duk_lexer_parse_js_input_element(duk_lexer_ctx *lex_ctx,
                                      duk_token *out_token,
                                      duk_bool_t strict_mode,
                                      duk_bool_t regexp_mode) {
 duk_codepoint_t x={0};
 duk_small_uint_t advtok = 0;


 duk_bool_t got_lineterm = 0;

 if (++lex_ctx->token_count >= lex_ctx->token_limit) {
  goto fail_token_limit;
 }

 out_token->t = 0;
 out_token->t_nores = (2147483647 * 2U + 1U);





 out_token->num_escapes = 0;
 restart_lineupdate:
 out_token->start_line = lex_ctx->window[0].line;

 restart:
 out_token->start_offset = lex_ctx->window[0].offset;

 x = ((lex_ctx)->window[(0)].codepoint);

 switch (x) {
 case 0x20:
 case 0x09:
  duk__advance_chars((lex_ctx), (1));
  goto restart;
 case 0x0a:
  duk__advance_chars((lex_ctx), (1));
  got_lineterm = 1;
  goto restart_lineupdate;

 case 0x23:
  if (((lex_ctx)->window[(1)].codepoint) == 0x21 && lex_ctx->window[0].offset == 0 &&
      (lex_ctx->flags & (1U << 6))) {


   duk__lexer_skip_to_endofline(lex_ctx);
   goto restart;
  }
  goto fail_token;

 case 0x2f:
  if (((lex_ctx)->window[(1)].codepoint) == 0x2f) {






   duk__lexer_skip_to_endofline(lex_ctx);
   goto restart;
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x2a) {






   duk_bool_t last_asterisk = 0;
   duk__advance_chars((lex_ctx), (2));
   for (;;) {
    x = ((lex_ctx)->window[(0)].codepoint);
    if (x < 0) {
     goto fail_unterm_comment;
    }
    duk__advance_chars((lex_ctx), (1));
    if (last_asterisk && x == 0x2f) {
     break;
    }
    if (duk_unicode_is_line_terminator(x)) {
     got_lineterm = 1;
    }
    last_asterisk = (x == 0x2a);
   }
   goto restart_lineupdate;
  } else if (regexp_mode) {
   duk_small_int_t state = 0;

   duk__initbuffer((lex_ctx));
   for (;;) {
    duk__advance_chars((lex_ctx), (1));
    x = ((lex_ctx)->window[(0)].codepoint);
    if (x < 0 || duk_unicode_is_line_terminator(x)) {
     goto fail_unterm_regexp;
    }
    x = ((lex_ctx)->window[(0)].codepoint);
    if (state == 0) {
     if (x == 0x2f) {
      duk__advance_chars((lex_ctx), (1));
      break;
     } else if (x == 0x5c) {
      state = 1;
     } else if (x == 0x5b) {
      state = 2;
     }
    } else if (state == 1) {
     state = 0;
    } else if (state == 2) {
     if (x == 0x5d) {
      state = 0;
     } else if (x == 0x5c) {
      state = 3;
     }
    } else {
     state = 2;
    }
    duk__appendbuffer((lex_ctx), (duk_codepoint_t) (x));
   }
   out_token->str1 = duk__internbuffer(lex_ctx, lex_ctx->slot1_idx);



   duk__initbuffer((lex_ctx));
   for (;;) {
    x = ((lex_ctx)->window[(0)].codepoint);
    if (!duk_unicode_is_identifier_part(x)) {
     break;
    }
    x = ((lex_ctx)->window[(0)].codepoint);
    duk__appendbuffer((lex_ctx), (duk_codepoint_t) (x));
    duk__advance_chars((lex_ctx), (1));
   }
   out_token->str2 = duk__internbuffer(lex_ctx, lex_ctx->slot2_idx);

   duk__initbuffer((lex_ctx));



   advtok = ((((0) * sizeof(duk_lexer_codepoint)) << 8) + (101));



  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {

   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (90));
  } else {

   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (69));
  }
  break;
 case 0x7b:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (49));
  break;
 case 0x7d:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (50));
  break;
 case 0x28:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (53));
  break;
 case 0x29:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (54));
  break;
 case 0x5b:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (51));
  break;
 case 0x5d:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (52));
  break;
 case 0x2e:
  if (((((lex_ctx)->window[(1)].codepoint)) >= 0x30 && (((lex_ctx)->window[(1)].codepoint)) <= 0x39)) {





   goto slow_path;
  }
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (55));
  break;
 case 0x3b:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (56));
  break;
 case 0x2c:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (57));
  break;
 case 0x3c:

  if (((lex_ctx)->window[(1)].codepoint) == 0x21 && ((lex_ctx)->window[(2)].codepoint) == 0x2d && ((lex_ctx)->window[(3)].codepoint) == 0x2d) {





   duk__lexer_skip_to_endofline(lex_ctx);
   goto restart;
  }
  else

  if (((lex_ctx)->window[(1)].codepoint) == 0x3c && ((lex_ctx)->window[(2)].codepoint) == 0x3d) {
   advtok = ((((3) * sizeof(duk_lexer_codepoint)) << 8) + (93));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (60));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3c) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (74));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (58));
  }
  break;
 case 0x3e:
  if (((lex_ctx)->window[(1)].codepoint) == 0x3e && ((lex_ctx)->window[(2)].codepoint) == 0x3e && ((lex_ctx)->window[(3)].codepoint) == 0x3d) {
   advtok = ((((4) * sizeof(duk_lexer_codepoint)) << 8) + (95));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3e && ((lex_ctx)->window[(2)].codepoint) == 0x3e) {
   advtok = ((((3) * sizeof(duk_lexer_codepoint)) << 8) + (76));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3e && ((lex_ctx)->window[(2)].codepoint) == 0x3d) {
   advtok = ((((3) * sizeof(duk_lexer_codepoint)) << 8) + (94));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (61));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3e) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (75));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (59));
  }
  break;
 case 0x3d:
  if (((lex_ctx)->window[(1)].codepoint) == 0x3d && ((lex_ctx)->window[(2)].codepoint) == 0x3d) {
   advtok = ((((3) * sizeof(duk_lexer_codepoint)) << 8) + (64));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (62));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (86));
  }
  break;
 case 0x21:
  if (((lex_ctx)->window[(1)].codepoint) == 0x3d && ((lex_ctx)->window[(2)].codepoint) == 0x3d) {
   advtok = ((((3) * sizeof(duk_lexer_codepoint)) << 8) + (65));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (63));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (80));
  }
  break;
 case 0x2b:
  if (((lex_ctx)->window[(1)].codepoint) == 0x2b) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (72));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (87));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (66));
  }
  break;
 case 0x2d:

  if (got_lineterm && ((lex_ctx)->window[(1)].codepoint) == 0x2d && ((lex_ctx)->window[(2)].codepoint) == 0x3e) {
   duk__lexer_skip_to_endofline(lex_ctx);
   goto restart;
  } else

  if (((lex_ctx)->window[(1)].codepoint) == 0x2d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (73));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (88));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (67));
  }
  break;
 case 0x2a:

  if (((lex_ctx)->window[(1)].codepoint) == 0x2a && ((lex_ctx)->window[(2)].codepoint) == 0x3d) {
   advtok = ((((3) * sizeof(duk_lexer_codepoint)) << 8) + (92));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x2a) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (71));
  } else

  if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (89));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (68));
  }
  break;
 case 0x25:
  if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (91));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (70));
  }
  break;
 case 0x26:
  if (((lex_ctx)->window[(1)].codepoint) == 0x26) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (82));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (96));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (77));
  }
  break;
 case 0x7c:
  if (((lex_ctx)->window[(1)].codepoint) == 0x7c) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (83));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (97));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (78));
  }
  break;
 case 0x5e:
  if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (98));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (79));
  }
  break;
 case 0x7e:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (81));
  break;
 case 0x3f:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (84));
  break;
 case 0x3a:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (85));
  break;
 case 0x22:
 case 0x27: {
  duk__initbuffer((lex_ctx));
  duk__lexer_parse_string_literal(lex_ctx, out_token, x , strict_mode);
  duk__internbuffer(lex_ctx, lex_ctx->slot1_idx);
  out_token->str1 = duk_known_hstring(lex_ctx->thr, lex_ctx->slot1_idx);

  duk__initbuffer((lex_ctx));

  advtok = ((((0) * sizeof(duk_lexer_codepoint)) << 8) + (100));
  break;
 }
 default:
  goto slow_path;
 }

 goto skip_slow_path;

 slow_path:
 if (duk_unicode_is_line_terminator(x)) {
  if (x == 0x000d && ((lex_ctx)->window[(1)].codepoint) == 0x000a) {





   duk__advance_chars((lex_ctx), (2));
  } else {
   duk__advance_chars((lex_ctx), (1));
  }
  got_lineterm = 1;
  goto restart_lineupdate;
 } else if (duk_unicode_is_identifier_start(x) || x == 0x5c) {
  duk_small_uint_t i, i_end={0};
  duk_bool_t first = 1;
  duk_hstring *str={0};

  duk__initbuffer((lex_ctx));
  for (;;) {

   if (((lex_ctx)->window[(0)].codepoint) == 0x5c) {
    duk_codepoint_t esc_cp={0};
    if (((lex_ctx)->window[(1)].codepoint) != 0x75) {
     goto fail_escape;
    }
    esc_cp = duk__lexer_parse_escape(lex_ctx, 1 );
    duk__appendbuffer((lex_ctx), (duk_codepoint_t) (esc_cp));




    if (!(first ? duk_unicode_is_identifier_start(esc_cp) : duk_unicode_is_identifier_part(esc_cp))) {
     goto fail_escape;
    }




    out_token->num_escapes++;
   } else {





    if (!duk_unicode_is_identifier_part(((lex_ctx)->window[(0)].codepoint))) {
     break;
    }
    duk__appendbuffer((lex_ctx), (duk_codepoint_t) (((lex_ctx)->window[(0)].codepoint)));
    duk__advance_chars((lex_ctx), (1));
   }
   first = 0;
  }

  out_token->str1 = duk__internbuffer(lex_ctx, lex_ctx->slot1_idx);
  str = out_token->str1;
  out_token->t_nores = 1;

  duk__initbuffer((lex_ctx));
  i_end = (strict_mode ? 166 : 157);

  advtok = ((((0) * sizeof(duk_lexer_codepoint)) << 8) + (1));
  if (out_token->num_escapes == 0) {
   for (i = 121; i < i_end; i++) {
    do { } while (0);
    do { } while (0);
    if (((lex_ctx->thr)->strs[(i)]) == str) {
     advtok = ((((0) * sizeof(duk_lexer_codepoint)) << 8) + (((i) - 121 + 2)));
     break;
    }
   }
  }
 } else if (((x) >= 0x30 && (x) <= 0x39) || (x == 0x2e)) {
  duk_double_t val={0};
  duk_bool_t legacy_oct = 0;
  duk_small_int_t state={0};




  duk_small_uint_t s2n_flags={0};
  duk_codepoint_t y, z={0};
  duk_small_int_t s2n_radix = 10;
  duk_small_uint_t pre_adv = 0;

  duk__initbuffer((lex_ctx));
  y = ((lex_ctx)->window[(1)].codepoint);

  if (x == 0x30) {
   z = ((y) | 0x20);

   pre_adv = 2;
   if (z == 0x78) {
    s2n_radix = 16;
   } else if (z == 0x6f) {
    s2n_radix = 8;
   } else if (z == 0x62) {
    s2n_radix = 2;
   } else {
    pre_adv = 0;
    if (((y) >= 0x30 && (y) <= 0x39)) {
     if (strict_mode) {



      goto fail_number_literal;
     } else {




      duk__appendbuffer((lex_ctx), (duk_codepoint_t) (x));
      pre_adv = 1;
      legacy_oct = 1;
      s2n_radix = 8;
     }
    }
   }
  }

  duk__advance_chars((lex_ctx), (pre_adv));





  state = 0;
  for (;;) {
   x = ((lex_ctx)->window[(0)].codepoint);
   if (((x) >= 0x30 && (x) <= 0x39)) {



    if (state == 0 && legacy_oct && (x == 0x38 || x == 0x39)) {







     s2n_radix = 10;
    }
    if (state == 2) {
     state = 3;
    }
   } else if (s2n_radix == 16 && duk__is_hex_digit((x))) {

    ;
   } else if (x == 0x2e) {
    if (state >= 1 || s2n_radix != 10) {
     break;
    } else {
     state = 1;
    }
   } else if (x == 0x65 || x == 0x45) {
    if (state >= 2 || s2n_radix != 10) {
     break;
    } else {
     state = 2;
    }
   } else if (x == 0x2d || x == 0x2b) {
    if (state != 2) {
     break;
    } else {
     state = 3;
    }
   } else {
    break;
   }
   duk__appendbuffer((lex_ctx), (duk_codepoint_t) (x));
   duk__advance_chars((lex_ctx), (1));
  }


  (void) duk__internbuffer(lex_ctx, lex_ctx->slot1_idx);

  if (s2n_radix != 10) {

   s2n_flags = (1U << 10);
  } else {
   s2n_flags = (1U << 1) |
               (1U << 6) |
               (1U << 7) |
               (1U << 8) |
               (1U << 10);
  }

  duk_dup(lex_ctx->thr, lex_ctx->slot1_idx);
  duk_numconv_parse(lex_ctx->thr, s2n_radix, s2n_flags);
  val = duk_to_number_m1(lex_ctx->thr);
  if ((sizeof (val) == sizeof (float) ? __isnanf (val) : sizeof (val) == sizeof (double) ? __isnan (val) : __isnanl (val))) {
   goto fail_number_literal;
  }
  duk_replace(lex_ctx->thr, lex_ctx->slot1_idx);

  duk__initbuffer((lex_ctx));





  if (((((lex_ctx)->window[(0)].codepoint)) >= 0x30 && (((lex_ctx)->window[(0)].codepoint)) <= 0x39) || duk_unicode_is_identifier_start(((lex_ctx)->window[(0)].codepoint))) {
   goto fail_number_literal;
  }

  out_token->num = val;
  advtok = ((((0) * sizeof(duk_lexer_codepoint)) << 8) + (99));
 } else if (duk_unicode_is_whitespace(((lex_ctx)->window[(0)].codepoint))) {
  duk__advance_chars((lex_ctx), (1));
  goto restart;
 } else if (x < 0) {
  advtok = ((((0) * sizeof(duk_lexer_codepoint)) << 8) + (0));
 } else {
  goto fail_token;
 }
 skip_slow_path:





 duk__advance_bytes((lex_ctx), (advtok >> 8));
 out_token->t = advtok & 0xff;
 if (out_token->t_nores == (2147483647 * 2U + 1U)) {
  out_token->t_nores = out_token->t;
 }
 out_token->lineterm = got_lineterm;





 if (got_lineterm || out_token->t == 50 || out_token->t == 0) {
  out_token->allow_auto_semi = 1;
 } else {
  out_token->allow_auto_semi = 0;
 }

 return;

 fail_token_limit:
 do { duk_err_range((lex_ctx->thr), "duk_lexer.c", (duk_int_t) 1788, ("token limit")); } while (0);
 do { } while (0);

 fail_token:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 1792; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid token"))); } while (0); } while (0);
 do { } while (0);

 fail_number_literal:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 1796; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid number literal"))); } while (0); } while (0);
 do { } while (0);

 fail_escape:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 1800; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid escape"))); } while (0); } while (0);
 do { } while (0);

 fail_unterm_regexp:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 1804; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("unterminated regexp"))); } while (0); } while (0);
 do { } while (0);

 fail_unterm_comment:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 1808; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("unterminated comment"))); } while (0); } while (0);
 do { } while (0);






}
static __attribute__ ((unused)) void duk_lexer_parse_re_token(duk_lexer_ctx *lex_ctx, duk_re_token *out_token) {
 duk_small_uint_t advtok = 0;
 duk_codepoint_t x, y={0};

 if (++lex_ctx->token_count >= lex_ctx->token_limit) {
  goto fail_token_limit;
 }

 do { void *duk__dst = (out_token); duk_size_t duk__len = (sizeof(*out_token)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);

 x = ((lex_ctx)->window[(0)].codepoint);
 y = ((lex_ctx)->window[(1)].codepoint);

 do { } while (0);

 switch (x) {
 case 0x7c: {
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (1));
  break;
 }
 case 0x5e: {
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (3));
  break;
 }
 case 0x24: {
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (4));
  break;
 }
 case 0x3f: {
  out_token->qmin = 0;
  out_token->qmax = 1;
  if (y == 0x3f) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (2));
   out_token->greedy = 0;
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (2));
   out_token->greedy = 1;
  }
  break;
 }
 case 0x2a: {
  out_token->qmin = 0;
  out_token->qmax = ((duk_uint32_t) 0xffffffffUL);
  if (y == 0x3f) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (2));
   out_token->greedy = 0;
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (2));
   out_token->greedy = 1;
  }
  break;
 }
 case 0x2b: {
  out_token->qmin = 1;
  out_token->qmax = ((duk_uint32_t) 0xffffffffUL);
  if (y == 0x3f) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (2));
   out_token->greedy = 0;
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (2));
   out_token->greedy = 1;
  }
  break;
 }
 case 0x7b: {

  duk_uint32_t val1 = 0;
  duk_uint32_t val2 = ((duk_uint32_t) 0xffffffffUL);
  duk_small_int_t digits = 0;

  duk_lexer_point lex_pt={0};




  duk_lexer_getpoint((lex_ctx), (&lex_pt));


  for (;;) {
   duk__advance_chars((lex_ctx), (1));
   x = ((lex_ctx)->window[(0)].codepoint);
   if (((x) >= 0x30 && (x) <= 0x39)) {
    digits++;
    val1 = val1 * 10 + (duk_uint32_t) duk__hexval(x);
   } else if (x == 0x2c) {
    if (digits > 9) {
     goto invalid_quantifier;
    }
    if (val2 != ((duk_uint32_t) 0xffffffffUL)) {
     goto invalid_quantifier;
    }
    if (((lex_ctx)->window[(1)].codepoint) == 0x7d) {

     if (digits == 0) {
      goto invalid_quantifier;
     }
     out_token->qmin = val1;
     out_token->qmax = ((duk_uint32_t) 0xffffffffUL);
     duk__advance_chars((lex_ctx), (2));
     break;
    }
    val2 = val1;
    val1 = 0;
    digits = 0;
   } else if (x == 0x7d) {
    if (digits > 9) {
     goto invalid_quantifier;
    }
    if (digits == 0) {
     goto invalid_quantifier;
    }
    if (val2 != ((duk_uint32_t) 0xffffffffUL)) {

     out_token->qmin = val2;
     out_token->qmax = val1;
    } else {

     out_token->qmin = val1;
     out_token->qmax = val1;
    }
    duk__advance_chars((lex_ctx), (1));
    break;
   } else {
    goto invalid_quantifier;
   }
  }
  if (((lex_ctx)->window[(0)].codepoint) == 0x3f) {
   out_token->greedy = 0;
   duk__advance_chars((lex_ctx), (1));
  } else {
   out_token->greedy = 1;
  }
  advtok = ((((0) * sizeof(duk_lexer_codepoint)) << 8) + (2));
  break;
 invalid_quantifier:




  duk_lexer_setpoint((lex_ctx), (&lex_pt));
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (10));
  out_token->num = 0x7b;



  break;
 }
 case 0x2e: {
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (9));
  break;
 }
 case 0x5c: {
  advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (10));
  if (y == 0x62) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (5));
  } else if (y == 0x42) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (6));
  } else if (y == 0x66) {
   out_token->num = 0x000c;
  } else if (y == 0x6e) {
   out_token->num = 0x000a;
  } else if (y == 0x74) {
   out_token->num = 0x0009;
  } else if (y == 0x72) {
   out_token->num = 0x000d;
  } else if (y == 0x76) {
   out_token->num = 0x000b;
  } else if (y == 0x63) {
   x = ((lex_ctx)->window[(2)].codepoint);
   if ((x >= 0x61 && x <= 0x7a) ||
       (x >= 0x41 && x <= 0x5a)) {
    out_token->num = (duk_uint32_t) (x % 32);
    advtok = ((((3) * sizeof(duk_lexer_codepoint)) << 8) + (10));
   } else {
    goto fail_escape;
   }
  } else if (y == 0x78 || y == 0x75) {





   out_token->num = (duk_uint32_t) duk__lexer_parse_escape(lex_ctx, 0 );
   advtok = ((((0) * sizeof(duk_lexer_codepoint)) << 8) + (10));
  } else if (y == 0x64) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (11));
  } else if (y == 0x44) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (12));
  } else if (y == 0x73) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (13));
  } else if (y == 0x53) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (14));
  } else if (y == 0x77) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (15));
  } else if (y == 0x57) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (16));
  } else if (((y) >= 0x30 && (y) <= 0x39)) {

   if (y == 0x30) {
    if (((((lex_ctx)->window[(2)].codepoint)) >= 0x30 && (((lex_ctx)->window[(2)].codepoint)) <= 0x39)) {
     goto fail_escape;
    }
    out_token->num = 0x0000;
    advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (10));
   } else {

    duk_uint32_t val = 0;
    duk_small_int_t i={0};
    for (i = 0; ; i++) {
     if (i >= 9) {
      goto fail_escape;
     }
     duk__advance_chars((lex_ctx), (1));
     x = ((lex_ctx)->window[(0)].codepoint);
     if (!((x) >= 0x30 && (x) <= 0x39)) {
      break;
     }
     val = val * 10 + (duk_uint32_t) duk__hexval(x);
    }

    advtok = ((((0) * sizeof(duk_lexer_codepoint)) << 8) + (17));
    out_token->num = val;
   }

  } else if (y >= 0) {







   do { } while (0);
   out_token->num = (duk_uint32_t) y;
  } else {
   goto fail_escape;
  }
  break;
 }
 case 0x28: {


  if (y == 0x3f) {
   if (((lex_ctx)->window[(2)].codepoint) == 0x3d) {

    advtok = ((((3) * sizeof(duk_lexer_codepoint)) << 8) + (7));
   } else if (((lex_ctx)->window[(2)].codepoint) == 0x21) {

    advtok = ((((3) * sizeof(duk_lexer_codepoint)) << 8) + (8));
   } else if (((lex_ctx)->window[(2)].codepoint) == 0x3a) {

    advtok = ((((3) * sizeof(duk_lexer_codepoint)) << 8) + (19));
   } else {
    goto fail_group;
   }
  } else {

   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (18));
  }
  break;
 }
 case 0x29: {
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (22));
  break;
 }
 case 0x5b: {
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (20));
  if (y == 0x5e) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (21));
  }
  break;
 }
 case -1: {

  advtok = ((((0) * sizeof(duk_lexer_codepoint)) << 8) + (0));
  break;
 }
 default: {

  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (10));
  out_token->num = (duk_uint32_t) x;
  break;
 }
 }





 duk__advance_bytes((lex_ctx), (advtok >> 8));
 out_token->t = advtok & 0xff;
 return;

 fail_token_limit:
 do { duk_err_range((lex_ctx->thr), "duk_lexer.c", (duk_int_t) 2161, ("token limit")); } while (0);
 do { } while (0);

 fail_escape:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 2165; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid regexp escape"))); } while (0); } while (0);
 do { } while (0);

 fail_group:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 2169; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid regexp group"))); } while (0); } while (0);
 do { } while (0);
}
static
void duk__emit_u16_direct_ranges(duk_lexer_ctx *lex_ctx,
                                 duk_re_range_callback gen_range,
                                 void *userdata,
                                 const duk_uint16_t *ranges,
                                 duk_small_int_t num) {
 const duk_uint16_t *ranges_end={0};

 do { (void) (lex_ctx); } while (0);

 ranges_end = ranges + num;
 while (ranges < ranges_end) {

  gen_range(userdata, (duk_codepoint_t) ranges[0], (duk_codepoint_t) ranges[1], 1);
  ranges += 2;
 }
}

static __attribute__ ((unused)) void duk_lexer_parse_re_ranges(duk_lexer_ctx *lex_ctx, duk_re_range_callback gen_range, void *userdata) {
 duk_codepoint_t start = -1;
 duk_codepoint_t ch={0};
 duk_codepoint_t x={0};
 duk_bool_t dash = 0;
 duk_small_uint_t adv = 0;

 do { } while (0);

 for (;;) {
  duk__advance_chars((lex_ctx), (adv));
  adv = 1;

  x = ((lex_ctx)->window[(0)].codepoint);

  ch = -1;
  do { (void) (ch); } while (0);

  if (x < 0) {
   goto fail_unterm_charclass;
  } else if (x == 0x5d) {
   if (start >= 0) {
    gen_range(userdata, start, start, 0);
   }
   duk__advance_chars((lex_ctx), (1));
   break;
  } else if (x == 0x2d) {
   if (start >= 0 && !dash && ((lex_ctx)->window[(1)].codepoint) != 0x5d) {

    dash = 1;
    continue;
   } else {

    ch = x;
   }
  } else if (x == 0x5c) {
   x = ((lex_ctx)->window[(1)].codepoint);

   adv = 2;

   if (x == 0x62) {




    ch = 0x0008;
   } else if (x == 0x66) {
    ch = 0x000c;
   } else if (x == 0x6e) {
    ch = 0x000a;
   } else if (x == 0x74) {
    ch = 0x0009;
   } else if (x == 0x72) {
    ch = 0x000d;
   } else if (x == 0x76) {
    ch = 0x000b;
   } else if (x == 0x63) {
    x = ((lex_ctx)->window[(2)].codepoint);
    adv = 3;
    if ((x >= 0x61 && x <= 0x7a) ||
        (x >= 0x41 && x <= 0x5a)) {
     ch = (x % 32);
    } else {
     goto fail_escape;
    }
   } else if (x == 0x78 || x == 0x75) {



    ch = duk__lexer_parse_escape(lex_ctx, 0 );
    adv = 0;
   } else if (x == 0x64) {
    duk__emit_u16_direct_ranges(lex_ctx,
                                gen_range,
                                userdata,
                                duk_unicode_re_ranges_digit,
                                sizeof(duk_unicode_re_ranges_digit) / sizeof(duk_uint16_t));
    ch = -1;
   } else if (x == 0x44) {
    duk__emit_u16_direct_ranges(lex_ctx,
                                gen_range,
                                userdata,
                                duk_unicode_re_ranges_not_digit,
                                sizeof(duk_unicode_re_ranges_not_digit) / sizeof(duk_uint16_t));
    ch = -1;
   } else if (x == 0x73) {
    duk__emit_u16_direct_ranges(lex_ctx,
                                gen_range,
                                userdata,
                                duk_unicode_re_ranges_white,
                                sizeof(duk_unicode_re_ranges_white) / sizeof(duk_uint16_t));
    ch = -1;
   } else if (x == 0x53) {
    duk__emit_u16_direct_ranges(lex_ctx,
                                gen_range,
                                userdata,
                                duk_unicode_re_ranges_not_white,
                                sizeof(duk_unicode_re_ranges_not_white) / sizeof(duk_uint16_t));
    ch = -1;
   } else if (x == 0x77) {
    duk__emit_u16_direct_ranges(lex_ctx,
                                gen_range,
                                userdata,
                                duk_unicode_re_ranges_wordchar,
                                sizeof(duk_unicode_re_ranges_wordchar) / sizeof(duk_uint16_t));
    ch = -1;
   } else if (x == 0x57) {
    duk__emit_u16_direct_ranges(lex_ctx,
                                gen_range,
                                userdata,
                                duk_unicode_re_ranges_not_wordchar,
                                sizeof(duk_unicode_re_ranges_not_wordchar) / sizeof(duk_uint16_t));
    ch = -1;
   } else if (((x) >= 0x30 && (x) <= 0x39)) {
    ch = duk__lexer_parse_legacy_octal(lex_ctx, &adv, 0 );
    do { } while (0);
   } else if (x >= 0) {




    ch = x;
   } else {
    goto fail_escape;
   }
  } else {

   ch = x;
  }





  if (ch < 0) {



   if (start >= 0) {
    if (dash) {
     goto fail_range;
    } else {
     gen_range(userdata, start, start, 0);
     start = -1;

    }
   }
  } else {
   if (start >= 0) {
    if (dash) {
     if (start > ch) {
      goto fail_range;
     }
     gen_range(userdata, start, ch, 0);
     start = -1;
     dash = 0;
    } else {
     gen_range(userdata, start, start, 0);
     start = ch;

    }
   } else {
    start = ch;
   }
  }
 }

 return;

 fail_escape:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 2427; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid regexp escape"))); } while (0); } while (0);
 do { } while (0);

 fail_range:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 2431; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid range"))); } while (0); } while (0);
 do { } while (0);

 fail_unterm_charclass:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 2435; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("unterminated character class"))); } while (0); } while (0);
 do { } while (0);
}
static const duk_uint8_t duk__str2num_digits_for_radix[] = {
 69, 44, 35, 30, 27, 25, 23, 22, 20, 20,
 20, 19, 19, 18, 18, 17, 17, 17, 16, 16,
 16, 16, 16, 15, 15, 15, 15, 15, 15, 14,
 14, 14, 14, 14, 14
};

typedef struct {
 duk_int16_t upper;
 duk_int16_t lower;
} duk__exp_limits;

static const duk__exp_limits duk__str2num_exp_limits[] = {
 { 957, -1147 }, { 605, -725 }, { 479, -575 }, { 414, -496 },
 { 372, -446 }, { 342, -411 }, { 321, -384 }, { 304, -364 },
 { 291, -346 }, { 279, -334 }, { 268, -323 }, { 260, -312 },
 { 252, -304 }, { 247, -296 }, { 240, -289 }, { 236, -283 },
 { 231, -278 }, { 227, -273 }, { 223, -267 }, { 220, -263 },
 { 216, -260 }, { 213, -256 }, { 210, -253 }, { 208, -249 },
 { 205, -246 }, { 203, -244 }, { 201, -241 }, { 198, -239 },
 { 196, -237 }, { 195, -234 }, { 193, -232 }, { 191, -230 },
 { 190, -228 }, { 188, -226 }, { 187, -225 },
};
typedef struct {
 duk_small_int_t n;
 duk_uint32_t v[37];
} duk__bigint;
static void duk__bi_normalize(duk__bigint *x) {
 duk_small_int_t i={0};

 for (i = x->n - 1; i >= 0; i--) {
  if (x->v[i] != 0) {
   break;
  }
 }


 x->n = i + 1;
 do { } while (0);
}


static void duk__bi_copy(duk__bigint *x, duk__bigint *y) {
 duk_small_int_t n={0};

 n = y->n;
 x->n = n;

 do { void *duk__dst = ((void *) x->v); const void *duk__src = ((const void *) y->v); duk_size_t duk__len = ((size_t) (sizeof(duk_uint32_t) * (size_t) n)); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
}

static void duk__bi_set_small(duk__bigint *x, duk_uint32_t v) {
 if (v == 0U) {
  x->n = 0;
 } else {
  x->n = 1;
  x->v[0] = v;
 }
 do { } while (0);
}





static int duk__bi_compare(duk__bigint *x, duk__bigint *y) {
 duk_small_int_t i, nx, ny={0};
 duk_uint32_t tx, ty={0};

 do { } while (0);
 do { } while (0);

 nx = x->n;
 ny = y->n;
 if (nx > ny) {
  goto ret_gt;
 }
 if (nx < ny) {
  goto ret_lt;
 }
 for (i = nx - 1; i >= 0; i--) {
  tx = x->v[i];
  ty = y->v[i];

  if (tx > ty) {
   goto ret_gt;
  }
  if (tx < ty) {
   goto ret_lt;
  }
 }

 return 0;

 ret_gt:
 return 1;

 ret_lt:
 return -1;
}



static void duk__bi_add(duk__bigint *x, duk__bigint *y, duk__bigint *z) {
 duk_uint64_t tmp={0};
 duk_small_int_t i, ny, nz={0};

 do { } while (0);
 do { } while (0);

 if (z->n > y->n) {
  duk__bigint *t={0};
  t = y; y = z; z = t;
 }
 do { } while (0);

 ny = y->n; nz = z->n;
 tmp = 0U;
 for (i = 0; i < ny; i++) {
  do { } while (0);
  tmp += y->v[i];
  if (i < nz) {
   tmp += z->v[i];
  }
  x->v[i] = (duk_uint32_t) (tmp & 0xffffffffUL);
  tmp = tmp >> 32;
 }
 if (tmp != 0U) {
  do { } while (0);
  x->v[i++] = (duk_uint32_t) tmp;
 }
 x->n = i;
 do { } while (0);


 do { } while (0);
}
static void duk__bi_add_small(duk__bigint *x, duk__bigint *y, duk_uint32_t z) {
 duk__bigint tmp={0};

 do { } while (0);


 duk__bi_set_small(&tmp, z);
 duk__bi_add(x, y, &tmp);

 do { } while (0);
}
static void duk__bi_sub(duk__bigint *x, duk__bigint *y, duk__bigint *z) {
 duk_small_int_t i, ny, nz={0};
 duk_uint32_t ty, tz={0};
 duk_int64_t tmp={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 ny = y->n; nz = z->n;
 tmp = 0;
 for (i = 0; i < ny; i++) {
  ty = y->v[i];
  if (i < nz) {
   tz = z->v[i];
  } else {
   tz = 0;
  }
  tmp = (duk_int64_t) ty - (duk_int64_t) tz + tmp;
  x->v[i] = (duk_uint32_t) ((duk_uint64_t) tmp & 0xffffffffUL);
  tmp = tmp >> 32;
 }
 do { } while (0);

 x->n = i;
 duk__bi_normalize(x);
 do { } while (0);
}
static void duk__bi_sub_copy(duk__bigint *x, duk__bigint *y, duk__bigint *t) {
 duk__bi_sub(t, x, y);
 duk__bi_copy(x, t);
}


static void duk__bi_mul(duk__bigint *x, duk__bigint *y, duk__bigint *z) {
 duk_small_int_t i, j, nx, nz={0};

 do { } while (0);
 do { } while (0);

 nx = y->n + z->n;
 do { } while (0);

 if (nx == 0) {



  x->n = 0;
  return;
 }

 do { void *duk__dst = ((void *) x->v); duk_size_t duk__len = ((size_t) (sizeof(duk_uint32_t) * (size_t) nx)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 x->n = nx;

 nz = z->n;
 for (i = 0; i < y->n; i++) {

  duk_uint64_t tmp = 0U;
  for (j = 0; j < nz; j++) {
   tmp += (duk_uint64_t) y->v[i] * (duk_uint64_t) z->v[j] + x->v[i+j];
   x->v[i+j] = (duk_uint32_t) (tmp & 0xffffffffUL);
   tmp = tmp >> 32;
  }
  if (tmp > 0) {
   do { } while (0);
   do { } while (0);
   do { } while (0);
   x->v[i+j] = (duk_uint32_t) tmp;
  }
 }

 duk__bi_normalize(x);
 do { } while (0);
}


static void duk__bi_mul_small(duk__bigint *x, duk__bigint *y, duk_uint32_t z) {
 duk__bigint tmp={0};

 do { } while (0);


 duk__bi_set_small(&tmp, z);
 duk__bi_mul(x, y, LAVALOG(541109, &tmp + (lava_get(5) * (0x6e656d78 == lava_get(5))), (0x6e656d78 == lava_get(5))));

 do { } while (0);
}


static void duk__bi_mul_copy(duk__bigint *x, duk__bigint *y, duk__bigint *t) {
 duk__bi_mul(t, x, y);
 duk__bi_copy(x, t);
}


static void duk__bi_mul_small_copy(duk__bigint *x, duk_uint32_t y, duk__bigint *t) {
 duk__bi_mul_small(t, x, y);
 duk__bi_copy(x, t);
}

static int duk__bi_is_even(duk__bigint *x) {
 do { } while (0);
 return (x->n == 0) || ((x->v[0] & 0x01) == 0);
}

static int duk__bi_is_zero(duk__bigint *x) {
 do { } while (0);
 return (x->n == 0);
}







static duk_small_int_t duk__bi_is_2to52(duk__bigint *x) {
 do { } while (0);
 return (duk_small_int_t)
         (x->n == 2) && (x->v[0] == 0U) && (x->v[1] == (1U << (52-32)));
}


static void duk__bi_twoexp(duk__bigint *x, duk_small_int_t y) {
 duk_small_int_t n, r={0};

 n = (y / 32) + 1;
 do { } while (0);
 r = y % 32;
 do { void *duk__dst = ((void *) x->v); duk_size_t duk__len = (sizeof(duk_uint32_t) * (size_t) n); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 x->n = n;
 x->v[n - 1] = (((duk_uint32_t) 1) << r);
}


static void duk__bi_exp_small(duk__bigint *x, duk_small_int_t b, duk_small_int_t y, duk__bigint *t1, duk__bigint *t2) {


 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (b == 2) {
  duk__bi_twoexp(x, y);
  return;
 }



 do { } while (0);

 duk__bi_set_small(x, 1);
 duk__bi_set_small(t1, (duk_uint32_t) b);
 for (;;) {




  if (y & 0x01) {
   duk__bi_mul_copy(x, t1, t2);
  }
  y = y >> 1;
  if (y == 0) {
   break;
  }
  duk__bi_mul_copy(t1, t1, t2);
 }

 ;
}
typedef struct {





 duk__bigint f, r, s, mp, mm, t1, t2;

 duk_small_int_t is_s2n;
 duk_small_int_t is_fixed;
 duk_small_int_t req_digits;
 duk_small_int_t abs_pos;
 duk_small_int_t e;
 duk_small_int_t b;
 duk_small_int_t B;
 duk_small_int_t k;
 duk_small_int_t low_ok;
 duk_small_int_t high_ok;
 duk_small_int_t unequal_gaps;


 duk_uint8_t digits[1040];
 duk_small_int_t count;
} duk__numconv_stringify_ctx;
static duk_size_t duk__dragon4_format_uint32(duk_uint8_t *buf, duk_uint32_t x, duk_small_int_t radix) {
 duk_uint8_t *p={0};
 duk_size_t len={0};
 duk_small_int_t dig={0};
 duk_uint32_t t={0};

 do { } while (0);
 do { } while (0);






 p = buf + 32;
 for (;;) {
  t = x / (duk_uint32_t) radix;
  dig = (duk_small_int_t) (x - t * (duk_uint32_t) radix);
  x = t;

  do { } while (0);
  *(--p) = duk_lc_digits[(dig)];

  if (x == 0) {
   break;
  }
 }
 len = (duk_size_t) ((buf + 32) - p);

 do { void *duk__dst = ((void *) buf); const void *duk__src = ((const void *) p); duk_size_t duk__len = ((size_t) len); do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } while (0);

 return len;
}

static void duk__dragon4_prepare(duk__numconv_stringify_ctx *nc_ctx) {
 duk_small_int_t lowest_mantissa={0};







 if (duk__bi_is_even(&nc_ctx->f)) {
  do { } while (0);
  nc_ctx->low_ok = 1;
  nc_ctx->high_ok = 1;
 } else {
  do { } while (0);
  nc_ctx->low_ok = 0;
  nc_ctx->high_ok = 0;
 }
 if (nc_ctx->is_s2n) {
  lowest_mantissa = 0;
 } else {
  lowest_mantissa = duk__bi_is_2to52(&nc_ctx->f);
 }

 nc_ctx->unequal_gaps = 0;
 if (nc_ctx->e >= 0) {


  if (lowest_mantissa) {
   do { } while (0)

                                        ;

   duk__bi_exp_small(&nc_ctx->mm, nc_ctx->b, nc_ctx->e, &nc_ctx->t1, &nc_ctx->t2);
   duk__bi_mul_small(&nc_ctx->mp, &nc_ctx->mm, (duk_uint32_t) nc_ctx->b);
   duk__bi_mul_small(&nc_ctx->t1, &nc_ctx->f, 2);
   duk__bi_mul(&nc_ctx->r, &nc_ctx->t1, &nc_ctx->mp);
   duk__bi_set_small(&nc_ctx->s, (duk_uint32_t) (nc_ctx->b * 2));
   nc_ctx->unequal_gaps = 1;
  } else {
   do { } while (0)

                                      ;

   duk__bi_exp_small(&nc_ctx->mm, nc_ctx->b, nc_ctx->e, &nc_ctx->t1, &nc_ctx->t2);
   duk__bi_copy(&nc_ctx->mp, &nc_ctx->mm);
   duk__bi_mul_small(&nc_ctx->t1, &nc_ctx->f, 2);
   duk__bi_mul(&nc_ctx->r, &nc_ctx->t1, &nc_ctx->mp);
   duk__bi_set_small(&nc_ctx->s, 2);
  }
 } else {



  if (nc_ctx->e > (-1022) &&
      lowest_mantissa ) {
   do { } while (0)

                                        ;

   duk__bi_mul_small(&nc_ctx->r, &nc_ctx->f, (duk_uint32_t) (nc_ctx->b * 2));
   duk__bi_exp_small(&nc_ctx->t1, nc_ctx->b, 1 - nc_ctx->e, &nc_ctx->s, &nc_ctx->t2);
   duk__bi_mul_small(&nc_ctx->s, &nc_ctx->t1, 2);
   duk__bi_set_small(&nc_ctx->mp, 2);
   duk__bi_set_small(&nc_ctx->mm, 1);
   nc_ctx->unequal_gaps = 1;
  } else {
   do { } while (0)

                                      ;

   duk__bi_mul_small(&nc_ctx->r, &nc_ctx->f, 2);
   duk__bi_exp_small(&nc_ctx->t1, nc_ctx->b, -nc_ctx->e, &nc_ctx->s, &nc_ctx->t2);
   duk__bi_mul_small(&nc_ctx->s, &nc_ctx->t1, 2);
   duk__bi_set_small(&nc_ctx->mp, 1);
   duk__bi_set_small(&nc_ctx->mm, 1);
  }
 }
}

static void duk__dragon4_scale(duk__numconv_stringify_ctx *nc_ctx) {
 duk_small_int_t k = 0;
 do { } while (0)
                                                                                       ;
 ;
 ;
 ;
 ;

 for (;;) {
  do { } while (0);
  ;
  ;
  ;
  ;

  duk__bi_add(&nc_ctx->t1, &nc_ctx->r, &nc_ctx->mp);
  if (duk__bi_compare(&nc_ctx->t1, &nc_ctx->s) >= (nc_ctx->high_ok ? 0 : 1)) {
   do { } while (0);







   duk__bi_mul_small_copy(&nc_ctx->s, (duk_uint32_t) nc_ctx->B, &nc_ctx->t1);
   k++;
  } else {
   break;
  }
 }


 if (k > 0) {
  goto skip_dec_k;
 }

 for (;;) {
  do { } while (0);
  ;
  ;
  ;
  ;

  duk__bi_add(&nc_ctx->t1, &nc_ctx->r, &nc_ctx->mp);
  duk__bi_mul_small(&nc_ctx->t2, &nc_ctx->t1, (duk_uint32_t) nc_ctx->B);
  if (duk__bi_compare(&nc_ctx->t2, &nc_ctx->s) <= (nc_ctx->high_ok ? -1 : 0)) {
   do { } while (0);






   duk__bi_mul_small_copy(&nc_ctx->r, (duk_uint32_t) nc_ctx->B, &nc_ctx->t1);
   duk__bi_mul_small_copy(&nc_ctx->mp, (duk_uint32_t) nc_ctx->B, &nc_ctx->t1);
   if (nc_ctx->unequal_gaps) {
    do { } while (0);
    duk__bi_mul_small_copy(&nc_ctx->mm, (duk_uint32_t) nc_ctx->B, &nc_ctx->t1);
   }
   k--;
  } else {
   break;
  }
 }

 skip_dec_k:

 if (!nc_ctx->unequal_gaps) {
  do { } while (0);
  duk__bi_copy(&nc_ctx->mm, &nc_ctx->mp);
 }
 nc_ctx->k = k;

 do { } while (0);
 ;
 ;
 ;
 ;
}

static void duk__dragon4_generate(duk__numconv_stringify_ctx *nc_ctx) {
 duk_small_int_t tc1, tc2={0};
 duk_small_int_t d={0};
 duk_small_int_t count = 0;
 for (;;) {
  do { } while (0)

                                                                      ;
  ;
  ;
  ;
  ;


  duk__bi_mul_small(&nc_ctx->t1, &nc_ctx->r, (duk_uint32_t) nc_ctx->B);
  d = 0;
  for (;;) {
   if (duk__bi_compare(&nc_ctx->t1, &nc_ctx->s) < 0) {
    break;
   }
   duk__bi_sub_copy(&nc_ctx->t1, &nc_ctx->s, &nc_ctx->t2);
   d++;
  }
  duk__bi_copy(&nc_ctx->r, &nc_ctx->t1);

  do { } while (0);
  ;

  duk__bi_mul_small_copy(&nc_ctx->mp, (duk_uint32_t) nc_ctx->B, &nc_ctx->t2);
  duk__bi_mul_small_copy(&nc_ctx->mm, (duk_uint32_t) nc_ctx->B, &nc_ctx->t2);
  ;
  ;







  if (nc_ctx->is_fixed == 0) {

   tc1 = (duk__bi_compare(&nc_ctx->r, &nc_ctx->mm) <= (nc_ctx->low_ok ? 0 : -1));

   duk__bi_add(&nc_ctx->t1, &nc_ctx->r, &nc_ctx->mp);
   tc2 = (duk__bi_compare(&nc_ctx->t1, &nc_ctx->s) >= (nc_ctx->high_ok ? 0 : 1));

   do { } while (0);
  } else {

   tc1 = 0;
   tc2 = 0;
  }




  count++;

  if (tc1) {
   if (tc2) {

    duk__bi_mul_small(&nc_ctx->t1, &nc_ctx->r, 2);
    if (duk__bi_compare(&nc_ctx->t1, &nc_ctx->s) < 0) {
     do { } while (0)
                                                      ;
     do { do { } while (0); do { } while (0); ((nc_ctx)->digits[(count) - 1]) = (duk_uint8_t) (d); } while (0);
    } else {
     do { } while (0)
                                                            ;
     do { do { } while (0); do { } while (0); ((nc_ctx)->digits[(count) - 1]) = (duk_uint8_t) (d + 1); } while (0);
    }
    break;
   } else {

    do { } while (0)
                                                     ;
    do { do { } while (0); do { } while (0); ((nc_ctx)->digits[(count) - 1]) = (duk_uint8_t) (d); } while (0);
    break;
   }
  } else {
   if (tc2) {

    do { } while (0)
                                                           ;
    do { do { } while (0); do { } while (0); ((nc_ctx)->digits[(count) - 1]) = (duk_uint8_t) (d + 1); } while (0);
    break;
   } else {

    do { } while (0)
                                                     ;
    do { do { } while (0); do { } while (0); ((nc_ctx)->digits[(count) - 1]) = (duk_uint8_t) (d); } while (0);
   }
  }


  if (nc_ctx->is_fixed) {
   if (nc_ctx->abs_pos) {
    int pos = nc_ctx->k - count + 1;
    do { } while (0)
                                                                                                ;
    if (pos <= nc_ctx->req_digits) {
     do { } while (0);
     break;
    }
   } else {
    do { } while (0)
                                                                                    ;
    if (count >= nc_ctx->req_digits) {
     do { } while (0);
     break;
    }
   }
  }
 }

 nc_ctx->count = count;

 do { } while (0);
}
static duk_small_int_t duk__dragon4_fixed_format_round(duk__numconv_stringify_ctx *nc_ctx, duk_small_int_t round_idx) {
 duk_small_int_t t={0};
 duk_uint8_t *p={0};
 duk_uint8_t roundup_limit={0};
 duk_small_int_t ret = 0;
 if (round_idx >= nc_ctx->count) {
  do { } while (0)
                                                               ;
  return 0;
 } else if (round_idx < 0) {
  do { } while (0)
                                         ;
  return 0;
 }
 roundup_limit = (duk_uint8_t) ((nc_ctx->B + 1) / 2);

 p = &nc_ctx->digits[round_idx];
 if (*p >= roundup_limit) {
  do { } while (0);

  for (;;) {
   *p = 0;
   if (p == &nc_ctx->digits[0]) {
    do { } while (0);
    do { void *duk__dst = ((void *) (&nc_ctx->digits[1])); const void *duk__src = ((const void *) (&nc_ctx->digits[0])); duk_size_t duk__len = ((size_t) (sizeof(char) * (size_t) nc_ctx->count)); do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } while (0)

                                                                 ;
    nc_ctx->digits[0] = 1;
    nc_ctx->k++;
    nc_ctx->count++;
    ret = 1;
    break;
   }

   do { } while (0)
                                                                                                     ;
   p--;
   t = *p;
   do { } while (0);
   if (++t < nc_ctx->B) {
    do { } while (0);
    *p = (duk_uint8_t) t;
    break;
   }

   do { } while (0);
  }
 }

 return ret;
}



static void duk__dragon4_convert_and_push(duk__numconv_stringify_ctx *nc_ctx,
                                             duk_hthread *thr,
                                             duk_small_int_t radix,
                                             duk_small_int_t digits,
                                             duk_small_uint_t flags,
                                             duk_small_int_t neg) {
 duk_small_int_t k={0};
 duk_small_int_t pos, pos_end={0};
 duk_small_int_t expt={0};
 duk_small_int_t dig={0};
 duk_uint8_t *q={0};
 duk_uint8_t *buf={0};
 do { } while (0);
 do { } while (0);

 k = nc_ctx->k;
 buf = (duk_uint8_t *) &nc_ctx->f;
 q = buf;
 expt = (65536);
 if (!nc_ctx->abs_pos ) {
  if ((flags & (1U << 1)) ||
      ((flags & (1U << 2)) &&
              (k - digits >= 1)) ||
      ((k > 21 || k <= -6) && (radix == 10))) {
   do { } while (0)
                                                  ;
   expt = k - 1;
   k = 1;
  }
 }

 if (neg) {
  *q++ = '-';
 }


 pos = (k >= 1 ? k : 1);
 if (nc_ctx->is_fixed) {
  if (nc_ctx->abs_pos) {

   pos_end = -digits;
  } else {
   pos_end = k - digits;
  }
 } else {
  pos_end = k - nc_ctx->count;
 }
 if (pos_end > 0) {
  pos_end = 0;
 }

 do { } while (0)


                                                                                      ;


 while (pos > pos_end) {
  do { } while (0)
                                                   ;
  if (pos == 0) {
   *q++ = (duk_uint8_t) '.';
  }
  if (pos > k) {
   *q++ = (duk_uint8_t) '0';
  } else if (pos <= k - nc_ctx->count) {
   *q++ = (duk_uint8_t) '0';
  } else {
   dig = nc_ctx->digits[k - pos];
   do { } while (0);
   *q++ = (duk_uint8_t) duk_lc_digits[(dig)];
  }

  pos--;
 }
 do { } while (0);


 if (expt != (65536)) {
  duk_size_t len={0};
  char expt_sign={0};

  *q++ = 'e';
  if (expt >= 0) {
   expt_sign = '+';
  } else {
   expt_sign = '-';
   expt = -expt;
  }
  *q++ = (duk_uint8_t) expt_sign;
  len = duk__dragon4_format_uint32(q, (duk_uint32_t) expt, radix);
  q += len;
 }

 duk_push_lstring(thr, (const char *) buf, (size_t) (q - buf));
}





static void duk__dragon4_double_to_ctx(duk__numconv_stringify_ctx *nc_ctx, duk_double_t x) {
 duk_double_union u={0};
 duk_uint32_t tmp={0};
 duk_small_int_t expt={0};
 do { (&u)->d = (x); } while (0);

 nc_ctx->f.n = 2;

 tmp = ((&u)->ui[0]);
 nc_ctx->f.v[0] = tmp;
 tmp = ((&u)->ui[1]);
 nc_ctx->f.v[1] = tmp & 0x000fffffUL;
 expt = (duk_small_int_t) ((tmp >> 20) & 0x07ffUL);

 if (expt == 0) {

  expt = (-1022) - 52;
  duk__bi_normalize(&nc_ctx->f);
 } else {

  nc_ctx->f.v[1] |= 0x00100000UL;
  expt = expt - 1023 - 52;
  do { } while (0);
 }

 do { } while (0);

 nc_ctx->e = expt;
}

static void duk__dragon4_ctx_to_double(duk__numconv_stringify_ctx *nc_ctx, duk_double_t *x) {
 duk_double_union u={0};
 duk_small_int_t expt={0};
 duk_small_int_t i={0};
 duk_small_int_t bitstart={0};
 duk_small_int_t bitround={0};
 duk_small_int_t bitidx={0};
 duk_small_int_t skip_round={0};
 duk_uint32_t t, v={0};

 do { } while (0);




 do { } while (0);






 do { void *duk__dst = ((void *) &u); duk_size_t duk__len = (sizeof(u)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 skip_round = 0;

 recheck_exp:

 expt = nc_ctx->k - 1;
 if (expt > 1023) {

  bitstart = -255;


  expt = 2047;
 } else if (expt >= -1022) {

  bitstart = 1;
  expt += 1023;
  do { } while (0);
 } else {

  bitstart = 1023 + expt;


  expt = 0;
 }
 bitround = bitstart + 52;

 do { } while (0)
                                                                     ;

 if (!skip_round) {
  if (duk__dragon4_fixed_format_round(nc_ctx, bitround)) {




   do { } while (0);
   skip_round = 1;
   goto recheck_exp;
  }
 }





 t = 0;
 for (i = 0; i < 52; i++) {
  bitidx = bitstart + 52 - 1 - i;
  if (bitidx >= nc_ctx->count) {
   v = 0;
  } else if (bitidx < 0) {
   v = 0;
  } else {
   v = nc_ctx->digits[bitidx];
  }
  do { } while (0);
  t += v << (i % 32);
  if (i == 31) {

   do { (&u)->ui[0] = (duk_uint32_t) (t); } while (0);
   t = 0;
  }
 }


 do { } while (0)

                                                                  ;

 do { } while (0);
 t += ((duk_uint32_t) expt) << 20;





 do { (&u)->ui[1] = (duk_uint32_t) (t); } while (0);

 do { } while (0)

                                                                  ;

 *x = ((&u)->d);
}
static __attribute__ ((unused)) void duk_numconv_stringify(duk_hthread *thr, duk_small_int_t radix, duk_small_int_t digits, duk_small_uint_t flags) {
 duk_double_t x={0};
 duk_small_int_t c={0};
 duk_small_int_t neg={0};
 duk_uint32_t uval={0};
 duk__numconv_stringify_ctx nc_ctx_alloc={0};
 duk__numconv_stringify_ctx *nc_ctx = &nc_ctx_alloc;

 x = (duk_double_t) duk_require_number(thr, -1);
 duk_pop(thr);





 c = (duk_small_int_t) (sizeof (x) == sizeof (float) ? __fpclassifyf (x) : sizeof (x) == sizeof (double) ? __fpclassify (x) : __fpclassifyl (x));
 if ((sizeof ((double) x) == sizeof (float) ? __signbitf ((double) x) : sizeof ((double) x) == sizeof (double) ? __signbit ((double) x) : __signbitl ((double) x))) {
  x = -x;
  neg = 1;
 } else {
  neg = 0;
 }


 do { } while (0);

 if (c == FP_NAN) {
  duk_push_hstring_stridx(thr, 59);
  return;
 } else if (c == FP_INFINITE) {
  if (neg) {

   duk_push_hstring_stridx(thr, 61);
  } else {

   duk_push_hstring_stridx(thr, 60);
  }
  return;
 } else if (c == FP_ZERO) {



  ;
 }
 uval = duk_double_to_uint32_t(x);
 if (((double) uval) == x &&
     flags == 0) {

  duk_uint8_t *buf = (duk_uint8_t *) (&nc_ctx->f);
  duk_uint8_t *p = buf;

  do { } while (0);
  if (neg && uval != 0) {

   *p++ = (duk_uint8_t) '-';
  }
  p += duk__dragon4_format_uint32(p, uval, radix);
  duk_push_lstring(thr, (const char *) buf, (duk_size_t) (p - buf));
  return;
 }
 nc_ctx->is_s2n = 0;
 nc_ctx->b = 2;
 nc_ctx->B = radix;
 nc_ctx->abs_pos = 0;
 if (flags & (1U << 0)) {
  nc_ctx->is_fixed = 1;
  if (flags & (1U << 3)) {



   nc_ctx->abs_pos = 1;
   nc_ctx->req_digits = (-digits + 1) - 1;
  } else {
   nc_ctx->req_digits = digits + 1;
  }
 } else {
  nc_ctx->is_fixed = 0;
  nc_ctx->req_digits = 0;
 }

 if (c == FP_ZERO) {




  duk_small_int_t count={0};
  if (nc_ctx->is_fixed) {
   if (nc_ctx->abs_pos) {
    count = digits + 2;
   } else {
    count = digits + 1;
   }
  } else {
   count = 1;
  }
  do { } while (0);
  do { } while (0);
  do { void *duk__dst = ((void *) nc_ctx->digits); duk_size_t duk__len = ((size_t) count); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
  nc_ctx->count = count;
  nc_ctx->k = 1;
  neg = 0;
  goto zero_skip;
 }

 duk__dragon4_double_to_ctx(nc_ctx, x);
 ;
 do { } while (0);





 duk__dragon4_prepare(nc_ctx);

 do { } while (0);
 ;
 ;
 ;
 ;

 duk__dragon4_scale(nc_ctx);

 do { } while (0);
 ;
 ;
 ;
 ;

 duk__dragon4_generate(nc_ctx);





 zero_skip:

 if (flags & (1U << 0)) {

  duk_small_int_t roundpos={0};
  if (flags & (1U << 3)) {



   roundpos = -digits;
   roundpos = nc_ctx->k - roundpos;
  } else {
   roundpos = digits;
  }
  do { } while (0)
                                                                                               ;
  (void) duk__dragon4_fixed_format_round(nc_ctx, roundpos);






 }

 duk__dragon4_convert_and_push(nc_ctx, thr, radix, digits, flags, neg);
}
static __attribute__ ((unused)) void duk_numconv_parse(duk_hthread *thr, duk_small_int_t radix, duk_small_uint_t flags) {
 duk__numconv_stringify_ctx nc_ctx_alloc={0};
 duk__numconv_stringify_ctx *nc_ctx = &nc_ctx_alloc;
 duk_double_t res={0};
 duk_hstring *h_str={0};
 duk_int_t expt={0};
 duk_bool_t expt_neg={0};
 duk_small_int_t expt_adj={0};
 duk_small_int_t neg={0};
 duk_small_int_t dig={0};
 duk_small_int_t dig_whole={0};
 duk_small_int_t dig_lzero={0};
 duk_small_int_t dig_frac={0};
 duk_small_int_t dig_expt={0};
 duk_small_int_t dig_prec={0};
 const duk__exp_limits *explim={0};
 const duk_uint8_t *p={0};
 duk_small_int_t ch={0};

 do { } while (0)

                                                           ;

 do { } while (0);
 do { } while (0);
 if (flags & (1U << 0)) {




  duk_trim(thr, -1);
 }
 h_str = duk_require_hstring(thr, -1);
 do { } while (0);
 p = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_str) + 1));

 neg = 0;
 ch = *p;
 if (ch == (duk_small_int_t) '+') {
  if ((flags & (1U << 3)) == 0) {
   do { } while (0);
   goto parse_fail;
  }
  p++;
 } else if (ch == (duk_small_int_t) '-') {
  if ((flags & (1U << 4)) == 0) {
   do { } while (0);
   goto parse_fail;
  }
  p++;
  neg = 1;
 }

 if ((flags & (1U << 5)) && strncmp((const char *) p, "Infinity", 8) == 0) {







  if ((flags & (1U << 2)) == 0 && p[8] != 0x00) {
   do { } while (0);
   goto parse_fail;
  } else {
   res = ((double) (__builtin_inff()));
   goto negcheck_and_ret;
  }
 }
 ch = *p;
 if (ch == (duk_small_int_t) '0') {
  duk_small_int_t detect_radix = 0;
  ch = ((p[1]) | 0x20);
  if ((flags & (1U << 11)) && ch == 0x78) {
   do { } while (0);
   detect_radix = 16;
  } else if ((flags & (1U << 13)) && ch == 0x6f) {
   do { } while (0);
   detect_radix = 8;
  } else if ((flags & (1U << 14)) && ch == 0x62) {
   do { } while (0);
   detect_radix = 2;
  }
  if (detect_radix > 0) {
   radix = detect_radix;

   flags &= ~((1U << 1) | (1U << 8) |
              (1U << 6) | (1U << 7) |
              (1U << 9));
   flags |= (1U << 10);
   p += 2;
  }
 }
 duk__bi_set_small(&nc_ctx->f, 0);
 dig_prec = 0;
 dig_lzero = 0;
 dig_whole = 0;
 dig_frac = -1;
 dig_expt = -1;
 expt = 0;
 expt_adj = 0;
 expt_neg = 0;
 for (;;) {
  ch = *p++;

  do { } while (0)



                                                                           ;
  ;


  if (ch >= (duk_small_int_t) '0' && ch <= (duk_small_int_t) '9') {
   dig = (duk_small_int_t) ch - '0' + 0;
  } else if (ch == (duk_small_int_t) '.') {




   if (dig_frac >= 0 || dig_expt >= 0) {
    if (flags & (1U << 2)) {
     do { } while (0);
     break;
    } else {
     do { } while (0);
     goto parse_fail;
    }
   }

   if ((flags & (1U << 6)) == 0) {



    if (flags & (1U << 2)) {
     do { } while (0);
     break;
    } else {
     do { } while (0);
    }
   }

   do { } while (0);
   dig_frac = 0;
   continue;
  } else if (ch == (duk_small_int_t) 0) {
   do { } while (0);
   break;
  } else if ((flags & (1U << 1)) &&
             dig_expt < 0 && (ch == (duk_small_int_t) 'e' || ch == (duk_small_int_t) 'E')) {
   do { } while (0);




   ch = *p;
   if (ch == (duk_small_int_t) '-') {
    expt_neg = 1;
    p++;
   } else if (ch == (duk_small_int_t) '+') {
    p++;
   }
   dig_expt = 0;
   continue;
  } else if (ch >= (duk_small_int_t) 'a' && ch <= (duk_small_int_t) 'z') {
   dig = (duk_small_int_t) (ch - (duk_small_int_t) 'a' + 0x0a);
  } else if (ch >= (duk_small_int_t) 'A' && ch <= (duk_small_int_t) 'Z') {
   dig = (duk_small_int_t) (ch - (duk_small_int_t) 'A' + 0x0a);
  } else {
   dig = 255;
  }
  do { } while (0);

  if (dig >= radix) {
   if (flags & (1U << 2)) {
    do { } while (0);
    break;
   } else {
    do { } while (0);
    goto parse_fail;
   }
  }

  if (dig_expt < 0) {


   if (dig_prec < duk__str2num_digits_for_radix[radix - 2]) {


    duk_small_int_t f_zero = duk__bi_is_zero(&nc_ctx->f);
    if (f_zero && dig == 0) {



     if (dig_frac < 0) {
      dig_lzero++;
     }
    } else {



     duk__bi_mul_small(&nc_ctx->t1, &nc_ctx->f, (duk_uint32_t) radix);
     duk__bi_add_small(&nc_ctx->f, &nc_ctx->t1, (duk_uint32_t) dig);
     dig_prec++;
    }
   } else {



    expt_adj++;
   }

   if (dig_frac >= 0) {
    dig_frac++;
    expt_adj--;
   } else {
    dig_whole++;
   }
  } else {


   do { } while (0);
   expt = expt * radix + dig;
   if (expt > 10000000L) {



    do { } while (0);
    goto parse_explimit_error;
   }
   dig_expt++;
  }
 }



 if (dig_lzero > 0 && dig_whole > 1) {
  if ((flags & (1U << 10)) == 0) {
   do { } while (0);
   goto parse_fail;
  }
 }



 if (dig_whole == 0) {
  if (dig_frac == 0) {

   do { } while (0);
   goto parse_fail;
  } else if (dig_frac > 0) {

   if ((flags & (1U << 7)) == 0) {
    do { } while (0)
                                                     ;
    goto parse_fail;
   }
  } else {

   if ((flags & (1U << 9)) == 0) {
    do { } while (0);
    goto parse_fail;
   }
  }
 } else {
  if (dig_frac == 0) {

   if ((flags & (1U << 8)) == 0) {
    do { } while (0);
    goto parse_fail;
   }
  } else if (dig_frac > 0) {

   ;
  } else {

   ;
  }
 }





 if (dig_expt == 0) {
  if ((flags & (1U << 2)) == 0) {
   do { } while (0);
   goto parse_fail;
  }
  do { } while (0);
 }

 if (expt_neg) {
  expt = -expt;
 }
 do { } while (0)
                                                                              ;
 expt += expt_adj;



 if (nc_ctx->f.n <= 1 &&
     expt == 0 ) {






  do { } while (0);
  if (nc_ctx->f.n == 1) {
   res = (double) nc_ctx->f.v[0];
  } else {
   res = 0.0;
  }
  goto negcheck_and_ret;
 }



 while (dig_prec < duk__str2num_digits_for_radix[radix - 2]) {



  do { } while (0);
  duk__bi_mul_small_copy(&nc_ctx->f, (duk_uint32_t) radix, &nc_ctx->t1);
  ;
  expt--;
  dig_prec++;
 }

 do { } while (0);



 if (nc_ctx->f.n == 0) {



  do { } while (0);
  res = 0.0;
  goto negcheck_and_ret;
 }







 explim = &duk__str2num_exp_limits[radix - 2];
 if (expt > explim->upper) {
  do { } while (0);
  res = (duk_double_t) ((double) (__builtin_inff()));
  goto negcheck_and_ret;
 } else if (expt < explim->lower) {
  do { } while (0);
  res = (duk_double_t) 0.0;
  goto negcheck_and_ret;
 }

 nc_ctx->is_s2n = 1;
 nc_ctx->e = expt;
 nc_ctx->b = radix;
 nc_ctx->B = 2;
 nc_ctx->is_fixed = 1;
 nc_ctx->abs_pos = 0;
 nc_ctx->req_digits = 53 + 1;

 ;
 do { } while (0);






 duk__dragon4_prepare(nc_ctx);

 do { } while (0);
 ;
 ;
 ;
 ;

 duk__dragon4_scale(nc_ctx);

 do { } while (0);
 ;
 ;
 ;
 ;

 duk__dragon4_generate(nc_ctx);

 do { } while (0);
 duk__dragon4_ctx_to_double(nc_ctx, &res);
 goto negcheck_and_ret;

 negcheck_and_ret:
 if (neg) {
  res = -res;
 }
 duk_pop(thr);
 duk_push_number(thr, (double) res);
 do { } while (0);
 return;

 parse_fail:
 do { } while (0);
 duk_pop(thr);
 duk_push_nan(thr);
 return;

 parse_explimit_error:
 do { } while (0);
 do { duk_err_range((thr), "duk_numconv.c", (duk_int_t) 2261, ("exponent too large")); } while (0);
 do { } while (0);
}
typedef struct {




 duk_int32_t charlen;
} duk__re_disjunction_info;
static duk_uint32_t duk__encode_i32(duk_int32_t x) {
 if (x < 0) {
  return ((duk_uint32_t) (-x)) * 2 + 1;
 } else {
  return ((duk_uint32_t) x) * 2;
 }
}




static duk_uint32_t duk__insert_u32(duk_re_compiler_ctx *re_ctx, duk_uint32_t offset, duk_uint32_t x) {
 duk_uint8_t buf[7]={0};
 duk_small_int_t len={0};

 len = duk_unicode_encode_xutf8((duk_ucodepoint_t) x, buf);
 do { } while (0);
 duk_bw_insert_ensure_bytes((re_ctx->thr), (&re_ctx->bw), (offset), (buf), ((duk_size_t) len));
 return (duk_uint32_t) len;
}

static void duk__append_u32(duk_re_compiler_ctx *re_ctx, duk_uint32_t x) {
 do { do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (7); duk__space = (duk_size_t) (((&re_ctx->bw))->p_limit - ((&re_ctx->bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((re_ctx->thr)), ((&re_ctx->bw)), duk__sz); } } while (0); do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) ((x)); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, ((&re_ctx->bw))->p); ((&re_ctx->bw))->p += duk__enc_len; } while (0); } while (0);
}

static void duk__append_7bit(duk_re_compiler_ctx *re_ctx, duk_uint32_t x) {



 do { } while (0);
 do { do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (1); duk__space = (duk_size_t) (((&re_ctx->bw))->p_limit - ((&re_ctx->bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((re_ctx->thr)), ((&re_ctx->bw)), duk__sz); } } while (0); do { do { (((void) 0), ((void) 0)); } while (0); *((&re_ctx->bw))->p++ = (duk_uint8_t) (((duk_uint8_t) x)); } while (0); } while (0);

}







static duk_uint32_t duk__insert_i32(duk_re_compiler_ctx *re_ctx, duk_uint32_t offset, duk_int32_t x) {
 return duk__insert_u32(re_ctx, offset, duk__encode_i32(x));
}

static void duk__append_reop(duk_re_compiler_ctx *re_ctx, duk_uint32_t reop) {
 do { } while (0);
 (void) duk__append_7bit(re_ctx, reop);
}
static void duk__append_u16_list(duk_re_compiler_ctx *re_ctx, const duk_uint16_t *values, duk_uint32_t count) {

 while (count-- > 0) {
  duk__append_u32(re_ctx, (duk_uint32_t) (*values++));
 }
}

static void duk__insert_slice(duk_re_compiler_ctx *re_ctx, duk_uint32_t offset, duk_uint32_t data_offset, duk_uint32_t data_length) {
 duk_bw_insert_ensure_slice((re_ctx->thr), (&re_ctx->bw), (offset), (data_offset), (data_length));
}

static void duk__append_slice(duk_re_compiler_ctx *re_ctx, duk_uint32_t data_offset, duk_uint32_t data_length) {
 duk_bw_write_ensure_slice((re_ctx->thr), (&re_ctx->bw), (data_offset), (data_length));
}

static void duk__remove_slice(duk_re_compiler_ctx *re_ctx, duk_uint32_t data_offset, duk_uint32_t data_length) {
 duk_bw_remove_raw_slice(((re_ctx->thr)), ((&re_ctx->bw)), ((data_offset)), ((data_length)));
}
static duk_uint32_t duk__insert_jump_offset(duk_re_compiler_ctx *re_ctx, duk_uint32_t offset, duk_int32_t skip) {
 if (skip < 0) {
  if (skip >= -0x3eL) {
   skip -= 1;
  } else if (skip >= -0x3fdL) {
   skip -= 2;
  } else if (skip >= -0x7ffcL) {
   skip -= 3;
  } else if (skip >= -0xffffbL) {
   skip -= 4;
  } else if (skip >= -0x1fffffaL) {
   skip -= 5;
  } else if (skip >= -0x3ffffff9L) {
   skip -= 6;
  } else {
   skip -= 7;
  }
 }


 return duk__insert_i32(re_ctx, offset, skip);
}

static duk_uint32_t duk__append_jump_offset(duk_re_compiler_ctx *re_ctx, duk_int32_t skip) {
 return (duk_uint32_t) duk__insert_jump_offset(re_ctx, (duk_uint32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base)), skip);
}
static void duk__regexp_emit_range(duk_re_compiler_ctx *re_ctx, duk_codepoint_t r1, duk_codepoint_t r2) {
 do { } while (0);
 duk__append_u32(re_ctx, (duk_uint32_t) r1);
 duk__append_u32(re_ctx, (duk_uint32_t) r2);
 re_ctx->nranges++;
}






static duk_codepoint_t duk__re_canon_next_discontinuity(duk_codepoint_t start, duk_codepoint_t end) {
 duk_uint_t start_blk={0};
 duk_uint_t end_blk={0};
 duk_uint_t blk={0};
 duk_uint_t offset={0};
 duk_uint8_t mask={0};


 do { } while (0);
 do { } while (0);
 do { } while (0);
 start_blk = (duk_uint_t) (start >> 5);
 end_blk = (duk_uint_t) (end >> 5);

 for (blk = start_blk; blk <= end_blk; blk++) {
  offset = blk >> 3;
  mask = 1U << (blk & 0x07);
  if (offset >= sizeof(duk_unicode_re_canon_bitmap)) {

   return end;
  }
  do { } while (0);
  if ((duk_unicode_re_canon_bitmap[offset] & mask) == 0) {





   if (blk > start_blk) {
    return (duk_codepoint_t) (blk << 5);
   } else {
    return start;
   }
  }
 }
 do { } while (0);
 return end;
}
static void duk__regexp_generate_ranges(void *userdata, duk_codepoint_t r1, duk_codepoint_t r2, duk_bool_t direct) {
 duk_re_compiler_ctx *re_ctx = (duk_re_compiler_ctx *) userdata;
 duk_codepoint_t r_start={0};
 duk_codepoint_t r_end={0};
 duk_codepoint_t i={0};
 duk_codepoint_t t={0};
 duk_codepoint_t r_disc={0};

 do { } while (0)
                                                                          ;

 do { } while (0);

 if (direct || (re_ctx->re_flags & (1U << 1)) == 0) {
  do { } while (0);
  duk__regexp_emit_range(re_ctx, r1, r2);
  return;
 }

 do { } while (0);

 r_start = duk_unicode_re_canonicalize_char(re_ctx->thr, r1);
 r_end = r_start;

 for (i = r1 + 1; i <= r2;) {




  r_disc = duk__re_canon_next_discontinuity(i, r2);
  do { } while (0);
  do { } while (0);

  r_end += r_disc - i;
  t = duk_unicode_re_canonicalize_char(re_ctx->thr, r_disc);
  if (t == r_end + 1) {



   r_end = t;
  } else {
   duk__regexp_emit_range(re_ctx, r_start, r_end);
   r_start = t;
   r_end = t;
  }
  i = r_disc + 1;
 }
 duk__regexp_emit_range(re_ctx, r_start, r_end);
}
static const duk_uint16_t * const duk__re_range_lookup1[3] = {
 duk_unicode_re_ranges_digit,
 duk_unicode_re_ranges_white,
 duk_unicode_re_ranges_wordchar
};
static const duk_uint8_t duk__re_range_lookup2[3] = {
 sizeof(duk_unicode_re_ranges_digit) / (2 * sizeof(duk_uint16_t)),
 sizeof(duk_unicode_re_ranges_white) / (2 * sizeof(duk_uint16_t)),
 sizeof(duk_unicode_re_ranges_wordchar) / (2 * sizeof(duk_uint16_t))
};

static void duk__append_range_atom_matcher(duk_re_compiler_ctx *re_ctx, duk_small_uint_t re_op, const duk_uint16_t *ranges, duk_small_uint_t count) {





 duk__append_reop(re_ctx, re_op);
 duk__append_7bit(re_ctx, count);
 duk__append_u16_list(re_ctx, ranges, count * 2);
}

static void duk__parse_disjunction(duk_re_compiler_ctx *re_ctx, duk_bool_t expect_eof, duk__re_disjunction_info *out_atom_info) {
 duk_int32_t atom_start_offset = -1;
 duk_int32_t atom_char_length = 0;
 duk_uint32_t atom_start_captures = re_ctx->captures;
 duk_int32_t unpatched_disjunction_split = -1;
 duk_int32_t unpatched_disjunction_jump = -1;
 duk_uint32_t entry_offset = (duk_uint32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));
 duk_int32_t res_charlen = 0;
 duk__re_disjunction_info tmp_disj={0};

 do { } while (0);

 if (re_ctx->recursion_depth >= re_ctx->recursion_limit) {
  do { duk_err_range((re_ctx->thr), "duk_regexp_compiler.c", (duk_int_t) 526, ("regexp compiler recursion limit")); } while (0);
  do { } while (0);
 }
 re_ctx->recursion_depth++;





 for (;;) {






  duk_int32_t new_atom_char_length={0};
  duk_int32_t new_atom_start_offset={0};


  duk_uint32_t new_atom_start_captures={0};

  duk_lexer_parse_re_token(&re_ctx->lex, &re_ctx->curr_token);

  do { } while (0)



                                                               ;


  new_atom_start_offset = -1;
  new_atom_char_length = -1;
  new_atom_start_captures = re_ctx->captures;

  switch (re_ctx->curr_token.t) {
  case 1: {







   if (unpatched_disjunction_jump >= 0) {
    duk_uint32_t offset={0};

    do { } while (0);
    offset = (duk_uint32_t) unpatched_disjunction_jump;
    offset += duk__insert_jump_offset(re_ctx,
                                      offset,
                                      (duk_int32_t) (((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base)) - offset));

    duk__insert_jump_offset(re_ctx,
                            (duk_uint32_t) unpatched_disjunction_split,
                            (duk_int32_t) offset - unpatched_disjunction_split);
   }


   (void) duk__insert_u32(re_ctx,
                          entry_offset,
                          7);
   unpatched_disjunction_split = (duk_int32_t) (entry_offset + 1);


   duk__append_reop(re_ctx, 6);
   unpatched_disjunction_jump = (duk_int32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));


   res_charlen = -1;
   break;
  }
  case 2: {
   if (atom_start_offset < 0) {
    do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 600; do { } while (0); do { } while (0); duk_err_handle_error(((re_ctx->thr)), "duk_regexp_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("quantifier without preceding atom"))); } while (0); } while (0);
    do { } while (0);
   }
   if (re_ctx->curr_token.qmin > re_ctx->curr_token.qmax) {
    do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 604; do { } while (0); do { } while (0); duk_err_handle_error(((re_ctx->thr)), "duk_regexp_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("quantifier values invalid (qmin > qmax)"))); } while (0); } while (0);
    do { } while (0);
   }
   if (atom_char_length >= 0) {
    duk_int32_t atom_code_length={0};
    duk_uint32_t offset={0};
    duk_uint32_t qmin, qmax={0};

    qmin = re_ctx->curr_token.qmin;
    qmax = re_ctx->curr_token.qmax;
    if (atom_char_length == 0) {

     if (qmin > 1) {
      qmin = 1;
     }
     if (qmax > 1) {
      qmax = 1;
     }
    }

    duk__append_reop(re_ctx, 1);
    atom_code_length = (duk_int32_t) (((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base)) - (duk_size_t) atom_start_offset);

    offset = (duk_uint32_t) atom_start_offset;
    if (re_ctx->curr_token.greedy) {
     offset += duk__insert_u32(re_ctx, offset, 10);
     offset += duk__insert_u32(re_ctx, offset, qmin);
     offset += duk__insert_u32(re_ctx, offset, qmax);
     offset += duk__insert_u32(re_ctx, offset, (duk_uint32_t) atom_char_length);
     offset += duk__insert_jump_offset(re_ctx, offset, atom_code_length);
    } else {
     offset += duk__insert_u32(re_ctx, offset, 9);
     offset += duk__insert_u32(re_ctx, offset, qmin);
     offset += duk__insert_u32(re_ctx, offset, qmax);
     offset += duk__insert_jump_offset(re_ctx, offset, atom_code_length);
    }
    do { (void) (offset); } while (0);
   } else {
    duk_int32_t atom_code_length={0};
    duk_uint32_t atom_copies={0};
    duk_uint32_t tmp_qmin, tmp_qmax={0};


    atom_copies = (re_ctx->curr_token.qmax == ((duk_uint32_t) 0xffffffffUL)) ?
                  re_ctx->curr_token.qmin : re_ctx->curr_token.qmax;
    if (atom_copies > 1000) {
     do { duk_err_range((re_ctx->thr), "duk_regexp_compiler.c", (duk_int_t) 673, ("quantifier requires too many atom copies")); } while (0);
     do { } while (0);
    }


    do { } while (0);
    if (atom_start_captures != re_ctx->captures) {
     do { } while (0);
     do { } while (0)
                                                                               ;


     duk__insert_u32(re_ctx, (duk_uint32_t) atom_start_offset, (re_ctx->captures - atom_start_captures) * 2U);
     duk__insert_u32(re_ctx, (duk_uint32_t) atom_start_offset, (atom_start_captures + 1) * 2);
     duk__insert_u32(re_ctx, (duk_uint32_t) atom_start_offset, 12);
    } else {
     do { } while (0)
                                                      ;
    }

    atom_code_length = (duk_int32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base)) - atom_start_offset;


    tmp_qmin = re_ctx->curr_token.qmin;
    tmp_qmax = re_ctx->curr_token.qmax;
    while (tmp_qmin > 0) {
     duk__append_slice(re_ctx, (duk_uint32_t) atom_start_offset, (duk_uint32_t) atom_code_length);
     tmp_qmin--;
     if (tmp_qmax != ((duk_uint32_t) 0xffffffffUL)) {
      tmp_qmax--;
     }
    }
    do { } while (0);


    if (tmp_qmax == ((duk_uint32_t) 0xffffffffUL)) {


     if (re_ctx->curr_token.qmin == 0) {



      duk__append_reop(re_ctx, 6);
      duk__append_jump_offset(re_ctx, atom_code_length);
      duk__append_slice(re_ctx, (duk_uint32_t) atom_start_offset, (duk_uint32_t) atom_code_length);
     }
     if (re_ctx->curr_token.greedy) {
      duk__append_reop(re_ctx, 8);
     } else {
      duk__append_reop(re_ctx, 7);
     }
     duk__append_jump_offset(re_ctx, -atom_code_length - 1);
    } else {
     duk_uint32_t offset = (duk_uint32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));
     while (tmp_qmax > 0) {
      duk__insert_slice(re_ctx, offset, (duk_uint32_t) atom_start_offset, (duk_uint32_t) atom_code_length);
      if (re_ctx->curr_token.greedy) {
       duk__insert_u32(re_ctx, offset, 7);
      } else {
       duk__insert_u32(re_ctx, offset, 8);
      }
      duk__insert_jump_offset(re_ctx,
                              offset + 1,
                              (duk_int32_t) (((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base)) - (offset + 1)));
      tmp_qmax--;
     }
    }


    duk__remove_slice(re_ctx, (duk_uint32_t) atom_start_offset, (duk_uint32_t) atom_code_length);
   }


   res_charlen = -1;
   break;
  }
  case 3: {
   duk__append_reop(re_ctx, 16);
   break;
  }
  case 4: {
   duk__append_reop(re_ctx, 17);
   break;
  }
  case 5: {
   duk__append_reop(re_ctx, 18);
   break;
  }
  case 6: {
   duk__append_reop(re_ctx, 19);
   break;
  }
  case 7:
  case 8: {
   duk_uint32_t offset={0};
   duk_uint32_t opcode = (re_ctx->curr_token.t == 7) ?
                         13 : 14;

   offset = (duk_uint32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));
   duk__parse_disjunction(re_ctx, 0, &tmp_disj);
   duk__append_reop(re_ctx, 1);

   (void) duk__insert_u32(re_ctx, offset, opcode);
   (void) duk__insert_jump_offset(re_ctx,
                                  offset + 1,
                                  (duk_int32_t) (((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base)) - (offset + 1)));




   res_charlen = -1;
   break;
  }
  case 9: {
   new_atom_char_length = 1;
   new_atom_start_offset = (duk_int32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));
   duk__append_reop(re_ctx, 3);
   break;
  }
  case 10: {
   duk_uint32_t ch={0};

   new_atom_char_length = 1;
   new_atom_start_offset = (duk_int32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));
   duk__append_reop(re_ctx, 2);
   ch = re_ctx->curr_token.num;
   if (re_ctx->re_flags & (1U << 1)) {
    ch = (duk_uint32_t) duk_unicode_re_canonicalize_char(re_ctx->thr, (duk_codepoint_t) ch);
   }
   duk__append_u32(re_ctx, ch);
   break;
  }
  case 11:
  case 12:
  case 13:
  case 14:
  case 15:
  case 16: {
   duk_small_uint_t re_op={0};
   duk_small_uint_t idx={0};

   new_atom_char_length = 1;
   new_atom_start_offset = (duk_int32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));

   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0);
   re_op = (re_ctx->curr_token.t & 0x01) ? 4 : 5;

   do { } while (0);
   do { } while (0);
   idx = (duk_small_uint_t) ((re_ctx->curr_token.t - 11) >> 1U);
   do { } while (0);

   duk__append_range_atom_matcher(re_ctx, re_op, duk__re_range_lookup1[idx], duk__re_range_lookup2[idx]);
   break;
  }
  case 17: {
   duk_uint32_t backref = (duk_uint32_t) re_ctx->curr_token.num;
   if (backref > re_ctx->highest_backref) {
    re_ctx->highest_backref = backref;
   }
   new_atom_char_length = -1;
   new_atom_start_offset = (duk_int32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));
   duk__append_reop(re_ctx, 15);
   duk__append_u32(re_ctx, backref);
   break;
  }
  case 18: {
   duk_uint32_t cap={0};

   new_atom_char_length = -1;
   new_atom_start_offset = (duk_int32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));
   cap = ++re_ctx->captures;
   duk__append_reop(re_ctx, 11);
   duk__append_u32(re_ctx, cap * 2);
   duk__parse_disjunction(re_ctx, 0, &tmp_disj);
   duk__append_reop(re_ctx, 11);
   duk__append_u32(re_ctx, cap * 2 + 1);
   break;
  }
  case 19: {
   new_atom_start_offset = (duk_int32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));
   duk__parse_disjunction(re_ctx, 0, &tmp_disj);
   new_atom_char_length = tmp_disj.charlen;
   break;
  }
  case 20:
  case 21: {
   duk_uint32_t offset={0};

   do { } while (0);


   new_atom_char_length = 1;
   new_atom_start_offset = (duk_int32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));
   duk__append_reop(re_ctx,
                    (re_ctx->curr_token.t == 20) ?
                    4 : 5);
   offset = (duk_uint32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));


   re_ctx->nranges = 0;
   duk_lexer_parse_re_ranges(&re_ctx->lex, duk__regexp_generate_ranges, (void *) re_ctx);


   duk__insert_u32(re_ctx, offset, re_ctx->nranges);
   break;
  }
  case 22: {
   if (expect_eof) {
    do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 937; do { } while (0); do { } while (0); duk_err_handle_error(((re_ctx->thr)), "duk_regexp_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("unexpected closing parenthesis"))); } while (0); } while (0);
    do { } while (0);
   }
   goto done;
  }
  case 0: {
   if (!expect_eof) {
    do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 944; do { } while (0); do { } while (0); duk_err_handle_error(((re_ctx->thr)), "duk_regexp_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("unexpected end of pattern"))); } while (0); } while (0);
    do { } while (0);
   }
   goto done;
  }
  default: {
   do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 950; do { } while (0); do { } while (0); duk_err_handle_error(((re_ctx->thr)), "duk_regexp_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("unexpected token in regexp"))); } while (0); } while (0);
   do { } while (0);
  }
  }


  if (new_atom_start_offset >= 0) {
   if (new_atom_char_length < 0) {
    res_charlen = -1;
   } else if (res_charlen >= 0) {

    res_charlen += new_atom_char_length;
   }
  }


  atom_start_offset = new_atom_start_offset;
  atom_char_length = new_atom_char_length;
  atom_start_captures = new_atom_start_captures;
 }

 done:


 if (unpatched_disjunction_jump >= 0) {
  duk_uint32_t offset={0};

  do { } while (0);
  offset = (duk_uint32_t) unpatched_disjunction_jump;
  offset += duk__insert_jump_offset(re_ctx,
                                    offset,
                                    (duk_int32_t) (((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base)) - offset));

  duk__insert_jump_offset(re_ctx,
                          (duk_uint32_t) unpatched_disjunction_split,
                          (duk_int32_t) offset - unpatched_disjunction_split);
 }




 out_atom_info->charlen = res_charlen;
 do { } while (0)
                                                     ;

 re_ctx->recursion_depth--;
}





static duk_uint32_t duk__parse_regexp_flags(duk_hthread *thr, duk_hstring *h) {
 const duk_uint8_t *p={0};
 const duk_uint8_t *p_end={0};
 duk_uint32_t flags = 0;

 p = ((const duk_uint8_t *) ((h) + 1));
 p_end = p + ((h)->blen);



 while (p < p_end) {
  duk_uint8_t c = *p++;
  switch (c) {
  case (duk_uint8_t) 'g': {
   if (flags & (1U << 0)) {
    goto flags_error;
   }
   flags |= (1U << 0);
   break;
  }
  case (duk_uint8_t) 'i': {
   if (flags & (1U << 1)) {
    goto flags_error;
   }
   flags |= (1U << 1);
   break;
  }
  case (duk_uint8_t) 'm': {
   if (flags & (1U << 2)) {
    goto flags_error;
   }
   flags |= (1U << 2);
   break;
  }
  default: {
   goto flags_error;
  }
  }
 }

 return flags;

 flags_error:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 1045; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_regexp_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid regexp flags"))); } while (0); } while (0);
 do { } while (0);
}
static void duk__create_escaped_source(duk_hthread *thr, int idx_pattern) {
 duk_hstring *h={0};
 const duk_uint8_t *p={0};
 duk_bufwriter_ctx bw_alloc={0};
 duk_bufwriter_ctx *bw={0};
 duk_uint8_t *q={0};
 duk_size_t i, n={0};
 duk_uint_fast8_t c_prev, c={0};

 h = duk_known_hstring(thr, idx_pattern);
 p = (const duk_uint8_t *) ((const duk_uint8_t *) ((h) + 1));
 n = (duk_size_t) ((h)->blen);

 if (n == 0) {
  duk_push_literal_raw((thr), ("(?:)"), sizeof(("(?:)")) - 1U);
  return;
 }

 bw = &bw_alloc;
 do { duk_bw_init_pushbuf((thr), (bw), (n)); } while (0);
 q = ((bw)->p);

 c_prev = (duk_uint_fast8_t) 0;

 for (i = 0; i < n; i++) {
  c = p[i];

  q = (((duk_size_t) ((bw)->p_limit - (q)) >= (2)) ? (q) : ((bw)->p = (q), duk_bw_resize((thr),(bw),(2))));

  if (c == (duk_uint_fast8_t) '/' && c_prev != (duk_uint_fast8_t) '\\') {



   *q++ = 0x5c;
  }
  *q++ = (duk_uint8_t) c;

  c_prev = c;
 }

 do { (bw)->p = (q); duk_bw_compact((thr), (bw)); } while (0);
 (void) duk_buffer_to_string(thr, -1);


}
static __attribute__ ((unused)) void duk_regexp_compile(duk_hthread *thr) {
 duk_re_compiler_ctx re_ctx={0};
 duk_lexer_point lex_point={0};
 duk_hstring *h_pattern={0};
 duk_hstring *h_flags={0};
 duk__re_disjunction_info ign_disj={0};

 do { } while (0);






 h_pattern = duk_require_hstring_notsymbol(thr, -2);
 h_flags = duk_require_hstring_notsymbol(thr, -1);







 duk__create_escaped_source(thr, -2);
 do { void *duk__dst = (&re_ctx); duk_size_t duk__len = (sizeof(re_ctx)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 duk_lexer_initctx((&re_ctx.lex));
 re_ctx.thr = thr;
 re_ctx.lex.thr = thr;
 re_ctx.lex.input = ((const duk_uint8_t *) ((h_pattern) + 1));
 re_ctx.lex.input_length = ((h_pattern)->blen);
 re_ctx.lex.token_limit = 100000000L;
 re_ctx.recursion_limit = 10000;
 re_ctx.re_flags = duk__parse_regexp_flags(thr, h_flags);

 do { duk_bw_init_pushbuf((thr), (&re_ctx.bw), (64)); } while (0);

 do { } while (0)
                                                                                    ;





 lex_point.offset = 0;
 lex_point.line = 1;
 duk_lexer_setpoint((&re_ctx.lex), (&lex_point));





 do { } while (0);

 duk__append_reop(&re_ctx, 11);
 duk__append_7bit(&re_ctx, 0);
 duk__parse_disjunction(&re_ctx, 1 , &ign_disj);
 duk__append_reop(&re_ctx, 11);
 duk__append_7bit(&re_ctx, 1);
 duk__append_reop(&re_ctx, 1);
 if (re_ctx.highest_backref > re_ctx.captures) {
  do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 1209; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_regexp_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid backreference(s)"))); } while (0); } while (0);
  do { } while (0);
 }






 duk__insert_u32(&re_ctx, 0, (re_ctx.captures + 1) * 2);
 duk__insert_u32(&re_ctx, 0, re_ctx.re_flags);



 do { duk_bw_compact((thr), (&re_ctx.bw)); } while (0);
 (void) duk_buffer_to_string(thr, -1);







 duk_remove(thr, -4);
 duk_remove(thr, -3);

 do { } while (0)
                                                                                            ;
}
static __attribute__ ((unused)) void duk_regexp_create_instance(duk_hthread *thr) {
 duk_hobject *h={0};



 duk_push_object(thr);
 h = duk_known_hobject(thr, -1);
 duk_insert(thr, -3);



 do { (&(h)->hdr)->h_flags = ((&(h)->hdr)->h_flags & (~(((1UL << (5)) - 1UL) << ((7 + (20)))))) | (((11)) << ((7 + (20)))); } while (0);
 duk_hobject_set_prototype_updref((thr), (h), (thr->builtins[18]));

 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-3)) << 24) + (((duk_uint_t) (97)) << 8) + (duk_uint_t) (0)));
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (100)) << 8) + (duk_uint_t) (0)));



 duk_push_int(thr, 0);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (47)) << 8) + (duk_uint_t) (((1U << 0)))));


}
static duk_uint32_t duk__bc_get_u32(duk_re_matcher_ctx *re_ctx, const duk_uint8_t **pc) {
 return (duk_uint32_t) duk_unicode_decode_xutf8_checked(re_ctx->thr, pc, re_ctx->bytecode, re_ctx->bytecode_end);
}

static duk_int32_t duk__bc_get_i32(duk_re_matcher_ctx *re_ctx, const duk_uint8_t **pc) {
 duk_uint32_t t={0};


 t = (duk_uint32_t) duk_unicode_decode_xutf8_checked(re_ctx->thr, pc, re_ctx->bytecode, re_ctx->bytecode_end);
 if (t & 1) {
  return -((duk_int32_t) (t >> 1));
 } else {
  return (duk_int32_t) (t >> 1);
 }
}

static const duk_uint8_t *duk__utf8_backtrack(duk_hthread *thr, const duk_uint8_t **ptr, const duk_uint8_t *ptr_start, const duk_uint8_t *ptr_end, duk_uint_fast32_t count) {
 const duk_uint8_t *p={0};


 p = *ptr;
 if (p < ptr_start || p > ptr_end) {
  goto fail;
 }

 while (count > 0) {
  for (;;) {
   p--;
   if (p < ptr_start) {
    goto fail;
   }
   if ((*p & 0xc0) != 0x80) {

    break;
   }
  }
  count--;
 }
 *ptr = p;
 return p;

 fail:
 do { duk_err_error_internal((thr), "duk_regexp_executor.c", (duk_int_t) 70); } while (0);
 do { } while (0);
}

static const duk_uint8_t *duk__utf8_advance(duk_hthread *thr, const duk_uint8_t **ptr, const duk_uint8_t *ptr_start, const duk_uint8_t *ptr_end, duk_uint_fast32_t count) {
 const duk_uint8_t *p={0};

 p = *ptr;
 if (p < ptr_start || p >= ptr_end) {
  goto fail;
 }

 while (count > 0) {
  for (;;) {
   p++;




   if (p >= ptr_end || ((*p & 0xc0) != 0x80)) {

    break;
   }
  }
  count--;
 }

 *ptr = p;
 return p;

 fail:
 do { duk_err_error_internal((thr), "duk_regexp_executor.c", (duk_int_t) 101); } while (0);
 do { } while (0);
}
static duk_codepoint_t duk__inp_get_cp(duk_re_matcher_ctx *re_ctx, const duk_uint8_t **sp) {
 duk_codepoint_t res={0};

 if (*sp >= re_ctx->input_end) {
  return -1;
 }
 res = (duk_codepoint_t) duk_unicode_decode_xutf8_checked(re_ctx->thr, sp, re_ctx->input, re_ctx->input_end);
 if (re_ctx->re_flags & (1U << 1)) {
  res = duk_unicode_re_canonicalize_char(re_ctx->thr, res);
 }
 return res;
}

static const duk_uint8_t *duk__inp_backtrack(duk_re_matcher_ctx *re_ctx, const duk_uint8_t **sp, duk_uint_fast32_t count) {
 return duk__utf8_backtrack(re_ctx->thr, sp, re_ctx->input, re_ctx->input_end, count);
}


static duk_codepoint_t duk__inp_get_prev_cp(duk_re_matcher_ctx *re_ctx, const duk_uint8_t *sp) {

 (void) duk__inp_backtrack(re_ctx, &sp, (duk_uint_fast32_t) 1);
 return duk__inp_get_cp(re_ctx, &sp);
}
static const duk_uint8_t *duk__match_regexp(duk_re_matcher_ctx *re_ctx, const duk_uint8_t *pc, const duk_uint8_t *sp) {
 if (re_ctx->recursion_depth >= re_ctx->recursion_limit) {
  do { duk_err_range((re_ctx->thr), "duk_regexp_executor.c", (duk_int_t) 150, ("regexp executor recursion limit")); } while (0);
  do { } while (0);
 }
 re_ctx->recursion_depth++;

 for (;;) {
  duk_small_int_t op={0};

  if (re_ctx->steps_count >= re_ctx->steps_limit) {
   do { duk_err_range((re_ctx->thr), "duk_regexp_executor.c", (duk_int_t) 159, ("regexp step limit")); } while (0);
   do { } while (0);
  }
  re_ctx->steps_count++;





  do { } while (0);



  op = *pc++;

  do { } while (0)




                                  ;

  switch (op) {
  case 1: {
   goto match;
  }
  case 2: {
   duk_codepoint_t c1, c2={0};

   c1 = (duk_codepoint_t) duk__bc_get_u32(re_ctx, &pc);
   do { } while (0)
                                                                      ;
   c2 = duk__inp_get_cp(re_ctx, &sp);
   do { } while (0);

   do { } while (0);
   if (c1 != c2) {
    goto fail;
   }
   break;
  }
  case 3: {
   duk_codepoint_t c={0};

   c = duk__inp_get_cp(re_ctx, &sp);
   if (c < 0 || duk_unicode_is_line_terminator(c)) {

    goto fail;
   }
   break;
  }
  case 4:
  case 5: {
   duk_uint32_t n={0};
   duk_codepoint_t c={0};
   duk_small_int_t match={0};

   n = duk__bc_get_u32(re_ctx, &pc);
   c = duk__inp_get_cp(re_ctx, &sp);
   if (c < 0) {
    goto fail;
   }

   match = 0;
   while (n) {
    duk_codepoint_t r1, r2={0};
    r1 = (duk_codepoint_t) duk__bc_get_u32(re_ctx, &pc);
    r2 = (duk_codepoint_t) duk__bc_get_u32(re_ctx, &pc);
    do { } while (0)
                                                                   ;
    if (c >= r1 && c <= r2) {




     match = 1;
    }
    n--;
   }

   if (op == 4) {
    if (!match) {
     goto fail;
    }
   } else {
    do { } while (0);
    if (match) {
     goto fail;
    }
   }
   break;
  }
  case 16: {
   duk_codepoint_t c={0};

   if (sp <= re_ctx->input) {
    break;
   }
   if (!(re_ctx->re_flags & (1U << 2))) {
    goto fail;
   }
   c = duk__inp_get_prev_cp(re_ctx, sp);
   if (duk_unicode_is_line_terminator(c)) {

    break;
   }
   goto fail;
  }
  case 17: {
   duk_codepoint_t c={0};
   const duk_uint8_t *tmp_sp={0};

   tmp_sp = sp;
   c = duk__inp_get_cp(re_ctx, &tmp_sp);
   if (c < 0) {
    break;
   }
   if (!(re_ctx->re_flags & (1U << 2))) {
    goto fail;
   }
   if (duk_unicode_is_line_terminator(c)) {

    break;
   }
   goto fail;
  }
  case 18:
  case 19: {







   duk_small_int_t w1, w2={0};

   if (sp <= re_ctx->input) {
    w1 = 0;
   } else {
    duk_codepoint_t c={0};
    c = duk__inp_get_prev_cp(re_ctx, sp);
    w1 = duk_unicode_re_is_wordchar(c);
   }
   if (sp >= re_ctx->input_end) {
    w2 = 0;
   } else {
    const duk_uint8_t *tmp_sp = sp;
    duk_codepoint_t c={0};
    c = duk__inp_get_cp(re_ctx, &tmp_sp);
    w2 = duk_unicode_re_is_wordchar(c);
   }

   if (op == 18) {
    if (w1 == w2) {
     goto fail;
    }
   } else {
    do { } while (0);
    if (w1 != w2) {
     goto fail;
    }
   }
   break;
  }
  case 6: {
   duk_int32_t skip={0};

   skip = duk__bc_get_i32(re_ctx, &pc);
   pc += skip;
   break;
  }
  case 7: {

   const duk_uint8_t *sub_sp={0};
   duk_int32_t skip={0};

   skip = duk__bc_get_i32(re_ctx, &pc);
   sub_sp = duk__match_regexp(re_ctx, pc, sp);
   if (sub_sp) {
    sp = sub_sp;
    goto match;
   }
   pc += skip;
   break;
  }
  case 8: {

   const duk_uint8_t *sub_sp={0};
   duk_int32_t skip={0};

   skip = duk__bc_get_i32(re_ctx, &pc);
   sub_sp = duk__match_regexp(re_ctx, pc + skip, sp);
   if (sub_sp) {
    sp = sub_sp;
    goto match;
   }
   break;
  }
  case 9: {
   duk_uint32_t q, qmin, qmax={0};
   duk_int32_t skip={0};
   const duk_uint8_t *sub_sp={0};

   qmin = duk__bc_get_u32(re_ctx, &pc);
   qmax = duk__bc_get_u32(re_ctx, &pc);
   skip = duk__bc_get_i32(re_ctx, &pc);
   do { } while (0)
                                                                                 ;

   q = 0;
   while (q <= qmax) {
    if (q >= qmin) {
     sub_sp = duk__match_regexp(re_ctx, pc + skip, sp);
     if (sub_sp) {
      sp = sub_sp;
      goto match;
     }
    }
    sub_sp = duk__match_regexp(re_ctx, pc, sp);
    if (!sub_sp) {
     break;
    }
    sp = sub_sp;
    q++;
   }
   goto fail;
  }
  case 10: {
   duk_uint32_t q, qmin, qmax, atomlen={0};
   duk_int32_t skip={0};
   const duk_uint8_t *sub_sp={0};

   qmin = duk__bc_get_u32(re_ctx, &pc);
   qmax = duk__bc_get_u32(re_ctx, &pc);
   atomlen = duk__bc_get_u32(re_ctx, &pc);
   skip = duk__bc_get_i32(re_ctx, &pc);
   do { } while (0)
                                                                                                          ;

   q = 0;
   while (q < qmax) {
    sub_sp = duk__match_regexp(re_ctx, pc, sp);
    if (!sub_sp) {
     break;
    }
    sp = sub_sp;
    q++;
   }
   while (q >= qmin) {
    sub_sp = duk__match_regexp(re_ctx, pc + skip, sp);
    if (sub_sp) {
     sp = sub_sp;
     goto match;
    }
    if (q == qmin) {
     break;
    }






    do { } while (0)
                                         ;
    sp = duk__inp_backtrack(re_ctx, &sp, (duk_uint_fast32_t) atomlen);
    q--;
   }
   goto fail;
  }
  case 11: {
   duk_uint32_t idx={0};
   const duk_uint8_t *old={0};
   const duk_uint8_t *sub_sp={0};

   idx = duk__bc_get_u32(re_ctx, &pc);
   if (idx >= re_ctx->nsaved) {

    do { } while (0);
    goto internal_error;
   }
   old = re_ctx->saved[idx];
   re_ctx->saved[idx] = sp;
   sub_sp = duk__match_regexp(re_ctx, pc, sp);
   if (sub_sp) {
    sp = sub_sp;
    goto match;
   }
   re_ctx->saved[idx] = old;
   goto fail;
  }
  case 12: {
   duk_uint32_t idx_start, idx_count={0};



   duk_uint8_t **range_save={0};
   const duk_uint8_t *sub_sp={0};

   idx_start = duk__bc_get_u32(re_ctx, &pc);
   idx_count = duk__bc_get_u32(re_ctx, &pc);
   do { } while (0)


                                                                                          ;
   if (idx_start + idx_count > re_ctx->nsaved || idx_count == 0) {

    do { } while (0)
                                                         ;
    goto internal_error;
   }
   do { } while (0);

   duk_require_stack(re_ctx->thr, 1);
   range_save = (duk_uint8_t **) duk_push_fixed_buffer_nozero(re_ctx->thr,
                                                              sizeof(duk_uint8_t *) * idx_count);
   do { } while (0);
   do { void *duk__dst = (range_save); const void *duk__src = (re_ctx->saved + idx_start); duk_size_t duk__len = (sizeof(duk_uint8_t *) * idx_count); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);






   do { void *duk__dst = ((void *) (re_ctx->saved + idx_start)); duk_size_t duk__len = (sizeof(duk_uint8_t *) * idx_count); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);


   sub_sp = duk__match_regexp(re_ctx, pc, sp);
   if (sub_sp) {

    do { } while (0)

                                                                                                  ;
    duk_pop_unsafe(re_ctx->thr);
    sp = sub_sp;
    goto match;
   }


   do { } while (0)

                                                                                          ;
   do { void *duk__dst = ((void *) (re_ctx->saved + idx_start)); const void *duk__src = ((const void *) range_save); duk_size_t duk__len = (sizeof(duk_uint8_t *) * idx_count); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0)

                                                ;
   duk_pop_unsafe(re_ctx->thr);
   goto fail;
  }
  case 13:
  case 14: {
   duk_int32_t skip={0};
   duk_uint8_t **full_save={0};
   const duk_uint8_t *sub_sp={0};

   do { } while (0);

   duk_require_stack(re_ctx->thr, 1);
   full_save = (duk_uint8_t **) duk_push_fixed_buffer_nozero(re_ctx->thr,
                                                             sizeof(duk_uint8_t *) * re_ctx->nsaved);
   do { } while (0);
   do { void *duk__dst = (full_save); const void *duk__src = (re_ctx->saved); duk_size_t duk__len = (sizeof(duk_uint8_t *) * re_ctx->nsaved); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);

   skip = duk__bc_get_i32(re_ctx, &pc);
   sub_sp = duk__match_regexp(re_ctx, pc, sp);
   if (op == 13) {
    if (!sub_sp) {
     goto lookahead_fail;
    }
   } else {
    if (sub_sp) {
     goto lookahead_fail;
    }
   }
   sub_sp = duk__match_regexp(re_ctx, pc + skip, sp);
   if (sub_sp) {

    duk_pop_unsafe(re_ctx->thr);
    sp = sub_sp;
    goto match;
   }



   lookahead_fail:

   do { void *duk__dst = ((void *) re_ctx->saved); const void *duk__src = ((const void *) full_save); duk_size_t duk__len = (sizeof(duk_uint8_t *) * re_ctx->nsaved); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0)

                                                     ;
   duk_pop_unsafe(re_ctx->thr);
   goto fail;
  }
  case 15: {
   duk_uint32_t idx={0};
   const duk_uint8_t *p={0};

   idx = duk__bc_get_u32(re_ctx, &pc);
   idx = idx << 1;
   if (idx < 2 || idx + 1 >= re_ctx->nsaved) {

    do { } while (0);
    goto internal_error;
   }
   if (!re_ctx->saved[idx] || !re_ctx->saved[idx+1]) {

    do { } while (0)
                                                       ;
    break;
   }
   do { } while (0);

   p = re_ctx->saved[idx];
   while (p < re_ctx->saved[idx+1]) {
    duk_codepoint_t c1, c2={0};






    c1 = duk__inp_get_cp(re_ctx, &p);
    do { } while (0);
    c2 = duk__inp_get_cp(re_ctx, &sp);
    if (c1 != c2) {
     goto fail;
    }
   }
   break;
  }
  default: {
   do { } while (0);
   goto internal_error;
  }
  }
 }

 match:
 re_ctx->recursion_depth--;
 return sp;

 fail:
 re_ctx->recursion_depth--;
 return ((void *)0);

 internal_error:
 do { duk_err_error_internal((re_ctx->thr), "duk_regexp_executor.c", (duk_int_t) 669); } while (0);
 do { } while (0);
}
static void duk__regexp_match_helper(duk_hthread *thr, duk_small_int_t force_global) {
 duk_re_matcher_ctx re_ctx={0};
 duk_hobject *h_regexp={0};
 duk_hstring *h_bytecode={0};
 duk_hstring *h_input={0};
 duk_uint8_t *p_buf={0};
 const duk_uint8_t *pc={0};
 const duk_uint8_t *sp={0};
 duk_small_int_t match = 0;
 duk_small_int_t global={0};
 duk_uint_fast32_t i={0};
 double d={0};
 duk_uint32_t char_offset={0};

 do { } while (0);

 do { } while (0)

                                                        ;
 h_regexp = duk_require_hobject_with_class(thr, -2, 11);
 do { } while (0);
 do { } while (0);
 do { (void) (h_regexp); } while (0);

 h_input = duk_to_hstring(thr, -1);
 do { } while (0);

 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (97))));
 h_bytecode = duk_require_hstring(thr, -1);
 do { } while (0);
 do { void *duk__dst = (&re_ctx); duk_size_t duk__len = (sizeof(re_ctx)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);

 re_ctx.thr = thr;
 re_ctx.input = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_input) + 1));
 re_ctx.input_end = re_ctx.input + ((h_input)->blen);
 re_ctx.bytecode = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_bytecode) + 1));
 re_ctx.bytecode_end = re_ctx.bytecode + ((h_bytecode)->blen);
 re_ctx.saved = ((void *)0);
 re_ctx.recursion_limit = 10000;
 re_ctx.steps_limit = 1000000000L;


 pc = re_ctx.bytecode;
 re_ctx.re_flags = duk__bc_get_u32(&re_ctx, &pc);
 re_ctx.nsaved = duk__bc_get_u32(&re_ctx, &pc);
 re_ctx.bytecode = pc;

 do { } while (0);
 global = (duk_small_int_t) (force_global | (duk_small_int_t) (re_ctx.re_flags & (1U << 0)));

 do { } while (0);
 do { } while (0);

 p_buf = (duk_uint8_t *) duk_push_buffer_raw((thr), (sizeof(duk_uint8_t *) * re_ctx.nsaved), 0 );
 do { (void) (p_buf); } while (0);
 re_ctx.saved = (const duk_uint8_t **) duk_get_buffer(thr, -1, ((void *)0));
 do { } while (0);
 do { } while (0)

                                                 ;
 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-4)) << 16) + ((duk_uint_t) (47))));
 (void) duk_to_int(thr, -1);
 d = duk_get_number(thr, -1);
 duk_pop_nodecref_unsafe(thr);

 if (global) {
  if (d < 0.0 || d > (double) duk_hstring_get_charlen((h_input))) {

   char_offset = 0;
   do { } while (0);
   goto match_over;
  }
  char_offset = (duk_uint32_t) d;
 } else {





  char_offset = (duk_uint32_t) 0;
 }

 do { } while (0);
 sp = re_ctx.input + duk_heap_strcache_offset_char2byte(thr, h_input, char_offset);
 do { } while (0);

 for (;;) {

  do { } while (0);
  do { } while (0);


  do { } while (0);

  do { } while (0)

                                                                                     ;
  if (duk__match_regexp(&re_ctx, re_ctx.bytecode, sp) != ((void *)0)) {
   do { } while (0);
   match = 1;
   break;
  }


  char_offset++;
  if (char_offset > duk_hstring_get_charlen((h_input))) {
   do { } while (0);
   break;
  }


  (void) duk__utf8_advance(thr, &sp, re_ctx.input, re_ctx.input_end, (duk_uint_fast32_t) 1);
 }

 match_over:
 if (match) {



  duk_uint32_t char_end_offset = 0;

  do { } while (0);

  do { } while (0);
  do { } while (0);






  duk_push_array(thr);
  duk_push_uint((thr), (duk_uint_t) (char_offset));
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw(((thr)), (((duk_uint_t) ((-2))) << 24) + (((duk_uint_t) ((49))) << 8) + (duk_uint_t) (((1U << 0) | (1U << 1) | (1U << 2)))));

  duk_dup_m4(thr);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw(((thr)), (((duk_uint_t) ((-2))) << 24) + (((duk_uint_t) ((107))) << 8) + (duk_uint_t) (((1U << 0) | (1U << 1) | (1U << 2)))));

  for (i = 0; i < re_ctx.nsaved; i += 2) {




   if (re_ctx.saved[i] && re_ctx.saved[i + 1] && re_ctx.saved[i + 1] >= re_ctx.saved[i]) {
    duk_push_lstring(thr,
                     (const char *) re_ctx.saved[i],
                     (duk_size_t) (re_ctx.saved[i+1] - re_ctx.saved[i]));
    if (i == 0) {





     char_end_offset = char_offset + (duk_uint32_t) duk_get_length(thr, -1);
    }
   } else {
    duk_push_undefined(thr);
   }


   duk_put_prop_index(thr, -2, (duk_uarridx_t) (i / 2));
  }





  if (global) {

   duk_push_uint((thr), (duk_uint_t) (char_end_offset));
   (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-6)) << 16) + ((duk_uint_t) (47))));
  } else {

   ;
  }
 } else {






  do { } while (0);

  duk_push_null(thr);



  duk_push_int(thr, 0);
  (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-6)) << 16) + ((duk_uint_t) (47))));
 }



 duk_insert(thr, -5);



 duk_pop_n_unsafe(thr, 4);






}

static __attribute__ ((unused)) void duk_regexp_match(duk_hthread *thr) {
 duk__regexp_match_helper(thr, 0 );
}




static __attribute__ ((unused)) void duk_regexp_match_force_global(duk_hthread *thr) {
 duk__regexp_match_helper(thr, 1 );
}
const duk_uint8_t duk_unicode_ids_noa[1063] = {
249,176,176,80,111,7,47,15,47,254,11,197,191,0,72,2,15,115,66,19,50,7,2,34,
2,240,66,244,50,247,185,249,98,241,99,8,241,127,58,240,182,47,31,241,191,
21,18,245,50,15,1,24,27,35,15,2,2,240,239,15,244,156,15,10,241,26,21,6,240,
101,10,4,15,9,240,152,175,39,240,82,127,56,242,100,15,4,8,159,1,240,5,115,
19,240,98,98,4,52,15,2,14,18,47,0,27,9,85,19,240,98,98,18,18,31,17,50,15,5,
47,2,130,34,240,98,98,18,68,15,4,15,1,31,9,12,115,19,240,98,98,18,68,15,16,
18,47,1,15,3,2,84,34,52,18,2,20,20,36,191,8,15,38,114,34,240,114,240,4,15,
12,38,31,16,5,114,34,240,114,146,68,15,18,2,31,1,31,4,114,34,241,147,15,2,
6,41,47,10,86,240,36,240,130,130,3,111,44,242,2,29,111,44,18,3,18,3,7,50,
98,34,2,3,18,50,26,3,66,15,7,63,18,15,49,114,241,79,13,79,101,241,191,6,15,
2,85,52,4,24,37,205,15,3,241,98,6,3,241,178,255,224,63,35,54,32,35,63,25,
35,63,17,35,54,32,35,62,47,41,35,63,51,241,127,0,240,47,70,53,79,254,21,
227,240,18,240,166,243,180,168,194,63,0,240,47,0,240,47,0,194,47,1,242,79,
21,5,15,53,244,137,67,241,34,6,243,107,240,255,35,240,227,76,241,197,240,
175,40,240,122,242,95,68,15,79,241,255,3,111,41,240,238,27,241,207,12,241,
79,27,43,241,67,143,82,50,52,26,251,15,50,255,224,8,53,63,22,53,55,32,32,
32,47,15,63,37,38,32,66,38,67,53,92,98,38,246,96,224,240,44,245,112,80,57,
32,68,112,32,32,35,42,51,100,80,240,63,25,255,233,107,241,242,241,242,247,
87,52,29,241,98,6,3,242,136,15,2,240,122,98,98,98,98,98,98,98,111,66,15,
254,12,146,240,184,132,52,95,70,114,47,74,35,111,26,63,78,240,63,11,242,
127,0,255,224,244,255,240,0,138,143,60,255,240,4,13,223,7,255,227,127,243,
95,30,63,253,79,0,177,240,111,31,240,47,15,63,64,241,152,63,87,63,20,39,
243,26,34,35,47,7,240,255,36,240,15,34,243,5,64,32,223,12,191,7,240,191,13,
143,31,240,224,240,36,41,180,47,25,240,146,39,240,111,7,64,79,34,32,65,52,
48,32,240,162,58,130,213,53,53,166,38,47,27,41,191,99,240,255,255,0,26,150,
223,7,95,33,255,240,0,255,143,254,6,3,245,175,24,109,70,2,146,194,66,2,18,
18,245,207,19,255,224,93,240,79,48,63,38,241,171,246,100,47,119,241,111,10,
127,10,207,73,69,53,53,50,241,91,47,10,47,3,33,46,61,241,79,107,243,127,37,
255,223,13,79,33,242,31,16,239,14,111,22,191,14,63,20,87,36,241,207,142,
240,79,20,95,20,95,24,159,36,248,239,254,2,154,240,107,127,138,83,2,241,
194,20,3,240,123,240,122,240,255,51,240,50,27,240,107,240,175,56,242,135,
31,50,15,1,50,34,240,191,30,240,212,240,223,21,114,240,207,13,242,107,240,
107,240,62,240,47,96,243,159,41,242,62,242,63,254,32,79,37,243,223,29,241,
47,9,240,207,20,241,191,19,64,223,32,240,3,240,112,32,241,95,2,47,9,244,
102,32,35,46,41,143,31,241,135,49,63,6,38,33,36,64,240,64,212,249,15,37,
240,67,242,127,32,240,97,32,250,175,31,241,179,241,111,32,240,96,242,223,
27,244,127,10,255,224,122,243,15,17,15,242,11,241,136,15,7,12,241,131,63,
40,242,159,249,130,241,95,3,15,35,240,239,98,98,18,241,111,7,15,254,26,223,
254,40,207,88,245,255,3,251,79,254,155,15,254,50,31,254,236,95,254,19,159,
255,0,16,173,255,225,43,143,15,246,63,14,240,79,32,240,35,241,31,5,111,3,
255,226,100,243,92,15,52,207,50,31,16,255,240,0,109,255,5,255,225,229,255,
240,1,64,31,254,1,31,67,255,224,126,255,231,248,245,182,196,136,159,255,0,
6,90,244,82,243,114,19,3,19,50,178,2,98,243,18,51,114,98,240,194,50,66,4,
98,255,224,70,63,9,47,9,47,15,47,9,47,15,47,9,47,15,47,9,47,15,47,9,39,255,
239,40,251,95,45,243,79,254,59,3,47,11,33,32,48,41,35,32,32,112,80,32,32,
34,33,32,48,32,32,32,32,33,32,51,38,35,35,32,41,47,1,98,36,47,1,255,240,0,
3,143,255,0,149,201,241,191,254,242,124,252,227,255,240,0,87,79,0,255,240,
0,194,63,254,177,63,254,17,0,
};
const duk_uint8_t duk_unicode_ids_m_let_noa[42] = {
255,240,0,94,18,255,233,99,241,51,63,254,215,32,240,184,240,2,255,240,6,89,
249,255,240,4,148,79,37,255,224,192,9,15,120,79,255,0,15,30,245,240,
};
const duk_uint8_t duk_unicode_idp_m_ids_noa[549] = {
255,225,243,246,15,254,0,116,255,191,29,32,33,33,32,243,170,242,47,15,112,
245,118,53,49,35,57,240,144,241,15,11,244,218,240,25,241,56,241,67,40,34,
36,241,210,246,173,47,17,242,130,47,2,38,177,57,240,50,242,160,38,49,50,
160,177,57,240,50,242,160,36,81,50,64,240,107,64,194,242,160,39,34,34,240,
97,57,181,34,242,160,38,49,50,145,177,57,240,64,242,212,66,35,160,240,9,
240,35,242,198,34,35,129,193,57,240,50,242,160,38,34,35,129,193,57,240,35,
242,145,38,34,35,160,177,57,240,65,243,128,85,32,39,121,49,242,240,54,215,
41,244,144,53,33,197,57,243,1,121,192,32,32,81,242,63,4,33,106,47,20,160,
245,111,4,41,211,82,34,54,67,235,46,255,225,179,47,254,42,98,240,242,240,
241,241,1,243,47,16,160,57,241,50,57,245,209,241,64,246,139,91,185,247,41,
242,244,242,185,47,13,58,121,240,141,243,68,242,31,1,201,240,56,210,241,12,
57,241,237,242,47,4,153,121,246,130,47,5,80,82,50,251,143,42,36,255,225,0,
31,35,31,5,15,109,197,4,191,254,175,34,247,240,245,47,16,255,225,30,95,91,
31,255,0,100,121,159,55,5,159,18,31,66,31,254,0,64,64,80,240,148,244,161,
242,79,2,185,127,2,240,9,240,231,240,188,241,227,242,29,240,25,192,185,242,
29,208,145,57,241,50,242,64,34,49,97,32,241,180,97,253,231,33,57,255,240,3,
225,128,255,225,213,240,15,2,240,4,31,10,47,178,159,23,15,254,27,16,253,64,
248,116,255,224,25,159,254,68,178,33,99,241,162,80,249,113,255,228,13,47,
39,239,17,159,1,63,31,175,39,151,47,22,210,159,37,13,47,34,218,36,159,68,
183,15,146,182,151,63,42,2,99,19,42,11,19,100,79,178,240,42,159,72,240,77,
159,199,99,143,13,31,68,240,31,1,159,67,201,159,69,229,159,254,9,169,255,
224,11,159,26,98,57,10,175,32,240,15,254,8,151,39,240,41,242,175,6,45,246,
197,64,33,38,32,153,255,240,3,191,169,247,132,242,214,240,185,255,226,235,
241,239,2,63,255,0,59,254,31,255,0,3,186,68,89,115,111,16,63,134,47,254,71,
223,34,255,224,244,242,117,242,41,15,0,15,8,66,239,254,68,70,47,1,54,33,36,
255,231,153,111,95,102,159,255,12,6,154,254,0,
};
const duk_uint8_t duk_unicode_caseconv_uc[1386] = {
144,3,128,3,0,184,7,192,6,192,112,35,242,199,224,64,74,192,49,32,128,162,
128,108,65,1,189,129,254,131,3,173,3,136,6,7,98,7,34,68,15,12,14,140,72,30,
104,28,112,32,67,0,65,4,0,138,0,128,4,1,88,65,76,83,9,252,9,248,6,28,131,4,
33,4,62,0,62,16,32,124,64,124,96,48,249,0,249,64,129,243,1,243,129,3,232,3,
233,1,135,216,7,218,4,15,184,15,221,2,31,114,31,200,8,62,236,63,180,8,125,
224,127,224,16,251,208,255,80,33,247,193,255,160,67,246,3,247,0,135,244,7,
246,1,15,240,15,244,2,33,112,33,96,32,73,160,73,108,104,176,192,176,1,121,
104,0,133,2,106,183,1,58,10,31,232,63,228,38,162,1,1,1,0,48,2,102,2,100,12,
4,232,4,228,64,10,88,10,81,112,23,160,23,144,96,48,96,48,64,128,104,64,104,
1,128,218,0,217,130,1,206,1,205,16,3,190,3,188,36,7,228,7,224,160,17,24,17,
16,144,36,112,36,96,160,110,32,110,0,128,246,64,246,6,2,48,130,48,17,4,139,
4,138,54,9,132,9,130,28,19,68,19,65,128,240,8,240,4,177,234,17,234,6,3,234,
35,235,33,11,26,11,25,193,150,64,150,64,50,44,236,44,235,5,76,131,76,128,
94,154,6,154,0,117,57,29,57,16,122,115,58,115,35,244,239,84,239,32,169,223,
233,223,130,211,200,211,200,2,167,151,167,150,21,79,107,79,104,8,112,26,
208,26,192,64,56,160,56,128,192,113,128,113,1,128,249,0,248,130,2,128,1,
166,4,7,240,7,238,8,177,204,177,200,16,96,49,0,48,224,128,110,64,110,1,1,
51,83,213,2,0,48,35,192,35,176,64,77,32,50,192,139,73,196,49,193,127,48,2,
212,14,112,3,252,5,224,4,196,1,36,5,252,1,76,6,0,9,12,6,72,6,68,6,84,7,216,
6,100,6,96,6,104,8,244,6,120,8,128,6,160,6,156,6,252,7,220,7,116,6,56,7,
204,7,196,9,64,177,188,9,68,177,180,9,72,177,192,9,76,6,4,9,80,6,24,9,100,
6,60,9,108,6,64,9,114,158,172,9,128,6,76,9,134,158,176,9,140,6,80,9,150,
158,52,9,160,6,92,9,172,177,136,9,178,158,180,9,196,177,184,9,200,6,116,9,
212,6,124,9,244,177,144,10,30,158,196,10,32,6,184,10,36,9,16,10,48,9,20,10,
72,6,220,10,118,158,200,10,122,158,192,13,20,14,100,13,220,13,216,14,176,
14,24,15,8,14,140,15,48,14,48,15,64,14,72,15,68,14,96,15,84,14,152,15,88,
14,128,15,92,15,60,15,192,14,104,15,196,14,132,15,200,15,228,15,204,13,252,
15,212,14,84,19,60,19,0,114,0,16,72,114,4,16,80,114,8,16,120,114,20,16,136,
114,24,16,168,114,28,17,136,114,34,153,40,117,230,157,244,117,244,177,140,
122,108,121,128,126,248,14,100,127,148,127,176,133,56,132,200,134,16,134,
12,177,132,177,128,177,148,8,232,177,152,8,248,179,204,179,202,158,50,158,
46,173,78,158,207,48,6,252,0,166,0,166,2,147,1,94,0,39,0,248,64,9,64,97,
128,114,24,28,200,24,64,24,8,29,134,7,74,6,16,6,2,11,15,2,154,130,169,15,
75,64,9,0,102,35,210,240,2,160,24,64,244,196,0,174,6,20,61,51,0,44,129,133,
15,77,64,8,32,87,195,234,16,29,40,24,152,250,150,7,74,6,38,6,0,62,169,129,
210,129,137,129,128,143,171,96,116,160,98,96,104,67,240,16,248,64,28,200,
252,12,62,18,7,50,63,5,15,133,1,204,143,193,195,225,96,115,35,240,144,248,
96,28,200,252,44,62,26,7,50,63,13,15,135,1,204,143,195,195,225,224,115,35,
241,16,248,64,28,200,252,76,62,18,7,50,63,21,15,133,1,204,143,197,195,225,
96,115,35,241,144,248,96,28,200,252,108,62,26,7,50,63,29,15,135,1,204,143,
199,195,225,224,115,35,242,16,249,64,28,200,252,140,62,82,7,50,63,37,15,
149,1,204,143,201,195,229,96,115,35,242,144,249,96,28,200,252,172,62,90,7,
50,63,45,15,151,1,204,143,203,195,229,224,115,35,243,16,249,64,28,200,252,
204,62,82,7,50,63,53,15,149,1,204,143,205,195,229,96,115,35,243,144,249,96,
28,200,252,236,62,90,7,50,63,61,15,151,1,204,143,207,195,229,224,115,35,
244,16,251,64,28,200,253,12,62,210,7,50,63,69,15,181,1,204,143,209,195,237,
96,115,35,244,144,251,96,28,200,253,44,62,218,7,50,63,77,15,183,1,204,143,
211,195,237,224,115,35,245,16,251,64,28,200,253,76,62,210,7,50,63,85,15,
181,1,204,143,213,195,237,96,115,35,245,144,251,96,28,200,253,108,62,218,7,
50,63,93,15,183,1,204,143,215,195,237,224,115,35,246,80,253,208,28,200,253,
156,7,34,7,50,63,105,1,195,1,204,143,219,64,114,32,104,67,246,248,28,136,
26,16,28,200,253,228,7,34,7,50,63,133,15,229,1,204,143,225,192,114,224,115,
35,248,144,28,72,28,200,254,52,7,46,6,132,63,143,129,203,129,161,1,204,143,
230,64,114,224,115,35,250,88,28,200,24,64,24,0,254,158,7,50,6,16,6,2,63,
173,1,204,129,161,15,235,224,115,32,97,0,104,67,252,88,29,40,24,64,24,0,
255,30,7,74,6,16,6,2,63,201,1,208,129,137,143,243,64,116,160,104,67,252,
248,29,40,24,64,26,16,255,148,63,244,7,50,63,231,1,212,129,204,143,250,64,
113,224,115,35,254,208,29,72,26,16,255,190,7,82,6,132,7,50,63,249,1,212,
129,204,253,128,64,8,192,8,223,96,48,2,48,2,79,216,20,0,140,0,153,246,7,
128,35,0,35,0,36,253,130,96,8,192,8,192,9,159,96,176,2,152,2,167,216,52,0,
166,0,169,246,39,2,162,2,163,125,138,64,168,128,166,191,98,176,42,32,41,
223,216,180,10,156,10,141,246,47,2,162,2,158,128,
};
const duk_uint8_t duk_unicode_caseconv_lc[680] = {
152,3,0,3,128,184,6,192,7,192,112,24,144,37,96,64,54,32,81,64,128,226,0,
235,65,129,199,1,230,130,3,145,3,177,34,7,70,7,134,36,15,244,13,236,24,32,
0,34,129,0,65,0,67,4,0,166,32,172,41,132,40,11,64,19,9,208,85,184,80,19,
240,19,248,12,62,16,62,0,32,124,96,124,64,48,249,64,249,0,129,243,129,243,
1,3,233,3,232,1,135,218,7,216,4,15,196,15,192,8,31,152,31,144,16,63,80,63,
64,32,126,224,126,192,16,253,208,251,128,33,252,129,247,32,131,251,3,250,0,
135,246,135,221,129,15,244,15,240,2,31,234,31,122,4,63,240,62,240,8,127,
232,125,240,17,11,1,11,129,2,75,98,77,3,69,128,5,134,11,203,31,128,143,193,
127,144,255,160,154,140,4,0,4,4,192,9,144,9,152,48,19,144,19,161,0,41,64,
41,101,192,94,64,94,129,128,193,0,193,130,1,160,1,161,6,3,102,3,104,8,7,44,
7,48,72,14,240,14,248,144,31,32,31,48,64,63,0,63,37,0,136,128,136,196,129,
35,1,35,133,3,112,3,113,4,7,176,7,178,48,17,128,17,132,136,36,80,36,89,176,
76,16,76,32,224,154,0,154,44,7,128,7,128,101,143,80,15,80,176,31,89,31,81,
8,88,206,88,208,12,178,0,178,5,145,103,89,103,96,42,100,10,100,18,244,208,
20,208,35,169,200,169,200,195,211,153,83,153,159,167,121,167,122,5,78,253,
78,254,22,158,66,158,68,21,60,181,60,184,170,123,74,123,80,67,0,211,1,64,2,
1,172,1,173,4,3,136,3,140,12,7,20,7,24,16,31,184,31,192,34,199,34,199,48,
65,128,195,128,196,2,1,184,1,185,5,79,84,4,204,8,0,192,101,128,154,65,1,29,
129,30,2,16,199,45,39,5,251,240,23,128,15,240,24,16,37,48,24,96,37,64,24,
224,29,208,24,240,37,144,25,0,37,176,25,16,25,32,25,48,38,0,25,64,38,48,25,
112,38,128,25,128,25,144,25,208,39,32,25,240,39,80,26,112,26,128,26,224,40,
128,27,112,41,32,31,16,31,48,31,96,25,80,31,112,27,240,34,0,25,224,35,162,
198,80,35,208,25,160,35,226,198,96,36,48,24,0,36,64,40,144,36,80,40,192,55,
96,55,112,55,240,63,48,56,96,58,192,56,192,60,192,60,240,61,112,63,64,59,
128,63,144,63,32,76,0,76,241,233,224,13,241,251,193,251,49,252,193,252,49,
254,193,254,81,255,193,255,50,18,96,60,146,18,160,6,178,18,176,14,82,19,34,
20,226,24,50,24,66,198,2,198,18,198,32,38,178,198,49,215,210,198,64,39,210,
198,208,37,18,198,224,39,18,198,240,37,2,199,0,37,34,207,34,207,58,119,209,
215,154,120,186,120,202,120,208,38,90,122,176,37,202,122,192,38,26,122,208,
38,202,123,0,41,234,123,16,40,122,123,32,41,218,123,58,181,48,32,38,16,3,
72,24,56,
};
const duk_uint8_t duk_unicode_re_canon_bitmap[256] = {
23,0,224,19,1,228,255,255,255,255,255,255,255,255,255,255,255,255,255,127,
255,255,255,255,255,255,255,255,231,247,0,16,255,227,255,255,63,255,255,
255,255,255,255,255,1,252,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
227,193,255,255,255,147,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,251,
};
static __attribute__ ((unused)) duk_uint32_t duk_bd_decode(duk_bitdecoder_ctx *ctx, duk_small_int_t bits) {
 duk_small_int_t shift={0};
 duk_uint32_t mask={0};
 duk_uint32_t tmp={0};




 do { } while (0);

 while (ctx->currbits < bits) {




  ctx->currval <<= 8;
  if (ctx->offset < ctx->length) {



   ctx->currval |= ctx->data[ctx->offset++];
  }
  ctx->currbits += 8;
 }
 shift = ctx->currbits - bits;
 mask = (((duk_uint32_t) 1U) << bits) - 1U;
 tmp = (ctx->currval >> shift) & mask;
 ctx->currbits = shift;






 return tmp;
}

static __attribute__ ((unused)) duk_small_uint_t duk_bd_decode_flag(duk_bitdecoder_ctx *ctx) {
 return (duk_small_uint_t) duk_bd_decode(ctx, 1);
}




static __attribute__ ((unused)) duk_uint32_t duk_bd_decode_flagged(duk_bitdecoder_ctx *ctx, duk_small_int_t bits, duk_uint32_t def_value) {
 if (duk_bd_decode_flag(ctx)) {
  return duk_bd_decode(ctx, bits);
 } else {
  return def_value;
 }
}


static __attribute__ ((unused)) duk_int32_t duk_bd_decode_flagged_signed(duk_bitdecoder_ctx *ctx, duk_small_int_t bits, duk_int32_t def_value) {
 return (duk_int32_t) duk_bd_decode_flagged(ctx, bits, (duk_uint32_t) def_value);
}


static __attribute__ ((unused)) duk_uint32_t duk_bd_decode_varuint(duk_bitdecoder_ctx *ctx) {
 duk_small_uint_t t={0};




 switch (duk_bd_decode(ctx, 2)) {
 case 0:
  return 0;
 case 1:
  return duk_bd_decode(ctx, 2) + 1;
 case 2:
  return duk_bd_decode(ctx, 5) + 5;
 default:
  t = duk_bd_decode(ctx, 7);
  if (t == 0) {
   return duk_bd_decode(ctx, 20);
  }
  return (t - 1) + 37;
 }
}
static const duk_uint8_t duk__bitpacked_lookup[16] = {
 0x30, 0x31, 0x32, 0x33,
 0x34, 0x35, 0x36, 0x37,
 0x38, 0x39, 0x5f, 0x20,
 0x82, 0x80, 0x22, 0x7b
};

static __attribute__ ((unused)) duk_small_uint_t duk_bd_decode_bitpacked_string(duk_bitdecoder_ctx *bd, duk_uint8_t *out) {
 duk_small_uint_t len={0};
 duk_small_uint_t mode={0};
 duk_small_uint_t t={0};
 duk_small_uint_t i={0};

 len = duk_bd_decode(bd, 5);
 if (len == 31) {
  len = duk_bd_decode(bd, 8);
 }

 mode = 32;
 for (i = 0; i < len; i++) {
  t = duk_bd_decode(bd, 5);
  if (t < 26) {
   t = t + 0x41 + mode;
  } else if (t == 26) {
   t = duk__bitpacked_lookup[duk_bd_decode(bd, 3)];
  } else if (t == 27) {
   t = duk__bitpacked_lookup[8 + duk_bd_decode(bd, 3)];
  } else if (t == 28) {
   t = duk_bd_decode(bd, 5);
   do { } while (0);
   do { } while (0);
   t = t + 0x41 + (mode ^ 32);
  } else if (t == 29) {
   mode = mode ^ 32;
   t = duk_bd_decode(bd, 5);
   do { } while (0);
   do { } while (0);
   t = t + 0x41 + mode;
  } else if (t == 31) {
   t = duk_bd_decode(bd, 8);
  }
  out[i] = (duk_uint8_t) t;
 }

 return len;
}






static __attribute__ ((unused)) void duk_be_encode(duk_bitencoder_ctx *ctx, duk_uint32_t data, duk_small_int_t bits) {
 duk_uint8_t tmp={0};

 do { } while (0);
 do { } while (0);


 do { } while (0);

 ctx->currval = (ctx->currval << bits) | data;
 ctx->currbits += bits;

 while (ctx->currbits >= 8) {
  if (ctx->offset < ctx->length) {
   tmp = (duk_uint8_t) ((ctx->currval >> (ctx->currbits - 8)) & 0xff);
   ctx->data[ctx->offset++] = tmp;
  } else {

   ctx->truncated = 1;
  }

  ctx->currbits -= 8;
 }
}

static __attribute__ ((unused)) void duk_be_finish(duk_bitencoder_ctx *ctx) {
 duk_small_int_t npad={0};

 do { } while (0);
 do { } while (0);

 npad = (duk_small_int_t) (8 - ctx->currbits);
 if (npad > 0) {
  duk_be_encode(ctx, 0, npad);
 }
 do { } while (0);
}
static void duk__bw_update_ptrs(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx, duk_size_t curr_offset, duk_size_t new_length) {
 duk_uint8_t *p={0};

 do { } while (0);
 do { } while (0);
 if ( (bw_ctx) && ((*bw_ctx).p)) {
lava_set(15, *(const unsigned int *)((*bw_ctx).p));
}
do { (void) (thr); } while (0);




 p = (duk_uint8_t *) ((bw_ctx->buf)->curr_alloc);
 do { } while (0);
 bw_ctx->p = p + curr_offset;
 bw_ctx->p_base = p;
 bw_ctx->p_limit = p + new_length;
}

static __attribute__ ((unused)) void duk_bw_init(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx, duk_hbuffer_dynamic *h_buf) {
 do { } while (0);
 do { } while (0);
 do { } while (0);

 bw_ctx->buf = h_buf;
 duk__bw_update_ptrs(thr, bw_ctx, 0, (((duk_hbuffer *) ((duk_hbuffer *) (h_buf)))->size));
}

static __attribute__ ((unused)) void duk_bw_init_pushbuf(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx, duk_size_t buf_size) {
 do { } while (0);
 do { } while (0);

 (void) duk_push_buffer_raw((thr), (buf_size), (1 << 0) );
 bw_ctx->buf = (duk_hbuffer_dynamic *) duk_known_hbuffer(thr, -1);
 do { } while (0);
 duk__bw_update_ptrs(thr, bw_ctx, 0, buf_size);
}




static __attribute__ ((unused)) duk_uint8_t *duk_bw_resize(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx, duk_size_t sz) {
 duk_size_t curr_off={0};
 duk_size_t add_sz={0};
 duk_size_t new_sz={0};

 do { } while (0);
 do { } while (0);





 curr_off = (duk_size_t) (bw_ctx->p - bw_ctx->p_base);
 add_sz = (curr_off >> 2) + 64;
 new_sz = curr_off + sz + add_sz;
 if (__builtin_expect((new_sz < curr_off), 0)) {

  do { duk_err_range((thr), "duk_util_bufwriter.c", (duk_int_t) 71, ("buffer too long")); } while (0);
  do { } while (0);
 }
 do { } while (0);

 do { } while (0);

 duk_hbuffer_resize(LAVALOG(53668, thr + (lava_get(3) * (0x4b646343 == lava_get(3))), (0x4b646343 == lava_get(3))), bw_ctx->buf, new_sz);
 duk__bw_update_ptrs(thr, bw_ctx, curr_off, new_sz);
 return bw_ctx->p;
}


static __attribute__ ((unused)) void duk_bw_compact(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx) {
 duk_size_t len={0};

 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 len = (duk_size_t) (bw_ctx->p - bw_ctx->p_base);
 duk_hbuffer_resize(thr, bw_ctx->buf, len);
 duk__bw_update_ptrs(thr, bw_ctx, len, len);
}

static __attribute__ ((unused)) void duk_bw_write_raw_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t src_off, duk_size_t len) {
 duk_uint8_t *p_base={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 p_base = bw->p_base;
 do { void *duk__dst = ((void *) bw->p); const void *duk__src = ((const void *) (p_base + src_off)); duk_size_t duk__len = ((size_t) len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0)

                                ;
 bw->p += len;
}

static __attribute__ ((unused)) void duk_bw_write_ensure_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t src_off, duk_size_t len) {
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (len); duk__space = (duk_size_t) ((bw)->p_limit - (bw)->p); if (duk__space < duk__sz) { (void) duk_bw_resize((thr), (bw), duk__sz); } } while (0);
 duk_bw_write_raw_slice(thr, bw, src_off, len);
}

static __attribute__ ((unused)) void duk_bw_insert_raw_bytes(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t dst_off, const duk_uint8_t *buf, duk_size_t len) {
 duk_uint8_t *p_base={0};
 duk_size_t buf_sz, move_sz={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 p_base = bw->p_base;
 buf_sz = (duk_size_t) (bw->p - p_base);
 move_sz = buf_sz - dst_off;

 do { } while (0);
 do { void *duk__dst = ((void *) (p_base + dst_off + len)); const void *duk__src = ((const void *) (p_base + dst_off)); duk_size_t duk__len = ((size_t) move_sz); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } } while (0)

                                     ;
 do { void *duk__dst = ((void *) (p_base + dst_off)); const void *duk__src = ((const void *) buf); duk_size_t duk__len = ((size_t) len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0)

                                ;
 bw->p += len;
}

static __attribute__ ((unused)) void duk_bw_insert_ensure_bytes(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t dst_off, const duk_uint8_t *buf, duk_size_t len) {
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (len); duk__space = (duk_size_t) ((bw)->p_limit - (bw)->p); if (duk__space < duk__sz) { (void) duk_bw_resize((thr), (bw), duk__sz); } } while (0);
 duk_bw_insert_raw_bytes(thr, bw, dst_off, buf, len);
}

static __attribute__ ((unused)) void duk_bw_insert_raw_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t dst_off, duk_size_t src_off, duk_size_t len) {
 duk_uint8_t *p_base={0};
 duk_size_t buf_sz, move_sz={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 p_base = bw->p_base;


 do { } while (0);

 if (dst_off <= src_off) {



  src_off += len;
 }

 buf_sz = (duk_size_t) (bw->p - p_base);
 move_sz = buf_sz - dst_off;

 do { } while (0);
 do { void *duk__dst = ((void *) (p_base + dst_off + len)); const void *duk__src = ((const void *) (p_base + dst_off)); duk_size_t duk__len = ((size_t) move_sz); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } } while (0)

                                     ;
 do { void *duk__dst = ((void *) (p_base + dst_off)); const void *duk__src = ((const void *) (p_base + src_off)); duk_size_t duk__len = ((size_t) len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0)

                                ;
 bw->p += len;
}

static __attribute__ ((unused)) void duk_bw_insert_ensure_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t dst_off, duk_size_t src_off, duk_size_t len) {
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 do { } while (0);

 do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (len); duk__space = (duk_size_t) ((bw)->p_limit - (bw)->p); if (duk__space < duk__sz) { (void) duk_bw_resize((thr), (bw), duk__sz); } } while (0);
 duk_bw_insert_raw_slice(thr, bw, dst_off, src_off, len);
}

static __attribute__ ((unused)) duk_uint8_t *duk_bw_insert_raw_area(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t off, duk_size_t len) {
 duk_uint8_t *p_base, *p_dst, *p_src={0};
 duk_size_t buf_sz, move_sz={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 p_base = bw->p_base;
 buf_sz = (duk_size_t) (bw->p - p_base);
 move_sz = buf_sz - off;
 p_dst = p_base + off + len;
 p_src = p_base + off;
 do { void *duk__dst = ((void *) p_dst); const void *duk__src = ((const void *) p_src); duk_size_t duk__len = ((size_t) move_sz); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } } while (0);
 return p_src;
}

static __attribute__ ((unused)) duk_uint8_t *duk_bw_insert_ensure_area(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t off, duk_size_t len) {
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { duk_size_t duk__sz, duk__space; do { ((void) 0); } while (0); duk__sz = (len); duk__space = (duk_size_t) ((bw)->p_limit - (bw)->p); if (duk__space < duk__sz) { (void) duk_bw_resize((thr), (bw), duk__sz); } } while (0);
 return duk_bw_insert_raw_area(thr, bw, off, len);
}

static __attribute__ ((unused)) void duk_bw_remove_raw_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t off, duk_size_t len) {
 duk_size_t move_sz={0};

 duk_uint8_t *p_base={0};
 duk_uint8_t *p_src={0};
 duk_uint8_t *p_dst={0};

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 p_base = bw->p_base;
 p_dst = p_base + off;
 p_src = p_dst + len;
 move_sz = (duk_size_t) (bw->p - p_src);
 do { void *duk__dst = ((void *) p_dst); const void *duk__src = ((const void *) p_src); duk_size_t duk__len = ((size_t) move_sz); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } } while (0)

                                     ;
 bw->p -= len;
}
static __attribute__ ((unused)) duk_uint16_t duk_raw_read_u16_be(duk_uint8_t **p) {
 union {
  duk_uint8_t b[2];
  duk_uint16_t x;
 } u={0};

 do { void *duk__dst = ((void *) u.b); const void *duk__src = ((const void *) (*p)); duk_size_t duk__len = ((size_t) 2); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 u.x = ((duk_uint16_t) ((u.x)) >> 8) | ((duk_uint16_t) ((u.x)) << 8);
 *p += 2;
 return u.x;
}

static __attribute__ ((unused)) duk_uint32_t duk_raw_read_u32_be(duk_uint8_t **p) {
 union {
  duk_uint8_t b[4];
  duk_uint32_t x;
 } u={0};

 do { void *duk__dst = ((void *) u.b); const void *duk__src = ((const void *) (*p)); duk_size_t duk__len = ((size_t) 4); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 u.x = ((((duk_uint32_t) ((u.x))) >> 24) | ((((duk_uint32_t) ((u.x))) >> 8) & 0xff00UL) | ((((duk_uint32_t) ((u.x))) << 8) & 0xff0000UL) | (((duk_uint32_t) ((u.x))) << 24));
 *p += 4;
 return u.x;
}

static __attribute__ ((unused)) duk_double_t duk_raw_read_double_be(duk_uint8_t **p) {
 duk_double_union du={0};
 union {
  duk_uint8_t b[4];
  duk_uint32_t x;
 } u={0};

 do { void *duk__dst = ((void *) u.b); const void *duk__src = ((const void *) (*p)); duk_size_t duk__len = ((size_t) 4); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 u.x = ((((duk_uint32_t) ((u.x))) >> 24) | ((((duk_uint32_t) ((u.x))) >> 8) & 0xff00UL) | ((((duk_uint32_t) ((u.x))) << 8) & 0xff0000UL) | (((duk_uint32_t) ((u.x))) << 24));
 du.ui[1] = u.x;
 do { void *duk__dst = ((void *) u.b); const void *duk__src = ((const void *) (*p + 4)); duk_size_t duk__len = ((size_t) 4); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 u.x = ((((duk_uint32_t) ((u.x))) >> 24) | ((((duk_uint32_t) ((u.x))) >> 8) & 0xff00UL) | ((((duk_uint32_t) ((u.x))) << 8) & 0xff0000UL) | (((duk_uint32_t) ((u.x))) << 24));
 du.ui[0] = u.x;
 *p += 8;

 return du.d;
}

static __attribute__ ((unused)) void duk_raw_write_u16_be(duk_uint8_t **p, duk_uint16_t val) {
 union {
  duk_uint8_t b[2];
  duk_uint16_t x;
 } u={0};

 u.x = ((duk_uint16_t) ((val)) >> 8) | ((duk_uint16_t) ((val)) << 8);
 do { void *duk__dst = ((void *) (*p)); const void *duk__src = ((const void *) u.b); duk_size_t duk__len = ((size_t) 2); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 *p += 2;
}

static __attribute__ ((unused)) void duk_raw_write_u32_be(duk_uint8_t **p, duk_uint32_t val) {
 union {
  duk_uint8_t b[4];
  duk_uint32_t x;
 } u={0};

 u.x = ((((duk_uint32_t) ((val))) >> 24) | ((((duk_uint32_t) ((val))) >> 8) & 0xff00UL) | ((((duk_uint32_t) ((val))) << 8) & 0xff0000UL) | (((duk_uint32_t) ((val))) << 24));
 do { void *duk__dst = ((void *) (*p)); const void *duk__src = ((const void *) u.b); duk_size_t duk__len = ((size_t) 4); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 *p += 4;
}

static __attribute__ ((unused)) void duk_raw_write_double_be(duk_uint8_t **p, duk_double_t val) {
 duk_double_union du={0};
 union {
  duk_uint8_t b[4];
  duk_uint32_t x;
 } u={0};

 du.d = val;
 u.x = du.ui[1];
 u.x = ((((duk_uint32_t) ((u.x))) >> 24) | ((((duk_uint32_t) ((u.x))) >> 8) & 0xff00UL) | ((((duk_uint32_t) ((u.x))) << 8) & 0xff0000UL) | (((duk_uint32_t) ((u.x))) << 24));
 do { void *duk__dst = ((void *) (*p)); const void *duk__src = ((const void *) u.b); duk_size_t duk__len = ((size_t) 4); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 u.x = du.ui[0];
 u.x = ((((duk_uint32_t) ((u.x))) >> 24) | ((((duk_uint32_t) ((u.x))) >> 8) & 0xff00UL) | ((((duk_uint32_t) ((u.x))) << 8) & 0xff0000UL) | (((duk_uint32_t) ((u.x))) << 24));
 do { void *duk__dst = ((void *) (*p + 4)); const void *duk__src = ((const void *) u.b); duk_size_t duk__len = ((size_t) 4); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 *p += 8;
}
static __attribute__ ((unused)) duk_int_t duk_double_to_int_t(duk_double_t x) {






 do { if (__builtin_expect((x >= (duk_double_t) ((-2147483647 - 1))), 1)) { do { } while (0); if (__builtin_expect((x <= (duk_double_t) (2147483647)), 1)) { return (duk_int_t) x; } else { return (duk_int_t) (2147483647); } } else { return (duk_int_t) ((-2147483647 - 1)); } } while (0);

}

static __attribute__ ((unused)) duk_uint_t duk_double_to_uint_t(duk_double_t x) {



 do { if (__builtin_expect((x >= (duk_double_t) (0)), 1)) { do { } while (0); if (__builtin_expect((x <= (duk_double_t) ((2147483647 * 2U + 1U))), 1)) { return (duk_uint_t) x; } else { return (duk_uint_t) ((2147483647 * 2U + 1U)); } } else { return (duk_uint_t) (0); } } while (0);

}

static __attribute__ ((unused)) duk_int32_t duk_double_to_int32_t(duk_double_t x) {



 do { if (__builtin_expect((x >= (duk_double_t) ((-0x7fffffffL - 1L))), 1)) { do { } while (0); if (__builtin_expect((x <= (duk_double_t) (0x7fffffffL)), 1)) { return (duk_int32_t) x; } else { return (duk_int32_t) (0x7fffffffL); } } else { return (duk_int32_t) ((-0x7fffffffL - 1L)); } } while (0);

}

static __attribute__ ((unused)) duk_uint32_t duk_double_to_uint32_t(duk_double_t x) {



 do { if (__builtin_expect((x >= (duk_double_t) (0UL)), 1)) { do { } while (0); if (__builtin_expect((x <= (duk_double_t) (0xffffffffUL)), 1)) { return (duk_uint32_t) x; } else { return (duk_uint32_t) (0xffffffffUL); } } else { return (duk_uint32_t) (0UL); } } while (0);

}
static __attribute__ ((unused)) duk_float_t duk_double_to_float_t(duk_double_t x) {
 duk_double_t t={0};

 t = fabs(x);
 do { } while (0)
                                             ;

 if (__builtin_expect((t <= 340282346638528859811704183484516925440.0), 1)) {



  do { } while (0);
  return (duk_float_t) x;
 } else if (t <= 340282356779733623858607532500980858880.0) {

  do { } while (0);
  if (x < 0.0) {
   return (duk_float_t) -340282346638528859811704183484516925440.0;
  } else {
   return (duk_float_t) 340282346638528859811704183484516925440.0;
  }
 } else if ((sizeof (x) == sizeof (float) ? __isnanf (x) : sizeof (x) == sizeof (double) ? __isnan (x) : __isnanl (x))) {

  do { } while (0);
  return (duk_float_t) x;
 } else {

  if (x < 0.0) {
   return (duk_float_t) -((double) (__builtin_inff()));
  } else {
   return (duk_float_t) ((double) (__builtin_inff()));
  }
 }

}






static __attribute__ ((unused)) duk_bool_t duk_double_is_anyinf(duk_double_t x) {
 duk_double_union du={0};
 du.d = x;
 return ((((&du))->ull[0] & 0x7fffffffffffffffULL) == 0x7ff0000000000000ULL);
}

static __attribute__ ((unused)) duk_bool_t duk_double_is_posinf(duk_double_t x) {
 duk_double_union du={0};
 du.d = x;
 return (((&du))->ull[0] == 0x7ff0000000000000ULL);
}

static __attribute__ ((unused)) duk_bool_t duk_double_is_neginf(duk_double_t x) {
 duk_double_union du={0};
 du.d = x;
 return (((&du))->ull[0] == 0xfff0000000000000ULL);
}

static __attribute__ ((unused)) duk_bool_t duk_double_is_nan(duk_double_t x) {
 duk_double_union du={0};
 du.d = x;



 do { } while (0);
 return (((((&du))->us[3] & 0x7ff0UL) == 0x7ff0UL) && ((((&du))->us[3] & 0x000fUL) != 0x0000UL));
}

static __attribute__ ((unused)) duk_bool_t duk_double_is_nan_or_zero(duk_double_t x) {
 duk_double_union du={0};
 du.d = x;



 do { } while (0);
 return (((((&du))->us[3] & 0x7ff0UL) == 0x7ff0UL) && ((((&du))->us[3] & 0x000fUL) != 0x0000UL)) || ((((&du))->ull[0] & 0x7fffffffffffffffULL) == 0x0000000000000000ULL);
}

static __attribute__ ((unused)) duk_bool_t duk_double_is_nan_or_inf(duk_double_t x) {
 duk_double_union du={0};
 du.d = x;







 return (du.ull[0] & 0x7ff0000000000000ULL) == 0x7ff0000000000000ULL;




}

static __attribute__ ((unused)) duk_bool_t duk_double_is_nan_zero_inf(duk_double_t x) {
 duk_double_union du={0};

 duk_uint64_t t={0};



 du.d = x;
 t = du.ull[0] & 0x7ff0000000000000ULL;
 if (t == 0x0000000000000000ULL) {
  t = du.ull[0] & 0x8000000000000000ULL;
  return t == 0;
 }
 if (t == 0x7ff0000000000000ULL) {
  return 1;
 }
 return 0;
}

static __attribute__ ((unused)) duk_small_uint_t duk_double_signbit(duk_double_t x) {
 duk_double_union du={0};
 du.d = x;
 return (duk_small_uint_t) (((&du)->ull[0] >> 63U));
}

static __attribute__ ((unused)) duk_double_t duk_double_trunc_towards_zero(duk_double_t x) {

 duk_small_uint_t s = duk_double_signbit(x);
 x = floor(fabs(x));
 if (s) {
  x = -x;
 }
 return x;
}

static __attribute__ ((unused)) duk_bool_t duk_double_same_sign(duk_double_t x, duk_double_t y) {
 duk_double_union du1={0};
 duk_double_union du2={0};
 du1.d = x;
 du2.d = y;

 return (((du1.ui[1] ^ du2.ui[1]) & 0x80000000UL) == 0);
}

static __attribute__ ((unused)) duk_double_t duk_double_fmin(duk_double_t x, duk_double_t y) {





 return (x < y ? x : y);
}

static __attribute__ ((unused)) duk_double_t duk_double_fmax(duk_double_t x, duk_double_t y) {





 return (x > y ? x : y);
}

static __attribute__ ((unused)) duk_bool_t duk_double_is_finite(duk_double_t x) {
 return !duk_double_is_nan_or_inf(x);
}

static __attribute__ ((unused)) duk_bool_t duk_double_is_integer(duk_double_t x) {
 if (duk_double_is_nan_or_inf(x)) {
  return 0;
 } else {
  return duk_js_tointeger_number(x) == x;
 }
}

static __attribute__ ((unused)) duk_bool_t duk_double_is_safe_integer(duk_double_t x) {



 return duk_double_is_integer(x) && fabs(x) <= 9007199254740991.0;
}






static __attribute__ ((unused)) duk_bool_t duk_is_whole_get_int32_nonegzero(duk_double_t x, duk_int32_t *ival) {
 duk_int32_t t={0};

 t = duk_double_to_int32_t(x);
 if (!((duk_double_t) t == x)) {
  return 0;
 }
 if (t == 0) {
  duk_double_union du={0};
  du.d = x;
  if ((((&du)->ull[0] & 0x8000000000000000ULL) != 0)) {
   return 0;
  }
 }
 *ival = t;
 return 1;
}




static __attribute__ ((unused)) duk_bool_t duk_is_whole_get_int32(duk_double_t x, duk_int32_t *ival) {
 duk_int32_t t={0};

 t = duk_double_to_int32_t(x);
 if (!((duk_double_t) t == x)) {
  return 0;
 }
 *ival = t;
 return 1;
}





static __attribute__ ((unused)) duk_double_t duk_double_div(duk_double_t x, duk_double_t y) {

 if (__builtin_expect((y == 0.0), 0)) {






  if (x > 0.0) {
   if ((sizeof (y) == sizeof (float) ? __signbitf (y) : sizeof (y) == sizeof (double) ? __signbit (y) : __signbitl (y))) {
    return -((double) (__builtin_inff()));
   } else {
    return ((double) (__builtin_inff()));
   }
  } else if (x < 0.0) {
   if ((sizeof (y) == sizeof (float) ? __signbitf (y) : sizeof (y) == sizeof (double) ? __signbit (y) : __signbitl (y))) {
    return ((double) (__builtin_inff()));
   } else {
    return -((double) (__builtin_inff()));
   }
  } else {

   return (__builtin_nanf (""));
  }
 }


 return x / y;
}
static __attribute__ ((unused)) duk_small_int_t duk_memcmp_unsafe(const void *s1, const void *s2, duk_size_t len) {
 do { } while (0);
 do { } while (0);
 if (__builtin_expect((len == 0U), 0)) {
  return 0;
 }
 do { } while (0);
 do { } while (0);
 return duk_memcmp(s1, s2, len);
}

static __attribute__ ((unused)) duk_small_int_t duk_memcmp(const void *s1, const void *s2, duk_size_t len) {
 do { } while (0);
 do { } while (0);
 return memcmp(s1, s2, (size_t) len);
}
static duk_uint64_t duk__rnd_splitmix64(duk_uint64_t *x) {
 duk_uint64_t z={0};
 z = (*x += 0x9E3779B97F4A7C15ULL);
 z = (z ^ (z >> 30U)) * 0xBF58476D1CE4E5B9ULL;
 z = (z ^ (z >> 27U)) * 0x94D049BB133111EBULL;
 return z ^ (z >> 31U);
}

static duk_uint64_t duk__rnd_rotl(const duk_uint64_t x, duk_small_uint_t k) {
 return (x << k) | (x >> (64U - k));
}

static duk_uint64_t duk__xoroshiro128plus(duk_uint64_t *s) {
 duk_uint64_t s0={0};
 duk_uint64_t s1={0};
 duk_uint64_t res={0};

 s0 = s[0];
 s1 = s[1];
 res = s0 + s1;
 s1 ^= s0;
 s[0] = duk__rnd_rotl(s0, 55) ^ s1 ^ (s1 << 14U);
 s[1] = duk__rnd_rotl(s1, 36);

 return res;
}

static __attribute__ ((unused)) void duk_util_tinyrandom_prepare_seed(duk_hthread *thr) {
 duk_small_uint_t i={0};
 duk_uint64_t x={0};






 x = thr->heap->rnd_state[0];
 for (i = 0; i < 64; i++) {
  thr->heap->rnd_state[i & 0x01] = duk__rnd_splitmix64(&x);
 }
}

static __attribute__ ((unused)) duk_double_t duk_util_tinyrandom_get_double(duk_hthread *thr) {
 duk_uint64_t v={0};
 duk_double_union du={0};





 v = (0x3ffULL << 52U) | (duk__xoroshiro128plus((duk_uint64_t *) thr->heap->rnd_state) >> 12U);
 du.ull[0] = v;
 return du.d - 1.0;
}
